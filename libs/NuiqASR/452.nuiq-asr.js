"use strict";(this.webpackChunkNuiqASR=this.webpackChunkNuiqASR||[]).push([[452],{452:(e,t,n)=>{n.r(t),n.d(t,{LocalBackend:()=>m});var r=n(590),s=n(41),i=n(512),a=n.n(i);function o(){return a()('(()=>{var e,t,n={98:(e,t,n)=>{"use strict";e.exports=n.p+"9784243b0cabe768d594.wasm"},193:()=>{},160:()=>{},448:()=>{},655:()=>{},626:()=>{},674:()=>{},666:()=>{}},r={};function s(e){var t=r[e];if(void 0!==t)return t.exports;var i=r[e]={exports:{}};return n[e](i,i.exports,s),i.exports}s.m=n,t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,s.t=function(n,r){if(1&r&&(n=this(n)),8&r)return n;if("object"==typeof n&&n){if(4&r&&n.__esModule)return n;if(16&r&&"function"==typeof n.then)return n}var i=Object.create(null);s.r(i);var a={};e=e||[null,t({}),t([]),t(t)];for(var o=2&r&&n;"object"==typeof o&&!~e.indexOf(o);o=t(o))Object.getOwnPropertyNames(o).forEach((e=>a[e]=()=>n[e]));return a.default=()=>n,s.d(i,a),i},s.d=(e,t)=>{for(var n in t)s.o(t,n)&&!s.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},s.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),s.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),s.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{var e;s.g.importScripts&&(e=s.g.location+"");var t=s.g.document;if(!e&&t&&(t.currentScript&&(e=t.currentScript.src),!e)){var n=t.getElementsByTagName("script");if(n.length)for(var r=n.length-1;r>-1&&(!e||!/^http(s?):/.test(e));)e=n[r--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\\?.*$/,"").replace(/\\/[^\\/]+$/,"/"),s.p=e})(),s.b=self.location+"",(()=>{"use strict";var e={};s.r(e),s.d(e,{InferenceSession:()=>tt,TRACE:()=>Qe,TRACE_FUNC_BEGIN:()=>Ze,TRACE_FUNC_END:()=>Je,Tensor:()=>Xe,default:()=>Sp,env:()=>Oe,registerBackend:()=>ze});var t={};s.r(t),s.d(t,{BeitFeatureExtractor:()=>GS,BitImageProcessor:()=>HS,CLIPFeatureExtractor:()=>QS,CLIPImageProcessor:()=>XS,ChineseCLIPFeatureExtractor:()=>KS,ConvNextFeatureExtractor:()=>ZS,ConvNextImageProcessor:()=>YS,DPTFeatureExtractor:()=>az,DPTImageProcessor:()=>iz,DeiTFeatureExtractor:()=>ez,DeiTImageProcessor:()=>JS,DetrFeatureExtractor:()=>nz,DetrImageProcessor:()=>tz,DonutFeatureExtractor:()=>sz,DonutImageProcessor:()=>rz,EfficientNetImageProcessor:()=>oz,GLPNFeatureExtractor:()=>lz,Idefics3ImageProcessor:()=>uz,JinaCLIPImageProcessor:()=>cz,LlavaOnevisionImageProcessor:()=>pz,Mask2FormerImageProcessor:()=>mz,MaskFormerFeatureExtractor:()=>fz,MaskFormerImageProcessor:()=>hz,MobileNetV1FeatureExtractor:()=>gz,MobileNetV1ImageProcessor:()=>_z,MobileNetV2FeatureExtractor:()=>yz,MobileNetV2ImageProcessor:()=>wz,MobileNetV3FeatureExtractor:()=>xz,MobileNetV3ImageProcessor:()=>bz,MobileNetV4FeatureExtractor:()=>$z,MobileNetV4ImageProcessor:()=>vz,MobileViTFeatureExtractor:()=>Ez,MobileViTImageProcessor:()=>kz,NougatImageProcessor:()=>Sz,OwlViTFeatureExtractor:()=>Cz,OwlViTImageProcessor:()=>zz,Owlv2ImageProcessor:()=>Tz,Phi3VImageProcessor:()=>Nz,PvtImageProcessor:()=>Pz,Qwen2VLImageProcessor:()=>Rz,RTDetrImageProcessor:()=>Dz,SamImageProcessor:()=>Lz,SegformerFeatureExtractor:()=>Uz,SegformerImageProcessor:()=>Fz,SiglipImageProcessor:()=>qz,Swin2SRImageProcessor:()=>Vz,VLMImageProcessor:()=>dz,ViTFeatureExtractor:()=>jz,ViTImageProcessor:()=>Wz,VitMatteImageProcessor:()=>Gz,VitPoseImageProcessor:()=>Hz,YolosFeatureExtractor:()=>Xz,YolosImageProcessor:()=>Kz});var n={};s.r(n),s.d(n,{ASTFeatureExtractor:()=>pC,ClapFeatureExtractor:()=>hC,ImageFeatureExtractor:()=>jS,MoonshineFeatureExtractor:()=>fC,PyAnnoteFeatureExtractor:()=>mC,SeamlessM4TFeatureExtractor:()=>_C,SpeechT5FeatureExtractor:()=>gC,Wav2Vec2FeatureExtractor:()=>wC,WeSpeakerFeatureExtractor:()=>yC,WhisperFeatureExtractor:()=>bC});var r={};s.r(r),s.d(r,{Florence2Processor:()=>Yz,Idefics3Processor:()=>kC,JinaCLIPProcessor:()=>SC,MgpstrProcessor:()=>Jz,MoonshineProcessor:()=>vC,OwlViTProcessor:()=>zC,PaliGemmaProcessor:()=>MC,Phi3VProcessor:()=>AC,PyAnnoteProcessor:()=>OC,Qwen2VLProcessor:()=>BC,SamProcessor:()=>NC,SpeechT5Processor:()=>PC,VLChatProcessor:()=>EC,Wav2Vec2ProcessorWithLM:()=>RC,WhisperProcessor:()=>DC});\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst i=Symbol("Comlink.proxy"),a=Symbol("Comlink.endpoint"),o=Symbol("Comlink.releaseProxy"),l=Symbol("Comlink.finalizer"),u=Symbol("Comlink.thrown"),d=e=>"object"==typeof e&&null!==e||"function"==typeof e,c=new Map([["proxy",{canHandle:e=>d(e)&&e[i],serialize(e){const{port1:t,port2:n}=new MessageChannel;return p(e,t),[n,[n]]},deserialize:e=>(e.start(),function t(e,n){return w(e,[],n)}(e))}],["throw",{canHandle:e=>d(e)&&u in e,serialize({value:e}){let t;return t=e instanceof Error?{isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:{isError:!1,value:e},[t,[]]},deserialize(e){if(e.isError)throw Object.assign(new Error(e.value.message),e.value);throw e.value}}]]);function p(e,t=globalThis,n=["*"]){t.addEventListener("message",(function r(s){if(!s||!s.data)return;if(!function a(e,t){for(const n of e){if(t===n||"*"===n)return!0;if(n instanceof RegExp&&n.test(t))return!0}return!1}(n,s.origin))return void console.warn(`Invalid origin \'${s.origin}\' for comlink proxy`);const{id:o,type:d,path:c}=Object.assign({path:[]},s.data),f=(s.data.argumentList||[]).map(k);let m;try{const t=c.slice(0,-1).reduce(((e,t)=>e[t]),e),n=c.reduce(((e,t)=>e[t]),e);switch(d){case"GET":m=n;break;case"SET":t[c.slice(-1)[0]]=k(s.data.value),m=!0;break;case"APPLY":m=n.apply(t,f);break;case"CONSTRUCT":m=function r(e){return Object.assign(e,{[i]:!0})}(new n(...f));break;case"ENDPOINT":{const{port1:t,port2:n}=new MessageChannel;p(e,n),m=v(t,[t])}break;case"RELEASE":m=void 0;break;default:return}}catch(e){m={value:e,[u]:0}}Promise.resolve(m).catch((e=>({value:e,[u]:0}))).then((n=>{const[s,i]=$(n);t.postMessage(Object.assign(Object.assign({},s),{id:o}),i),"RELEASE"===d&&(t.removeEventListener("message",r),h(t),l in e&&"function"==typeof e[l]&&e[l]())})).catch((e=>{const[n,r]=$({value:new TypeError("Unserializable return value"),[u]:0});t.postMessage(Object.assign(Object.assign({},n),{id:o}),r)}))})),t.start&&t.start()}function h(e){(function t(e){return"MessagePort"===e.constructor.name})(e)&&e.close()}function f(e){if(e)throw new Error("Proxy has been released and is not useable")}function m(e){return E(e,{type:"RELEASE"}).then((()=>{h(e)}))}const _=new WeakMap,g="FinalizationRegistry"in globalThis&&new FinalizationRegistry((e=>{const t=(_.get(e)||0)-1;_.set(e,t),0===t&&m(e)}));function w(e,t=[],n=function(){}){let r=!1;const s=new Proxy(n,{get(n,i){if(f(r),i===o)return()=>{!function t(e){g&&g.unregister(e)}(s),m(e),r=!0};if("then"===i){if(0===t.length)return{then:()=>s};const n=E(e,{type:"GET",path:t.map((e=>e.toString()))}).then(k);return n.then.bind(n)}return w(e,[...t,i])},set(n,s,i){f(r);const[a,o]=$(i);return E(e,{type:"SET",path:[...t,s].map((e=>e.toString())),value:a},o).then(k)},apply(n,s,i){f(r);const o=t[t.length-1];if(o===a)return E(e,{type:"ENDPOINT"}).then(k);if("bind"===o)return w(e,t.slice(0,-1));const[l,u]=b(i);return E(e,{type:"APPLY",path:t.map((e=>e.toString())),argumentList:l},u).then(k)},construct(n,s){f(r);const[i,a]=b(s);return E(e,{type:"CONSTRUCT",path:t.map((e=>e.toString())),argumentList:i},a).then(k)}});return function i(e,t){const n=(_.get(t)||0)+1;_.set(t,n),g&&g.register(e,t,e)}(s,e),s}function y(e){return Array.prototype.concat.apply([],e)}function b(e){const t=e.map($);return[t.map((e=>e[0])),y(t.map((e=>e[1])))]}const x=new WeakMap;function v(e,t){return x.set(e,t),e}function $(e){for(const[t,n]of c)if(n.canHandle(e)){const[r,s]=n.serialize(e);return[{type:"HANDLER",name:t,value:r},s]}return[{type:"RAW",value:e},x.get(e)||[]]}function k(e){switch(e.type){case"HANDLER":return c.get(e.name).deserialize(e.value);case"RAW":return e.value}}function E(e,t,n){return new Promise((r=>{const s=function i(){return new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-")}();e.addEventListener("message",(function t(n){n.data&&n.data.id&&n.data.id===s&&(e.removeEventListener("message",t),r(n.data))})),e.start&&e.start(),e.postMessage(Object.assign({id:s},t),n)}))}var S=s(626),z=s(674),C=s(666);const T="undefined"!=typeof window&&"undefined"!=typeof window.document,A="undefined"!=typeof self&&"DedicatedWorkerGlobalScope"===self.constructor?.name,I="undefined"!=typeof self&&"caches"in self,M="undefined"!=typeof navigator&&"gpu"in navigator,O="undefined"!=typeof navigator&&"ml"in navigator,B="undefined"!=typeof process,N=B&&"node"===process?.release?.name,P=!W(S),R=!W(z),D=Object.freeze({IS_BROWSER_ENV:T,IS_WEBWORKER_ENV:A,IS_WEB_CACHE_AVAILABLE:I,IS_WEBGPU_AVAILABLE:M,IS_WEBNN_AVAILABLE:O,IS_PROCESS_AVAILABLE:B,IS_NODE_ENV:N,IS_FS_AVAILABLE:P,IS_PATH_AVAILABLE:R}),L=P&&R;let F="./";if(L){const e=Object({}).url;e?F=z.dirname(z.dirname(C.fileURLToPath(e))):"undefined"!=typeof __dirname&&(F=z.dirname(__dirname))}const U=L?z.join(F,"/.cache/"):null,q="/models/",V={version:"3.2.0",backends:{onnx:{}},allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!(T||A),localModelPath:L?z.join(F,q):q,useFS:P,useBrowserCache:I,useFSCache:P,cacheDir:U,useCustomCache:!1,customCache:null};function W(e){return 0===Object.keys(e).length}const j=class{constructor(){let e=function(...t){return e._call(...t)};return Object.setPrototypeOf(e,new.target.prototype)}_call(...e){throw Error("Must implement _call method in subclass")}};function G(e,t){e&&e(t)}function H(e){return e.replace(/[.*+?^${}()|[\\]\\\\]/g,"\\\\$&")}function K(e){return null==e||-1===e}function X(e){const t=[];let n=e;for(;Array.isArray(n);)t.push(n.length),n=n[0];return t}function Q(...e){return Array.prototype.concat.apply([],e)}function Y(...e){return e.reduce(((e,t)=>e.flatMap((e=>t.map((t=>[e,t]))))))}function Z(e,t){return Math.abs((e+t)%(2*t)-t)}function J(e,t){return Object.assign({},...t.map((t=>{if(void 0!==e[t])return{[t]:e[t]}})))}function ee(e){let t=0;for(const n of e)++t;return t}function te(e,t){let n=0;for(const r of e)r===t&&++n;return n}var ne=s(160),re=s(448);const se={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};class ie{constructor(e){if(this.filePath=e,this.headers=new Headers,this.exists=ne.existsSync(e),this.exists){this.status=200,this.statusText="OK";let t=ne.statSync(e);this.headers.set("content-length",t.size.toString()),this.updateContentType();let n=this;this.body=new ReadableStream({start(e){n.arrayBuffer().then((t=>{e.enqueue(new Uint8Array(t)),e.close()}))}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const e=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",se[e]??"application/octet-stream")}clone(){let e=new ie(this.filePath);return e.exists=this.exists,e.status=this.status,e.statusText=this.statusText,e.headers=new Headers(this.headers),e}async arrayBuffer(){return(await ne.promises.readFile(this.filePath)).buffer}async blob(){const e=await ne.promises.readFile(this.filePath);return new Blob([e],{type:this.headers.get("content-type")})}async text(){return await ne.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function ae(e,t=null,n=null){let r;try{r=new URL(e)}catch(e){return!1}return!(t&&!t.includes(r.protocol))&&!(n&&!n.includes(r.hostname))}async function oe(e){if(V.useFS&&!ae(e,["http:","https:","blob:"]))return new ie(e);if("undefined"!=typeof process&&"node"===process?.release?.name){const t=!!process.env?.TESTING_REMOTELY,n=V.version,r=new Headers;r.set("User-Agent",`transformers.js/${n}; is_ci/${t};`);if(ae(e,["http:","https:"],["huggingface.co","hf.co"])){const e=process.env?.HF_TOKEN??process.env?.HF_ACCESS_TOKEN;e&&r.set("Authorization",`Bearer ${e}`)}return fetch(e,{headers:r})}return fetch(e)}const le={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};class ue{constructor(e){this.path=e}async match(e){let t=re.join(this.path,e),n=new ie(t);return n.exists?n:void 0}async put(e,t){const n=Buffer.from(await t.arrayBuffer());let r=re.join(this.path,e);try{await ne.promises.mkdir(re.dirname(r),{recursive:!0}),await ne.promises.writeFile(r,n)}catch(e){console.warn("An error occurred while writing the file to cache:",e)}}}async function de(e,t,n=!0,r={}){if(!V.allowLocalModels){if(r.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!V.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}let s;if(G(r.progress_callback,{status:"initiate",name:e,file:t}),!s&&V.useBrowserCache){if("undefined"==typeof caches)throw Error("Browser cache is not available in this environment.");try{s=await caches.open("transformers-cache")}catch(e){console.warn("An error occurred while opening the browser cache:",e)}}if(!s&&V.useFSCache&&(s=new ue(r.cache_dir??V.cacheDir)),!s&&V.useCustomCache){if(!V.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");if(!V.customCache.match||!V.customCache.put)throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");s=V.customCache}const i=r.revision??"main";let a,o,l=pe(e,t),u=pe(V.localModelPath,l),d=pe(V.remoteHost,V.remotePathTemplate.replaceAll("{model}",e).replaceAll("{revision}",encodeURIComponent(i)),t),c="main"===i?l:pe(e,i,t),p=s instanceof ue?c:d,h=!1;s&&(o=await async function f(e,...t){for(let n of t)try{let t=await e.match(n);if(t)return t}catch(e){continue}}(s,u,p));const m=void 0!==o;if(void 0===o){if(V.allowLocalModels){if(ae(l,["http:","https:"])){if(r.local_files_only)throw new Error(`\\`local_files_only=true\\`, but attempted to load a remote file from: ${l}.`);if(!V.allowRemoteModels)throw new Error(`\\`env.allowRemoteModels=false\\`, but attempted to load a remote file from: ${l}.`)}else try{o=await oe(u),a=u}catch(e){console.warn(`Unable to load from local path "${u}": "${e}"`)}}if(void 0===o||404===o.status){if(r.local_files_only||!V.allowRemoteModels){if(n)throw Error(`\\`local_files_only=true\\` or \\`env.allowRemoteModels=false\\` and file was not found locally at "${u}".`);return null}if(o=await oe(d),200!==o.status)return function e(t,n,r){if(!r)return null;const s=le[t]??`Error (${t}) occurred while trying to load file`;throw Error(`${s}: "${n}".`)}(o.status,d,n);a=p}h=s&&"undefined"!=typeof Response&&o instanceof Response&&200===o.status}let _;return G(r.progress_callback,{status:"download",name:e,file:t}),r.progress_callback?m&&"undefined"!=typeof navigator&&/firefox/i.test(navigator.userAgent)?(_=new Uint8Array(await o.arrayBuffer()),G(r.progress_callback,{status:"progress",name:e,file:t,progress:100,loaded:_.length,total:_.length})):_=await async function g(e,t){const n=e.headers.get("Content-Length");null===n&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let r=parseInt(n??"0"),s=new Uint8Array(r),i=0;const a=e.body.getReader();async function o(){const{done:e,value:n}=await a.read();if(e)return;let l=i+n.length;if(l>r){r=l;let e=new Uint8Array(r);e.set(s),s=e}s.set(n,i),i=l;return t({progress:i/r*100,loaded:i,total:r}),o()}return await o(),s}(o,(n=>{G(r.progress_callback,{status:"progress",name:e,file:t,...n})})):_=new Uint8Array(await o.arrayBuffer()),h&&a&&void 0===await s.match(a)&&await s.put(a,new Response(_,{headers:o.headers})).catch((e=>{console.warn(`Unable to add response to browser cache: ${e}.`)})),G(r.progress_callback,{status:"done",name:e,file:t}),_}async function ce(e,t,n=!0,r={}){let s=await de(e,t,n,r);if(null===s)return{};let i=new TextDecoder("utf-8").decode(s);return JSON.parse(i)}function pe(...e){return e=e.map(((t,n)=>(n&&(t=t.replace(new RegExp("^/"),"")),n!==e.length-1&&(t=t.replace(new RegExp("/$"),"")),t))),e.join("/")}function he(e){const t=_e(e)[0],n=e.map((e=>Math.exp(e-t))),r=n.reduce(((e,t)=>e+t),0);return n.map((e=>e/r))}function fe(e){const t=_e(e)[0];let n=0;for(let r=0;r<e.length;++r)n+=Math.exp(e[r]-t);const r=Math.log(n);return e.map((e=>e-t-r))}function me(e){if(0===e.length)throw Error("Array must not be empty");let t=e[0],n=0;for(let r=1;r<e.length;++r)e[r]<t&&(t=e[r],n=r);return[t,n]}function _e(e){if(0===e.length)throw Error("Array must not be empty");let t=e[0],n=0;for(let r=1;r<e.length;++r)e[r]>t&&(t=e[r],n=r);return[Number(t),n]}function ge(e){return e>0&&!(e&e-1)}class we{constructor(e){if(this.size=0|e,this.size<=1||!ge(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=e<<1,this.table=new Float64Array(2*this.size);for(let e=0;e<this.table.length;e+=2){const t=Math.PI*e/this.size;this.table[e]=Math.cos(t),this.table[e+1]=-Math.sin(t)}let t=0;for(let e=1;this.size>e;e<<=1)++t;this._width=t%2==0?t-1:t,this._bitrev=new Int32Array(1<<this._width);for(let e=0;e<this._bitrev.length;++e){this._bitrev[e]=0;for(let t=0;t<this._width;t+=2){const n=this._width-t-2;this._bitrev[e]|=(e>>>t&3)<<n}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(e,t){const n=t||new Array(e.length>>>1);for(let t=0;t<e.length;t+=2)n[t>>>1]=e[t];return n}toComplexArray(e,t){const n=t||this.createComplexArray();for(let t=0;t<n.length;t+=2)n[t]=e[t>>>1],n[t+1]=0;return n}transform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._transform4(e,t,1)}realTransform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._realTransform4(e,t,1)}inverseTransform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._transform4(e,t,-1);for(let t=0;t<e.length;++t)e[t]/=this.size}_transform4(e,t,n){const r=this._csize;let s,i,a=1<<this._width,o=r/a<<1;const l=this._bitrev;if(4===o)for(s=0,i=0;s<r;s+=o,++i){const n=l[i];this._singleTransform2(t,e,s,n,a)}else for(s=0,i=0;s<r;s+=o,++i){const r=l[i];this._singleTransform4(t,e,s,r,a,n)}const u=this.table;for(a>>=2;a>=2;a>>=2){o=r/a<<1;const t=o>>>2;for(s=0;s<r;s+=o){const r=s+t-1;for(let i=s,o=0;i<r;i+=2,o+=a){const r=i,s=r+t,a=s+t,l=a+t,d=e[r],c=e[r+1],p=e[s],h=e[s+1],f=e[a],m=e[a+1],_=e[l],g=e[l+1],w=u[o],y=n*u[o+1],b=p*w-h*y,x=p*y+h*w,v=u[2*o],$=n*u[2*o+1],k=f*v-m*$,E=f*$+m*v,S=u[3*o],z=n*u[3*o+1],C=_*S-g*z,T=_*z+g*S,A=d+k,I=c+E,M=d-k,O=c-E,B=b+C,N=x+T,P=n*(b-C),R=n*(x-T);e[r]=A+B,e[r+1]=I+N,e[s]=M+R,e[s+1]=O-P,e[a]=A-B,e[a+1]=I-N,e[l]=M-R,e[l+1]=O+P}}}}_singleTransform2(e,t,n,r,s){const i=e[r],a=e[r+1],o=e[r+s],l=e[r+s+1];t[n]=i+o,t[n+1]=a+l,t[n+2]=i-o,t[n+3]=a-l}_singleTransform4(e,t,n,r,s,i){const a=2*s,o=3*s,l=e[r],u=e[r+1],d=e[r+s],c=e[r+s+1],p=e[r+a],h=e[r+a+1],f=e[r+o],m=e[r+o+1],_=l+p,g=u+h,w=l-p,y=u-h,b=d+f,x=c+m,v=i*(d-f),$=i*(c-m);t[n]=_+b,t[n+1]=g+x,t[n+2]=w+$,t[n+3]=y-v,t[n+4]=_-b,t[n+5]=g-x,t[n+6]=w-$,t[n+7]=y+v}_realTransform4(e,t,n){const r=this._csize;let s,i,a=1<<this._width,o=r/a<<1;const l=this._bitrev;if(4===o)for(s=0,i=0;s<r;s+=o,++i){const n=l[i];this._singleRealTransform2(t,e,s,n>>>1,a>>>1)}else for(s=0,i=0;s<r;s+=o,++i){const r=l[i];this._singleRealTransform4(t,e,s,r>>>1,a>>>1,n)}const u=this.table;for(a>>=2;a>=2;a>>=2){o=r/a<<1;const t=o>>>1,i=t>>>1,l=i>>>1;for(s=0;s<r;s+=o)for(let r=0,o=0;r<=l;r+=2,o+=a){const a=s+r,d=a+i,c=d+i,p=c+i,h=e[a],f=e[a+1],m=e[d],_=e[d+1],g=e[c],w=e[c+1],y=e[p],b=e[p+1],x=h,v=f,$=u[o],k=n*u[o+1],E=m*$-_*k,S=m*k+_*$,z=u[2*o],C=n*u[2*o+1],T=g*z-w*C,A=g*C+w*z,I=u[3*o],M=n*u[3*o+1],O=y*I-b*M,B=y*M+b*I,N=x+T,P=v+A,R=x-T,D=v-A,L=E+O,F=S+B,U=n*(E-O),q=n*(S-B);if(e[a]=N+L,e[a+1]=P+F,e[d]=R+q,e[d+1]=D-U,0===r){e[c]=N-L,e[c+1]=P-F;continue}if(r===l)continue;const V=s+i-r,W=s+t-r;e[V]=R-n*q,e[V+1]=-D-n*U,e[W]=N-n*L,e[W+1]=n*F-P}}const d=r>>>1;for(let t=2;t<d;t+=2)e[r-t]=e[t],e[r-t+1]=-e[t+1]}_singleRealTransform2(e,t,n,r,s){const i=e[r],a=e[r+s];t[n]=i+a,t[n+1]=0,t[n+2]=i-a,t[n+3]=0}_singleRealTransform4(e,t,n,r,s,i){const a=2*s,o=3*s,l=e[r],u=e[r+s],d=e[r+a],c=e[r+o],p=l+d,h=l-d,f=u+c,m=i*(u-c);t[n]=p+f,t[n+1]=0,t[n+2]=h,t[n+3]=-m,t[n+4]=p-f,t[n+5]=0,t[n+6]=h,t[n+7]=m}}class ye{constructor(e){const t=2*(e-1),n=2*(2*e-1),r=2**Math.ceil(Math.log2(n));this.bufferSize=r,this._a=t;const s=new Float64Array(n),i=new Float64Array(r);this._chirpBuffer=new Float64Array(r),this._buffer1=new Float64Array(r),this._buffer2=new Float64Array(r),this._outBuffer1=new Float64Array(r),this._outBuffer2=new Float64Array(r);const a=-2*Math.PI/e,o=Math.cos(a),l=Math.sin(a);for(let t=0;t<n>>1;++t){const n=(t+1-e)**2/2,r=Math.sqrt(o**2+l**2)**n,a=n*Math.atan2(l,o),u=2*t;s[u]=r*Math.cos(a),s[u+1]=r*Math.sin(a),i[u]=s[u],i[u+1]=-s[u+1]}this._slicedChirpBuffer=s.subarray(t,n),this._f=new we(r>>1),this._f.transform(this._chirpBuffer,i)}_transform(e,t,n){const r=this._buffer1,s=this._buffer2,i=this._outBuffer1,a=this._outBuffer2,o=this._chirpBuffer,l=this._slicedChirpBuffer,u=this._a;if(n)for(let e=0;e<l.length;e+=2){const n=e+1,s=t[e>>1];r[e]=s*l[e],r[n]=s*l[n]}else for(let e=0;e<l.length;e+=2){const n=e+1;r[e]=t[e]*l[e]-t[n]*l[n],r[n]=t[e]*l[n]+t[n]*l[e]}this._f.transform(i,r);for(let e=0;e<o.length;e+=2){const t=e+1;s[e]=i[e]*o[e]-i[t]*o[t],s[t]=i[e]*o[t]+i[t]*o[e]}this._f.inverseTransform(a,s);for(let t=0;t<a.length;t+=2){const n=a[t+u],r=a[t+u+1],s=l[t],i=l[t+1];e[t]=n*s-r*i,e[t+1]=n*i+r*s}}transform(e,t){this._transform(e,t,!1)}realTransform(e,t){this._transform(e,t,!0)}}class be{constructor(e){this.fft_length=e,this.isPowerOfTwo=ge(e),this.isPowerOfTwo?(this.fft=new we(e),this.outputBufferSize=2*e):(this.fft=new ye(e),this.outputBufferSize=this.fft.bufferSize)}realTransform(e,t){this.fft.realTransform(e,t)}transform(e,t){this.fft.transform(e,t)}}function xe(e,t){if(t%2==0||t<=0)throw new Error("Window size must be a positive odd number");const n=new e.constructor(e.length),r=new e.constructor(t),s=Math.floor(t/2);for(let t=0;t<e.length;++t){let i=0;for(let n=-s;n<=s;++n){let s=t+n;s<0?s=Math.abs(s):s>=e.length&&(s=2*(e.length-1)-s),r[i++]=e[s]}r.sort(),n[t]=r[s]}return n}function ve(e,t){const n=Math.pow(10,t);return Math.round(e*n)/n}function $e(e){const t=e.length,n=e[0].length,r=[t+1,n+1],s=Array.from({length:r[0]},(()=>Array(r[1]).fill(Infinity)));s[0][0]=0;const i=Array.from({length:r[0]},(()=>Array(r[1]).fill(-1)));for(let t=1;t<r[1];++t)for(let n=1;n<r[0];++n){const r=s[n-1][t-1],a=s[n-1][t],o=s[n][t-1];let l,u;r<a&&r<o?(l=r,u=0):a<r&&a<o?(l=a,u=1):(l=o,u=2),s[n][t]=e[n-1][t-1]+l,i[n][t]=u}for(let e=0;e<r[1];++e)i[0][e]=2;for(let e=0;e<r[0];++e)i[e][0]=1;let a=t,o=n,l=[],u=[];for(;a>0||o>0;)switch(l.push(a-1),u.push(o-1),i[a][o]){case 0:--a,--o;break;case 1:--a;break;case 2:--o;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${a}, ${o}]. Please file a bug report.`)}return l.reverse(),u.reverse(),[l,u]}var ke,Ee,Se,ze,Ce,Te,Ae,Ie,Me,Oe,Be,Ne,Pe,Re,De,Le,Fe,Ue,qe,Ve,We,je,Ge,He,Ke,Xe,Qe,Ye,Ze,Je,et,tt,nt=s(193),rt=s.t(nt,2),st=Object.defineProperty,it=Object.getOwnPropertyDescriptor,at=Object.getOwnPropertyNames,ot=Object.prototype.hasOwnProperty,lt=(ke=function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error(\'Dynamic require of "\'+e+\'" is not supported\')},typeof require<"u"?require:typeof Proxy<"u"?new Proxy(ke,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):ke),ut=(e,t)=>()=>(e&&(t=e(e=0)),t),dt=(e,t)=>{for(var n in t)st(e,n,{get:t[n],enumerable:!0})},ct=e=>((e,t,n,r)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let s of at(t))!ot.call(e,s)&&s!==n&&st(e,s,{get:()=>t[s],enumerable:!(r=it(t,s))||r.enumerable});return e})(st({},"__esModule",{value:!0}),e),pt=ut((()=>{Ee=new Map,Se=[],ze=(e,t,n)=>{if(!t||"function"!=typeof t.init||"function"!=typeof t.createInferenceSessionHandler)throw new TypeError("not a valid backend");{let r=Ee.get(e);if(void 0===r)Ee.set(e,{backend:t,priority:n});else{if(r.priority>n)return;if(r.priority===n&&r.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){let t=Se.indexOf(e);-1!==t&&Se.splice(t,1);for(let t=0;t<Se.length;t++)if(Ee.get(Se[t]).priority<=n)return void Se.splice(t,0,e);Se.push(e)}}},Ce=async e=>{let t=Ee.get(e);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let n=!!t.initPromise;try{return n||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(e){return n||(t.error=`${e}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},Te=async e=>{let t,n=e.executionProviders||[],r=n.map((e=>"string"==typeof e?e:e.name)),s=0===r.length?Se:r,i=[],a=new Set;for(let e of s){let n=await Ce(e);"string"==typeof n?i.push({name:e,err:n}):(t||(t=n),t===n&&a.add(e))}if(!t)throw new Error(`no available backend found. ERR: ${i.map((e=>`[${e.name}] ${e.err}`)).join(", ")}`);for(let{name:e,err:t}of i)r.includes(e)&&console.warn(`removing requested execution provider "${e}" from session options because it is not available: ${t}`);let o=n.filter((e=>a.has("string"==typeof e?e:e.name)));return[t,new Proxy(e,{get:(e,t)=>"executionProviders"===t?o:Reflect.get(e,t)})]}})),ht=ut((()=>{pt()})),ft=ut((()=>{Ae="1.21.0-dev.20241205-6ed77cc374"})),mt=ut((()=>{ft(),Ie="warning",Me={wasm:{},webgl:{},webgpu:{},versions:{common:Ae},set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);Ie=e}},get logLevel(){return Ie}},Object.defineProperty(Me,"logLevel",{enumerable:!0})})),_t=ut((()=>{mt(),Oe=Me})),gt=ut((()=>{Be=(e,t)=>{let n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];let r=n.getContext("2d");if(null!=r){let s,i;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(s=e.dims[2],i=e.dims[3]):(s=e.dims[3],i=e.dims[2]);let a,o,l=void 0!==t?.format?t.format:"RGB",u=t?.norm;void 0===u||void 0===u.mean?a=[255,255,255,255]:"number"==typeof u.mean?a=[u.mean,u.mean,u.mean,u.mean]:(a=[u.mean[0],u.mean[1],u.mean[2],0],void 0!==u.mean[3]&&(a[3]=u.mean[3])),void 0===u||void 0===u.bias?o=[0,0,0,0]:"number"==typeof u.bias?o=[u.bias,u.bias,u.bias,u.bias]:(o=[u.bias[0],u.bias[1],u.bias[2],0],void 0!==u.bias[3]&&(o[3]=u.bias[3]));let d=i*s,c=0,p=d,h=2*d,f=-1;"RGBA"===l?(c=0,p=d,h=2*d,f=3*d):"RGB"===l?(c=0,p=d,h=2*d):"RBG"===l&&(c=0,h=d,p=2*d);for(let t=0;t<i;t++)for(let n=0;n<s;n++){let s=(e.data[c++]-o[0])*a[0],i=(e.data[p++]-o[1])*a[1],l=(e.data[h++]-o[2])*a[2],u=-1===f?255:(e.data[f++]-o[3])*a[3];r.fillStyle="rgba("+s+","+i+","+l+","+u+")",r.fillRect(n,t,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}throw new Error("Can not access image data")},Ne=(e,t)=>{let n,r=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");if(null==r)throw new Error("Can not access image data");{let s,i,a;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(s=e.dims[2],i=e.dims[1],a=e.dims[3]):(s=e.dims[3],i=e.dims[2],a=e.dims[1]);let o,l,u=void 0!==t&&void 0!==t.format?t.format:"RGB",d=t?.norm;void 0===d||void 0===d.mean?o=[255,255,255,255]:"number"==typeof d.mean?o=[d.mean,d.mean,d.mean,d.mean]:(o=[d.mean[0],d.mean[1],d.mean[2],255],void 0!==d.mean[3]&&(o[3]=d.mean[3])),void 0===d||void 0===d.bias?l=[0,0,0,0]:"number"==typeof d.bias?l=[d.bias,d.bias,d.bias,d.bias]:(l=[d.bias[0],d.bias[1],d.bias[2],0],void 0!==d.bias[3]&&(l[3]=d.bias[3]));let c=i*s;if(void 0!==t&&(void 0!==t.format&&4===a&&"RGBA"!==t.format||3===a&&"RGB"!==t.format&&"BGR"!==t.format))throw new Error("Tensor format doesn\'t match input tensor dims");let p=4,h=0,f=1,m=2,_=3,g=0,w=c,y=2*c,b=-1;"RGBA"===u?(g=0,w=c,y=2*c,b=3*c):"RGB"===u?(g=0,w=c,y=2*c):"RBG"===u&&(g=0,y=c,w=2*c),n=r.createImageData(s,i);for(let t=0;t<i*s;h+=p,f+=p,m+=p,_+=p,t++)n.data[h]=(e.data[g++]-l[0])*o[0],n.data[f]=(e.data[w++]-l[1])*o[1],n.data[m]=(e.data[y++]-l[2])*o[2],n.data[_]=-1===b?255:(e.data[b++]-l[3])*o[3]}return n}})),wt=ut((()=>{xt(),Pe=(e,t)=>{if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");let n,r,{height:s,width:i}=t,a=t.norm??{mean:255,bias:0};n="number"==typeof a.mean?[a.mean,a.mean,a.mean,a.mean]:[a.mean[0],a.mean[1],a.mean[2],a.mean[3]??255],r="number"==typeof a.bias?[a.bias,a.bias,a.bias,a.bias]:[a.bias[0],a.bias[1],a.bias[2],a.bias[3]??0];let o=void 0!==t.format?t.format:"RGBA",l=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",u=s*i,d="RGBA"===l?new Float32Array(4*u):new Float32Array(3*u),c=4,p=0,h=1,f=2,m=3,_=0,g=u,w=2*u,y=-1;"RGB"===o&&(c=3,p=0,h=1,f=2,m=-1),"RGBA"===l?y=3*u:"RBG"===l?(_=0,w=u,g=2*u):"BGR"===l&&(w=0,g=u,_=2*u);for(let t=0;t<u;t++,p+=c,f+=c,h+=c,m+=c)d[_++]=(e[p]+r[0])/n[0],d[g++]=(e[h]+r[1])/n[1],d[w++]=(e[f]+r[2])/n[2],-1!==y&&-1!==m&&(d[y++]=(e[m]+r[3])/n[3]);return new Ke("float32",d,"RGBA"===l?[1,4,s,i]:[1,3,s,i])},Re=async(e,t)=>{let n,r=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,s=typeof ImageData<"u"&&e instanceof ImageData,i=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,a="string"==typeof e,o=t??{},l=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},u=e=>typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas?e.getContext("2d"):null;if(r){let r=l();r.width=e.width,r.height=e.height;let s=u(r);if(null==s)throw new Error("Can not access image data");{let r=e.height,i=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(r=t.resizedHeight,i=t.resizedWidth),void 0!==t){if(o=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");o.tensorFormat="RGBA",o.height=r,o.width=i}else o.tensorFormat="RGBA",o.height=r,o.width=i;s.drawImage(e,0,0),n=s.getImageData(0,0,i,r).data}}else{if(!s){if(i){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");let r=l();r.width=e.width,r.height=e.height;let s=u(r);if(null!=s){let t=e.height,r=e.width;return s.drawImage(e,0,0,r,t),n=s.getImageData(0,0,r,t).data,o.height=t,o.width=r,Pe(n,o)}throw new Error("Can not access image data")}if(a)return new Promise(((t,n)=>{let r=l(),s=u(r);if(!e||!s)return n();let i=new Image;i.crossOrigin="Anonymous",i.src=e,i.onload=()=>{r.width=i.width,r.height=i.height,s.drawImage(i,0,0,r.width,r.height);let e=s.getImageData(0,0,r.width,r.height);o.height=r.height,o.width=r.width,t(Pe(e.data,o))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{let r,s;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(r=t.resizedHeight,s=t.resizedWidth):(r=e.height,s=e.width),void 0!==t&&(o=t),o.format="RGBA",o.height=r,o.width=s,void 0!==t){let t=l();t.width=s,t.height=r;let i=u(t);if(null==i)throw new Error("Can not access image data");i.putImageData(e,0,0),n=i.getImageData(0,0,s,r).data}else n=e.data}}if(void 0!==n)return Pe(n,o);throw new Error("Input data provided is not supported - aborted tensor creation")},De=(e,t)=>{let{width:n,height:r,download:s,dispose:i}=t;return new Ke({location:"texture",type:"float32",texture:e,dims:[1,r,n,4],download:s,dispose:i})},Le=(e,t)=>{let{dataType:n,dims:r,download:s,dispose:i}=t;return new Ke({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:r,download:s,dispose:i})},Fe=(e,t)=>{let{dataType:n,dims:r,download:s,dispose:i}=t;return new Ke({location:"ml-tensor",type:n??"float32",mlTensor:e,dims:r,download:s,dispose:i})},Ue=(e,t,n)=>new Ke({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]})})),yt=ut((()=>{qe=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Ve=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),We=!1,je=()=>{if(!We){We=!0;let e=typeof BigInt64Array<"u"&&BigInt64Array.from,t=typeof BigUint64Array<"u"&&BigUint64Array.from,n=typeof Float16Array<"u"&&Float16Array.from;e&&(qe.set("int64",BigInt64Array),Ve.set(BigInt64Array,"int64")),t&&(qe.set("uint64",BigUint64Array),Ve.set(BigUint64Array,"uint64")),n?(qe.set("float16",Float16Array),Ve.set(Float16Array,"float16")):qe.set("float16",Uint16Array)}}})),bt=ut((()=>{xt(),Ge=e=>{let t=1;for(let n=0;n<e.length;n++){let r=e[n];if("number"!=typeof r||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t},He=(e,t)=>{switch(e.location){case"cpu":return new Ke(e.type,e.data,t);case"cpu-pinned":return new Ke({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new Ke({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new Ke({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new Ke({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}})),xt=ut((()=>{gt(),wt(),yt(),bt(),Ke=class{constructor(e,t,n){let r,s;if(je(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,r=e.type,s=e.dims,e.location){case"cpu-pinned":{let t=qe.get(r);if(!t)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw new TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"uint8"!==r&&"bool"!==r&&"uint4"!==r&&"int4"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;case"ml-tensor":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"uint64"!==r&&"int8"!==r&&"uint8"!==r&&"bool"!==r&&"uint4"!==r&&"int4"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break;default:throw new Error(`Tensor constructor: unsupported location \'${this.dataLocation}\'`)}else{let i,a;if("string"==typeof e)if(r=e,a=n,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor\'s data must be a string array.");i=t}else{let n=qe.get(e);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e&&n===Uint16Array||"uint4"===e||"int4"===e)throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${n.name} as data.`);i="uint64"===e||"int64"===e?n.from(t,BigInt):n.from(t)}else if(t instanceof n)i=t;else{if(!(t instanceof Uint8ClampedArray))throw new TypeError(`A ${r} tensor\'s data must be type of ${n}`);if("uint8"!==e)throw new TypeError("A Uint8ClampedArray tensor\'s data must be type of uint8");i=Uint8Array.from(t)}}else if(a=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");let t=typeof e[0];if("string"===t)r="string",i=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);r="bool",i=Uint8Array.from(e)}}else if(e instanceof Uint8ClampedArray)r="uint8",i=Uint8Array.from(e);else{let t=Ve.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=t,i=e}if(void 0===a)a=[i.length];else if(!Array.isArray(a))throw new TypeError("A tensor\'s dims must be a number array");s=a,this.cpuData=i,this.dataLocation="cpu"}let i=Ge(s);if(this.cpuData&&i!==this.cpuData.length&&("uint4"!==r&&"int4"!==r||Math.ceil(i/2)!==this.cpuData.length))throw new Error(`Tensor\'s size(${i}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=s,this.size=i}static async fromImage(e,t){return Re(e,t)}static fromTexture(e,t){return De(e,t)}static fromGpuBuffer(e,t){return Le(e,t)}static fromMLTensor(e,t){return Fe(e,t)}static fromPinnedBuffer(e,t,n){return Ue(e,t,n)}toDataURL(e){return Be(this,e)}toImageData(e){return Ne(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return He(this,e)}}})),vt=ut((()=>{xt(),Xe=Ke})),$t=ut((()=>{mt(),Qe=(e,t)=>{(typeof Me.trace>"u"?!Me.wasm.trace:!Me.trace)||console.timeStamp(`${e}::ORT::${t}`)},Ye=(e,t)=>{let n=(new Error).stack?.split(/\\r\\n|\\r|\\n/g)||[],r=!1;for(let s=0;s<n.length;s++){if(r&&!n[s].includes("TRACE_FUNC")){let r=`FUNC_${e}::${n[s].trim().split(" ")[1]}`;return t&&(r+=`::${t}`),void Qe("CPU",r)}n[s].includes("TRACE_FUNC")&&(r=!0)}},Ze=e=>{(typeof Me.trace>"u"?!Me.wasm.trace:!Me.trace)||Ye("BEGIN",e)},Je=e=>{(typeof Me.trace>"u"?!Me.wasm.trace:!Me.trace)||Ye("END",e)}})),kt=ut((()=>{pt(),vt(),$t(),et=class e{constructor(e){this.handler=e}async run(e,t,n){Ze();let r={},s={};if("object"!=typeof e||null===e||e instanceof Xe||Array.isArray(e))throw new TypeError("\'feeds\' must be an object that use input names as keys and OnnxValue as corresponding values.");let i=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof Xe)throw new TypeError("\'fetches\' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("\'fetches\' cannot be an empty array.");i=!1;for(let e of t){if("string"!=typeof e)throw new TypeError("\'fetches\' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`\'fetches\' contains invalid output name: ${e}.`);r[e]=null}if("object"==typeof n&&null!==n)s=n;else if(typeof n<"u")throw new TypeError("\'options\' must be an object.")}else{let e=!1,a=Object.getOwnPropertyNames(t);for(let n of this.outputNames)if(-1!==a.indexOf(n)){let s=t[n];(null===s||s instanceof Xe)&&(e=!0,i=!1,r[n]=s)}if(e){if("object"==typeof n&&null!==n)s=n;else if(typeof n<"u")throw new TypeError("\'options\' must be an object.")}else s=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be \'fetches\' or \'options\'.");for(let t of this.inputNames)if(typeof e[t]>"u")throw new Error(`input \'${t}\' is missing in \'feeds\'.`);if(i)for(let e of this.outputNames)r[e]=null;let a=await this.handler.run(e,r,s),o={};for(let e in a)if(Object.hasOwnProperty.call(a,e)){let t=a[e];o[e]=t instanceof Xe?t:new Xe(t.type,t.data,t.dims)}return Je(),o}async release(){return this.handler.dispose()}static async create(t,n,r,s){Ze();let i,a={};if("string"==typeof t){if(i=t,"object"==typeof n&&null!==n)a=n;else if(typeof n<"u")throw new TypeError("\'options\' must be an object.")}else if(t instanceof Uint8Array){if(i=t,"object"==typeof n&&null!==n)a=n;else if(typeof n<"u")throw new TypeError("\'options\' must be an object.")}else{if(!(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be \'path\' or \'buffer\'.");{let e=t,o=0,l=t.byteLength;if("object"==typeof n&&null!==n)a=n;else if("number"==typeof n){if(o=n,!Number.isSafeInteger(o))throw new RangeError("\'byteOffset\' must be an integer.");if(o<0||o>=e.byteLength)throw new RangeError(`\'byteOffset\' is out of range [0, ${e.byteLength}).`);if(l=t.byteLength-o,"number"==typeof r){if(l=r,!Number.isSafeInteger(l))throw new RangeError("\'byteLength\' must be an integer.");if(l<=0||o+l>e.byteLength)throw new RangeError(`\'byteLength\' is out of range (0, ${e.byteLength-o}].`);if("object"==typeof s&&null!==s)a=s;else if(typeof s<"u")throw new TypeError("\'options\' must be an object.")}else if(typeof r<"u")throw new TypeError("\'byteLength\' must be a number.")}else if(typeof n<"u")throw new TypeError("\'options\' must be an object.");i=new Uint8Array(e,o,l)}}let[o,l]=await Te(a),u=await o.createInferenceSessionHandler(i,l);return Je(),new e(u)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}})),Et=ut((()=>{kt(),tt=et})),St=ut((()=>{})),zt=ut((()=>{})),Ct=ut((()=>{})),Tt=ut((()=>{})),At={};dt(At,{InferenceSession:()=>tt,TRACE:()=>Qe,TRACE_FUNC_BEGIN:()=>Ze,TRACE_FUNC_END:()=>Je,Tensor:()=>Xe,env:()=>Oe,registerBackend:()=>ze});var It=ut((()=>{ht(),_t(),Et(),vt(),St(),zt(),$t(),Ct(),Tt()})),Mt=ut((()=>{})),Ot={};dt(Ot,{default:()=>Pt});var Bt,Nt,Pt,Rt=ut((()=>{wp(),wd(),gd(),Bt="ort-wasm-proxy-worker",(Nt=globalThis.self?.name===Bt)&&(self.onmessage=e=>{let{type:t,in:n}=e.data;try{switch(t){case"init-wasm":nn(n.wasm).then((()=>{Lc(n).then((()=>{postMessage({type:t})}),(e=>{postMessage({type:t,err:e})}))}),(e=>{postMessage({type:t,err:e})}));break;case"init-ep":{let{epName:e,env:r}=n;Fc(r,e).then((()=>{postMessage({type:t})}),(e=>{postMessage({type:t,err:e})}));break}case"copy-from":{let{buffer:e}=n,r=Vc(e);postMessage({type:t,out:r});break}case"create":{let{model:e,options:r}=n;Wc(e,r).then((e=>{postMessage({type:t,out:e})}),(e=>{postMessage({type:t,err:e})}));break}case"release":jc(n),postMessage({type:t});break;case"run":{let{sessionId:e,inputIndices:r,inputs:s,outputIndices:i,options:a}=n;Hc(e,r,s,i,new Array(i.length).fill(null),a).then((e=>{e.some((e=>"cpu"!==e[3]))?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:e},Xc([...s,...e]))}),(e=>{postMessage({type:t,err:e})}));break}case"end-profiling":Kc(n),postMessage({type:t})}}catch(e){postMessage({type:t,err:e})}}),Pt=Nt?null:e=>new Worker(e??qt,{type:"module",name:Bt})})),Dt={};dt(Dt,{default:()=>Ut});var Lt,Ft,Ut,qt,Vt,Wt,jt,Gt,Ht,Kt,Xt,Qt,Yt,Zt,Jt,en,tn,nn,rn,sn,an,on,ln,un,dn,cn,pn,hn,fn,mn,_n,gn,wn,yn,bn,xn,vn,$n,kn,En,Sn,zn,Cn,Tn,An,In,Mn,On,Bn,Nn,Pn,Rn,Dn,Ln,Fn,Un,qn,Vn,Wn,jn,Gn,Hn,Kn,Xn,Qn,Yn,Zn,Jn,er,tr,nr,rr,sr,ir,ar,or,lr,ur,dr,cr,pr,hr,fr,mr,_r,gr,wr,yr,br,xr,vr,$r,kr,Er,Sr,zr,Cr,Tr,Ar,Ir,Mr,Or,Br,Nr,Pr,Rr,Dr,Lr,Fr,Ur,qr,Vr,Wr,jr,Gr,Hr,Kr,Xr,Qr,Yr,Zr,Jr,es,ts,ns,rs,ss,is,as,os,ls,us,ds,cs,ps,hs,fs,ms,_s,gs,ws,ys,bs,xs,vs,$s,ks,Es,Ss,zs,Cs,Ts,As,Is,Ms,Os,Bs,Ns,Ps,Rs,Ds,Ls,Fs,Us,qs,Vs,Ws,js,Gs,Hs,Ks,Xs,Qs,Ys,Zs,Js,ei,ti,ni,ri,si,ii,ai,oi,li,ui,di,ci,pi,hi,fi,mi,_i,gi,wi,yi,bi,xi,vi,$i,ki,Ei,Si,zi,Ci,Ti,Ai,Ii,Mi,Oi,Bi,Ni,Pi,Ri,Di,Li,Fi,Ui,qi,Vi,Wi,ji,Gi,Hi,Ki,Xi,Qi,Yi,Zi,Ji,ea,ta,na,ra,sa,ia,aa,oa,la,ua,da,ca,pa,ha,fa,ma,_a,ga,wa,ya,ba,xa,va,$a,ka,Ea,Sa,za,Ca,Ta,Aa,Ia,Ma,Oa,Ba,Na,Pa,Ra,Da,La,Fa,Ua,qa,Va,Wa,ja,Ga,Ha,Ka,Xa,Qa,Ya,Za,Ja,eo,to,no,ro,so,io,ao,oo,lo,uo,co,po,ho,fo,mo,_o,go,wo,yo,bo,xo,vo,$o,ko,Eo,So,zo,Co,To,Ao,Io,Mo,Oo,Bo,No,Po,Ro,Do,Lo,Fo,Uo,qo,Vo,Wo,jo,Go,Ho,Ko,Xo,Qo,Yo,Zo,Jo,el,tl,nl,rl,sl,il,al,ol,ll,ul,dl,cl,pl,hl,fl,ml,_l,gl,wl,yl,bl,xl,vl,$l,kl,El,Sl,zl,Cl,Tl,Al,Il,Ml,Ol,Bl,Nl,Pl,Rl,Dl,Ll,Fl,Ul,ql,Vl,Wl,jl,Gl,Hl,Kl,Xl,Ql,Yl,Zl,Jl,eu,tu,nu,ru,su,iu,au,ou,lu,uu,du,cu,pu,hu,fu,mu,_u,gu,wu,yu,bu,xu,vu,$u,ku,Eu,Su,zu,Cu,Tu,Au,Iu,Mu,Ou,Bu,Nu,Pu,Ru,Du,Lu,Fu,Uu,qu,Vu,Wu,ju,Gu,Hu,Ku,Xu,Qu,Yu,Zu,Ju,ed,td,nd,rd,sd,id,ad,od,ld,ud,dd,cd,pd,hd,fd,md,_d=ut((()=>{Lt="file:///Users/sam-schaack/gamp/nuiq-asr/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs",Ft=async function(e={}){function t(){return I.buffer!=B.buffer&&j(),B}function n(){return I.buffer!=B.buffer&&j(),N}function r(){return I.buffer!=B.buffer&&j(),P}function i(){return I.buffer!=B.buffer&&j(),R}function a(){return I.buffer!=B.buffer&&j(),D}function o(){return I.buffer!=B.buffer&&j(),L}function l(){return I.buffer!=B.buffer&&j(),F}function u(){return I.buffer!=B.buffer&&j(),V}var d,c,p=Object.assign({},e),h=new Promise(((e,t)=>{d=e,c=t})),f="object"==typeof window,m="function"==typeof importScripts,_=m&&"em-pthread"==self.name;p.mountExternalData=(e,t)=>{e.startsWith("./")&&(e=e.substring(2)),(p.Fb||(p.Fb=new Map)).set(e,t)},p.unmountExternalData=()=>{delete p.Fb};var g=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor;let w=()=>{let e=(e,t,n)=>(...r)=>{let s=Kt,i=t?.();r=e(...r);let a=t?.();return i!==a&&(e=a,n(i),t=n=null),Kt!=s?new Promise(((e,t)=>{en={resolve:e,reject:t}})):r},t=e=>async(...t)=>{try{if(p.Gb)throw Error("Session already started");let n=p.Gb={hc:t[0],errors:[]},r=await e(...t);if(p.Gb!==n)throw Error("Session mismatch");p.Hb?.flush();let s=n.errors;if(0<s.length){let e=await Promise.all(s);if(e=e.filter((e=>e)),0<e.length)throw Error(e.join("\\n"))}return r}finally{p.Gb=null}};p._OrtCreateSession=e(p._OrtCreateSession,(()=>p._OrtCreateSession),(e=>p._OrtCreateSession=e)),p._OrtRun=t(e(p._OrtRun,(()=>p._OrtRun),(e=>p._OrtRun=e))),p._OrtRunWithBinding=t(e(p._OrtRunWithBinding,(()=>p._OrtRunWithBinding),(e=>p._OrtRunWithBinding=e))),p._OrtBindInput=e(p._OrtBindInput,(()=>p._OrtBindInput),(e=>p._OrtBindInput=e)),w=void 0};p.jsepInit=(e,t)=>{if(w?.(),"webgpu"===e){[p.Hb,p.Vb,p.Zb,p.Ob,p.Yb,p.kb,p.$b,p.cc,p.Wb,p.Xb,p.ac]=t;let e=p.Hb;p.jsepRegisterBuffer=(t,n,r,s)=>e.registerBuffer(t,n,r,s),p.jsepGetBuffer=t=>e.getBuffer(t),p.jsepCreateDownloader=(t,n,r)=>e.createDownloader(t,n,r),p.jsepOnCreateSession=t=>{e.onCreateSession(t)},p.jsepOnReleaseSession=t=>{e.onReleaseSession(t)},p.jsepOnRunStart=t=>e.onRunStart(t),p.dc=(t,n)=>{e.upload(t,n)}}else if("webnn"===e){[p.Hb,p.bc,p.Pb,p.jsepEnsureTensor,p.ec,p.jsepDownloadTensor]=t,p.jsepReleaseTensorId=p.Pb;let e=p.Hb;p.jsepOnRunStart=t=>e.onRunStart(t),p.jsepRegisterMLContext=(t,n)=>{e.registerMLContext(t,n)},p.jsepOnReleaseSession=t=>{e.onReleaseSession(t)},p.jsepCreateMLTensorDownloader=(t,n)=>e.createMLTensorDownloader(t,n),p.jsepRegisterMLTensor=(t,n,r)=>e.registerMLTensor(t,n,r),p.jsepCreateMLContext=t=>e.createMLContext(t),p.jsepRegisterMLConstant=(t,n,r,s,i)=>e.registerMLConstant(t,n,r,s,i,p.Fb)}};var y,b,x=Object.assign({},p),v=(e,t)=>{throw t},$="";(f||m)&&(m?$=self.location.href:typeof document<"u"&&document.currentScript&&($=document.currentScript.src),Lt&&($=Lt),$=$.startsWith("blob:")?"":$.substr(0,$.replace(/[?#].*/,"").lastIndexOf("/")+1),m&&(b=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),y=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var k,E=console.log.bind(console),S=console.error.bind(console),z=E,C=S;if(Object.assign(p,x),x=null,_){let e=function(t){try{var n=t.data,r=n.cmd;if("load"===r){let t=[];self.onmessage=e=>t.push(e),self.startWorker=()=>{postMessage({cmd:"loaded"});for(let n of t)e(n);self.onmessage=e};for(let e of n.handlers)p[e]&&!p[e].proxy||(p[e]=(...t)=>{postMessage({Nb:"callHandler",pc:e,args:t})},"print"==e&&(z=p[e]),"printErr"==e&&(C=p[e]));I=n.wasmMemory,j(),T(n.wasmModule)}else if("run"===r){kr(n.pthread_ptr,0,0,1,0,0),Bt(n.pthread_ptr),Se(),ve(),A||(yr(),A=!0);try{ze(n.start_routine,n.arg)}catch(e){if("unwind"!=e)throw e}}else"cancel"===r?xr()&&Cr(-1):"setimmediate"!==n.target&&("checkMailbox"===r?A&&Nt():r&&(C(`worker: received unknown command ${r}`),C(n)))}catch(e){throw Er(),e}};var T,A=!1;C=function(...e){e=e.join(" "),console.error(e)},self.alert=function(...e){postMessage({Nb:"alert",text:e.join(" "),rc:xr()})},p.instantiateWasm=(e,t)=>new Promise((e=>{T=n=>{n=new WebAssembly.Instance(n,ie()),t(n),e()}})),self.onunhandledrejection=e=>{throw e.reason||e},self.onmessage=e}p.wasmBinary&&(k=p.wasmBinary);var I,M,O,B,N,P,R,D,L,F,U,q,V,W=!1;function j(){var e=I.buffer;p.HEAP8=B=new Int8Array(e),p.HEAP16=P=new Int16Array(e),p.HEAPU8=N=new Uint8Array(e),p.HEAPU16=R=new Uint16Array(e),p.HEAP32=D=new Int32Array(e),p.HEAPU32=L=new Uint32Array(e),p.HEAPF32=F=new Float32Array(e),p.HEAPF64=V=new Float64Array(e),p.HEAP64=U=new BigInt64Array(e),p.HEAPU64=q=new BigUint64Array(e)}if(!_){if(!((I=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0})).buffer instanceof g))throw C("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),Error("bad memory");j()}var G=[],H=[],K=[],X=0,Q=null,Y=null;function Z(){if(0==--X&&(null!==Q&&(clearInterval(Q),Q=null),Y)){var e=Y;Y=null,e()}}function J(e){throw C(e="Aborted("+e+")"),W=!0,O=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),c(e),e}var ee,te=e=>e.startsWith("data:application/octet-stream;base64,"),ne=e=>e.startsWith("file://");function re(e){if(e==ee&&k)return new Uint8Array(k);if(b)return b(e);throw"both async and sync fetching of the wasm failed"}function se(e,t,n){return function(e){if(!k&&(f||m)){if("function"==typeof fetch&&!ne(e))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw`failed to load wasm binary file at \'${e}\'`;return t.arrayBuffer()})).catch((()=>re(e)));if(y)return new Promise(((t,n)=>{y(e,(e=>t(new Uint8Array(e))),n)}))}return Promise.resolve().then((()=>re(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then(n,(e=>{C(`failed to asynchronously prepare wasm: ${e}`),J(e)}))}function ie(){return{a:{O:le,Aa:oe,b:Te,aa:Ie,B:Ne,qa:Pe,Y:Fe,_:Ue,ra:qe,oa:Ve,ha:We,na:je,L:Ge,Z:He,W:Ke,pa:Xe,X:Qe,va:Je,F:at,Q:lt,P:_t,E:wt,u:yt,q:bt,G:xt,A:Tt,R:At,ua:It,ka:Mt,U:Pt,ba:Dt,H:Ft,ja:Bt,ta:Ut,t:Wt,Ba:jt,x:rn,n:an,l:un,c:ct,o:cn,j:mn,w:_n,p:gn,f:wn,s:yn,m:bn,e:xn,k:vn,i:$n,h:kn,d:En,ea:Sn,fa:An,ga:In,ca:Mn,da:On,T:Bn,g:Rn,D:Dn,I:Ln,M:Fn,y:Un,sa:Vn,V:Wn,v:qn,z:jn,N:Gn,S:Hn,za:Yn,ya:Zn,la:nr,ma:rr,$:_e,C:sr,K:ir,ia:ar,J:lr,a:I,xa:fe,wa:pr,r:hr}}}var ae={874308:(e,t,r,s,i)=>{if(void 0===p||!p.Fb)return 1;if((e=Be(Number(e>>>0))).startsWith("./")&&(e=e.substring(2)),!(e=p.Fb.get(e)))return 2;if(t=Number(t>>>0),r=Number(r>>>0),s=Number(s>>>0),t+r>e.byteLength)return 3;try{let a=e.subarray(t,t+r);switch(i){case 0:n().set(a,s>>>0);break;case 1:p.dc(s,a);break;default:return 4}return 0}catch{return 4}},875023:(e,t,r)=>{p.ec(e,n().subarray(t>>>0,t+r>>>0))},875086:()=>p.bc(),875127:e=>{p.Pb(e)},875163:()=>{p.Wb()},875194:()=>{p.Xb()},875223:()=>{p.ac()},875248:e=>p.Vb(e),875281:e=>p.Zb(e),875313:(e,t,n)=>{p.Ob(Number(e),Number(t),Number(n),!0)},875376:(e,t,n)=>{p.Ob(Number(e),Number(t),Number(n))},875433:()=>typeof wasmOffsetConverter<"u",875490:e=>{p.kb("Abs",e,void 0)},875541:e=>{p.kb("Neg",e,void 0)},875592:e=>{p.kb("Floor",e,void 0)},875645:e=>{p.kb("Ceil",e,void 0)},875697:e=>{p.kb("Reciprocal",e,void 0)},875755:e=>{p.kb("Sqrt",e,void 0)},875807:e=>{p.kb("Exp",e,void 0)},875858:e=>{p.kb("Erf",e,void 0)},875909:e=>{p.kb("Sigmoid",e,void 0)},875964:(e,t,n)=>{p.kb("HardSigmoid",e,{alpha:t,beta:n})},876043:e=>{p.kb("Log",e,void 0)},876094:e=>{p.kb("Sin",e,void 0)},876145:e=>{p.kb("Cos",e,void 0)},876196:e=>{p.kb("Tan",e,void 0)},876247:e=>{p.kb("Asin",e,void 0)},876299:e=>{p.kb("Acos",e,void 0)},876351:e=>{p.kb("Atan",e,void 0)},876403:e=>{p.kb("Sinh",e,void 0)},876455:e=>{p.kb("Cosh",e,void 0)},876507:e=>{p.kb("Asinh",e,void 0)},876560:e=>{p.kb("Acosh",e,void 0)},876613:e=>{p.kb("Atanh",e,void 0)},876666:e=>{p.kb("Tanh",e,void 0)},876718:e=>{p.kb("Not",e,void 0)},876769:(e,t,n)=>{p.kb("Clip",e,{min:t,max:n})},876838:e=>{p.kb("Clip",e,void 0)},876890:(e,t)=>{p.kb("Elu",e,{alpha:t})},876948:e=>{p.kb("Gelu",e,void 0)},877e3:e=>{p.kb("Relu",e,void 0)},877052:(e,t)=>{p.kb("LeakyRelu",e,{alpha:t})},877116:(e,t)=>{p.kb("ThresholdedRelu",e,{alpha:t})},877186:(e,t)=>{p.kb("Cast",e,{to:t})},877244:e=>{p.kb("Add",e,void 0)},877295:e=>{p.kb("Sub",e,void 0)},877346:e=>{p.kb("Mul",e,void 0)},877397:e=>{p.kb("Div",e,void 0)},877448:e=>{p.kb("Pow",e,void 0)},877499:e=>{p.kb("Equal",e,void 0)},877552:e=>{p.kb("Greater",e,void 0)},877607:e=>{p.kb("GreaterOrEqual",e,void 0)},877669:e=>{p.kb("Less",e,void 0)},877721:e=>{p.kb("LessOrEqual",e,void 0)},877780:(e,t,n,r,s)=>{p.kb("ReduceMean",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},877955:(e,t,n,r,s)=>{p.kb("ReduceMax",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},878129:(e,t,n,r,s)=>{p.kb("ReduceMin",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},878303:(e,t,n,r,s)=>{p.kb("ReduceProd",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},878478:(e,t,n,r,s)=>{p.kb("ReduceSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},878652:(e,t,n,r,s)=>{p.kb("ReduceL1",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},878825:(e,t,n,r,s)=>{p.kb("ReduceL2",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},878998:(e,t,n,r,s)=>{p.kb("ReduceLogSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},879175:(e,t,n,r,s)=>{p.kb("ReduceSumSquare",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},879355:(e,t,n,r,s)=>{p.kb("ReduceLogSumExp",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},879535:e=>{p.kb("Where",e,void 0)},879588:(e,t,n)=>{p.kb("Transpose",e,{perm:t?Array.from(a().subarray(Number(t)>>>0,Number(n)>>>0)):[]})},879712:(e,t,n,r)=>{p.kb("DepthToSpace",e,{blocksize:t,mode:Be(n),format:r?"NHWC":"NCHW"})},879845:(e,t,n,r)=>{p.kb("DepthToSpace",e,{blocksize:t,mode:Be(n),format:r?"NHWC":"NCHW"})},879978:(e,n,r,s,i,o,l,u,d,c,h,f,m,_,g)=>{p.kb("ConvTranspose",e,{format:d?"NHWC":"NCHW",autoPad:n,dilations:[r],group:s,kernelShape:[i],pads:[o,l],strides:[u],wIsConst:()=>!!t()[c>>>0],outputPadding:h?Array.from(a().subarray(Number(h)>>>0,Number(f)>>>0)):[],outputShape:m?Array.from(a().subarray(Number(m)>>>0,Number(_)>>>0)):[],activation:Be(g)})},880411:(e,n,r,s,i,o,l,u,d,c,h,f,m,_)=>{p.kb("ConvTranspose",e,{format:u?"NHWC":"NCHW",autoPad:n,dilations:Array.from(a().subarray(Number(r)>>>0,2+(Number(r)>>>0)>>>0)),group:s,kernelShape:Array.from(a().subarray(Number(i)>>>0,2+(Number(i)>>>0)>>>0)),pads:Array.from(a().subarray(Number(o)>>>0,4+(Number(o)>>>0)>>>0)),strides:Array.from(a().subarray(Number(l)>>>0,2+(Number(l)>>>0)>>>0)),wIsConst:()=>!!t()[d>>>0],outputPadding:c?Array.from(a().subarray(Number(c)>>>0,Number(h)>>>0)):[],outputShape:f?Array.from(a().subarray(Number(f)>>>0,Number(m)>>>0)):[],activation:Be(_)})},881072:(e,n,r,s,i,o,l,u,d,c,h,f,m,_,g)=>{p.kb("ConvTranspose",e,{format:d?"NHWC":"NCHW",autoPad:n,dilations:[r],group:s,kernelShape:[i],pads:[o,l],strides:[u],wIsConst:()=>!!t()[c>>>0],outputPadding:h?Array.from(a().subarray(Number(h)>>>0,Number(f)>>>0)):[],outputShape:m?Array.from(a().subarray(Number(m)>>>0,Number(_)>>>0)):[],activation:Be(g)})},881505:(e,n,r,s,i,o,l,u,d,c,h,f,m,_)=>{p.kb("ConvTranspose",e,{format:u?"NHWC":"NCHW",autoPad:n,dilations:Array.from(a().subarray(Number(r)>>>0,2+(Number(r)>>>0)>>>0)),group:s,kernelShape:Array.from(a().subarray(Number(i)>>>0,2+(Number(i)>>>0)>>>0)),pads:Array.from(a().subarray(Number(o)>>>0,4+(Number(o)>>>0)>>>0)),strides:Array.from(a().subarray(Number(l)>>>0,2+(Number(l)>>>0)>>>0)),wIsConst:()=>!!t()[d>>>0],outputPadding:c?Array.from(a().subarray(Number(c)>>>0,Number(h)>>>0)):[],outputShape:f?Array.from(a().subarray(Number(f)>>>0,Number(m)>>>0)):[],activation:Be(_)})},882166:(e,t)=>{p.kb("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},882257:(e,t,n,r,s,i,o,l,u,d,c,h,f,m)=>{p.kb("AveragePool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:s,dilations:i?Array.from(a().subarray(Number(i)>>>0,Number(o)>>>0)):[],kernel_shape:l?Array.from(a().subarray(Number(l)>>>0,Number(u)>>>0)):[],pads:d?Array.from(a().subarray(Number(d)>>>0,Number(c)>>>0)):[],strides:h?Array.from(a().subarray(Number(h)>>>0,Number(f)>>>0)):[]})},882736:(e,t)=>{p.kb("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},882827:(e,t,n,r,s,i,o,l,u,d,c,h,f,m)=>{p.kb("AveragePool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:s,dilations:i?Array.from(a().subarray(Number(i)>>>0,Number(o)>>>0)):[],kernel_shape:l?Array.from(a().subarray(Number(l)>>>0,Number(u)>>>0)):[],pads:d?Array.from(a().subarray(Number(d)>>>0,Number(c)>>>0)):[],strides:h?Array.from(a().subarray(Number(h)>>>0,Number(f)>>>0)):[]})},883306:(e,t)=>{p.kb("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},883393:(e,t,n,r,s,i,o,l,u,d,c,h,f,m)=>{p.kb("MaxPool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:s,dilations:i?Array.from(a().subarray(Number(i)>>>0,Number(o)>>>0)):[],kernel_shape:l?Array.from(a().subarray(Number(l)>>>0,Number(u)>>>0)):[],pads:d?Array.from(a().subarray(Number(d)>>>0,Number(c)>>>0)):[],strides:h?Array.from(a().subarray(Number(h)>>>0,Number(f)>>>0)):[]})},883868:(e,t)=>{p.kb("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},883955:(e,t,n,r,s,i,o,l,u,d,c,h,f,m)=>{p.kb("MaxPool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:s,dilations:i?Array.from(a().subarray(Number(i)>>>0,Number(o)>>>0)):[],kernel_shape:l?Array.from(a().subarray(Number(l)>>>0,Number(u)>>>0)):[],pads:d?Array.from(a().subarray(Number(d)>>>0,Number(c)>>>0)):[],strides:h?Array.from(a().subarray(Number(h)>>>0,Number(f)>>>0)):[]})},884430:(e,t,n,r,s)=>{p.kb("Gemm",e,{alpha:t,beta:n,transA:r,transB:s})},884534:e=>{p.kb("MatMul",e,void 0)},884588:(e,t,n,r)=>{p.kb("ArgMax",e,{keepDims:!!t,selectLastIndex:!!n,axis:r})},884696:(e,t,n,r)=>{p.kb("ArgMin",e,{keepDims:!!t,selectLastIndex:!!n,axis:r})},884804:(e,t)=>{p.kb("Softmax",e,{axis:t})},884867:(e,t)=>{p.kb("Concat",e,{axis:t})},884927:(e,t,n,r,s)=>{p.kb("Split",e,{axis:t,numOutputs:n,splitSizes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},885083:e=>{p.kb("Expand",e,void 0)},885137:(e,t)=>{p.kb("Gather",e,{axis:Number(t)})},885208:(e,t)=>{p.kb("GatherElements",e,{axis:Number(t)})},885287:(e,t)=>{p.kb("GatherND",e,{batch_dims:Number(t)})},885366:(e,t,n,r,s,i,o,l,u,d,c)=>{p.kb("Resize",e,{antialias:t,axes:n?Array.from(a().subarray(Number(n)>>>0,Number(r)>>>0)):[],coordinateTransformMode:Be(s),cubicCoeffA:i,excludeOutside:o,extrapolationValue:l,keepAspectRatioPolicy:Be(u),mode:Be(d),nearestMode:Be(c)})},885728:(e,t,n,r,s,i,o)=>{p.kb("Slice",e,{starts:t?Array.from(a().subarray(Number(t)>>>0,Number(n)>>>0)):[],ends:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[],axes:i?Array.from(a().subarray(Number(i)>>>0,Number(o)>>>0)):[]})},885992:e=>{p.kb("Tile",e,void 0)},886044:(e,t,n)=>{p.kb("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},886158:(e,t,n)=>{p.kb("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},886272:e=>{p.kb("Range",e,void 0)},886325:(e,t)=>{p.kb("Einsum",e,{equation:Be(t)})},886406:(e,t,n,r,s)=>{p.kb("Pad",e,{mode:t,value:n,pads:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},886549:(e,t,n,r,s,i)=>{p.kb("BatchNormalization",e,{epsilon:t,momentum:n,spatial:!!s,trainingMode:!!r,format:i?"NHWC":"NCHW"})},886718:(e,t,n,r,s,i)=>{p.kb("BatchNormalization",e,{epsilon:t,momentum:n,spatial:!!s,trainingMode:!!r,format:i?"NHWC":"NCHW"})},886887:(e,t,n)=>{p.kb("CumSum",e,{exclusive:Number(t),reverse:Number(n)})},886984:(e,t,n)=>{p.kb("DequantizeLinear",e,{axis:t,blockSize:n})},887074:(e,t,n,r,s)=>{p.kb("GridSample",e,{align_corners:t,mode:Be(n),padding_mode:Be(r),format:s?"NHWC":"NCHW"})},887244:(e,t,n,r,s)=>{p.kb("GridSample",e,{align_corners:t,mode:Be(n),padding_mode:Be(r),format:s?"NHWC":"NCHW"})},887414:(e,t)=>{p.kb("ScatterND",e,{reduction:Be(t)})},887499:(e,t,n,r,s,i,o,l,u)=>{p.kb("Attention",e,{numHeads:t,isUnidirectional:n,maskFilterValue:r,scale:s,doRotary:i,qkvHiddenSizes:o?Array.from(a().subarray(Number(l)>>>0,Number(l)+o>>>0)):[],pastPresentShareBuffer:!!u})},887771:e=>{p.kb("BiasAdd",e,void 0)},887826:e=>{p.kb("BiasSplitGelu",e,void 0)},887887:e=>{p.kb("FastGelu",e,void 0)},887943:(e,n,r,s,i,o,u,d,c,h,f,m,_,g,w,y)=>{p.kb("Conv",e,{format:m?"NHWC":"NCHW",auto_pad:n,dilations:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[],group:i,kernel_shape:o?Array.from(a().subarray(Number(o)>>>0,Number(u)>>>0)):[],pads:d?Array.from(a().subarray(Number(d)>>>0,Number(c)>>>0)):[],strides:h?Array.from(a().subarray(Number(h)>>>0,Number(f)>>>0)):[],w_is_const:()=>!!t()[Number(_)>>>0],activation:Be(g),activation_params:w?Array.from(l().subarray(Number(w)>>>0,Number(y)>>>0)):[]})},888527:e=>{p.kb("Gelu",e,void 0)},888579:(e,t,n,r,s,i,a,o,l)=>{p.kb("GroupQueryAttention",e,{numHeads:t,kvNumHeads:n,scale:r,softcap:s,doRotary:i,rotaryInterleaved:a,smoothSoftmax:o,localWindowSize:l})},888796:(e,t,n,r)=>{p.kb("LayerNormalization",e,{axis:t,epsilon:n,simplified:!!r})},888907:(e,t,n,r)=>{p.kb("LayerNormalization",e,{axis:t,epsilon:n,simplified:!!r})},889018:(e,t,n,r,s,i)=>{p.kb("MatMulNBits",e,{k:t,n,accuracyLevel:r,bits:s,blockSize:i})},889145:(e,t,n,r,s,i)=>{p.kb("MultiHeadAttention",e,{numHeads:t,isUnidirectional:n,maskFilterValue:r,scale:s,doRotary:i})},889304:(e,t)=>{p.kb("QuickGelu",e,{alpha:t})},889368:(e,t,n,r,s)=>{p.kb("RotaryEmbedding",e,{interleaved:!!t,numHeads:n,rotaryEmbeddingDim:r,scale:s})},889507:(e,t,n)=>{p.kb("SkipLayerNormalization",e,{epsilon:t,simplified:!!n})},889609:(e,t,n)=>{p.kb("SkipLayerNormalization",e,{epsilon:t,simplified:!!n})},889711:(e,t,n,r)=>{p.kb("GatherBlockQuantized",e,{gatherAxis:t,quantizeAxis:n,blockSize:r})},889832:e=>{p.$b(e)},889866:(e,t)=>p.cc(Number(e),Number(t),p.Gb.hc,p.Gb.errors)};function oe(e,t,n){return nn((async()=>{await p.Yb(Number(e),Number(t),Number(n))}))}function le(){return typeof wasmOffsetConverter<"u"}function ue(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}var de=e=>{e.terminate(),e.onmessage=()=>{}},ce=e=>{0==ge.length&&(ke(),$e(ge[0]));var t=ge.pop();if(!t)return 6;we.push(t),be[e.Bb]=t,t.Bb=e.Bb;var n={cmd:"run",start_routine:e.ic,arg:e.Rb,pthread_ptr:e.Bb};return t.postMessage(n,e.nc),0},pe=0,he=(e,t,...n)=>{for(var r=2*n.length,s=Or(),i=Mr(8*r),a=i>>>3,o=0;o<n.length;o++){var l=n[o];"bigint"==typeof l?(U[a+2*o]=1n,U[a+2*o+1]=l):(U[a+2*o]=0n,u()[a+2*o+1>>>0]=l)}return e=Sr(e,0,r,i,t),Ir(s),e};function fe(e){if(_)return he(0,1,e);if(O=e,!(0<pe)){for(var t of we)de(t);for(t of ge)de(t);ge=[],we=[],be=[],W=!0}v(e,new ue(e))}function me(e){if(_)return he(1,0,e);_e(e)}var _e=e=>{if(O=e,_)throw me(e),"unwind";fe(e)},ge=[],we=[],ye=[],be={},xe=e=>{var t=e.Bb;delete be[t],ge.push(e),we.splice(we.indexOf(e),1),e.Bb=0,zr(t)};function ve(){ye.forEach((e=>e()))}var $e=e=>new Promise((t=>{e.onmessage=n=>{var r=(n=n.data).cmd;if(n.targetThread&&n.targetThread!=xr()){var s=be[n.targetThread];s?s.postMessage(n,n.transferList):C(`Internal error! Worker sent a message "${r}" to target pthread ${n.targetThread}, but that thread no longer exists!`)}else"checkMailbox"===r?Nt():"spawnThread"===r?ce(n):"cleanupThread"===r?xe(be[n.thread]):"killThread"===r?(n=n.thread,r=be[n],delete be[n],de(r),zr(n),we.splice(we.indexOf(r),1),r.Bb=0):"cancelThread"===r?be[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,t(e)):"alert"===r?alert(`Thread ${n.threadId}: ${n.text}`):"setimmediate"===n.target?e.postMessage(n):"callHandler"===r?p[n.handler](...n.args):r&&C(`worker sent an unknown command ${r}`)},e.onerror=e=>{throw C(`worker sent an error! ${e.filename}:${e.lineno}: ${e.message}`),e};var n,r=[];for(n of[])p.hasOwnProperty(n)&&r.push(n);e.postMessage({cmd:"load",handlers:r,wasmMemory:I,wasmModule:M})}));function ke(){var e=new Worker(new URL("file:///Users/sam-schaack/gamp/nuiq-asr/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs"),{type:"module",workerData:"em-pthread",name:"em-pthread"});ge.push(e)}var Ee=e=>{for(;0<e.length;)e.shift()(p)},Se=()=>{var e=xr(),t=o()[e+52>>>2>>>0];e=o()[e+56>>>2>>>0],Ar(t,t-e),Ir(t)},ze=(e,t)=>{pe=0,e=Br(e,t),0<pe?O=e:Cr(e)};class Ce{constructor(e){this.Kb=e-24}}function Te(e,t,n){var r=new Ce(e>>>=0);throw t>>>=0,n>>>=0,o()[r.Kb+16>>>2>>>0]=0,o()[r.Kb+4>>>2>>>0]=t,o()[r.Kb+8>>>2>>>0]=n,e}function Ae(e,t,n,r){return _?he(2,1,e,t,n,r):Ie(e,t,n,r)}function Ie(e,t,n,r){if(e>>>=0,t>>>=0,n>>>=0,r>>>=0,void 0===g)return C("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var s=[];return _&&0===s.length?Ae(e,t,n,r):(e={ic:n,Bb:e,Rb:r,nc:s},_?(e.Nb="spawnThread",postMessage(e,s),0):ce(e))}var Me=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Oe=(e,t,n)=>{var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&Me)return Me.decode(e.buffer instanceof g?e.slice(t,n):e.subarray(t,n));for(r="";t<n;){var s=e[t++];if(128&s){var i=63&e[t++];if(192==(224&s))r+=String.fromCharCode((31&s)<<6|i);else{var a=63&e[t++];65536>(s=224==(240&s)?(15&s)<<12|i<<6|a:(7&s)<<18|i<<12|a<<6|63&e[t++])?r+=String.fromCharCode(s):(s-=65536,r+=String.fromCharCode(55296|s>>10,56320|1023&s))}}else r+=String.fromCharCode(s)}return r},Be=(e,t)=>(e>>>=0)?Oe(n(),e,t):"";function Ne(e,t,n){return _?he(3,1,e,t,n):0}function Pe(e,t){if(_)return he(4,1,e,t)}var Re=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t},De=(e,t,n,r)=>{if(!(0<r))return 0;var s=n>>>=0;r=n+r-1;for(var i=0;i<e.length;++i){var a=e.charCodeAt(i);if(55296<=a&&57343>=a&&(a=65536+((1023&a)<<10)|1023&e.charCodeAt(++i)),127>=a){if(n>=r)break;t[n++>>>0]=a}else{if(2047>=a){if(n+1>=r)break;t[n++>>>0]=192|a>>6}else{if(65535>=a){if(n+2>=r)break;t[n++>>>0]=224|a>>12}else{if(n+3>=r)break;t[n++>>>0]=240|a>>18,t[n++>>>0]=128|a>>12&63}t[n++>>>0]=128|a>>6&63}t[n++>>>0]=128|63&a}}return t[n>>>0]=0,n-s},Le=(e,t,r)=>De(e,n(),t,r);function Fe(e,t){if(_)return he(5,1,e,t)}function Ue(e,t,n){if(_)return he(6,1,e,t,n)}function qe(e,t,n){return _?he(7,1,e,t,n):0}function Ve(e,t){if(_)return he(8,1,e,t)}function We(e,t,n){if(_)return he(9,1,e,t,n)}function je(e,t,n,r){if(_)return he(10,1,e,t,n,r)}function Ge(e,t,n,r){if(_)return he(11,1,e,t,n,r)}function He(e,t,n,r){if(_)return he(12,1,e,t,n,r)}function Ke(e){if(_)return he(13,1,e)}function Xe(e,t){if(_)return he(14,1,e,t)}function Qe(e,t,n){if(_)return he(15,1,e,t,n)}var Ye,Ze,Je=()=>{J("")},et=e=>{for(var t="";n()[e>>>0];)t+=Ye[n()[e++>>>0]];return t},tt={},nt={},rt={};function st(e,t,n={}){if(!("argPackAdvance"in t))throw new TypeError("registerType registeredInstance requires argPackAdvance");return function(e,t,n={}){var r=t.name;if(!e)throw new Ze(`type "${r}" must have a positive integer typeid pointer`);if(nt.hasOwnProperty(e)){if(n.Tb)return;throw new Ze(`Cannot register type \'${r}\' twice`)}nt[e]=t,delete rt[e],tt.hasOwnProperty(e)&&(t=tt[e],delete tt[e],t.forEach((e=>e())))}(e,t,n)}var it=(e,s,l)=>{switch(s){case 1:return l?e=>t()[e>>>0]:e=>n()[e>>>0];case 2:return l?e=>r()[e>>>1>>>0]:e=>i()[e>>>1>>>0];case 4:return l?e=>a()[e>>>2>>>0]:e=>o()[e>>>2>>>0];case 8:return l?e=>U[e>>>3]:e=>q[e>>>3];default:throw new TypeError(`invalid integer width (${s}): ${e}`)}};function at(e,t,n){n>>>=0,st(e>>>=0,{name:t=et(t>>>0),fromWireType:e=>e,toWireType:function(e,t){if("bigint"!=typeof t&&"number"!=typeof t)throw t=null===t?"null":"object"==(e=typeof t)||"array"===e||"function"===e?t.toString():""+t,new TypeError(`Cannot convert "${t}" to ${this.name}`);return"number"==typeof t&&(t=BigInt(t)),t},argPackAdvance:ot,readValueFromPointer:it(t,n,-1==t.indexOf("u")),Eb:null})}var ot=8;function lt(e,t,r,s){st(e>>>=0,{name:t=et(t>>>0),fromWireType:function(e){return!!e},toWireType:function(e,t){return t?r:s},argPackAdvance:ot,readValueFromPointer:function(e){return this.fromWireType(n()[e>>>0])},Eb:null})}var ut=[],dt=[];function ct(e){9<(e>>>=0)&&0==--dt[e+1]&&(dt[e]=void 0,ut.push(e))}var pt=e=>{if(!e)throw new Ze("Cannot use deleted val. handle = "+e);return dt[e]},ht=e=>{switch(e){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let t=ut.pop()||dt.length;return dt[t]=e,dt[t+1]=1,t}};function ft(e){return this.fromWireType(o()[e>>>2>>>0])}var mt={name:"emscripten::val",fromWireType:e=>{var t=pt(e);return ct(e),t},toWireType:(e,t)=>ht(t),argPackAdvance:ot,readValueFromPointer:ft,Eb:null};function _t(e){return st(e>>>0,mt)}var gt=(e,t)=>{switch(t){case 4:return function(e){return this.fromWireType(l()[e>>>2>>>0])};case 8:return function(e){return this.fromWireType(u()[e>>>3>>>0])};default:throw new TypeError(`invalid float width (${t}): ${e}`)}};function wt(e,t,n){n>>>=0,st(e>>>=0,{name:t=et(t>>>0),fromWireType:e=>e,toWireType:(e,t)=>t,argPackAdvance:ot,readValueFromPointer:gt(t,n),Eb:null})}function yt(e,t,n,r,s){if(e>>>=0,n>>>=0,t=et(t>>>0),-1===s&&(s=4294967295),s=e=>e,0===r){var i=32-8*n;s=e=>e<<i>>>i}var a=t.includes("unsigned")?function(e,t){return t>>>0}:function(e,t){return t};st(e,{name:t,fromWireType:s,toWireType:a,argPackAdvance:ot,readValueFromPointer:it(t,n,0!==r),Eb:null})}function bt(e,n,r){function s(e){var n=o()[e>>>2>>>0];return e=o()[e+4>>>2>>>0],new i(t().buffer,e,n)}var i=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][n];st(e>>>=0,{name:r=et(r>>>0),fromWireType:s,argPackAdvance:ot,readValueFromPointer:s},{Tb:!0})}function xt(e,t){e>>>=0;var r="std::string"===(t=et(t>>>0));st(e,{name:t,fromWireType:function(e){var t=o()[e>>>2>>>0],s=e+4;if(r)for(var i=s,a=0;a<=t;++a){var l=s+a;if(a==t||0==n()[l>>>0]){if(i=Be(i,l-i),void 0===u)var u=i;else u+=String.fromCharCode(0),u+=i;i=l+1}}else{for(u=Array(t),a=0;a<t;++a)u[a]=String.fromCharCode(n()[s+a>>>0]);u=u.join("")}return vr(e),u},toWireType:function(e,t){t instanceof ArrayBuffer&&(t=new Uint8Array(t));var s="string"==typeof t;if(!(s||t instanceof Uint8Array||t instanceof Uint8ClampedArray||t instanceof Int8Array))throw new Ze("Cannot pass non-string to std::string");var i=r&&s?Re(t):t.length,a=$r(4+i+1),l=a+4;if(o()[a>>>2>>>0]=i,r&&s)Le(t,l,i+1);else if(s)for(s=0;s<i;++s){var u=t.charCodeAt(s);if(255<u)throw vr(l),new Ze("String has UTF-16 code units that do not fit in 8 bits");n()[l+s>>>0]=u}else for(s=0;s<i;++s)n()[l+s>>>0]=t[s];return null!==e&&e.push(vr,a),a},argPackAdvance:ot,readValueFromPointer:ft,Eb(e){vr(e)}})}var vt=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,$t=(e,t)=>{for(var s=e>>1,a=s+t/2;!(s>=a)&&i()[s>>>0];)++s;if(32<(s<<=1)-e&&vt)return vt.decode(n().slice(e,s));for(s="",a=0;!(a>=t/2);++a){var o=r()[e+2*a>>>1>>>0];if(0==o)break;s+=String.fromCharCode(o)}return s},kt=(e,t,n)=>{if(n??=2147483647,2>n)return 0;var s=t;n=(n-=2)<2*e.length?n/2:e.length;for(var i=0;i<n;++i){var a=e.charCodeAt(i);r()[t>>>1>>>0]=a,t+=2}return r()[t>>>1>>>0]=0,t-s},Et=e=>2*e.length,St=(e,t)=>{for(var n=0,r="";!(n>=t/4);){var s=a()[e+4*n>>>2>>>0];if(0==s)break;++n,65536<=s?(s-=65536,r+=String.fromCharCode(55296|s>>10,56320|1023&s)):r+=String.fromCharCode(s)}return r},zt=(e,t,n)=>{if(t>>>=0,n??=2147483647,4>n)return 0;var r=t;n=r+n-4;for(var s=0;s<e.length;++s){var i=e.charCodeAt(s);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++s)),a()[t>>>2>>>0]=i,(t+=4)+4>n)break}return a()[t>>>2>>>0]=0,t-r},Ct=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);55296<=r&&57343>=r&&++n,t+=4}return t};function Tt(e,t,n){if(e>>>=0,t>>>=0,n=et(n>>>=0),2===t)var r=$t,s=kt,a=Et,l=e=>i()[e>>>1>>>0];else 4===t&&(r=St,s=zt,a=Ct,l=e=>o()[e>>>2>>>0]);st(e,{name:n,fromWireType:e=>{for(var n,s=o()[e>>>2>>>0],i=e+4,a=0;a<=s;++a){var u=e+4+a*t;a!=s&&0!=l(u)||(i=r(i,u-i),void 0===n?n=i:(n+=String.fromCharCode(0),n+=i),i=u+t)}return vr(e),n},toWireType:(e,r)=>{if("string"!=typeof r)throw new Ze(`Cannot pass non-string to C++ string type ${n}`);var i=a(r),l=$r(4+i+t);return o()[l>>>2>>>0]=i/t,s(r,l+4,i+t),null!==e&&e.push(vr,l),l},argPackAdvance:ot,readValueFromPointer:ft,Eb(e){vr(e)}})}function At(e,t){st(e>>>=0,{Ub:!0,name:t=et(t>>>0),argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})}var It=()=>1;function Mt(e){kr(e>>>0,!m,1,!f,131072,!1),ve()}var Ot=e=>{if(!W)try{if(e(),!(0<pe))try{_?Cr(O):_e(O)}catch(e){e instanceof ue||"unwind"==e||v(1,e)}}catch(e){e instanceof ue||"unwind"==e||v(1,e)}};function Bt(e){e>>>=0,"function"==typeof Atomics.oc&&(Atomics.oc(a(),e>>>2,e).value.then(Nt),e+=128,Atomics.store(a(),e>>>2,1))}var Nt=()=>{var e=xr();e&&(Bt(e),Ot(Tr))};function Pt(e,t){(e>>>=0)==t>>>0?setTimeout(Nt):_?postMessage({targetThread:e,cmd:"checkMailbox"}):(e=be[e])&&e.postMessage({cmd:"checkMailbox"})}var Rt=[];function Dt(e,t,n,r,s){for(t>>>=0,r/=2,Rt.length=r,n=s>>>0>>>3,s=0;s<r;s++)Rt[s]=U[n+2*s]?U[n+2*s+1]:u()[n+2*s+1>>>0];return(t?ae[t]:_r[e])(...Rt)}function Ft(e){e>>>=0,_?postMessage({cmd:"cleanupThread",thread:e}):xe(be[e])}function Ut(e){}var qt=(e,t)=>{var n=nt[e];if(void 0===n)throw e=wr(e),n=et(e),vr(e),new Ze(`${t} has unknown type ${n}`);return n},Vt=(e,t,n)=>{var r=[];return e=e.toWireType(r,n),r.length&&(o()[t>>>2>>>0]=ht(r)),e};function Wt(e,t,n){return t>>>=0,n>>>=0,e=pt(e>>>0),t=qt(t,"emval::as"),Vt(t,n,e)}function jt(e,t){return t>>>=0,e=pt(e>>>0),(t=qt(t,"emval::as")).toWireType(null,e)}var Gt=e=>{try{e()}catch(e){J(e)}},Ht=0,Kt=null,Xt=0,Qt=[],Yt={},Zt={},Jt=0,en=null,tn=[];function nn(e){return function(t){if(!W){if(0===Ht){var n=!1,r=!1;(t=>{e().then(t)})(((e=0)=>{if(!W&&(Xt=e,n=!0,r)){Ht=2,Gt((()=>Rr(Kt))),typeof Browser<"u"&&Browser.Lb.Sb&&Browser.Lb.resume(),e=!1;try{var t=(o=a()[Kt+8>>>2>>>0],o=gr[Zt[o]],--pe,o())}catch(o){t=o,e=!0}var s=!1;if(!Kt){var i=en;i&&(en=null,(e?i.reject:i.resolve)(t),s=!0)}if(e&&!s)throw t}var o})),r=!0,n||(Ht=1,Kt=function(){var e=$r(65548),t=e+12;o()[e>>>2>>>0]=t,o()[e+4>>>2>>>0]=t+65536,t=Qt[0];var n=Yt[t];return void 0===n&&(n=Jt++,Yt[t]=n,Zt[n]=t),t=n,a()[e+8>>>2>>>0]=t,e}(),typeof Browser<"u"&&Browser.Lb.Sb&&Browser.Lb.pause(),Gt((()=>Nr(Kt))))}else 2===Ht?(Ht=0,Gt(Dr),vr(Kt),Kt=null,tn.forEach(Ot)):J(`invalid state: ${Ht}`);return Xt}}()}function rn(e){return e>>>=0,nn((()=>(e=pt(e)).then(ht)))}var sn=[];function an(e,t,n,r){return n>>>=0,r>>>=0,(e=sn[e>>>0])(null,t=pt(t>>>0),n,r)}var on={},ln=e=>{var t=on[e];return void 0===t?et(e):t};function un(e,t,n,r,s){return n>>>=0,r>>>=0,s>>>=0,(e=sn[e>>>0])(t=pt(t>>>0),t[n=ln(n)],r,s)}var dn=()=>"object"==typeof globalThis?globalThis:Function("return this")();function cn(e){return 0==(e>>>=0)?ht(dn()):(e=ln(e),ht(dn()[e]))}var pn=e=>{var t=sn.length;return sn.push(e),t},hn=(e,t)=>{for(var n=Array(e),r=0;r<e;++r)n[r]=qt(o()[t+4*r>>>2>>>0],"parameter "+r);return n},fn=(e,t)=>Object.defineProperty(t,"name",{value:e});function mn(e,t,n){var r=(t=hn(e,t>>>0)).shift();e--;var s="return function (obj, func, destructorsRef, args) {\\n",i=0,a=[];0===n&&a.push("obj");for(var o=["retType"],l=[r],u=0;u<e;++u)a.push("arg"+u),o.push("argType"+u),l.push(t[u]),s+=`  var arg${u} = argType${u}.readValueFromPointer(args${i?"+"+i:""});\\n`,i+=t[u].argPackAdvance;return s+=`  var rv = ${1===n?"new func":"func.call"}(${a.join(", ")});\\n`,r.Ub||(o.push("emval_returnValue"),l.push(Vt),s+="  return emval_returnValue(retType, destructorsRef, rv);\\n"),o.push(s+"};\\n"),e=function(e){var t=Function;if(!(t instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof t} which is not a function`);var n=fn(t.name||"unknownFunctionName",(function(){}));return n.prototype=t.prototype,n=new n,(e=t.apply(n,e))instanceof Object?e:n}(o)(...l),n=`methodCaller<(${t.map((e=>e.name)).join(", ")}) => ${r.name}>`,pn(fn(n,e))}function _n(e){return e=ln(e>>>0),ht(p[e])}function gn(e,t){return t>>>=0,e=pt(e>>>0),t=pt(t),ht(e[t])}function wn(e){9<(e>>>=0)&&(dt[e+1]+=1)}function yn(){return ht([])}function bn(e){e=pt(e>>>0);for(var t=Array(e.length),n=0;n<e.length;n++)t[n]=e[n];return ht(t)}function xn(e){return ht(ln(e>>>0))}function vn(){return ht({})}function $n(e){for(var t=pt(e>>>=0);t.length;){var n=t.pop();t.pop()(n)}ct(e)}function kn(e,t,n){t>>>=0,n>>>=0,e=pt(e>>>0),t=pt(t),n=pt(n),e[t]=n}function En(e,t){return t>>>=0,e=(e=qt(e>>>0,"_emval_take_value")).readValueFromPointer(t),ht(e)}function Sn(e,t){e=-9007199254740992>e||9007199254740992<e?NaN:Number(e),t>>>=0,e=new Date(1e3*e),a()[t>>>2>>>0]=e.getUTCSeconds(),a()[t+4>>>2>>>0]=e.getUTCMinutes(),a()[t+8>>>2>>>0]=e.getUTCHours(),a()[t+12>>>2>>>0]=e.getUTCDate(),a()[t+16>>>2>>>0]=e.getUTCMonth(),a()[t+20>>>2>>>0]=e.getUTCFullYear()-1900,a()[t+24>>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[t+28>>>2>>>0]=e}var zn=e=>e%4==0&&(e%100!=0||e%400==0),Cn=[0,31,60,91,121,152,182,213,244,274,305,335],Tn=[0,31,59,90,120,151,181,212,243,273,304,334];function An(e,t){e=-9007199254740992>e||9007199254740992<e?NaN:Number(e),t>>>=0,e=new Date(1e3*e),a()[t>>>2>>>0]=e.getSeconds(),a()[t+4>>>2>>>0]=e.getMinutes(),a()[t+8>>>2>>>0]=e.getHours(),a()[t+12>>>2>>>0]=e.getDate(),a()[t+16>>>2>>>0]=e.getMonth(),a()[t+20>>>2>>>0]=e.getFullYear()-1900,a()[t+24>>>2>>>0]=e.getDay();var n=(zn(e.getFullYear())?Cn:Tn)[e.getMonth()]+e.getDate()-1|0;a()[t+28>>>2>>>0]=n,a()[t+36>>>2>>>0]=-60*e.getTimezoneOffset(),n=new Date(e.getFullYear(),6,1).getTimezoneOffset();var r=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(n!=r&&e.getTimezoneOffset()==Math.min(r,n)),a()[t+32>>>2>>>0]=e}function In(e){e>>>=0;var t=new Date(a()[e+20>>>2>>>0]+1900,a()[e+16>>>2>>>0],a()[e+12>>>2>>>0],a()[e+8>>>2>>>0],a()[e+4>>>2>>>0],a()[e>>>2>>>0],0),n=a()[e+32>>>2>>>0],r=t.getTimezoneOffset(),s=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=new Date(t.getFullYear(),0,1).getTimezoneOffset(),o=Math.min(i,s);return 0>n?a()[e+32>>>2>>>0]=+(s!=i&&o==r):0<n!=(o==r)&&(s=Math.max(i,s),t.setTime(t.getTime()+6e4*((0<n?o:s)-r))),a()[e+24>>>2>>>0]=t.getDay(),n=(zn(t.getFullYear())?Cn:Tn)[t.getMonth()]+t.getDate()-1|0,a()[e+28>>>2>>>0]=n,a()[e>>>2>>>0]=t.getSeconds(),a()[e+4>>>2>>>0]=t.getMinutes(),a()[e+8>>>2>>>0]=t.getHours(),a()[e+12>>>2>>>0]=t.getDate(),a()[e+16>>>2>>>0]=t.getMonth(),a()[e+20>>>2>>>0]=t.getYear(),e=t.getTime(),BigInt(isNaN(e)?-1:e/1e3)}function Mn(e,t,n,r,s,i,a){return _?he(16,1,e,t,n,r,s,i,a):-52}function On(e,t,n,r,s,i){if(_)return he(17,1,e,t,n,r,s,i)}function Bn(e,t,n,r){e>>>=0,t>>>=0,n>>>=0,r>>>=0;var s=(new Date).getFullYear(),i=new Date(s,0,1),l=new Date(s,6,1);s=i.getTimezoneOffset();var u=l.getTimezoneOffset(),d=Math.max(s,u);o()[e>>>2>>>0]=60*d,a()[t>>>2>>>0]=+(s!=u),i=(e=e=>e.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1])(i),l=e(l),u<s?(Le(i,n,17),Le(l,r,17)):(Le(i,r,17),Le(l,n,17))}var Nn=[],Pn=(e,t)=>{Nn.length=0;for(var r;r=n()[e++>>>0];){var s=105!=r;t+=(s&=112!=r)&&t%8?4:0,Nn.push(112==r?o()[t>>>2>>>0]:106==r?U[t>>>3]:105==r?a()[t>>>2>>>0]:u()[t>>>3>>>0]),t+=s?8:4}return Nn};function Rn(e,t,n){return e>>>=0,t=Pn(t>>>0,n>>>0),ae[e](...t)}function Dn(e,t,n){return e>>>=0,t=Pn(t>>>0,n>>>0),ae[e](...t)}var Ln=()=>{},Fn=()=>Date.now();function Un(e,t){return C(Be(e>>>0,t>>>0))}var qn,Vn=()=>{throw pe+=1,"unwind"};function Wn(){return 4294901760}qn=()=>performance.timeOrigin+performance.now();var jn=()=>navigator.hardwareConcurrency;function Gn(){return J("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function Hn(e){e>>>=0;var t=n().length;if(e<=t||4294901760<e)return!1;for(var r=1;4>=r;r*=2){var s=t*(1+.2/r);s=Math.min(s,e+100663296);var i=Math;s=Math.max(e,s);e:{i=(i.min.call(i,4294901760,s+(65536-s%65536)%65536)-I.buffer.byteLength+65535)/65536;try{I.grow(i),j();var a=1;break e}catch{}a=void 0}if(a)return!0}return!1}var Kn=()=>(J("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),Xn={},Qn=e=>{e.forEach((e=>{var t=Kn();t&&(Xn[t]=e)}))};function Yn(){var e=Error().stack.toString().split("\\n");return"Error"==e[0]&&e.shift(),Qn(e),Xn.Qb=Kn(),Xn.fc=e,Xn.Qb}function Zn(e,t,n){if(e>>>=0,t>>>=0,Xn.Qb==e)var r=Xn.fc;else"Error"==(r=Error().stack.toString().split("\\n"))[0]&&r.shift(),Qn(r);for(var s=3;r[s]&&Kn()!=e;)++s;for(e=0;e<n&&r[e+s];++e)a()[t+4*e>>>2>>>0]=Kn();return e}var Jn,er={},tr=()=>{if(!Jn){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:"./this.program"};for(e in er)void 0===er[e]?delete t[e]:t[e]=er[e];var n=[];for(e in t)n.push(`${e}=${t[e]}`);Jn=n}return Jn};function nr(e,n){if(_)return he(18,1,e,n);e>>>=0,n>>>=0;var r=0;return tr().forEach(((s,i)=>{var a=n+r;for(i=o()[e+4*i>>>2>>>0]=a,a=0;a<s.length;++a)t()[i++>>>0]=s.charCodeAt(a);t()[i>>>0]=0,r+=s.length+1})),0}function rr(e,t){if(_)return he(19,1,e,t);e>>>=0,t>>>=0;var n=tr();o()[e>>>2>>>0]=n.length;var r=0;return n.forEach((e=>r+=e.length+1)),o()[t>>>2>>>0]=r,0}function sr(e){return _?he(20,1,e):52}function ir(e,t,n,r){return _?he(21,1,e,t,n,r):52}function ar(e,t,n,r){return _?he(22,1,e,t,n,r):70}var or=[null,[],[]];function lr(e,t,r,s){if(_)return he(23,1,e,t,r,s);t>>>=0,r>>>=0,s>>>=0;for(var i=0,a=0;a<r;a++){var l=o()[t>>>2>>>0],u=o()[t+4>>>2>>>0];t+=8;for(var d=0;d<u;d++){var c=n()[l+d>>>0],p=or[e];0===c||10===c?((1===e?z:C)(Oe(p,0)),p.length=0):p.push(c)}i+=u}return o()[s>>>2>>>0]=i,0}var ur=[31,29,31,30,31,30,31,31,30,31,30,31],dr=[31,28,31,30,31,30,31,31,30,31,30,31],cr=(e,n)=>{t().set(e,n>>>0)};function pr(e,t,n,r){function s(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function i(e,t){return s(e,t,"0")}function l(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function u(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function d(e){var t=e.Cb;for(e=new Date(new Date(e.Db+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(zn(e.getFullYear())?ur:dr)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=u(new Date(e.getFullYear(),0,4)),n=u(n),0>=l(t,e)?0>=l(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,n>>>=0,r>>>=0;var c=o()[r+40>>>2>>>0];for(var p in r={lc:a()[r>>>2>>>0],kc:a()[r+4>>>2>>>0],Ib:a()[r+8>>>2>>>0],Mb:a()[r+12>>>2>>>0],Jb:a()[r+16>>>2>>>0],Db:a()[r+20>>>2>>>0],vb:a()[r+24>>>2>>>0],Cb:a()[r+28>>>2>>>0],sc:a()[r+32>>>2>>>0],jc:a()[r+36>>>2>>>0],mc:c?Be(c):""},n=Be(n),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(p,"g"),c[p]);var h,f,m="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),_="January February March April May June July August September October November December".split(" ");for(p in c={"%a":e=>m[e.vb].substring(0,3),"%A":e=>m[e.vb],"%b":e=>_[e.Jb].substring(0,3),"%B":e=>_[e.Jb],"%C":e=>i((e.Db+1900)/100|0,2),"%d":e=>i(e.Mb,2),"%e":e=>s(e.Mb,2," "),"%g":e=>d(e).toString().substring(2),"%G":d,"%H":e=>i(e.Ib,2),"%I":e=>(0==(e=e.Ib)?e=12:12<e&&(e-=12),i(e,2)),"%j":e=>{for(var t=0,n=0;n<=e.Jb-1;t+=(zn(e.Db+1900)?ur:dr)[n++]);return i(e.Mb+t,3)},"%m":e=>i(e.Jb+1,2),"%M":e=>i(e.kc,2),"%n":()=>"\\n","%p":e=>0<=e.Ib&&12>e.Ib?"AM":"PM","%S":e=>i(e.lc,2),"%t":()=>"\\t","%u":e=>e.vb||7,"%U":e=>i(Math.floor((e.Cb+7-e.vb)/7),2),"%V":e=>{var t=Math.floor((e.Cb+7-(e.vb+6)%7)/7);if(2>=(e.vb+371-e.Cb-2)%7&&t++,t)53==t&&(4==(n=(e.vb+371-e.Cb)%7)||3==n&&zn(e.Db)||(t=1));else{t=52;var n=(e.vb+7-e.Cb-1)%7;(4==n||5==n&&zn(e.Db%400-1))&&t++}return i(t,2)},"%w":e=>e.vb,"%W":e=>i(Math.floor((e.Cb+7-(e.vb+6)%7)/7),2),"%y":e=>(e.Db+1900).toString().substring(2),"%Y":e=>e.Db+1900,"%z":e=>(0<=(e=e.jc)?"+":"-")+("0000"+((e=Math.abs(e)/60)/60*100+e%60)).slice(-4),"%Z":e=>e.mc,"%%":()=>"%"},n=n.replace(/%%/g,"\\0\\0"),c)n.includes(p)&&(n=n.replace(new RegExp(p,"g"),c[p](r)));return h=n=n.replace(/\\0\\0/g,"%"),f=Array(Re(h)+1),De(h,f,0,f.length),(p=f).length>t?0:(cr(p,e),p.length-1)}function hr(e,t,n,r){return pr(e>>>0,t>>>0,n>>>0,r>>>0)}_||function(){for(var e=p.numThreads-1;e--;)ke();G.unshift((()=>{var e;X++,e=()=>Z(),_?e():Promise.all(ge.map($e)).then(e)}))}();for(var fr=Array(256),mr=0;256>mr;++mr)fr[mr]=String.fromCharCode(mr);Ye=fr,Ze=p.BindingError=class extends Error{constructor(e){super(e),this.name="BindingError"}},p.InternalError=class extends Error{constructor(e){super(e),this.name="InternalError"}},dt.push(0,1,void 0,1,null,1,!0,1,!1,1),p.count_emval_handles=()=>dt.length/2-5-ut.length;var _r=[fe,me,Ae,Ne,Pe,Fe,Ue,qe,Ve,We,je,Ge,He,Ke,Xe,Qe,Mn,On,nr,rr,sr,ir,ar,lr],gr=function(){function e(e,t){return gr=e.exports,gr=function(){var e=gr,t={};for(let[n,r]of Object.entries(e))t[n]="function"==typeof r?(...e)=>{Qt.push(n);try{return r(...e)}finally{W||(Qt.pop(),Kt&&1===Ht&&0===Qt.length&&(Ht=0,pe+=1,Gt(Pr),typeof Fibers<"u"&&Fibers.tc()))}}:r;return t}(),n=gr,r=e=>t=>e(t)>>>0,s=e=>()=>e()>>>0,(n=Object.assign({},n)).Da=r(n.Da),n.gb=s(n.gb),n.ib=r(n.ib),n.emscripten_main_runtime_thread_id=s(n.emscripten_main_runtime_thread_id),n.tb=r(n.tb),n.ub=s(n.ub),gr=n,ye.push(gr.jb),H.unshift(gr.Ca),M=t,Z(),gr;var n,r,s}var t,n,r,i=ie();if(X++,p.instantiateWasm)try{return p.instantiateWasm(i,e)}catch(t){C(`Module.instantiateWasm callback failed with error: ${t}`),c(t)}return ee||=p.locateFile?te("ort-wasm-simd-threaded.jsep.wasm")?"ort-wasm-simd-threaded.jsep.wasm":p.locateFile?p.locateFile("ort-wasm-simd-threaded.jsep.wasm",$):$+"ort-wasm-simd-threaded.jsep.wasm":new URL(s(98),s.b).href,(t=i,n=function(t){e(t.instance,t.module)},r=ee,k||"function"!=typeof WebAssembly.instantiateStreaming||te(r)||ne(r)||"function"!=typeof fetch?se(r,t,n):fetch(r,{credentials:"same-origin"}).then((e=>WebAssembly.instantiateStreaming(e,t).then(n,(function(e){return C(`wasm streaming compile failed: ${e}`),C("falling back to ArrayBuffer instantiation"),se(r,t,n)}))))).catch(c),{}}(),wr=e=>(wr=gr.Da)(e),yr=()=>(yr=gr.Ea)();p._OrtInit=(e,t)=>(p._OrtInit=gr.Fa)(e,t),p._OrtGetLastError=(e,t)=>(p._OrtGetLastError=gr.Ga)(e,t),p._OrtCreateSessionOptions=(e,t,n,r,s,i,a,o,l,u)=>(p._OrtCreateSessionOptions=gr.Ha)(e,t,n,r,s,i,a,o,l,u),p._OrtAppendExecutionProvider=(e,t)=>(p._OrtAppendExecutionProvider=gr.Ia)(e,t),p._OrtAddFreeDimensionOverride=(e,t,n)=>(p._OrtAddFreeDimensionOverride=gr.Ja)(e,t,n),p._OrtAddSessionConfigEntry=(e,t,n)=>(p._OrtAddSessionConfigEntry=gr.Ka)(e,t,n),p._OrtReleaseSessionOptions=e=>(p._OrtReleaseSessionOptions=gr.La)(e),p._OrtCreateSession=(e,t,n)=>(p._OrtCreateSession=gr.Ma)(e,t,n),p._OrtReleaseSession=e=>(p._OrtReleaseSession=gr.Na)(e),p._OrtGetInputOutputCount=(e,t,n)=>(p._OrtGetInputOutputCount=gr.Oa)(e,t,n),p._OrtGetInputName=(e,t)=>(p._OrtGetInputName=gr.Pa)(e,t),p._OrtGetOutputName=(e,t)=>(p._OrtGetOutputName=gr.Qa)(e,t),p._OrtFree=e=>(p._OrtFree=gr.Ra)(e),p._OrtCreateTensor=(e,t,n,r,s,i)=>(p._OrtCreateTensor=gr.Sa)(e,t,n,r,s,i),p._OrtGetTensorData=(e,t,n,r,s)=>(p._OrtGetTensorData=gr.Ta)(e,t,n,r,s),p._OrtReleaseTensor=e=>(p._OrtReleaseTensor=gr.Ua)(e),p._OrtCreateRunOptions=(e,t,n,r)=>(p._OrtCreateRunOptions=gr.Va)(e,t,n,r),p._OrtAddRunConfigEntry=(e,t,n)=>(p._OrtAddRunConfigEntry=gr.Wa)(e,t,n),p._OrtReleaseRunOptions=e=>(p._OrtReleaseRunOptions=gr.Xa)(e),p._OrtCreateBinding=e=>(p._OrtCreateBinding=gr.Ya)(e),p._OrtBindInput=(e,t,n)=>(p._OrtBindInput=gr.Za)(e,t,n),p._OrtBindOutput=(e,t,n,r)=>(p._OrtBindOutput=gr._a)(e,t,n,r),p._OrtClearBoundOutputs=e=>(p._OrtClearBoundOutputs=gr.$a)(e),p._OrtReleaseBinding=e=>(p._OrtReleaseBinding=gr.ab)(e),p._OrtRunWithBinding=(e,t,n,r,s)=>(p._OrtRunWithBinding=gr.bb)(e,t,n,r,s),p._OrtRun=(e,t,n,r,s,i,a,o)=>(p._OrtRun=gr.cb)(e,t,n,r,s,i,a,o),p._OrtEndProfiling=e=>(p._OrtEndProfiling=gr.db)(e),p._JsepOutput=(e,t,n)=>(p._JsepOutput=gr.eb)(e,t,n),p._JsepGetNodeName=e=>(p._JsepGetNodeName=gr.fb)(e);var br,xr=()=>(xr=gr.gb)(),vr=p._free=e=>(vr=p._free=gr.hb)(e),$r=p._malloc=e=>($r=p._malloc=gr.ib)(e),kr=(e,t,n,r,s,i)=>(kr=gr.lb)(e,t,n,r,s,i),Er=()=>(Er=gr.mb)(),Sr=(e,t,n,r,s)=>(Sr=gr.nb)(e,t,n,r,s),zr=e=>(zr=gr.ob)(e),Cr=e=>(Cr=gr.pb)(e),Tr=()=>(Tr=gr.qb)(),Ar=(e,t)=>(Ar=gr.rb)(e,t),Ir=e=>(Ir=gr.sb)(e),Mr=e=>(Mr=gr.tb)(e),Or=()=>(Or=gr.ub)(),Br=p.dynCall_ii=(e,t)=>(Br=p.dynCall_ii=gr.wb)(e,t),Nr=e=>(Nr=gr.xb)(e),Pr=()=>(Pr=gr.yb)(),Rr=e=>(Rr=gr.zb)(e),Dr=()=>(Dr=gr.Ab)();function Lr(){0<X||(_?(d(p),_||Ee(H),startWorker(p)):(Ee(G),0<X||br||(br=!0,p.calledRun=!0,W||(_||Ee(H),d(p),_||Ee(K)))))}return p.___start_em_js=889994,p.___stop_em_js=890240,p.stackSave=()=>Or(),p.stackRestore=e=>Ir(e),p.stackAlloc=e=>Mr(e),p.setValue=function(e,n,s="i8"){switch(s.endsWith("*")&&(s="*"),s){case"i1":case"i8":t()[e>>>0]=n;break;case"i16":r()[e>>>1>>>0]=n;break;case"i32":a()[e>>>2>>>0]=n;break;case"i64":U[e>>>3]=BigInt(n);break;case"float":l()[e>>>2>>>0]=n;break;case"double":u()[e>>>3>>>0]=n;break;case"*":o()[e>>>2>>>0]=n;break;default:J(`invalid type for setValue: ${s}`)}},p.getValue=function(e,n="i8"){switch(n.endsWith("*")&&(n="*"),n){case"i1":case"i8":return t()[e>>>0];case"i16":return r()[e>>>1>>>0];case"i32":return a()[e>>>2>>>0];case"i64":return U[e>>>3];case"float":return l()[e>>>2>>>0];case"double":return u()[e>>>3>>>0];case"*":return o()[e>>>2>>>0];default:J(`invalid type for getValue: ${n}`)}},p.UTF8ToString=Be,p.stringToUTF8=Le,p.lengthBytesUTF8=Re,Y=function e(){br||Lr(),br||(Y=e)},Lr(),p.PTR_SIZE=4,h},Ut=Ft,"em-pthread"===globalThis.self?.name&&Ft()})),gd=ut((()=>{Mt(),qt="file:///Users/sam-schaack/gamp/nuiq-asr/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs",Vt=typeof location>"u"?void 0:location.origin,Wt=(e,t)=>{try{let n=t??qt;return(n?new URL(e,n):new URL(e)).origin===Vt}catch{return!1}},jt=async e=>{let t=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(t)},Gt=(Rt(),ct(Ot)).default,Ht=async()=>{if(!qt)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(Wt(qt))return[void 0,Gt()];let e=await jt(qt);return[e,Gt(e)]},Kt=(_d(),ct(Dt)).default,Xt=async(e,t,n)=>[void 0,Kt]})),wd=ut((()=>{gd(),Yt=!1,Zt=!1,Jt=!1,en=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},tn=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},nn=async e=>{if(Yt)return Promise.resolve();if(Zt)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(Jt)throw new Error("previous call to \'initializeWebAssembly()\' failed.");Zt=!0;let t=e.initTimeout,n=e.numThreads;if(!tn())throw new Error("WebAssembly SIMD is not supported in the current environment.");let r=en();n>1&&!r&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=n=1);let s=e.wasmPaths,i="string"==typeof s?s:void 0,a=s?.mjs,o=a?.href??a,l=s?.wasm,u=l?.href??l,d=e.wasmBinary,[c,p]=await Xt(o,i,n>1),h=!1,f=[];if(t>0&&f.push(new Promise((e=>{setTimeout((()=>{h=!0,e()}),t)}))),f.push(new Promise(((e,t)=>{let r={numThreads:n};d?r.wasmBinary=d:(u||i)&&(r.locateFile=(e,t)=>u??(i??t)+e),p(r).then((t=>{Zt=!1,Yt=!0,Qt=t,e(),c&&URL.revokeObjectURL(c)}),(e=>{Zt=!1,Jt=!0,t(e)}))}))),await Promise.race(f),h)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},rn=()=>{if(Yt&&Qt)return Qt;throw new Error("WebAssembly is not initialized yet.")}})),yd=ut((()=>{wd(),sn=(e,t)=>{let n=rn(),r=n.lengthBytesUTF8(e)+1,s=n._malloc(r);return n.stringToUTF8(e,s,r),t.push(s),s},an=(e,t,n,r)=>{if("object"==typeof e&&null!==e){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach((([e,s])=>{let i=t?t+e:e;if("object"==typeof s)an(s,i+".",n,r);else if("string"==typeof s||"number"==typeof s)r(i,s.toString());else{if("boolean"!=typeof s)throw new Error("Can\'t handle extra config type: "+typeof s);r(i,s?"1":"0")}}))},on=e=>{let t=rn(),n=t.stackSave();try{let n=t.PTR_SIZE,r=t.stackAlloc(2*n);t._OrtGetLastError(r,r+n);let s=Number(t.getValue(r,4===n?"i32":"i64")),i=t.getValue(r+n,"*"),a=i?t.UTF8ToString(i):"";throw new Error(`${e} ERROR_CODE: ${s}, ERROR_MESSAGE: ${a}`)}finally{t.stackRestore(n)}}})),bd=ut((()=>{wd(),yd(),ln=e=>{let t=rn(),n=0,r=[],s=e||{};try{if(void 0===e?.logSeverityLevel)s.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===e?.logVerbosityLevel)s.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===e?.terminate&&(s.terminate=!1);let i=0;return void 0!==e?.tag&&(i=sn(e.tag,r)),n=t._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,i),0===n&&on("Can\'t create run options."),void 0!==e?.extra&&an(e.extra,"",new WeakSet,((e,s)=>{let i=sn(e,r),a=sn(s,r);0!==t._OrtAddRunConfigEntry(n,i,a)&&on(`Can\'t set a run config entry: ${e} - ${s}.`)})),[n,r]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),r.forEach((e=>t._free(e))),e}}})),xd=ut((()=>{wd(),yd(),un=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},dn=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},cn=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)},pn=(e,t,n)=>{for(let r of t){let t="string"==typeof r?r:r.name;switch(t){case"webnn":if(t="WEBNN","string"!=typeof r){let t=r?.deviceType;if(t){let r=sn("deviceType",n),s=sn(t,n);0!==rn()._OrtAddSessionConfigEntry(e,r,s)&&on(`Can\'t set a session config entry: \'deviceType\' - ${t}.`)}}break;case"webgpu":if(t="JS","string"!=typeof r){let t=r;if(t?.preferredLayout){if("NCHW"!==t.preferredLayout&&"NHWC"!==t.preferredLayout)throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${t.preferredLayout}`);let r=sn("preferredLayout",n),s=sn(t.preferredLayout,n);0!==rn()._OrtAddSessionConfigEntry(e,r,s)&&on(`Can\'t set a session config entry: \'preferredLayout\' - ${t.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${t}`)}let s=sn(t,n);0!==rn()._OrtAppendExecutionProvider(e,s)&&on(`Can\'t append execution provider: ${t}.`)}},hn=e=>{let t=rn(),n=0,r=[],s=e||{};cn(s);try{let e=un(s.graphOptimizationLevel??"all"),i=dn(s.executionMode??"sequential"),a="string"==typeof s.logId?sn(s.logId,r):0,o=s.logSeverityLevel??2;if(!Number.isInteger(o)||o<0||o>4)throw new Error(`log serverity level is not valid: ${o}`);let l=s.logVerbosityLevel??0;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log verbosity level is not valid: ${l}`);let u="string"==typeof s.optimizedModelFilePath?sn(s.optimizedModelFilePath,r):0;if(n=t._OrtCreateSessionOptions(e,!!s.enableCpuMemArena,!!s.enableMemPattern,i,!!s.enableProfiling,0,a,o,l,u),0===n&&on("Can\'t create session options."),s.executionProviders&&pn(n,s.executionProviders,r),void 0!==s.enableGraphCapture){if("boolean"!=typeof s.enableGraphCapture)throw new Error(`enableGraphCapture must be a boolean value: ${s.enableGraphCapture}`);let e=sn("enableGraphCapture",r),i=sn(s.enableGraphCapture.toString(),r);0!==t._OrtAddSessionConfigEntry(n,e,i)&&on(`Can\'t set a session config entry: \'enableGraphCapture\' - ${s.enableGraphCapture}.`)}if(s.freeDimensionOverrides)for(let[e,i]of Object.entries(s.freeDimensionOverrides)){if("string"!=typeof e)throw new Error(`free dimension override name must be a string: ${e}`);if("number"!=typeof i||!Number.isInteger(i)||i<0)throw new Error(`free dimension override value must be a non-negative integer: ${i}`);let s=sn(e,r);0!==t._OrtAddFreeDimensionOverride(n,s,i)&&on(`Can\'t set a free dimension override: ${e} - ${i}.`)}return void 0!==s.extra&&an(s.extra,"",new WeakSet,((e,s)=>{let i=sn(e,r),a=sn(s,r);0!==t._OrtAddSessionConfigEntry(n,i,a)&&on(`Can\'t set a session config entry: ${e} - ${s}.`)})),[n,r]}catch(e){throw 0!==n&&0!==t._OrtReleaseSessionOptions(n)&&on("Can\'t release session options."),r.forEach((e=>t._free(e))),e}}})),vd=ut((()=>{fn=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},mn=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},_n=(e,t)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],r="number"==typeof t?t:t.reduce(((e,t)=>e*t),1);return n>0?Math.ceil(r*n):void 0},gn=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},wn=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},yn=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,bn=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint64"===e||"int8"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,xn=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}})),$d=ut((()=>{Mt(),vn=async e=>{if("string"==typeof e){{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let n=t.headers.get("Content-Length"),r=n?parseInt(n,10):0;if(r<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let n,s=t.body.getReader();try{n=new ArrayBuffer(r)}catch(e){if(!(e instanceof RangeError))throw e;{let e=Math.ceil(r/65536);n=new WebAssembly.Memory({initial:e,maximum:e}).buffer}}let i=0;for(;;){let{done:e,value:t}=await s.read();if(e)break;let r=t.byteLength;new Uint8Array(n,i,r).set(t),i+=r}return new Uint8Array(n,0,r)}}}return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}})),kd=ut((()=>{vd(),$n=["V","I","W","E","F"],kn=(e,t)=>{console.log(`[${$n[e]},${(new Date).toISOString()}]${t}`)},zn=(e,t)=>{En=e,Sn=t},Cn=(e,t)=>{let n=wn(e);n>=wn(En)&&kn(n,"function"==typeof t?t():t)},Tn=(...e)=>{Sn&&Cn(...e)}})),Ed=ut((()=>{vd(),An=(e,t)=>new(gn(t))(e)})),Sd=ut((()=>{})),zd=ut((()=>{kd(),Sd(),In=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),Mn=[],On=e=>16*Math.ceil(Number(e)/16),Bn=e=>{for(let t=0;t<Mn.length;t++){let n=Mn[t];if(e<=n)return n}return 16*Math.ceil(e/16)},Nn=1,Pn=()=>Nn++,Rn=async(e,t,n,r)=>{let s=On(n),i=e.device.createBuffer({size:s,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let a=e.getCommandEncoder();e.endComputePass(),a.copyBufferToBuffer(t,0,i,0,s),e.flush(),await i.mapAsync(GPUMapMode.READ);let o=i.getMappedRange();if(r){let e=r();return e.set(new Uint8Array(o,0,n)),e}return new Uint8Array(o.slice(0,n))}finally{i.destroy()}},Dn=class{constructor(e){this.backend=e,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[e]of In)Mn.push(e),this.freeBuffers.set(e,[]),this.freeUniformBuffers.set(e,[]);this.sessionCount=0}upload(e,t){let n=t.buffer,r=t.byteOffset,s=t.byteLength,i=On(s),a=this.storageCache.get(e);if(!a)throw new Error("gpu data for uploading does not exist");if(Number(a.originalSize)!==s)throw new Error(`inconsistent data size. gpu data size=${a.originalSize}, data size=${s}`);let o=this.backend.device.createBuffer({mappedAtCreation:!0,size:i,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),l=o.getMappedRange();new Uint8Array(l).set(new Uint8Array(n,r,s)),o.unmap();let u=this.backend.device.createCommandEncoder();u.copyBufferToBuffer(o,0,a.gpuData.buffer,0,i),this.backend.device.queue.submit([u.finish()]),o.destroy(),Tn("verbose",(()=>`[WebGPU] GpuDataManager.upload(id=${e})`))}memcpy(e,t){let n=this.storageCache.get(e);if(!n)throw new Error("source gpu data for memcpy does not exist");let r=this.storageCache.get(t);if(!r)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==r.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=On(n.originalSize),i=this.backend.getCommandEncoder();this.backend.endComputePass(),i.copyBufferToBuffer(n.gpuData.buffer,0,r.gpuData.buffer,0,s)}registerExternalBuffer(e,t,n){let r;if(n){if(r=n[0],e===n[1])return Tn("verbose",(()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${r}, buffer is the same, skip.`)),r;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error("Registering a different external buffer under graph capture mode is not supported yet.\\n             Please use the previous external buffer!")}else r=Pn();return this.storageCache.set(r,{gpuData:{id:r,type:0,buffer:e},originalSize:t}),Tn("verbose",(()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${r}, registered.`)),r}unregisterExternalBuffer(e){void 0!==e&&(this.storageCache.delete(e),Tn("verbose",(()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`)))}create(e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n,r=Bn(e),s=(t&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,i=(t&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||i){let e=(s?this.freeBuffers:this.freeUniformBuffers).get(r);n=e&&e.length>0?e.pop():this.backend.device.createBuffer({size:r,usage:t})}else n=this.backend.device.createBuffer({size:r,usage:t});let a={id:Pn(),type:0,buffer:n};return this.storageCache.set(a.id,{gpuData:a,originalSize:Number(e)}),Tn("verbose",(()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${a.id}`)),a}get(e){return this.storageCache.get(e)?.gpuData}release(e){let t="bigint"==typeof e?Number(e):e,n=this.storageCache.get(t);if(!n){if(0===this.storageCache.size)return 0;throw new Error("releasing data does not exist")}return Tn("verbose",(()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${n.gpuData.id}`)),this.storageCache.delete(t),this.buffersPending.push(n.gpuData.buffer),n.originalSize}async download(e,t){let n=this.storageCache.get(Number(e));if(!n)throw new Error("data does not exist");await Rn(this.backend,n.gpuData.buffer,n.originalSize,t)}refreshPendingBuffers(){if(0!==this.buffersPending.length)if("default"===this.backend.sessionStatus){for(let e of this.buffersPending){let t=In.get(e.size);if((e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let n=this.freeBuffers.get(e.size)||[];void 0===t||n.length>=t?e.destroy():n.push(e)}else if((e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let n=this.freeUniformBuffers.get(e.size)||[];void 0===t||n.length>=t?e.destroy():n.push(e)}else e.destroy()}this.buffersPending=[]}else{let e=this.capturedPendingBuffers.get(this.backend.currentSessionId);e||(e=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,e));for(let t of this.buffersPending)e.push(t);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.freeUniformBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.storageCache.forEach((e=>{e.gpuData.buffer.destroy()})),this.capturedPendingBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(e){let t=this.capturedPendingBuffers.get(e);t&&(t.forEach((e=>{e.destroy()})),this.capturedPendingBuffers.delete(e)),this.sessionCount-=1,0===this.sessionCount&&(Tn("warning",(()=>"[WebGPU] Clearing webgpu buffer cache")),this.storageCache.forEach((e=>{e.gpuData.buffer.destroy()})),this.storageCache=new Map)}},Ln=(...e)=>new Dn(...e)})),Cd=ut((()=>{Fn=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map((e=>`${this[e]}`)).join(";")),this.key}},Un=e=>new Fn(e)})),Td=ut((()=>{qn=class{static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}},Vn=class{static calcShape(e,t,n=!1){let r=e.length,s=t.length;if(0===r)return t;if(0===s)return e;let i=Math.max(e.length,t.length),a=new Array(i);if(n){if(r<2||s<2)return;let n=qn.calcMatMulShape([e[r-2],e[r-1]],[t[s-2],t[s-1]]);if(void 0===n)return;[a[i-2],a[i-1]]=n}for(let o=n?3:1;o<=i;o++){let n=r-o<0?1:e[r-o],l=s-o<0?1:t[s-o];if(n!==l&&n>1&&l>1)return;let u=Math.max(n,l);if(n&&l)a[i-o]=Math.max(n,l);else{if(u>1)return;a[i-o]=0}}return a}static isValidBroadcast(e,t){let n=e.length,r=t.length;if(n>r)return!1;for(let s=1;s<=n;s++)if(1!==e[n-s]&&e[n-s]!==t[r-s])return!1;return!0}},Wn=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static convertShape(e,t=4){let n=e.length;if(0===n)return[];let r=new Array(n),s=n-1;for(;s>=0;){if(e[s]%t==0){r[s]=e[s]/t;break}if(t%e[s]!=0)throw new Error("cannot convert shape");r[s]=1,t/=e[s],s--}for(s--;s>=0;s--)r[s]=e[s];return r}static sizeFromDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,n,t.length)}static sizeToDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,n)}static getSizeFromDimensionRange(e,t,n){let r=1;for(let s=t;s<n;s++){if(e[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");r*=Number(e[s])}return r}static computeStrides(e){let t=e.length;if(0===t)return[];if(1===t)return[1];let n=new Array(t);n[t-1]=1,n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map((n=>this.normalizeAxis(n,t??e.length)))}static sortBasedOnPerm(e,t){return t?t.map((t=>e[t])):e.slice().reverse()}static padShape(e,t){let n=e.length;return e.map(((e,r)=>e+t[r]+t[r+n]))}static areEqual(e,t){return e.length===t.length&&e.every(((e,n)=>e===t[n]))}},jn=class e{static adjustPoolAttributes(e,t,n,r,s,i){if(!e&&n.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let e=0;e<t.length-2;e++)e>=n.length?n.push(t[e+2]):n[e]=t[e+2];for(let e=0;e<n.length;e++)if(e<r.length){if(r[e]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let e=0;e<n.length;e++)if(e<s.length){if(s[e]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let e=0;e<2*n.length;e++)if(e<i.length){if(i[e]<0)throw new Error("pad should be greater than or equal to 1")}else i.push(0);for(let e=0;e<n.length;e++){if(n[e]<=0)throw new Error("kernel shapes need to be greater than 0");if(i[e]>=n[e]||i[e+n.length]>=n[e])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,n,r,s,i,a,o){if(o){if(i.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(s.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let l=0;l<t.length-2;l++)e.adjustPadAndReturnShape(t[l+(a?1:2)],n[l],r[l],s[l],i,l,l+t.length-2,o)}}static computePoolOutputShape(t,n,r,s,i,a,o){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let l=[n[0],n[1]];return e.computeShapeHelper(t,n,l,r,s,i,a,o),l}static computeConvOutputShape(t,n,r,s,i,a,o){if(t.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let l=[t[0],n[0]];return e.computeShapeHelper(!1,t,l,r,s,i,a,o),l}static computeShapeHelper(t,n,r,s,i,a,o,l){if(t)for(let e=0;e<n.length-2;e++)r.push(1);else for(let t=0;t<n.length-2;t++)r.push(e.adjustPadAndReturnShape(n[t+2],s[t],i[t],a[t],o,t,t+n.length-2,l))}static adjustPadAndReturnShape(e,t,n,r,s,i,a,o){let l=n*(r-1)+1;if(!o||"NOTSET"===o)return Math.floor((e+s[i]+s[a]-l)/t+1);switch(o){case"VALID":return s[i]=0,s[a]=0,Math.floor((e-l)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let n=((e+t-1)/t-1)*t+r-e;return s[i]=Math.floor("SAME_LOWER"===o?(n+1)/2:n/2),s[a]=n-s[i],Math.floor((e+n-r)/t+1)}default:throw new Error("Unsupported AutoPad type")}}},Gn=class{static getShapeOfGemmResult(e,t,n,r,s){if(2!==e.length||2!==n.length)throw new Error("shape need to be of size 2");let i,a,o;t?(i=e[1],a=e[0]):(i=e[0],a=e[1]);let l=-1;if(r?(o=n[0],l=1):(o=n[1],l=0),n[l]!==a)throw new Error("dimension mismatch");if(i<=0||o<=0||a<=0)throw new Error("invalid shape specified");if(s&&!Vn.isValidBroadcast(s,[i,o]))throw new Error("gemm: invalid bias shape for broadcast");return[i,o,a]}},Hn=-34028234663852886e22,Kn=34028234663852886e22})),Ad=ut((()=>{vd(),Td(),Xn=64,Qn=(e,t)=>{if(3===t)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(e)){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(4!==t)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${e}`)}},Yn=(e,t=1)=>{let n=Qn(e,t);return"string"==typeof n?n:n[0]},Zn=(e,t=1)=>{let n=Qn(e,t);return"string"==typeof n?n:n[1]},Jn=(...e)=>{let t=[];return e.forEach((e=>{0!==e.length&&t.push({type:12,data:e},{type:12,data:Wn.computeStrides(e)})})),t},er=e=>e%4==0?4:e%2==0?2:1,tr=(e="f32",t,n="0")=>t&&1!==t?`vec${t}<${e}>(${n})`:`${e}(${n})`,nr=(e,t,n)=>"f32"===e?n:1===t?`f32(${n})`:`vec${t}<f32>(${n})`,rr=(e,t)=>4===t?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:2===t?`(${e}.x + ${e}.y)`:3===t?`(${e}.x + ${e}.y + ${e}.z)`:e,sr=(e,t,n,r)=>e.startsWith("uniforms.")&&n>4?"string"==typeof t?"f16"===r?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:"f16"===r?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:n>1?`${e}[${t}]`:e,ir=(e,t,n,r,s)=>{let i="number"==typeof n,a=i?n:n.length,o=[...new Array(a).keys()],l=a<2?"u32":a<=4?`vec${a}<u32>`:`array<u32, ${a}>`,u=Qn(t,s),d="string"==typeof u?u:u[1],c="string"==typeof u?u:u[0],p={indices:l,value:d,storage:c,tensor:t},h=e=>"string"==typeof e?e:`${e}u`,f={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},m=i?"uniforms.":"",_=`${m}${e}_shape`,g=`${m}${e}_strides`,w="";for(let e=0;e<a-1;e++)w+=`\\n    let dim${e} = current / ${sr(g,e,a)};\\n    let rest${e} = current % ${sr(g,e,a)};\\n    indices[${e}] = dim${e};\\n    current = rest${e};\\n    `;w+=`indices[${a-1}] = current;`;let y=a<2?"":`\\n  fn o2i_${e}(offset: u32) -> ${p.indices} {\\n    var indices: ${p.indices};\\n    var current = offset;\\n    ${w}\\n    return indices;\\n  }`,b=[];if(a>=2)for(let e=a-1;e>=0;e--)b.push(`${sr(g,e,a)} * (indices[${e}])`);let x=a<2?"":`\\n  fn i2o_${e}(indices: ${p.indices}) -> u32 {\\n    return ${b.join("+")};\\n  }`,v=(...e)=>0===a?"0u":`${p.indices}(${e.map(h).join(",")})`,$=(e,t)=>a<2?`${e}`:`${sr(e,t,a)}`,k={},E=(t,n)=>(()=>{if(p.storage===p.value)return`${e}[${t}]=${n};`;if("vec2<u32>"===p.storage&&"i32"===p.value)return`${e}[${t}]=vec2<u32>(u32(${n}), select(0u, 0xFFFFFFFFu, ${n} < 0));`;if("vec2<u32>"===p.storage&&"u32"===p.value)return`${e}[${t}]=vec2<u32>(u32(${n}), 0u);`;if("u32"===p.storage&&"vec4<bool>"===p.value)return`${e}[${t}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${n}));`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),S=t=>(()=>{if(p.storage===p.value)return`${e}[${t}]`;if("vec2<u32>"===p.storage&&"i32"===p.value)return`i32(${e}[${t}].x)`;if("vec2<u32>"===p.storage&&"u32"===p.value)return`u32(${e}[${t}].x)`;if("u32"===p.storage&&"vec4<bool>"===p.value)return`vec4<bool>(bool(${e}[${t}] & 0xFFu), bool(${e}[${t}] & 0xFF00u), bool(${e}[${t}] & 0xFF0000u), bool(${e}[${t}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),z=a<2?"":`\\n  fn get_${e}ByIndices(indices: ${p.indices}) -> ${d} {\\n    return ${S(`i2o_${e}(indices)`)};\\n  }`,C=a<2?"":(()=>{let t=o.map((e=>`d${e}: u32`)).join(", "),n=o.map((e=>`d${e}`)).join(", ");return`\\n  fn get_${e}(${t}) -> ${d} {\\n    return get_${e}ByIndices(${v(n)});\\n  }`})(),T=a<2?"":`\\n  fn set_${e}ByIndices(indices: ${p.indices}, value: ${d}) {\\n    ${E(`i2o_${e}(indices)`,"value")}\\n  }`,A=a<2?"":(()=>{let t=o.map((e=>`d${e}: u32`)).join(", "),n=o.map((e=>`d${e}`)).join(", ");return`\\n  fn set_${e}(${t}, value: ${d}) {\\n    set_${e}ByIndices(${v(n)}, value);\\n  }`})();return{impl:()=>{let e=[],t=!1;return f.offsetToIndices&&(e.push(y),t=!0),f.indicesToOffset&&(e.push(x),t=!0),f.broadcastedIndicesToOffset&&(Object.values(k).forEach((t=>e.push(t))),t=!0),f.set&&(e.push(A),t=!0),f.setByIndices&&(e.push(T),t=!0),f.get&&(e.push(C),t=!0),f.getByIndices&&(e.push(z),t=!0),!i&&t&&e.unshift(`const ${_} = ${p.indices}(${n.join(",")});`,`const ${g} = ${p.indices}(${Wn.computeStrides(n).join(",")});`),e.join("\\n")},type:p,offsetToIndices:t=>(f.offsetToIndices=!0,a<2?t:`o2i_${e}(${t})`),indicesToOffset:t=>(f.indicesToOffset=!0,a<2?t:`i2o_${e}(${t})`),broadcastedIndicesToOffset:(t,n)=>{f.broadcastedIndicesToOffset=!0;let r=`${n.name}broadcastedIndicesTo${e}Offset`;if(r in k)return`${r}(${t})`;let s=[];for(let e=a-1;e>=0;e--){let t=n.indicesGet("outputIndices",e+n.rank-a);s.push(`${$(g,e)} * (${t} % ${$(_,e)})`)}return k[r]=`fn ${r}(outputIndices: ${n.type.indices}) -> u32 {\\n             return ${s.length>0?s.join("+"):"0u"};\\n           }`,`${r}(${t})`},indices:v,indicesGet:$,indicesSet:(e,t,n)=>a<2?`${e}=${n};`:`${sr(e,t,a)}=${n};`,set:(...t)=>{if(t.length!==a+1)throw new Error(`indices length must be ${a}`);let n=t[a];if("string"!=typeof n)throw new Error("value must be string");let r=t.slice(0,a).map(h).join(",");return 0===a?E("0u",n):1===a?E(r[0],n):(f.set=!0,f.setByIndices=!0,f.indicesToOffset=!0,`set_${e}(${r}, ${n})`)},setByOffset:E,setByIndices:(t,n)=>a<2?E(t,n):(f.setByIndices=!0,f.indicesToOffset=!0,`set_${e}ByIndices(${t}, ${n});`),get:(...t)=>{if(t.length!==a)throw new Error(`indices length must be ${a}`);let n=t.map(h).join(",");return 0===a?S("0u"):1===a?S(n[0]):(f.get=!0,f.getByIndices=!0,f.indicesToOffset=!0,`get_${e}(${n})`)},getByOffset:S,getByIndices:t=>a<2?S(t):(f.getByIndices=!0,f.indicesToOffset=!0,`get_${e}ByIndices(${t})`),usage:r,name:e,strides:g,shape:_,rank:a}},ar=(e,t,n,r=1)=>ir(e,t,n,"input",r),or=(e,t,n,r=1)=>ir(e,t,n,"output",r),lr=(e,t,n)=>ir(e,t,n,"atomicOutput",1),ur=(e,t,n,r=1)=>ir(e,t,n,"internal",r),dr=class{constructor(e,t){this.normalizedDispatchGroup=e,this.limits=t,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${"number"==typeof e?`${e}u`:e}) { return; }`}mainStart(e=Xn){let t="number"==typeof e?e:e[0],n="number"==typeof e?1:e[1],r="number"==typeof e?1:e[2];if(t>this.limits.maxComputeWorkgroupSizeX||n>this.limits.maxComputeWorkgroupSizeY||r>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${t}, ${n}, ${r}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(t*n*r>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${t}, ${n}, ${r}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let s=1===this.normalizedDispatchGroup[1]&&1===this.normalizedDispatchGroup[2];return`@compute @workgroup_size(${t}, ${n}, ${r})\\n  fn main(${s?"@builtin(global_invocation_id) global_id : vec3<u32>,\\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\\n    @builtin(local_invocation_index) local_idx : u32,\\n    @builtin(local_invocation_id) local_id : vec3<u32>":"@builtin(global_invocation_id) global_id : vec3<u32>,\\n                                             @builtin(local_invocation_id) local_id : vec3<u32>,\\n    @builtin(local_invocation_index) local_idx : u32,\\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\\n    @builtin(num_workgroups) num_workgroups : vec3<u32>"}) {\\n    ${s?"let global_idx = global_id.x;\\n         let workgroup_index = workgroup_id.x;":`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\\n             workgroup_id.y * num_workgroups[0] + workgroup_id.x;\\n         let global_idx = workgroup_index * ${t*n*r}u + local_idx;`}\\n  `}appendVariableUniforms(e){0!==e.rank&&(e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:"u32",length:e.rank}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:"u32",length:e.rank}))}declareVariable(e,t){if("internal"===e.usage)throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(e),this.appendVariableUniforms(e);let n="input"===e.usage?"read":"read_write",r="atomicOutput"===e.usage?"atomic<i32>":e.type.storage;return`@group(0) @binding(${t}) var<storage, ${n}> ${e.name}: array<${r}>;`}declareVariables(...e){return e.map((e=>this.declareVariable(e,this.variableIndex++))).join("\\n")}registerInternalVariable(e){if("internal"!==e.usage)throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(e),this.appendVariableUniforms(e)}registerInternalVariables(...e){return e.forEach((e=>this.registerInternalVariable(e))),this}registerUniform(e,t,n=1){return this.uniforms.push({name:e,type:t,length:n}),this}registerUniforms(e){return this.uniforms=this.uniforms.concat(e),this}uniformDeclaration(){if(0===this.uniforms.length)return"";let e=[];for(let{name:t,type:n,length:r}of this.uniforms)if(r&&r>4)"f16"===n?e.push(`@align(16) ${t}:array<mat2x4<${n}>, ${Math.ceil(r/8)}>`):e.push(`${t}:array<vec4<${n}>, ${Math.ceil(r/4)}>`);else{let s=null==r||1===r?n:`vec${r}<${n}>`;e.push(`${t}:${s}`)}return`\\n      struct Uniforms { ${e.join(", ")} };\\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map((e=>e.impl())).join("\\n")+this.internalVariables.map((e=>e.impl())).join("\\n")}get variablesInfo(){if(0===this.uniforms.length)return;let e=e=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(e)];return this.uniforms.map((t=>[e(t.type),t.length??1]))}},cr=(e,t)=>new dr(e,t)})),Id=ut((()=>{vd(),Td(),Cd(),Ad(),pr=e=>{if(!e||1!==e.length)throw new Error("Transpose requires 1 input.")},hr=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,fr=(e,t)=>Wn.sortBasedOnPerm(e,hr(e.length,t)),mr=(e,t,n,r)=>{let s=`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {\\n    var a: ${n.type.indices};`;for(let n=0;n<t;++n)s+=`a[${e[n]}]=i[${n}];`;return s+"return a;}"},_r=(e,t)=>{let n=[],r=[];for(let s=0;s<e.length;++s)1!==e[s]&&n.push(e[s]),1!==e[t[s]]&&r.push(t[s]);return{newShape:n,newPerm:r}},gr=(e,t)=>{let n=0;for(let r=0;r<e.length;++r)if(1!==t[e[r]]){if(e[r]<n)return!1;n=e[r]}return!0},wr=(e,t)=>{let n,r=e.dataType,s=e.dims.length,i=hr(s,t),a=fr(e.dims,i),o=e.dims,l=a;if(s<2||gr(i,e.dims))return n=e=>{let t=ar("input",r,o,4),n=or("output",r,l,4);return`\\n  ${e.registerUniform("output_size","u32").declareVariables(t,n)}\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n    output[global_idx] = input[global_idx];\\n  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let t=Wn.size(a);return{outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(t/64/4)},programUniforms:[{type:12,data:Math.ceil(t/4)}]}},getShaderSource:n};let{newShape:u,newPerm:d}=_r(e.dims,i),c=Wn.areEqual(d,[2,3,1]),p=Wn.areEqual(d,[3,1,2]);if(2===u.length||c||p){o=c?[u[0],u[1]*u[2]]:p?[u[0]*u[1],u[2]]:u,l=[o[1],o[0]];let t=16;return n=e=>{let n=ar("a",r,o.length),s=or("output",r,l.length);return`\\n  ${e.registerUniform("output_size","u32").declareVariables(n,s)}\\n  var<workgroup> tile : array<array<${s.type.value}, ${t+1}>, ${t}>;\\n  ${e.mainStart([t,t,1])}\\n    let stride = (uniforms.output_shape[1] - 1) / ${t} + 1;\\n    let workgroup_id_x = workgroup_index % stride;\\n    let workgroup_id_y = workgroup_index / stride;\\n    let input_col = workgroup_id_y * ${t}u + local_id.x;\\n    let input_row = workgroup_id_x * ${t}u + local_id.y;\\n    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {\\n      tile[local_id.y][local_id.x] = ${n.getByIndices(`${n.type.indices}(input_row, input_col)`)};\\n    }\\n    workgroupBarrier();\\n\\n    let output_col = workgroup_id_x * ${t}u + local_id.x;\\n    let output_row = workgroup_id_y * ${t}u + local_id.y;\\n    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {\\n      ${s.setByIndices(`${s.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}\\n    }\\n  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let n=Wn.size(a);return{outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(l[1]/t),y:Math.ceil(l[0]/t)},programUniforms:[{type:12,data:n},...Jn(o,l)]}},getShaderSource:n}}return n=e=>{let t=ar("a",r,o.length),n=or("output",r,l.length);return`\\n  ${e.registerUniform("output_size","u32").declareVariables(t,n)}\\n\\n  ${mr(i,s,t,n)}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n\\n    let indices = ${n.offsetToIndices("global_idx")};\\n    let aIndices = perm(indices);\\n\\n    ${n.setByOffset("global_idx",t.getByIndices("aIndices"))}\\n  }`},{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:["rank"]},getRunData:()=>{let t=Wn.size(a);return{outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(t/64)},programUniforms:[{type:12,data:t},...Jn(o,l)]}},getShaderSource:n}},yr=(e,t)=>{pr(e.inputs),e.compute(wr(e.inputs[0],t.perm))},br=e=>Un({perm:e.perm})})),Md=ut((()=>{vd(),Td(),Ad(),Od(),Id(),xr={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},vr={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},$r={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},kr={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Er=(e,t)=>{let n=[];for(let r=t-e;r<t;++r)n.push(r);return n},Sr=(e,t)=>{let n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);return[n,t.map((t=>e[t]))]},zr=(e,t)=>{let n=e.length+t.length,r=[],s=0;for(let i=0;i<n;i++)-1===t.indexOf(i)?r.push(e[s++]):r.push(1);return r},Cr=(e,t)=>{for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0},Tr=(e,t)=>{let n=[];if(!Cr(e,t)){for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);e.forEach((e=>n.push(e)))}return n},Ar=(e,t,n,r,s,i,a)=>{let o=n[0].dims,l=Wn.size(i),u=Wn.size(a),d=ar("_A",n[0].dataType,o),c=or("output",s,i),p=64;1===l&&(p=256);let h=`\\n          var<workgroup> aBestValues : array<f32, ${p}>;\\n       `;return{name:e,shaderCache:{hint:`${t};${p}`,inputDependencies:["type"]},getShaderSource:e=>`\\n        ${e.registerUniform("reduceSize","u32").declareVariables(d,c)}\\n        ${h}\\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\\n          return ((a - 1u) / b + 1u);\\n         }\\n         ${e.mainStart(p)}\\n\\n          let outputIndex = global_idx / ${p};\\n          let offset = outputIndex * uniforms.reduceSize;\\n\\n          var bestValue = f32(${$r[r]});\\n          let Length = uniforms.reduceSize;\\n          for (var k = local_idx; k < Length; k = k + ${p}) {\\n           let candidate = f32(${d.getByOffset("offset + k")});\\n           bestValue = ${xr[r]};\\n          }\\n          aBestValues[local_idx] = bestValue;\\n          workgroupBarrier();\\n\\n         var reduceSize = min(Length, ${p}u);\\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\\n             currentSize = reduceSize / 2u) {\\n           let interval = DIV_CEIL(reduceSize, 2u);\\n           if (local_idx < currentSize) {\\n            let candidate = aBestValues[local_idx + interval];\\n            bestValue = ${vr[r]};\\n            aBestValues[local_idx] = bestValue;\\n           }\\n           reduceSize = interval;\\n           workgroupBarrier();\\n         }\\n\\n         if (local_idx == 0u) {\\n          ${c.setByOffset("outputIndex",""+("mean"===r?`${c.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${c.type.storage}(${kr[r]})`))};\\n         }\\n        }`,getRunData:()=>({outputs:[{dims:i,dataType:s}],dispatchGroup:{x:l},programUniforms:[{type:12,data:u}]})}},Ir=(e,t,n,r)=>{let s=1===e.inputs.length?n:jr(e.inputs,n),i=s.axes;0===i.length&&!s.noopWithEmptyAxes&&(i=e.inputs[0].dims.map(((e,t)=>t)));let a=Wn.normalizeAxes(i,e.inputs[0].dims.length),o=a,l=e.inputs[0],u=Tr(o,e.inputs[0].dims.length);u.length>0&&(l=e.compute(wr(e.inputs[0],u),{inputs:[0],outputs:[-1]})[0],o=Er(o.length,l.dims.length));let[d,c]=Sr(l.dims,o),p=d;s.keepDims&&(p=zr(d,a)),e.compute(Ar(t,s.cacheKey,[l],r,e.inputs[0].dataType,p,c),{inputs:[l]})},Mr=(e,t)=>{Ir(e,"ReduceMeanShared",t,"mean")},Or=(e,t)=>{Ir(e,"ReduceL1Shared",t,"l1")},Br=(e,t)=>{Ir(e,"ReduceL2Shared",t,"l2")},Nr=(e,t)=>{Ir(e,"ReduceLogSumExpShared",t,"logSumExp")},Pr=(e,t)=>{Ir(e,"ReduceMaxShared",t,"max")},Rr=(e,t)=>{Ir(e,"ReduceMinShared",t,"min")},Dr=(e,t)=>{Ir(e,"ReduceProdShared",t,"prod")},Lr=(e,t)=>{Ir(e,"ReduceSumShared",t,"sum")},Fr=(e,t)=>{Ir(e,"ReduceSumSquareShared",t,"sumSquare")},Ur=(e,t)=>{Ir(e,"ReduceLogSumShared",t,"logSum")}})),Od=ut((()=>{vd(),Td(),Cd(),Ad(),Md(),qr=e=>{if(!e||0===e.length||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(2===e.length&&1!==e[1].dims.length)throw new Error("Invalid axes input dims.")},Vr=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],Wr=(e,t,n,r,s,i,a=!1,o=!1)=>{let l=[],u=n[0].dims,d=u.length,c=Wn.normalizeAxes(s,d),p=!o&&0===c.length;u.forEach(((e,t)=>{p||c.indexOf(t)>=0?a&&l.push(1):l.push(e)}));let h=l.length,f=Wn.size(l);return{name:e,shaderCache:t,getShaderSource:e=>{let t=[],s=ar("_A",n[0].dataType,d),o=or("output",i,h),l=r(s,o,c),f=l[2];for(let e=0,n=0;e<d;e++)p||c.indexOf(e)>=0?(a&&n++,f=`for(var j${e}: u32 = 0; j${e} < ${u[e]}; j${e}++) {\\n                  ${l[2].includes("last_index")?`let last_index = j${e};`:""}\\n                  ${s.indicesSet("input_indices",e,`j${e}`)}\\n                  ${f}\\n                }`):(t.push(`${s.indicesSet("input_indices",e,o.indicesGet("output_indices",n))};`),n++);return`\\n\\n        ${e.registerUniform("output_size","u32").declareVariables(s,o)}\\n\\n        ${e.mainStart()}\\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n          var input_indices: ${s.type.indices};\\n          let output_indices = ${o.offsetToIndices("global_idx")};\\n\\n          ${t.join("\\n")}\\n          ${l[0]}       // init ops for reduce max/min\\n          ${l[1]}\\n          ${f}\\n          ${l[3]}\\n          ${4===l.length?o.setByOffset("global_idx","value"):l.slice(4).join("\\n")}\\n        }`},getRunData:()=>({outputs:[{dims:l,dataType:i}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:[{type:12,data:f},...Jn(u,l)]})}},jr=(e,t)=>{let n=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach((e=>n.push(Number(e)))),Un({axes:n,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},Gr=(e,t,n,r)=>{let s=e.inputs,i=1===s.length?n:jr(s,n);e.compute(Wr(t,{hint:i.cacheKey,inputDependencies:["rank"]},[s[0]],i.noopWithEmptyAxes&&0===i.axes.length?Vr:r,i.axes,s[0].dataType,i.keepDims,i.noopWithEmptyAxes),{inputs:[0]})},Hr=(e,t)=>{qr(e.inputs),Gr(e,"ReduceLogSum",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByIndices("input_indices")};`,"value = log(value);"]))},Kr=(e,t)=>{qr(e.inputs),Gr(e,"ReduceL1",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += abs(${e.getByIndices("input_indices")});`,""]))},Xr=(e,t)=>{qr(e.inputs),Gr(e,"ReduceL2",t,((e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"]))},Qr=(e,t)=>{qr(e.inputs),Gr(e,"ReduceLogSumExp",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += exp(${e.getByIndices("input_indices")});`,"value = log(value);"]))},Yr=(e,t)=>{qr(e.inputs),Gr(e,"ReduceMax",t,((e,t,n)=>{let r=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&r.push(e.indicesSet("input_indices",t,0));return[`${r.join("\\n")}`,`var value = ${e.getByIndices("input_indices")};`,`value = max(value, ${e.getByIndices("input_indices")});`,""]}))},Zr=(e,t)=>{qr(e.inputs),Gr(e,"ReduceMean",t,((t,n,r)=>{let s=1;for(let n=0;n<t.rank;n++)(r.indexOf(n)>=0||0===r.length)&&(s*=e.inputs[0].dims[n]);return["var sum = f32(0);","",`sum += f32(${t.getByIndices("input_indices")});`,`let value = ${n.type.value}(sum / ${s});`]}))},Jr=(e,t)=>{qr(e.inputs),Gr(e,"ReduceMin",t,((e,t,n)=>{let r=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&r.push(`input_indices[${t}] = 0;`);return[`${r.join("\\n")}`,`var value = ${e.getByIndices("input_indices")};`,`value = min(value, ${e.getByIndices("input_indices")});`,""]}))},es=(e,t)=>{qr(e.inputs),Gr(e,"ReduceProd",t,((e,t)=>[`var value = ${t.type.storage}(1);`,"",`value *= ${e.getByIndices("input_indices")};`,""]))},ts=(e,t)=>{qr(e.inputs),Gr(e,"ReduceSum",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByIndices("input_indices")};`,""]))},ns=(e,t)=>{qr(e.inputs),Gr(e,"ReduceSumSquare",t,((e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByIndices("input_indices")}; value += t * t;`,""]))},rs=(e,t,n)=>{if(0===t.length)return n;let r=1,s=1;for(let n=0;n<t.length;n++)-1===t.indexOf(n)?r*=e[n]:s*=e[n];return s<32&&r>1024},ss=(e,t)=>{rs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Zr(e,t):Mr(e,t)},is=(e,t)=>{rs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Kr(e,t):Or(e,t)},as=(e,t)=>{rs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Xr(e,t):Br(e,t)},os=(e,t)=>{rs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Qr(e,t):Nr(e,t)},ls=(e,t)=>{rs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Yr(e,t):Pr(e,t)},us=(e,t)=>{rs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Jr(e,t):Rr(e,t)},ds=(e,t)=>{rs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?es(e,t):Dr(e,t)},cs=(e,t)=>{rs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ts(e,t):Lr(e,t)},ps=(e,t)=>{rs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ns(e,t):Fr(e,t)},hs=(e,t)=>{rs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Hr(e,t):Ur(e,t)}})),Bd=ut((()=>{vd(),Cd(),Od(),fs=e=>{if(!e||0===e.length||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(1!==e[0].dataType)throw new Error("Invalid input type.")},ms=(e,t)=>{fs(e.inputs);e.compute(Wr("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],((e,n,r)=>{let s=[];for(let t=0;t<e.rank;t++)(r.indexOf(t)>=0||0===r.length)&&s.push(`input_indices[${t}] = 0;`);return[`${s.join("\\n")}`,`var value = ${e.getByIndices("input_indices")};\\nvar best_index : i32 = 0;`,`if (${e.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {\\n         value = ${e.getByIndices("input_indices")};\\n         best_index = i32(last_index);\\n       }`,"",n.setByOffset("global_idx","best_index")]}),[t.axis],7,t.keepDims),{inputs:[0]})},_s=(e,t)=>{fs(e.inputs);e.compute(Wr("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],((e,n,r)=>{let s=[];for(let t=0;t<e.rank;t++)(r.indexOf(t)>=0||0===r.length)&&s.push(`input_indices[${t}] = 0;`);return[`${s.join("\\n")}`,`var value = ${e.getByIndices("input_indices")};\\nvar best_index : i32 = 0;`,`if (${e.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {\\n         value = ${e.getByIndices("input_indices")};\\n         best_index = i32(last_index);\\n       }`,"",n.setByOffset("global_idx","best_index")]}),[t.axis],7,t.keepDims),{inputs:[0]})},gs=e=>Un(e)})),Nd=ut((()=>{vd(),Td(),Sd(),Ad(),ws=(e,t)=>{let n=e[0],r=e[1],s=e[2],i=e[3],a=e[4],o=e[5];if(a&&o)throw new Error("Attention cannot have both past and attention_bias");if(3!==n.dims.length)throw new Error(\'Input "input" must have 3 dimensions\');let l=n.dims[0],u=n.dims[1],d=n.dims[2];if(1!==s.dims.length)throw new Error(\'Input "bias" is expected to have 1 dimensions\');if(2!==r.dims.length)throw new Error(\'Input "weights" is expected to have 2 dimensions\');if(r.dims[0]!==d)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(s.dims[0]!==r.dims[1])throw new Error(\'Input "bias" dimension 0 should have same length as dimension 1 of input "weights"\');let c=s.dims[0]/3,p=c,h=p;if(t.qkvHiddenSizes.length>0){if(3!==t.qkvHiddenSizes.length)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let e of t.qkvHiddenSizes)if(e%t.numHeads!=0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");c=t.qkvHiddenSizes[0],p=t.qkvHiddenSizes[1],h=t.qkvHiddenSizes[2]}let f=u;if(c!==p)throw new Error("qkv_hidden_sizes first element should be same as the second");if(s.dims[0]!==c+p+h)throw new Error(\'Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes\');let m=0;if(a){if(p!==h)throw new Error(\'Input "past" expect k_hidden_size == v_hidden_size\');if(5!==a.dims.length)throw new Error(\'Input "past" must have 5 dimensions\');if(2!==a.dims[0])throw new Error(\'Input "past" first dimension must be 2\');if(a.dims[1]!==l)throw new Error(\'Input "past" second dimension must be batch_size\');if(a.dims[2]!==t.numHeads)throw new Error(\'Input "past" third dimension must be num_heads\');if(a.dims[4]!==p/t.numHeads)throw new Error(\'Input "past" fifth dimension must be k_hidden_size / num_heads\');t.pastPresentShareBuffer||(m=a.dims[3])}let _=f+m;if(i)throw new Error("Mask not supported");if(a)throw new Error("past is not supported");if(o){if(4!==o.dims.length)throw new Error(\'Input "attention_bias" must have 4 dimensions\');if(o.dims[0]!==l||o.dims[1]!==t.numHeads||o.dims[2]!==u||o.dims[3]!==_)throw new Error(\'Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)\')}return{batchSize:l,sequenceLength:u,pastSequenceLength:m,kvSequenceLength:f,totalSequenceLength:_,maxSequenceLength:-1,inputHiddenSize:d,hiddenSize:c,vHiddenSize:h,headSize:Math.floor(c/t.numHeads),vHeadSize:Math.floor(h/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:0,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},ys=(e,t,n)=>t&&e?`\\n      let total_sequence_length_input = u32(${t.getByOffset("0")});\\n      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);\\n      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;\\n      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;\\n      total_sequence_length = u32(${e?.getByOffset("batchIdx")}) + 1;\\n      var past_sequence_length: u32 = 0;\\n      if (is_first_prompt == false) {\\n        past_sequence_length = total_sequence_length - sequence_length;\\n      }\\n       `:`\\n    ${n?"let past_sequence_length = uniforms.past_sequence_length":""};\\n    let present_sequence_length = total_sequence_length;\\n    `,bs=(e,t,n,r,s,i,a,o)=>{let l=er(a?1:i),u=64,d=i/l;d<u&&(u=32);let c=Math.ceil(i/l/u),p=[{type:12,data:t},{type:12,data:n},{type:12,data:r},{type:12,data:s},{type:12,data:d},{type:12,data:c}],h=Yn(e.dataType,l),f=Zn(1,l),m=["type"];a&&m.push("type"),o&&m.push("type");return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${u};${h};${l}`,inputDependencies:m},getShaderSource:t=>{let n=or("x",e.dataType,e.dims,l),r=[n],s=a?ar("seq_lens",a.dataType,a.dims):void 0;s&&r.push(s);let i=o?ar("total_sequence_length_input",o.dataType,o.dims):void 0;i&&r.push(i);let d=Zn(e.dataType);return`\\n  var<workgroup> thread_max: array<f32, ${u}>;\\n  var<workgroup> thread_sum: array<f32, ${u}>;\\n  ${t.registerUniforms([{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}]).declareVariables(...r)}\\n  ${t.mainStart([u,1,1])}\\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\\n    let headIdx = workgroup_id.z % uniforms.num_heads;\\n    let sequence_length = uniforms.sequence_length;\\n    var total_sequence_length = uniforms.total_sequence_length;\\n    ${ys(s,i,!1)}\\n    let local_offset = local_idx * uniforms.elements_per_thread;\\n    let offset = (global_idx / ${u}) * uniforms.total_sequence_length + local_offset;\\n    let seq_causal_length = ${a?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};\\n    var thread_max_vector = ${f}(-3.402823e+38f);\\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\\n      thread_max_vector = max(${f}(x[offset + i]), thread_max_vector);\\n    }\\n    thread_max[local_idx] = ${(()=>{switch(l){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${l}`)}})()};\\n    workgroupBarrier();\\n\\n    var max_value =  f32(-3.402823e+38f);\\n    for (var i = 0u; i < ${u}; i++) {\\n      max_value = max(thread_max[i], max_value);\\n    }\\n\\n    var sum_vector = ${f}(0);\\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\\n      sum_vector += exp(${f}(x[offset + i]) - max_value);\\n    }\\n    thread_sum[local_idx] = ${(()=>{switch(l){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${l}`)}})()};\\n    workgroupBarrier();\\n\\n    var sum: f32 = 0;\\n    for (var i = 0u; i < ${u}; i++) {\\n      sum += thread_sum[i];\\n    }\\n\\n    if (sum == 0) {\\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\\n        x[offset + i] = ${n.type.value}(${d}(1.0) / ${d}(seq_causal_length));\\n      }\\n    } else {\\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\\n        var f32input = ${f}(x[offset + i]);\\n        x[offset + i] = ${n.type.value}(exp(f32input - max_value) / sum);\\n      }\\n    }\\n      ${a?`\\n        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {\\n          x[offset + total_seq_id] = ${n.type.value}(${d}(0));\\n        }`:""};\\n  }`},getRunData:()=>({outputs:[],dispatchGroup:{x:Math.ceil(i/u),y:s,z:t*n},programUniforms:p})}},xs=(e,t,n,r,s,i,a,o,l)=>{let u=a+i.kvSequenceLength,d=[i.batchSize,i.numHeads,i.sequenceLength,u],c=e>1&&r,p=i.kvNumHeads?i.kvNumHeads:i.numHeads,h=c?[i.batchSize,p,u,i.headSize]:void 0,f=i.nReps?i.nReps:1,m=0===i.scale?1/Math.sqrt(i.headSize):i.scale,_=er(i.headSize),g=i.headSize/_,w=12,y={x:Math.ceil(u/w),y:Math.ceil(i.sequenceLength/w),z:i.batchSize*i.numHeads},b=[{type:12,data:i.sequenceLength},{type:12,data:g},{type:12,data:u},{type:12,data:i.numHeads},{type:12,data:i.headSize},{type:1,data:m},{type:12,data:a},{type:12,data:i.kvSequenceLength},{type:12,data:f}],x=c&&r&&Wn.size(r.dims)>0,v=["type","type"];x&&v.push("type"),s&&v.push("type"),o&&v.push("type"),l&&v.push("type");let $=[{dims:d,dataType:t.dataType,gpuDataType:0}];c&&$.push({dims:h,dataType:t.dataType,gpuDataType:0});return{name:"AttentionProbs",shaderCache:{hint:`${_};${void 0!==s};${void 0!==r};${e}`,inputDependencies:v},getRunData:()=>({outputs:$,dispatchGroup:y,programUniforms:b}),getShaderSource:e=>{let i=ar("q",t.dataType,t.dims,_),a=[i,ar("key",n.dataType,n.dims,_)];if(x){let e=ar("past_key",r.dataType,r.dims,_);a.push(e)}s&&a.push(ar("attention_bias",s.dataType,s.dims));let u=o?ar("seq_lens",o.dataType,o.dims):void 0;u&&a.push(u);let p=l?ar("total_sequence_length_input",l.dataType,l.dims):void 0;p&&a.push(p);let m=or("output",t.dataType,d),g=[m];c&&g.push(or("present_key",t.dataType,h,_));let y=Zn(1,_);return`\\n  const TILE_SIZE = 12u;\\n\\n  var<workgroup> tileQ: array<${i.type.storage}, 144>;\\n  var<workgroup> tileK: array<${i.type.storage}, 144>;\\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}]).declareVariables(...a,...g)}\\n  ${e.mainStart([w,w,1])}\\n    // x holds the N and y holds the M\\n    let headIdx = workgroup_id.z % uniforms.num_heads;\\n    let kvHeadIdx = ${1===f?"headIdx":"headIdx / uniforms.n_reps"};\\n    let kv_num_heads = ${1===f?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};\\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\\n    let m = workgroup_id.y * TILE_SIZE;\\n    let n = workgroup_id.x * TILE_SIZE;\\n    let sequence_length = uniforms.M;\\n    var total_sequence_length = uniforms.N;\\n    ${ys(u,p,!0)}\\n    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;\\n    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\\n    ${x&&c?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};\\n    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;\\n    ${c?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}\\n    var value = ${y}(0);\\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\\n      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {\\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\\n      }\\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\\n        var idx = TILE_SIZE * local_id.y + local_id.x;\\n      ${x&&c?"\\n              if (n + local_id.y < past_sequence_length) {\\n                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\\n              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\\n                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];\\n              }":"\\n          if (n + local_id.y < uniforms.kv_sequence_length) {\\n            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\\n          }"}\\n      ${c?"if (n + local_id.y < present_sequence_length) {\\n        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];\\n      }":""}\\n      }\\n      workgroupBarrier();\\n\\n      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\\n          value += ${y}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);\\n      }\\n\\n      workgroupBarrier();\\n    }\\n\\n    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {\\n      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;\\n      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;\\n      var sum: f32 = ${(()=>{switch(_){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${_}`)}})()};\\n        output[outputIdx] = ${m.type.value} (sum * uniforms.alpha) + ${s?"attention_bias[outputIdx]":"0.0"};\\n    }\\n  }`}}},vs=(e,t,n,r,s,i,a=void 0,o=void 0)=>{let l=i+s.kvSequenceLength,u=s.nReps?s.nReps:1,d=s.vHiddenSize*u,c=e>1&&r,p=s.kvNumHeads?s.kvNumHeads:s.numHeads,h=c?[s.batchSize,p,l,s.headSize]:void 0,f=[s.batchSize,s.sequenceLength,d],m=12,_={x:Math.ceil(s.vHeadSize/m),y:Math.ceil(s.sequenceLength/m),z:s.batchSize*s.numHeads},g=[{type:12,data:s.sequenceLength},{type:12,data:l},{type:12,data:s.vHeadSize},{type:12,data:s.numHeads},{type:12,data:s.headSize},{type:12,data:d},{type:12,data:i},{type:12,data:s.kvSequenceLength},{type:12,data:u}],w=c&&r&&Wn.size(r.dims)>0,y=["type","type"];w&&y.push("type"),a&&y.push("type"),o&&y.push("type");let b=[{dims:f,dataType:t.dataType,gpuDataType:0}];c&&b.push({dims:h,dataType:t.dataType,gpuDataType:0});return{name:"AttentionScore",shaderCache:{hint:`${void 0!==r};${e}`,inputDependencies:y},getRunData:()=>({outputs:b,dispatchGroup:_,programUniforms:g}),getShaderSource:e=>{let s=ar("probs",t.dataType,t.dims),i=[s,ar("v",n.dataType,n.dims)];w&&i.push(ar("past_value",r.dataType,r.dims));let l=a?ar("seq_lens",a.dataType,a.dims):void 0;a&&i.push(l);let d=o?ar("total_sequence_length_input",o.dataType,o.dims):void 0;o&&i.push(d);let p=[or("output",t.dataType,f)];c&&p.push(or("present_value",t.dataType,h));return`\\n  const TILE_SIZE = 12u;\\n  var<workgroup> tileQ: array<${s.type.value}, 144>;\\n  var<workgroup> tileV: array<${s.type.value}, 144>;\\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}]).declareVariables(...i,...p)}\\n  ${e.mainStart([m,m,1])}\\n   let headIdx = workgroup_id.z % uniforms.num_heads;\\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\\n   let kvHeadIdx = ${1===u?"headIdx":"headIdx / uniforms.n_reps"};\\n   let kv_num_heads = ${1===u?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};\\n   let m = global_id.y;\\n   let n = global_id.x;\\n   let sequence_length = uniforms.M;\\n   var total_sequence_length = uniforms.K;\\n   ${ys(l,d,!0)}\\n   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\\n   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch\\n   ${w&&c?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};\\n   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;\\n   ${c?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}\\n   var value = ${s.type.storage}(0);\\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\\n      }\\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\\n        var idx = TILE_SIZE * local_id.y + local_id.x;\\n        ${w&&c?"\\n        if (w + local_id.y < past_sequence_length) {\\n          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];\\n        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\\n          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];\\n        }\\n      ":"\\n            if (w + local_id.y < uniforms.kv_sequence_length) {\\n              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];\\n            }"}\\n        ${c?"\\n            if (w + local_id.y < present_sequence_length) {\\n          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];\\n        }":""}\\n      }\\n     workgroupBarrier();\\n     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {\\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];\\n     }\\n     workgroupBarrier();\\n   }\\n\\n   // we need to transpose output from BNSH_v to BSND_v\\n   if (m < uniforms.M && n < uniforms.N) {\\n     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size\\n       + headIdx * uniforms.N + n;\\n     output[outputIdx] = value;\\n   }\\n  }`}}},$s=(e,t,n,r,s,i,a,o,l,u,d=void 0,c=void 0)=>{let p=Math.min(e.outputCount,1+(a?1:0)+(o?1:0)),h=p>1?u.pastSequenceLength:0,f=h+u.kvSequenceLength,m=l&&Wn.size(l.dims)>0?l:void 0,_=[t,n];p>1&&a&&Wn.size(a.dims)>0&&_.push(a),m&&_.push(m),d&&_.push(d),c&&_.push(c);let g=e.compute(xs(p,t,n,a,m,u,h,d,c),{inputs:_,outputs:p>1?[-1,1]:[-1]})[0];e.compute(bs(g,u.batchSize,u.numHeads,h,u.sequenceLength,f,d,c),{inputs:d&&c?[g,d,c]:[g],outputs:[]});let w=[g,r];p>1&&o&&Wn.size(o.dims)>0&&w.push(o),d&&w.push(d),c&&w.push(c),e.compute(vs(p,g,r,o,u,h,d,c),{inputs:w,outputs:p>1?[0,2]:[0]})},ks=(e,t)=>{let n=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],r=t.sequenceLength,s=t.inputHiddenSize,i=t.headSize,a=12,o={x:Math.ceil(t.headSize/a),y:Math.ceil(t.sequenceLength/a),z:t.batchSize*t.numHeads},l=[e.inputs[0],e.inputs[1],e.inputs[2]],u=[{type:12,data:r},{type:12,data:s},{type:12,data:i},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}];return e.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:o,programUniforms:u}),getShaderSource:e=>{let t=or("output_q",l[0].dataType,n),r=or("output_k",l[0].dataType,n),s=or("output_v",l[0].dataType,n),i=ar("input",l[0].dataType,l[0].dims),o=ar("weight",l[1].dataType,l[1].dims),u=ar("bias",l[2].dataType,l[2].dims),d=i.type.storage;return`\\n  const TILE_SIZE = 12u;\\n  var<workgroup> tileInput: array<${d}, 144>;\\n  var<workgroup> tileWeightQ: array<${d}, 144>;\\n  var<workgroup> tileWeightK: array<${d}, 144>;\\n  var<workgroup> tileWeightV: array<${d}, 144>;\\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}]).declareVariables(i,o,u,t,r,s)}\\n  ${e.mainStart([a,a,1])}\\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\\n    let headNumber = workgroup_id.z % uniforms.num_heads;\\n    let m = global_id.y;\\n    let n = global_id.x;\\n\\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\\n    let biasOffsetQ = headNumber * uniforms.head_size;\\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\\n\\n    var valueQ = ${d}(0);\\n    var valueK = ${d}(0);\\n    var valueV = ${d}(0);\\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\\n      }\\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\\n        let offset = n + (w + local_id.y) * uniforms.ldb;\\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\\n      }\\n      workgroupBarrier();\\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\\n      }\\n\\n      workgroupBarrier();\\n    }\\n\\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\\n    valueQ += bias[headOffset + biasOffsetQ];\\n    valueK += bias[headOffset + biasOffsetK];\\n    valueV += bias[headOffset + biasOffsetV];\\n\\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\\n    if (m < uniforms.M && n < uniforms.N) {\\n      let outputIdx = offset + m * uniforms.N + n;\\n      output_q[outputIdx] = valueQ;\\n      output_k[outputIdx] = valueK;\\n      output_v[outputIdx] = valueV;\\n    }\\n  }`}},{inputs:l,outputs:[-1,-1,-1]})},Es=(e,t)=>{let n=ws(e.inputs,t),[r,s,i]=ks(e,n);return $s(e,r,s,i,e.inputs[4],void 0,void 0,void 0,e.inputs[5],n)}})),Pd=ut((()=>{It(),vd(),Td(),Cd(),Ad(),Ss=(e,t)=>{if(!e||5!==e.length)throw new Error("BatchNormalization requires 5 inputs");let n=(e,t,n)=>{let r=t.length;if(r!==e.length)throw new Error(`${n}: num dimensions != ${r}`);t.forEach(((t,r)=>{if(t!==e[r])throw new Error(`${n}: dim[${r}] do not match`)}))};if(e[0].dims.length>1){let r="NHWC"===t.format?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);n(e[1].dims,r,"Invalid input scale"),n(e[2].dims,r,"Invalid input B"),n(e[3].dims,r,"Invalid input mean"),n(e[4].dims,r,"Invalid input var")}else n(e[1].dims,[1],"Invalid input scale"),n(e[2].dims,[1],"Invalid input B"),n(e[3].dims,[1],"Invalid input mean"),n(e[4].dims,[1],"Invalid input var")},zs=(e,t)=>{let{epsilon:n,spatial:r,format:s}=t,i=e[0].dims,a=r?er(i[i.length-1]):1,o="NHWC"===s&&i.length>1?a:1,l=Wn.size(i)/a,u=r,d=u?i.length:i,c=ar("x",e[0].dataType,e[0].dims,a),p=ar("scale",e[1].dataType,e[1].dims,o),h=ar("bias",e[2].dataType,e[2].dims,o),f=ar("inputMean",e[3].dataType,e[3].dims,o),m=ar("inputVar",e[4].dataType,e[4].dims,o),_=or("y",e[0].dataType,d,a);return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${r}_${a}`,inputDependencies:u?["rank","type","type","type","type"]:void 0},getShaderSource:e=>`\\n  const epsilon = ${n};\\n  ${e.registerUniform("outputSize","u32").declareVariables(c,p,h,f,m,_)}\\n  ${e.mainStart()}\\n  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n    var outputIndices = ${_.offsetToIndices(`global_idx * ${a}`)};\\n    ${(()=>{let e="";if(r)e=`let cOffset = ${1===i.length?"0u":"NHWC"===s?`outputIndices[${i.length-1}] / ${a}`:"outputIndices[1]"};`;else if("NCHW"===s)e=`\\n            ${_.indicesSet("outputIndices","0","0")}\\n            let cOffset = ${_.indicesToOffset("outputIndices")};`;else{e=`var cIndices = ${p.type.indices}(0);\\n                       cIndices[0] = outputIndices[${i.length-1}];`;for(let t=1;t<p.rank;t++)e+=`cIndices[${t}] = outputIndices[${t}];`;e+=`let cOffset = ${p.indicesToOffset("cIndices")};`}return e})()}\\n    let scale = ${p.getByOffset("cOffset")};\\n    let bias = ${h.getByOffset("cOffset")};\\n    let inputMean = ${f.getByOffset("cOffset")};\\n    let inputVar = ${m.getByOffset("cOffset")};\\n    let x = ${c.getByOffset("global_idx")};\\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\\n    ${_.setByOffset("global_idx","value")}\\n  }`,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u?[{type:12,data:l},...Jn(i)]:[{type:12,data:l}]})}},Cs=e=>Un(e),Ts=(e,t)=>{let{inputs:n,outputCount:r}=e,s=Cs({...t,outputCount:r});if(Oe.webgpu.validateInputContent&&Ss(n,s),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(zs(n,s))}})),Rd=ut((()=>{Td(),Ad(),As=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Is=e=>{let t=e[0].dims,n=e[0].dims[2],r=Wn.size(t)/4,s=e[0].dataType,i=ar("input",s,t,4),a=ar("bias",s,[n],4),o=ar("residual",s,t,4),l=or("output",s,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(r/64)}}),getShaderSource:e=>`\\n  const channels = ${n}u / 4;\\n  ${e.declareVariables(i,a,o,l)}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(r)}\\n    let value = ${i.getByOffset("global_idx")}\\n      + ${a.getByOffset("global_idx % channels")} + ${o.getByOffset("global_idx")};\\n    ${l.setByOffset("global_idx","value")}\\n  }`}},Ms=e=>{As(e.inputs),e.compute(Is(e.inputs))}})),Dd=ut((()=>{vd(),Td(),Cd(),Ad(),Os=(e,t,n,r,s,i,a)=>{let o=Math.ceil(t/4),l="";l="string"==typeof s?`${s}(a)`:s("a");let u=ar("inputData",n,[o],4),d=or("outputData",r,[o],4),c=[{name:"vec_size",type:"u32"}];return a&&c.push(...a),`\\n      ${e.registerUniforms(c).declareVariables(u,d)}\\n\\n  ${i??""}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\\n\\n    let a = ${u.getByOffset("global_idx")};\\n    ${d.setByOffset("global_idx",l)}\\n  }`},Bs=(e,t,n,r,s,i=e.dataType,a,o)=>{let l=[{type:12,data:Math.ceil(Wn.size(e.dims)/4)}];return a&&l.push(...a),{name:t,shaderCache:{hint:s,inputDependencies:["type"]},getShaderSource:t=>Os(t,Wn.size(e.dims),e.dataType,i,n,r,o),getRunData:t=>({outputs:[{dims:e.dims,dataType:i}],dispatchGroup:{x:Math.ceil(Wn.size(t[0].dims)/64/4)},programUniforms:l})}},Ns=e=>{e.compute(Bs(e.inputs[0],"Abs","abs"))},Ps=e=>{e.compute(Bs(e.inputs[0],"Acos","acos"))},Rs=e=>{e.compute(Bs(e.inputs[0],"Acosh","acosh"))},Ds=e=>{e.compute(Bs(e.inputs[0],"Asin","asin"))},Ls=e=>{e.compute(Bs(e.inputs[0],"Asinh","asinh"))},Fs=e=>{e.compute(Bs(e.inputs[0],"Atan","atan"))},Us=e=>{e.compute(Bs(e.inputs[0],"Atanh","atanh"))},qs=e=>Un(e),Vs=(e,t)=>{let n;switch(t.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute(Bs(e.inputs[0],"Cast",n,void 0,t.cacheKey,t.to))},Ws=e=>{let t,n,r=e.length>=2&&0!==e[1].data,s=e.length>=3&&0!==e[2].data;switch(e[0].dataType){case 1:t=r?e[1].getFloat32Array()[0]:-34028234663852886e22,n=s?e[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:t=r?e[1].getUint16Array()[0]:64511,n=s?e[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return Un({min:t,max:n})},js=(e,t)=>{let n=t||Ws(e.inputs),r=Zn(e.inputs[0].dataType);e.compute(Bs(e.inputs[0],"Clip",(e=>`clamp(${e}, vec4<${r}>(uniforms.min), vec4<${r}>(uniforms.max))`),void 0,n.cacheKey,void 0,[{type:e.inputs[0].dataType,data:n.min},{type:e.inputs[0].dataType,data:n.max}],[{name:"min",type:r},{name:"max",type:r}]),{inputs:[0]})},Gs=e=>{e.compute(Bs(e.inputs[0],"Ceil","ceil"))},Hs=e=>{e.compute(Bs(e.inputs[0],"Cos","cos"))},Ks=e=>{e.compute(Bs(e.inputs[0],"Cosh","cosh"))},Xs=e=>Un(e),Qs=(e,t)=>{let n=Zn(e.inputs[0].dataType);e.compute(Bs(e.inputs[0],"Elu",(e=>`elu_vf32(${e})`),`\\n  const elu_alpha_ = ${n}(${t.alpha});\\n\\n  fn elu_f32(a: ${n}) -> ${n} {\\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\\n  }\\n\\n  fn elu_vf32(v: vec4<${n}>) -> vec4<${n}> {\\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\\n  }`,t.cacheKey))},Ys=(e="f32")=>`\\nconst r0: ${e} = 0.3275911;\\nconst r1: ${e} = 0.254829592;\\nconst r2: ${e} = -0.284496736;\\nconst r3: ${e} = 1.421413741;\\nconst r4: ${e} = -1.453152027;\\nconst r5: ${e} = 1.061405429;\\n\\nfn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {\\n  let absv = abs(v);\\n  let x = 1.0 / (1.0 + r0 * absv);\\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\\n}`,Zs=e=>{let t=Zn(e.inputs[0].dataType);e.compute(Bs(e.inputs[0],"Erf",(e=>`erf_vf32(${e})`),Ys(t)))},Js=e=>{e.compute(Bs(e.inputs[0],"Exp","exp"))},ei=e=>{e.compute(Bs(e.inputs[0],"Floor","floor"))},ti=e=>{let t=Zn(e.inputs[0].dataType);e.compute(Bs(e.inputs[0],"Gelu",(e=>`0.5 * ${e} * (1.0 + erf_vf32(${e} * 0.7071067811865475))`),Ys(t)))},ni=(e,t)=>{let n=Zn(e.inputs[0].dataType);e.compute(Bs(e.inputs[0],"LeakyRelu",(e=>`select(leaky_relu_alpha_ * ${e}, ${e}, ${e} >= vec4<${n}>(0.0))`),`const leaky_relu_alpha_ = ${n}(${t.alpha});`,t.cacheKey))},ri=e=>{e.compute(Bs(e.inputs[0],"Not",(e=>`!${e}`)))},si=e=>{e.compute(Bs(e.inputs[0],"Neg",(e=>`-${e}`)))},ii=e=>{e.compute(Bs(e.inputs[0],"Reciprocal",(e=>`1.0/${e}`)))},ai=e=>{let t=Zn(e.inputs[0].dataType);e.compute(Bs(e.inputs[0],"Relu",(e=>`select(vec4<${t}>(0.0), ${e}, ${e} > vec4<${t}>(0.0))`)))},oi=e=>{e.compute(Bs(e.inputs[0],"Sigmoid",(e=>`(1.0 / (1.0 + exp(-${e})))`)))},li=e=>Un(e),ui=(e,t)=>{let n=Zn(e.inputs[0].dataType);e.compute(Bs(e.inputs[0],"HardSigmoid",(e=>`max(vec4<${n}>(0.0), min(vec4<${n}>(1.0), ${t.alpha} * ${e} + vec4<${n}>(${t.beta})))`),void 0,t.cacheKey))},di=e=>{e.compute(Bs(e.inputs[0],"Sin","sin"))},ci=e=>{e.compute(Bs(e.inputs[0],"Sinh","sinh"))},pi=e=>{e.compute(Bs(e.inputs[0],"Sqrt","sqrt"))},hi=e=>{e.compute(Bs(e.inputs[0],"Tan","tan"))},fi=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,mi=e=>{e.compute(Bs(e.inputs[0],"Tanh",fi))},_i=(e="f32")=>`\\nconst fast_gelu_a: ${e} = 0.5;\\nconst fast_gelu_b: ${e} = 0.7978845608028654;\\nconst fast_gelu_c: ${e} = 0.035677408136300125;\\n\\nfn tanh_v(v: vec4<${e}>) -> vec4<${e}> {\\n  return ${fi("v")};\\n}\\n`,gi=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,wi=e=>{let t=Zn(e.inputs[0].dataType);e.compute(Bs(e.inputs[0],"FastGelu",gi,_i(t),void 0,e.inputs[0].dataType))},yi=(e,t)=>{let n=Zn(e.inputs[0].dataType);return e.compute(Bs(e.inputs[0],"ThresholdedRelu",(e=>`select(vec4<${n}>(0.0), ${e}, ${e} > thresholded_relu_alpha_)`),`const thresholded_relu_alpha_ = vec4<${n}>(${t.alpha});`,t.cacheKey)),0},bi=e=>{e.compute(Bs(e.inputs[0],"Log","log"))},xi=(e,t)=>`\\nconst alpha = vec4<${e}>(${t});\\nconst one = ${e}(1.0);\\nconst zero = ${e}(0.0);\\n\\nfn quick_gelu_impl(x: vec4<${e}>) -> vec4<${e}> {\\n  let v = x *alpha;\\n  var x1 : vec4<${e}>;\\n  for (var i = 0; i < 4; i = i + 1) {\\n    if (v[i] >= zero) {\\n      x1[i] = one / (one + exp(-v[i]));\\n    } else {\\n      x1[i] = one - one / (one + exp(v[i]));\\n    }\\n  }\\n  return x * x1;\\n}\\n`,vi=e=>`quick_gelu_impl(${e})`,$i=(e,t)=>{let n=Zn(e.inputs[0].dataType);e.compute(Bs(e.inputs[0],"QuickGelu",vi,xi(n,t.alpha),t.cacheKey,e.inputs[0].dataType))}})),Ld=ut((()=>{Td(),Ad(),Dd(),ki=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Ei=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let n=ar("input",e[0].dataType,e[0].dims,4),r=ar("bias",e[0].dataType,[e[0].dims[2]],4),s=or("output",e[0].dataType,t,4),i=Wn.size(t)/4,a=Yn(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:t=>`\\n  const M_SQRT2 = sqrt(2.0);\\n  const halfChannels = ${e[0].dims[2]/4/2}u;\\n\\n  ${t.declareVariables(n,r,s)}\\n\\n  ${Ys(a)}\\n\\n  ${t.mainStart()}\\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes(i)}\\n    let biasIdx = global_idx % halfChannels;\\n    let batchIndex = global_idx / halfChannels;\\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\\n    let valueLeft = input[inputOffset] + bias[biasIdx];\\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\\n\\n    ${s.setByOffset("global_idx","valueLeft * geluRight")}\\n  }`}},Si=e=>{ki(e.inputs),e.compute(Ei(e.inputs))}})),Fd=ut((()=>{vd(),Td(),Ad(),zi=(e,t,n,r,s,i,a,o,l,u,d,c)=>{let p,h;"string"==typeof o?p=h=(e,t)=>`${o}((${e}),(${t}))`:"function"==typeof o?p=h=o:(p=o.scalar,h=o.vector);let f,m=or("outputData",d,r.length,4),_=ar("aData",l,t.length,4),g=ar("bData",u,n.length,4);if(s)if(i){let e=1===Wn.size(t),r=1===Wn.size(n),s=t.length>0&&t[t.length-1]%4==0,i=n.length>0&&n[n.length-1]%4==0;f=e||r?m.setByOffset("global_idx",h(e?`${_.type.value}(${_.getByOffset("0")}.x)`:_.getByOffset("global_idx"),r?`${g.type.value}(${g.getByOffset("0")}.x)`:g.getByOffset("global_idx"))):`\\n            let outputIndices = ${m.offsetToIndices("global_idx * 4u")};\\n            let offsetA = ${_.broadcastedIndicesToOffset("outputIndices",m)};\\n            let offsetB = ${g.broadcastedIndicesToOffset("outputIndices",m)};\\n            ${m.setByOffset("global_idx",h(a||s?_.getByOffset("offsetA / 4u"):`${_.type.value}(${_.getByOffset("offsetA / 4u")}[offsetA % 4u])`,a||i?g.getByOffset("offsetB / 4u"):`${g.type.value}(${g.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}\\n          `}else f=m.setByOffset("global_idx",h(_.getByOffset("global_idx"),g.getByOffset("global_idx")));else{if(!i)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let e=(e,t,n="")=>{let r=`aData[indexA${t}][componentA${t}]`,s=`bData[indexB${t}][componentB${t}]`;return`\\n            let outputIndices${t} = ${m.offsetToIndices(`global_idx * 4u + ${t}u`)};\\n            let offsetA${t} = ${_.broadcastedIndicesToOffset(`outputIndices${t}`,m)};\\n            let offsetB${t} = ${g.broadcastedIndicesToOffset(`outputIndices${t}`,m)};\\n            let indexA${t} = offsetA${t} / 4u;\\n            let indexB${t} = offsetB${t} / 4u;\\n            let componentA${t} = offsetA${t} % 4u;\\n            let componentB${t} = offsetB${t} % 4u;\\n            ${e}[${t}] = ${n}(${p(r,s)});\\n          `};f=9===d?`\\n            var data = vec4<u32>(0);\\n            ${e("data",0,"u32")}\\n            ${e("data",1,"u32")}\\n            ${e("data",2,"u32")}\\n            ${e("data",3,"u32")}\\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\\n            ${e("outputData[global_idx]",0)}\\n            ${e("outputData[global_idx]",1)}\\n            ${e("outputData[global_idx]",2)}\\n            ${e("outputData[global_idx]",3)}\\n          `}return`\\n        ${e.registerUniform("vec_size","u32").declareVariables(_,g,m)}\\n\\n        ${c??""}\\n\\n        ${e.mainStart()}\\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\\n        ${f}\\n      }`},Ci=(e,t,n,r,s,i,a=n.dataType)=>{let o=n.dims.map((e=>Number(e)??1)),l=r.dims.map((e=>Number(e)??1)),u=!Wn.areEqual(o,l),d=o,c=Wn.size(o),p=!1,h=!1,f=[u];if(u){let e=Vn.calcShape(o,l,!1);if(!e)throw new Error("Can\'t perform binary op on the given tensors");d=e.slice(),c=Wn.size(d);let t=1===Wn.size(o),n=1===Wn.size(l),r=o.length>0&&o[o.length-1]%4==0,s=l.length>0&&l[l.length-1]%4==0;f.push(t),f.push(n),f.push(r),f.push(s);let i=1;for(let e=1;e<d.length;e++){let t=o[o.length-e];if(t!==l[l.length-e])break;i*=t}i%4==0?(h=!0,p=!0):(t||n||r||s)&&(p=!0)}else p=!0;return f.push(p),{name:e,shaderCache:{hint:t+f.map((e=>e.toString())).join("_"),inputDependencies:["rank","rank"]},getShaderSource:e=>zi(e,o,l,d,p,u,h,s,n.dataType,r.dataType,a,i),getRunData:()=>({outputs:[{dims:d,dataType:a}],dispatchGroup:{x:Math.ceil(c/64/4)},programUniforms:[{type:12,data:Math.ceil(Wn.size(d)/4)},...Jn(o,l,d)]})}},Ti=(e,t,n,r,s,i)=>{e.compute(Ci(t,s??"",e.inputs[0],e.inputs[1],n,r,i))},Ai=e=>{Ti(e,"Add",((e,t)=>`${e}+${t}`))},Ii=e=>{Ti(e,"Div",((e,t)=>`${e}/${t}`))},Mi=e=>{Ti(e,"Equal",{scalar:(e,t)=>`u32(${e}==${t})`,vector:(e,t)=>`vec4<u32>(${e}==${t})`},void 0,void 0,9)},Oi=e=>{Ti(e,"Mul",((e,t)=>`${e}*${t}`))},Bi=e=>{let t=ar("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;Ti(e,"Pow",{scalar:(e,t)=>`pow_custom(${e},${t})`,vector:(e,t)=>`pow_vector_custom(${e},${t})`},`\\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\\n      if (b == ${t}(0.0)) {\\n        return ${t}(1.0);\\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\\n        return ${t}(pow(f32(a), f32(b))); // NaN\\n      }\\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${"i32"===t?"round":""}(pow(f32(abs(a)), f32(b))));\\n    }\\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\\n      // TODO: implement vectorized pow\\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\\n    }\\n      `)},Ni=e=>{Ti(e,"Sub",((e,t)=>`${e}-${t}`))},Pi=e=>{Ti(e,"Greater",{scalar:(e,t)=>`u32(${e}>${t})`,vector:(e,t)=>`vec4<u32>(${e}>${t})`},void 0,void 0,9)},Ri=e=>{Ti(e,"Less",{scalar:(e,t)=>`u32(${e}<${t})`,vector:(e,t)=>`vec4<u32>(${e}<${t})`},void 0,void 0,9)},Di=e=>{Ti(e,"GreaterOrEqual",{scalar:(e,t)=>`u32(${e}>=${t})`,vector:(e,t)=>`vec4<u32>(${e}>=${t})`},void 0,void 0,9)},Li=e=>{Ti(e,"LessOrEqual",{scalar:(e,t)=>`u32(${e}<=${t})`,vector:(e,t)=>`vec4<u32>(${e}<=${t})`},void 0,void 0,9)}})),Ud=ut((()=>{vd(),Td(),Cd(),Ad(),Fi=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");let n=e[0],r=n.dataType,s=n.dims.length;e.forEach(((e,i)=>{if(0!==i){if(e.dataType!==r)throw new Error("input tensors should be one type");if(e.dims.length!==s)throw new Error("input tensors should have the same shape");e.dims.forEach(((e,r)=>{if(r!==t&&e!==n.dims[r])throw new Error("non concat dimensions must match")}))}}))},Ui=(e,t)=>`\\n  fn calculateInputIndex(index: u32) -> u32 {\\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\\n      if (index < sizeInConcatAxis[i]) {\\n        return i;\\n      }\\n    }\\n    return ${e}u;\\n  }`,qi=(e,t)=>{let n=e.length,r=[];for(let s=0;s<n;++s){let i=t.setByOffset("global_idx",e[s].getByIndices("indices"));1===n?r.push(i):0===s?r.push(`if (inputIndex == ${s}u) { ${i} }`):s===n-1?r.push(`else { ${i} }`):r.push(`else if (inputIndex == ${s}) { ${i} }`)}return r.join("\\n")},Vi=(e,t,n,r)=>{let s=Wn.size(n),i=new Array(e.length),a=new Array(e.length),o=0,l=[],u=[],d=[{type:12,data:s}];for(let n=0;n<e.length;++n)o+=e[n].dims[t],i[n]=o,u.push(e[n].dims.length),a[n]=ar(`input${n}`,r,u[n]),l.push("rank"),d.push({type:12,data:i[n]});for(let t=0;t<e.length;++t)d.push(...Jn(e[t].dims));d.push(...Jn(n));let c=or("output",r,n.length),p=c.indicesGet("indices",t),h=Array.from(Array(i.length).keys()).map((e=>`uniforms.sizeInConcatAxis${e}`)).join(",");return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:n,dataType:r}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:d}),getShaderSource:t=>`\\n\\n  ${(()=>{t.registerUniform("outputSize","u32");for(let n=0;n<e.length;n++)t.registerUniform(`sizeInConcatAxis${n}`,"u32");return t.declareVariables(...a,c)})()}\\n\\n  ${Ui(i.length,h)}\\n\\n  ${t.mainStart()}\\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n\\n    var indices = ${c.offsetToIndices("global_idx")};\\n\\n    let inputIndex = calculateInputIndex(${p});\\n    if (inputIndex != 0u) {\\n      let sizeInConcatAxis = array<u32, ${i.length}u>(${h});\\n      ${p} -= sizeInConcatAxis[inputIndex - 1u];\\n    }\\n\\n    ${qi(a,c)}\\n  }`}},Wi=(e,t)=>{let n=e.inputs,r=n[0].dims,s=Wn.normalizeAxis(t.axis,r.length);Fi(n,s);let i=r.slice();i[s]=n.reduce(((e,t)=>e+(t.dims.length>s?t.dims[s]:0)),0);let a=n.filter((e=>Wn.size(e.dims)>0));e.compute(Vi(a,s,i,n[0].dataType),{inputs:a})},ji=e=>Un({axis:e.axis})})),qd=ut((()=>{vd(),Td(),Gi=(e,t,n="f32")=>{switch(e.activation){case"Relu":return`value = max(value, ${t}(0.0));`;case"Sigmoid":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${t}(${n}(uniforms.clip_min)), ${t}(${n}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${t}(0.0), min(${t}(1.0), ${n}(uniforms.alpha) * value + ${n}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${n}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case"Tanh":return"let e2x = exp(-2.0 * abs(value));\\n              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);\\n        ";case"":return"";default:throw new Error(`Unsupported activation ${e.activation}`)}},Hi=(e,t)=>{"Clip"===e.activation?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):"HardSigmoid"===e.activation?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):"LeakyRelu"===e.activation&&t.push({type:1,data:e.alpha})},Ki=(e,t)=>{"Clip"===e.activation?t.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):"HardSigmoid"===e.activation?t.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):"LeakyRelu"===e.activation&&t.push({name:"alpha",type:"f32"})},Xi=e=>{let t=e?.activation||"";if("HardSigmoid"===t){let[n,r]=e?.activation_params||[.2,.5];return{activation:t,alpha:n,beta:r}}if("Clip"===t){let[n,r]=e?.activation_params||[Hn,Kn];return{activation:t,clipMax:r,clipMin:n}}if("LeakyRelu"===t){let[n]=e?.activation_params||[.01];return{activation:t,alpha:n}}return{activation:t}}})),Vd=ut((()=>{Qi=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Yi=e=>`\\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\\n      `})),Wd=ut((()=>{Zi=e=>`\\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\\n  return dot(coords, vec4<i32>(\\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\\n}\\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\\n  return dot(coords, vec4<i32>(\\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\\n}\\n`})),jd=ut((()=>{vd(),Td(),Ad(),qd(),Ji=(e,t,n,r,s)=>{let i=r-n;return`\\n      ${Array.from({length:n}).map(((n,a)=>`\\n      if (${sr(t.shape,a,t.rank)} != 1) {\\n        ${t.indicesSet(e,a,sr(s,a+i,r))}\\n      } else {\\n        ${t.indicesSet(e,a,0)}\\n      }`)).join("")}\\n`},ea=(e,t,n,r,s=!1,i)=>{let a=e[0].dims,o=e[1].dims,l=a[a.length-2],u=o[o.length-1],d=a[a.length-1],c=er(u),p=er(d),h=er(l),f=Wn.size(n)/c/h,m=e.length>2,_=r?r.slice(0,-2):n.slice(0,-2),g=[Wn.size(_),l,u],w=[{type:12,data:f},{type:12,data:l},{type:12,data:u},{type:12,data:d}];Hi(t,w),w.push(...Jn(_,a,o)),m&&w.push(...Jn(e[2].dims)),w.push(...Jn(g));return{name:"MatMulNaive",shaderCache:{hint:`${t.activation};${c};${p};${h};${s}`,inputDependencies:m?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:i?i(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:w}),getShaderSource:r=>{let i=ur("batch_dims",e[0].dataType,_.length),l=ar("a",e[0].dataType,a.length,p),u=ar("b",e[1].dataType,o.length,c),d=or("output",e[0].dataType,g.length,c),f=Yn(d.type.tensor),w=Gi(t,d.type.value,f),y=[l,u],b="";if(m){let t=s?c:1;y.push(ar("bias",e[2].dataType,e[2].dims.length,t)),b=""+(s?`value += bias[col / ${t}];`:`value += ${d.type.value}(bias[row + i]);`)}let x=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];Ki(t,x);return`\\n  ${r.registerUniforms(x).registerInternalVariables(i).declareVariables(...y,d)}\\n  ${r.mainStart()}\\n    ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n    let col = (global_idx % (uniforms.N / ${c})) * ${c};\\n    var index1 = global_idx / (uniforms.N / ${c});\\n    let stride1 = uniforms.M / ${h};\\n    let row = (index1 % stride1) * ${h};\\n    let batch = index1 / stride1;\\n\\n    ${2===n.length?"":`let batch_indices = ${i.offsetToIndices("batch")};`}\\n\\n    var a_indices: ${l.type.indices};\\n    ${Ji("a_indices",l,l.rank-2,i.rank,"batch_indices")}\\n    ${l.indicesSet("a_indices",l.rank-2,0)}\\n    ${l.indicesSet("a_indices",l.rank-1,0)}\\n    let a_offset = ${l.indicesToOffset("a_indices")};\\n\\n    var b_indices: ${u.type.indices};\\n    ${Ji("b_indices",u,u.rank-2,i.rank,"batch_indices")}\\n    ${u.indicesSet("b_indices",u.rank-2,0)}\\n    ${u.indicesSet("b_indices",u.rank-1,0)}\\n    let b_offset = ${u.indicesToOffset("b_indices")};\\n    var values: array<${d.type.value}, ${h}>;\\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${p}) {\\n      ${(()=>{let e=`var a_data: ${l.type.value};`;for(let t=0;t<p;t++)e+=`\\n              let b_data${t} = b[(b_offset + (k + ${t}) * uniforms.N + col) / ${c}];`;for(let t=0;t<h;t++){e+=`a_data = a[(a_offset + (row + ${t}) * uniforms.K + k) / ${p}];`;for(let n=0;n<p;n++)e+=`\\n            values[${t}] = fma(${u.type.value}(a_data${1===p?"":`[${n}]`}), b_data${n}, values[${t}]);\\n`}return e})()}\\n    }\\n    for (var i = 0u; i < ${h}u; i++) {\\n      var value = values[i];\\n      ${b}\\n      ${w}\\n      let cur_indices = ${d.type.indices}(batch, row + i, col);\\n      let offset = ${d.indicesToOffset("cur_indices")};\\n      ${d.setByOffset(`offset / ${c}`,"value")};\\n    }\\n  }\\n  `}}}})),Gd=ut((()=>{vd(),Td(),Ad(),qd(),jd(),Vd(),ta=(e,t)=>e?`\\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n          kStart + inputRow,\\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\\n        `:`\\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n          globalRow + innerRow,\\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\\n        `,na=(e,t)=>e?`\\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\\n        ${3===t?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\\n        for (var i = 0; i < rowPerThread; i = i + 1) {\\n          acc[i] = BCached0 * ACached0[i] + acc[i];\\n          acc[i] = BCached1 * ACached1[i] + acc[i];\\n          acc[i] = BCached2 * ACached2[i] + acc[i];\\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\\n        }`:`\\n        for (var i = 0; i < rowPerThread; i = i + 1) {\\n          let ACached = mm_Asub[tileRow + i][k];\\n          acc[i] = BCached0 * ACached.x + acc[i];\\n          acc[i] = BCached1 * ACached.y + acc[i];\\n          acc[i] = BCached2 * ACached.z + acc[i];\\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\\n        }`,ra=(e,t,n="f32",r,s=!1,i=32,a=!1,o=32)=>{let l=t[1]*e[1],u=t[0]*e[0],d=s?l:i,c=s?i:l,p=d/t[0],h=i/t[1];if((!s||4!==p||4!==e[1])&&(s||3!==p&&4!==p)||d%t[0]!=0||i%t[1]!=0||4!==e[0])throw new Error(`If transposeA ${s} is true, innerElementSize ${p} and workPerThread[1] ${e[1]} must be 4.\\n      Otherwise, innerElementSize ${p} must be 3 or 4.\\n  tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}. tileInner ${i} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\\nvar<workgroup> mm_Asub: array<array<vec${p}<${n}>, ${d/p}>, ${c}>;\\nvar<workgroup> mm_Bsub: array<array<vec4<${n}>, ${u/e[0]}>, ${i}>;\\n\\nconst rowPerThread = ${e[1]};\\nconst colPerThread = ${e[0]};\\nconst innerElementSize = ${p};\\nconst tileInner = ${i};\\n\\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\\n        @builtin(global_invocation_id) globalId : vec3<u32>,\\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\\n  let localRow = i32(localId.y);\\n  let tileRow = localRow * rowPerThread;\\n  let tileCol = i32(localId.x);\\n\\n  let globalRow =i32(globalId.y) * rowPerThread;\\n  let globalCol = i32(globalId.x);\\n  let batch = ${a?"0":"i32(globalId.z)"};\\n  ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}\\n  let globalRowStart = i32(workgroupId.y) * ${l};\\n\\n  let num_tiles = ${a?`${Math.ceil(o/i)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\\n  var kStart = ${a?`i32(globalId.z) * ${o}`:"0"};\\n\\n  var acc: array<vec4<${n}>, rowPerThread>;\\n\\n  // Loop over shared dimension.\\n  let tileRowB = localRow * ${h};\\n  for (var t = 0; t < num_tiles; t = t + 1) {\\n      // Load one tile of A into local memory.\\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n          let inputRow = tileRow + innerRow;\\n          let inputCol = tileCol;\\n          ${ta(s,r)}\\n      }\\n\\n      // Load one tile of B into local memory.\\n      for (var innerRow = 0; innerRow < ${h}; innerRow = innerRow + 1) {\\n          let inputRow = tileRowB + innerRow;\\n          let inputCol = tileCol;\\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${r?", batchIndices":""});\\n      }\\n      kStart = kStart + tileInner;\\n      workgroupBarrier();\\n\\n      // Compute acc values for a single thread.\\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\\n          ${3===p?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\\n\\n          ${na(s,p)}\\n      }\\n\\n      workgroupBarrier();\\n  }\\n\\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\\n  }\\n}`},sa=(e,t)=>e?`\\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n              kStart + inputRow,\\n              globalRowStart + inputCol${t?", batchIndices":""});\\n            `:`\\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n              globalRowStart + inputRow,\\n              kStart + inputCol${t?", batchIndices":""});\\n            `,ia=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",aa=(e,t,n="f32",r,s=!1,i=32,a=!1,o=32,l=!1)=>{let u=e[1]*t[1],d=e[0]*t[0],c=s?u:i,p=s?i:u;if(p%t[1]!=0||c%t[0]!=0||i%t[1]!=0)throw new Error(`tileAHight ${p} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}, tileInner ${i} must be divisible by workgroupSize[1]${t[1]}`);let h=p/t[1],f=c/t[0],m=i/t[1],_=l?`\\n    let localRow = i32(localId.y);\\n    let localCol = i32(localId.x);\\n    let globalRowStart = i32(workgroupId.y) * ${u};\\n    let globalColStart = i32(workgroupId.x) * ${d};\\n\\n    // Loop over shared dimension.\\n    for (var t = 0; t < num_tiles; t = t + 1) {\\n      // Load one tile of A into local memory.\\n      for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${t[1]}) {\\n        for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {\\n          ${sa(s,r)}\\n        }\\n      }\\n      // Load one tile of B into local memory.\\n      for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${t[1]}) {\\n            for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${t[0]}) {\\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\\n            kStart + inputRow,\\n            globalColStart + inputCol${r?", batchIndices":""});\\n        }\\n      }\\n      kStart = kStart + tileInner;\\n      workgroupBarrier();\\n\\n      // Compute acc values for a single thread.\\n      var BCached : array<${n}, colPerThread>;\\n      for (var k = 0; k < tileInner; k = k + 1) {\\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\\n        }\\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n          let ACached = ${s?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\\n                ACached * BCached[innerCol];\\n          }\\n        }\\n      }\\n      workgroupBarrier();\\n    }\\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\\n      }\\n    }\\n    `:`\\nlet tileRow = i32(localId.y) * rowPerThread;\\nlet tileCol = i32(localId.x) * colPerThread;\\n\\nlet globalRow = i32(globalId.y) * rowPerThread;\\nlet globalCol = i32(globalId.x) * colPerThread;\\nlet globalRowStart = i32(workgroupId.y) * ${u};\\n\\nlet tileRowA = i32(localId.y) * ${h};\\nlet tileColA = i32(localId.x) * ${f};\\nlet tileRowB = i32(localId.y) * ${m};\\n// Loop over shared dimension.\\nfor (var t = 0; t < num_tiles; t = t + 1) {\\n  // Load one tile of A into local memory.\\n  for (var innerRow = 0; innerRow < ${h}; innerRow = innerRow + 1) {\\n    for (var innerCol = 0; innerCol < ${f}; innerCol = innerCol + 1) {\\n      let inputRow = tileRowA + innerRow;\\n      let inputCol = tileColA + innerCol;\\n      ${sa(s,r)}\\n    }\\n  }\\n\\n  // Load one tile of B into local memory.\\n  for (var innerRow = 0; innerRow < ${m}; innerRow = innerRow + 1) {\\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n      let inputRow = tileRowB + innerRow;\\n      let inputCol = tileCol + innerCol;\\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\\n        kStart + inputRow,\\n        globalCol + innerCol${r?", batchIndices":""});\\n    }\\n  }\\n  kStart = kStart + tileInner;\\n  workgroupBarrier();\\n\\n  // Compute acc values for a single thread.\\n  var BCached : array<${n}, colPerThread>;\\n  for (var k = 0; k < tileInner; k = k + 1) {\\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\\n    }\\n\\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      ${ia(s)}\\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\\n      }\\n    }\\n  }\\n\\n  workgroupBarrier();\\n}\\n\\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\\n        acc[innerRow][innerCol]);\\n  }\\n}\\n`;return`\\n  var<workgroup> mm_Asub : array<array<${n}, ${c}>, ${p}>;\\n  var<workgroup> mm_Bsub : array<array<${n}, ${d}>, ${i}>;\\n  const rowPerThread = ${e[1]};\\n  const colPerThread = ${e[0]};\\n  const tileInner = ${i};\\n\\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\\n        @builtin(global_invocation_id) globalId : vec3<u32>,\\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\\n    let batch = ${a?"0":"i32(globalId.z)"};\\n    ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}\\n    let num_tiles = ${a?`${Math.ceil(o/i)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\\n    var kStart = ${a?`i32(globalId.z) * ${o}`:"0"};\\n\\n    var acc : array<array<${n}, colPerThread>, rowPerThread>;\\n    ${_}\\n  }\\n`},oa=(e,t,n,r,s=!1)=>{let[i,a,o,l]=r,u=Yn(r[0].type.tensor);return`\\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${i.type.indices}) -> ${Qi(e,u)} {\\n      var value = ${Qi(e,u)}(0.0);\\n      let col = colIn * ${e};\\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\\n      {\\n        var aIndices: ${a.type.indices};\\n        ${Ji("aIndices",a,a.rank-2,i.rank,"batchIndices")}\\n        ${a.indicesSet("aIndices",a.rank-2,"u32(row)")}\\n        ${a.indicesSet("aIndices",a.rank-1,"u32(colIn)")}\\n        value = ${a.getByIndices("aIndices")};\\n      }\\n      return value;\\n    }\\n\\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${i.type.indices}) -> ${Qi(e,u)} {\\n      var value = ${Qi(e,u)}(0.0);\\n      let col = colIn * ${e};\\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\\n      {\\n        var bIndices: ${o.type.indices};\\n        ${Ji("bIndices",o,o.rank-2,i.rank,"batchIndices")}\\n        ${o.indicesSet("bIndices",o.rank-2,"u32(row)")}\\n        ${o.indicesSet("bIndices",o.rank-1,"u32(colIn)")}\\n        value = ${o.getByIndices("bIndices")};\\n      }\\n      return value;\\n    }\\n\\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Qi(e,u)}) {\\n      let col = colIn * ${e};\\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\\n        var value = valueIn;\\n        let coords = vec3<i32>(batch, row, colIn);\\n        ${t?`value = value + ${s?"bias[colIn]":`${Qi(e,u)}(bias[row])`};`:""}\\n        ${n}\\n        ${l.setByIndices("vec3<u32>(coords)","value")}\\n      }\\n    }\\n    `},la=(e,t,n,r,s=!1,i)=>{let a=e[0].dims,o=e[1].dims,l=a.slice(0,-2),u=o.slice(0,-2),d=r?r.slice(0,-2):n.slice(0,-2),c=Wn.size(d),p=a[a.length-2],h=a[a.length-1],f=o[o.length-1],m=h%4==0&&f%4==0,_=p<=8?[4,1,1]:[4,4,1],g=[8,8,1],w=[Math.ceil(f/g[0]/_[0]),Math.ceil(p/g[1]/_[1]),Math.ceil(c/g[2]/_[2])],y=m?4:1,b=[...l,p,h/y],x=b.length,v=[...u,h,f/y],$=v.length,k=[c,p,f/y],E=[{type:6,data:p},{type:6,data:f},{type:6,data:h}];Hi(t,E),E.push(...Jn(d,b,v));let S=["rank","rank"],z=e.length>2;z&&(E.push(...Jn(e[2].dims)),S.push("rank")),E.push(...Jn(k));return{name:"MatMul",shaderCache:{hint:`${_};${t.activation};${m};${s}`,inputDependencies:S},getRunData:()=>({outputs:[{dims:i?i(n):n,dataType:e[0].dataType}],dispatchGroup:{x:w[0],y:w[1],z:w[2]},programUniforms:E}),getShaderSource:n=>{let r=d.length,i=ur("batchDims",e[0].dataType,r,1),a=Yn(e[0].dataType),o=ar("a",e[0].dataType,x,y),l=ar("b",e[1].dataType,$,y),u=or("result",e[0].dataType,k.length,y),c=[o,l];if(z){let t=s?y:1;c.push(ar("bias",e[2].dataType,e[2].dims.length,t))}let p=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];Ki(t,p);let h=Yn(u.type.tensor),f=Gi(t,u.type.value,h),w=oa(y,z,f,[i,o,l,u],s);return`\\n  ${n.registerUniforms(p).registerInternalVariables(i).declareVariables(...c,u)}\\n  ${w}\\n  ${m?ra(_,g,a,i):aa(_,g,a,i)}\\n                   `}}}})),Hd=ut((()=>{vd(),kd(),Ad(),qd(),Vd(),Wd(),Gd(),ua=(e,t,n,r,s=!1,i,a=4,o=4,l=4,u="f32")=>{let d=e?"\\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\\n    ":"\\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\\n    ",c=e?"\\n    let coords = vec4<i32>(\\n      batch,\\n      row / outWidth,\\n      row % outWidth,\\n      col);\\n    ":"\\n    let coords = vec4<i32>(\\n      batch,\\n      row,\\n      col / outWidth,\\n      col % outWidth);\\n    ",p=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",h=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",f=e?"row":"col",m=e?"col":"row",_=`\\n    let inChannels = i32(uniforms.w_shape[2]);\\n    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\\n    let outRow = ${f} / outWidth;\\n    let outCol = ${f} % outWidth;\\n\\n    let WRow = ${m} / (i32(uniforms.w_shape[1]) * inChannels);\\n    let WCol = ${m} / inChannels % i32(uniforms.w_shape[1]);\\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\\n    let xCh = ${m} % inChannels;\\n    var resData = ${Qi(a,u)}(0.0);\\n    // The bounds checking is always needed since we use it to pad zero for\\n    // the \'same\' padding type.\\n    if (xRow >= 0 && xRow < ${p} && xCol >= 0 && xCol < ${h}) {\\n      ${d}\\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\\n      ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${u}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(a)}\\n    }\\n    return resData;`,g=e?t&&r?`\\n    let col = colIn * ${a};\\n    ${_}`:`\\n    let col = colIn * ${a};\\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\\n      ${_}\\n    }\\n    return ${Qi(a,u)}(0.0);`:r&&n?`\\n    let col = colIn * ${a};\\n    ${_}`:`\\n    let col = colIn * ${a};\\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\\n      ${_}\\n    }\\n    return ${Qi(a,u)}(0.0);`,w=`${(e=>{switch(e){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(o)}`,y=Qi(l,u),b=Qi(e?a:o,u),x=Qi(e?o:a,u),v=Gi(i,y,u);return`\\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${b} {\\n      ${e?g:w}\\n    }\\n\\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${x} {\\n      ${e?w:g}\\n    }\\n\\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${y}) {\\n      let col = colIn * ${l};\\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\\n      {\\n      var value = valueIn;\\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\\n      ${c}\\n      ${Yi(s)}\\n      ${v}\\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\\n      }\\n    }`},da=(e,t,n,r,s,i,a,o,l)=>{let u="NHWC"===t.format,d=u?e[0].dims[3]:e[0].dims[1],c=n[0],p=u?n[2]:n[3],h=u?n[1]:n[2],f=u?n[3]:n[1],m=u&&(d%4==0||d%3==0)&&f%4==0,_=u?f:p*h,g=u?p*h:f,w=[8,8,1],y=r<=8?[4,1,1]:[4,4,1],b=[Math.ceil(_/w[0]/y[0]),Math.ceil(g/w[1]/y[1]),Math.ceil(c/w[2]/y[2])];Tn("verbose",(()=>`[conv2d_mm_webgpu] dispatch = ${b}`));let x=m?u&&d%4!=0?3:4:1,v=w[1]*y[1],$=w[0]*y[0],k=Math.max(w[0]*x,w[1]),E=r%v==0,S=s%$==0,z=i%k==0,C=m?[x,4,4]:[1,1,1],T=[{type:6,data:r},{type:6,data:s},{type:6,data:i},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];Hi(t,T),T.push(...Jn(e[0].dims,e[1].dims));let A=["rank","rank"];a&&(T.push(...Jn(e[2].dims)),A.push("rank")),T.push(...Jn(n));return{name:"Conv2DMatMul",shaderCache:{hint:`${t.cacheKey};${x};${m};${E};${S};${z};${v};${$};${k}`,inputDependencies:A},getRunData:()=>({outputs:[{dims:l?l(n):n,dataType:e[0].dataType}],dispatchGroup:{x:b[0],y:b[1],z:b[2]},programUniforms:T}),getShaderSource:r=>{let s=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];Ki(t,s);let i=m?4:1,l=Yn(e[0].dataType),d=`\\n      fn setOutputAtIndex(flatIndex : i32, value : ${m?`vec4<${l}>`:l}) {\\n        result[flatIndex] = ${m?`vec4<${l}>`:l}(value);\\n      }\\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${m?`vec4<${l}>`:l}) {\\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\\n        setOutputAtIndex(flatIndex ${m?"/ 4":""}, value);\\n      }`,c=[ar("x",e[0].dataType,e[0].dims.length,3===x?1:x),ar("w",e[1].dataType,e[1].dims.length,i)],p=or("result",e[0].dataType,n.length,i);if(a){let t=ar("bias",e[2].dataType,e[2].dims.length,i);c.push(t),d+=`\\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${m?`vec4<${l}>`:l} {\\n          return bias[coords.${u?"w":"y"}${m?"/ 4":""}];\\n        }`}return`\\n        ${Zi("uniforms.result_strides")}\\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\\n        ${r.registerUniforms(s).declareVariables(...c,p)}\\n        ${d}\\n        ${ua(u,E,S,z,a,t,C[0],C[1],C[2],l)}\\n        ${m?ra(y,w,l,void 0,!u,k):aa(y,w,l,void 0,!u,k,!1,void 0,o)}`}}}})),Kd=ut((()=>{vd(),kd(),Td(),Ad(),qd(),Vd(),ca=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t},pa=e=>"number"==typeof e?[e,e,e]:e,ha=(e,t)=>t<=1?e:e+(e-1)*(t-1),fa=(e,t,n,r=1)=>{let s=ha(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)},ma=(e,t,n,r,s)=>{null==s&&(s=fa(e,t[0],r[0]));let i=[0,0,0,n];for(let n=0;n<3;n++)e[n]+2*s>=t[n]&&(i[n]=Math.trunc((e[n]-t[n]+2*s)/r[n]+1));return i},_a=(e,t,n,r,s,i,a,o,l,u)=>{let d,c,p,h;if("VALID"===e&&(e=0),"number"==typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e};let f=ma([t,n,r,1],[o,l,u],1,[s,i,a],e);c=f[0],p=f[1],h=f[2]}else if(Array.isArray(e)){if(!e.every(((e,t,n)=>e===n[0])))throw Error(`Unsupported padding parameter: ${e}`);d={top:e[0],bottom:e[1],left:e[2],right:e[3],front:e[4],back:e[5]};let f=ma([t,n,r,1],[o,l,u],1,[s,i,a],e[0]);c=f[0],p=f[1],h=f[2]}else{if("SAME_UPPER"!==e)throw Error(`Unknown padding parameter: ${e}`);{c=Math.ceil(t/s),p=Math.ceil(n/i),h=Math.ceil(r/a);let e=(c-1)*s+o-t,f=(p-1)*i+l-n,m=(h-1)*a+u-r,_=Math.floor(e/2),g=e-_,w=Math.floor(f/2),y=f-w,b=Math.floor(m/2);d={top:w,bottom:y,left:b,right:m-b,front:_,back:g}}}return{padInfo:d,outDepth:c,outHeight:p,outWidth:h}},ga=(e,t,n,r,s,i=!1,a="channelsLast")=>{let o,l,u,d,c;if("channelsLast"===a)[o,l,u,d,c]=e;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[o,c,l,u,d]=e}let[p,,h,f,m]=t,[_,g,w]=pa(n),[y,b,x]=pa(r),v=ha(h,y),$=ha(f,b),k=ha(m,x),{padInfo:E,outDepth:S,outHeight:z,outWidth:C}=_a(s,l,u,d,_,g,w,v,$,k),T=i?p*c:p,A=[0,0,0,0,0];return"channelsFirst"===a?A=[o,T,S,z,C]:"channelsLast"===a&&(A=[o,S,z,C,T]),{batchSize:o,dataFormat:a,inDepth:l,inHeight:u,inWidth:d,inChannels:c,outDepth:S,outHeight:z,outWidth:C,outChannels:T,padInfo:E,strideDepth:_,strideHeight:g,strideWidth:w,filterDepth:h,filterHeight:f,filterWidth:m,effectiveFilterDepth:v,effectiveFilterHeight:$,effectiveFilterWidth:k,dilationDepth:y,dilationHeight:b,dilationWidth:x,inShape:e,outShape:A,filterShape:t}},wa=(e,t,n,r,s,i)=>{let a="channelsLast"===i,o=(a?e[0].dims[3]:e[0].dims[1],{x:n.map(((e,t)=>t))}),l=[Math.ceil(ca(o.x.map((e=>n[e])))/64),1,1];Tn("verbose",(()=>`[conv3d_naive_webgpu] dispatch = ${l}`));let u=[{type:12,data:Wn.size(n)},{type:12,data:r},{type:12,data:s},{type:12,data:t.strides},{type:12,data:t.dilations}];Hi(t,u),u.push(...Jn(e[0].dims,e[1].dims));let d=["rank","rank"],c=3===e.length;c&&(u.push(...Jn(e[2].dims)),d.push("rank")),u.push(...Jn(n));return{name:"Conv3DNaive",shaderCache:{hint:`${t.cacheKey};${a};1;${c}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:l[0],y:l[1],z:l[2]},programUniforms:u}),getShaderSource:i=>{let o=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:r.length},{name:"pads",type:"u32",length:s.length},{name:"strides",type:"u32",length:t.strides.length},{name:"dilations",type:"u32",length:t.dilations.length}];Ki(t,o);let l=Yn(e[0].dataType),u=ar("x",e[0].dataType,e[0].dims.length,1),d=ar("W",e[1].dataType,e[1].dims.length,1),p=[u,d],h=or("result",e[0].dataType,n.length,1),f="";if(c){let t=ar("bias",e[2].dataType,e[2].dims.length,1);p.push(t),f+=`\\n        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${l} {\\n          return bias[${sr("coords",a?4:1,5)}];\\n        }`}let m=Qi(1,l),_=Gi(t,m,l);return`\\n            ${f}\\n            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\\n              return ${u.getByIndices("aIndices")};\\n            }\\n            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\\n              return ${d.getByIndices("aIndices")};\\n            }\\n          ${i.registerUniforms(o).declareVariables(...p,h)}\\n          ${i.mainStart()}\\n          ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n              let coords = ${h.offsetToIndices("global_idx")};\\n              let batch = ${sr("coords",0,u.rank)};\\n              let d2 = ${sr("coords",a?u.rank-1:1,u.rank)};\\n              let xFRCCorner = vec3<u32>(${sr("coords",a?1:2,u.rank)},\\n              ${sr("coords",a?2:3,u.rank)},\\n              ${sr("coords",a?3:4,u.rank)}) * uniforms.strides - uniforms.pads;\\n              let xFCorner = xFRCCorner.x;\\n              let xRCorner = xFRCCorner.y;\\n              let xCCorner = xFRCCorner.z;\\n              let xShapeY = ${sr("uniforms.x_shape",a?1:2,u.rank)};\\n              let xShapeZ = ${sr("uniforms.x_shape",a?2:3,u.rank)};\\n              let xShapeW = ${sr("uniforms.x_shape",a?3:4,u.rank)};\\n              let xShapeU = ${sr("uniforms.x_shape",a?4:1,u.rank)};\\n              let inputDepthNearestVec4 = (xShapeU / 4) * 4;\\n              let inputDepthVec4Remainder = xShapeU % 4;\\n\\n              var value = 0.0;\\n              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {\\n                let xF = xFCorner + wF * uniforms.dilations[0];\\n                if (xF < 0 || xF >= xShapeY) {\\n                  continue;\\n                }\\n\\n                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {\\n                  let xR = xRCorner + wR * uniforms.dilations[1];\\n                  if (xR < 0 || xR >= xShapeZ) {\\n                    continue;\\n                  }\\n\\n                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {\\n                    let xC = xCCorner + wC * uniforms.dilations[2];\\n                    if (xC < 0 || xC >= xShapeW) {\\n                      continue;\\n                    }\\n\\n                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {\\n                      ${a?"let xValues = vec4<f32>(\\n                               getX(batch, xF, xR, xC, d1),\\n                               getX(batch, xF, xR, xC, d1 + 1),\\n                               getX(batch, xF, xR, xC, d1 + 2),\\n                               getX(batch, xF, xR, xC, d1 + 3));\\n                            ":"let xValues = vec4<f32>(\\n                               getX(batch, d1, xF, xR, xC),\\n                               getX(batch, d1 + 1, xF, xR, xC),\\n                               getX(batch, d1 + 2, xF, xR, xC),\\n                               getX(batch, d1 + 3, xF, xR, xC));\\n                            "}\\n                            let wValues = vec4<f32>(\\n                              getW(d2, d1, wF, wR, wC),\\n                              getW(d2, d1 + 1, wF, wR, wC),\\n                              getW(d2, d1 + 2, wF, wR, wC),\\n                              getW(d2, d1 + 3, wF, wR, wC));\\n                      value += dot(xValues, wValues);\\n                    }\\n                    if (inputDepthVec4Remainder == 1) {\\n                        ${a?"value += getX(batch, xF, xR, xC, inputDepthNearestVec4)\\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);":"value += getX(batch, inputDepthNearestVec4, xF, xR, xC)\\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);"}\\n                    } else if (inputDepthVec4Remainder == 2) {\\n                      ${a?"let xValues = vec2<f32>(\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));\\n                      ":"let xValues = vec2<f32>(\\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));\\n                    "}\\n                    let wValues = vec2<f32>(\\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));\\n                      value += dot(xValues, wValues);\\n                    } else if (inputDepthVec4Remainder == 3) {\\n                      ${a?"let xValues = vec3<f32>(\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));\\n                      ":"let xValues = vec3<f32>(\\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),\\n                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));\\n                    "}\\n                    let wValues = vec3<f32>(\\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),\\n                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));\\n                      value += dot(xValues, wValues);\\n                    }\\n                  }\\n                }\\n              }\\n              ${c?"value = value + getBiasByOutputCoords(coords)":""};\\n              ${_}\\n              result[global_idx] = f32(value);\\n          }`}}}})),Xd=ut((()=>{vd(),Td(),Ad(),qd(),ya=(e,t,n,r)=>{let s=e.length>2,i=s?"value += b[output_channel];":"",a=e[0].dims,o=e[1].dims,l="NHWC"===t.format,u=l?n[3]:n[1],d=u/t.group,c=l&&d>=4?er(u):1,p=Wn.size(n)/c,h=[{type:12,data:p},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:d}];Hi(t,h),h.push(...Jn(a,[o[0],o[1],o[2],o[3]/c]));let f=s?["rank","rank","rank"]:["rank","rank"];h.push(...Jn([n[0],n[1],n[2],n[3]/c]));return{name:"GroupedConv",shaderCache:{hint:`${t.cacheKey}_${c}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:r?r(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:h}),getShaderSource:r=>{let u=or("output",e[0].dataType,n.length,c),d=Yn(u.type.tensor),p=Gi(t,u.type.value,d),h=ar("x",e[0].dataType,a.length),f=ar("w",e[1].dataType,o.length,c),m=[h,f];s&&m.push(ar("b",e[2].dataType,e[2].dims,c));let _=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:t.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];Ki(t,_);let g=l?`\\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {\\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\\n\\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {\\n          continue;\\n        }\\n\\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {\\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {\\n            continue;\\n          }\\n\\n          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {\\n            let input_channel = in_channel_offset + wInChannel;\\n            let xVal = ${h.get("batch","xHeight","xWidth","input_channel")};\\n            let wVal = ${f.get("wHeight","wWidth","wInChannel","output_channel")};\\n            value += xVal * wVal;\\n          }\\n        }\\n      }\\n      `:`\\n      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\\n        let input_channel = in_channel_offset + wInChannel;\\n        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\\n          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\\n\\n          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {\\n            continue;\\n          }\\n\\n          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\\n            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\\n            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {\\n              continue;\\n            }\\n\\n            let xVal = ${h.get("batch","input_channel","xHeight","xWidth")};\\n            let wVal = ${f.get("output_channel","wInChannel","wHeight","wWidth")};\\n            value += xVal * wVal;\\n          }\\n        }\\n      }\\n      `;return`\\n  ${r.registerUniforms(_).declareVariables(...m,u)}\\n\\n  ${r.mainStart()}\\n    ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n\\n    let outputIndices = ${u.offsetToIndices("global_idx")};\\n    let batch: u32 = outputIndices[0];\\n    let output_channel: u32 = outputIndices[${l?3:1}];\\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${l?1:2}], outputIndices[${l?2:3}]) * uniforms.strides - uniforms.pads;\\n    let group_id: u32 = output_channel * ${c} / uniforms.output_channels_per_group;\\n    var in_channel_offset = group_id * uniforms.w_shape[${l?2:1}];\\n\\n    var value: ${u.type.value} = ${u.type.value}(0);\\n    ${g}\\n    ${i}\\n    ${p}\\n    ${u.setByOffset("global_idx","value")}\\n  }`}}},ba=(e,t,n,r)=>{let s=e.length>2,i=er(n[3]),a=er(n[2]),o=Wn.size(n)/i/a,l=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/i],u=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/i],d=[n[0],n[1],n[2],n[3]/i],c=[{type:12,data:o},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];Hi(t,c),c.push(...Jn(l,u,d));let p=(a-1)*t.strides[1]+u[1];return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${t.cacheKey};${i};${a};${p};${u[0]};${u[1]}`,inputDependencies:s?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:r?r(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:c}),getShaderSource:n=>{let r=or("output",e[0].dataType,d.length,i),o=Yn(r.type.tensor),c=Gi(t,r.type.value,o),h=ar("x",e[0].dataType,l.length,i),f=ar("w",e[1].dataType,u.length,i),m=[h,f];s&&m.push(ar("b",e[2].dataType,e[2].dims,i));let _=s?"value += b[output_channel];":"",g=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return Ki(t,g),`\\n  ${n.registerUniforms(g).declareVariables(...m,r)}\\n  ${n.mainStart()}\\n    ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n    let width0 = uniforms.output_shape[3];\\n    let output_channel = global_idx % width0;\\n    var index1 = global_idx / width0;\\n    let width1 = uniforms.output_shape[2] / ${a}u;\\n    let col = (index1 % width1) * ${a}u;\\n    index1 = index1 / width1;\\n    let row = index1 % uniforms.output_shape[1];\\n    let batch = index1 / uniforms.output_shape[1];\\n\\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\\n\\n    var x_vals: array<${h.type.value}, ${p}>;\\n    var values: array<${r.type.value}, ${a}>;\\n    let input_channel = output_channel;\\n    // Use constant instead of uniform can give better performance for w\'s height/width.\\n    for (var w_height: u32 = 0u; w_height < ${u[0]}; w_height++) {\\n      let x_height = x_corner.x + i32(w_height);\\n      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {\\n        for (var i = 0; i < ${p}; i++) {\\n          let x_width = x_corner.y + i;\\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\\n            x_vals[i] = ${h.get("batch","u32(x_height)","u32(x_width)","input_channel")};\\n          } else {\\n            x_vals[i] = ${h.type.value}(0);\\n          }\\n        }\\n        for (var w_width: u32 = 0u; w_width < ${u[1]}; w_width++) {\\n          let w_val = ${f.get("w_height","w_width","0","output_channel")};\\n          for (var i = 0u; i < ${a}u; i++) {\\n            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);\\n          }\\n        }\\n      }\\n    }\\n\\n    for (var i = 0u; i < ${a}u; i++) {\\n      var value = values[i];\\n      ${_}\\n      ${c}\\n      ${r.set("batch","row","col + i","output_channel","value")};\\n    }\\n  }`}}}})),Qd=ut((()=>{Td(),Hd(),Kd(),Gd(),Xd(),qd(),jd(),Id(),xa=(e,t,n,r,s,i)=>{let a=e[0],o=e.slice(i?1:2,i?3:4),l=o.length,u=t[0],d=t.slice(2).map(((e,t)=>e+(e-1)*(n[t]-1))),c=o.map(((e,t)=>e+r[t]+r[t+l])).map(((e,t)=>Math.floor((e-d[t]+s[t])/s[t])));return c.splice(0,0,a),c.splice(i?3:1,0,u),c},va=[2,3,1,0],$a=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length>5)throw new Error("greater than 5D is not supported");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[1]*t.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===e.length&&(1!==e[2].dims.length||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},ka=(e,t)=>{let n=e.kernelShape.slice();n.length<t[1].dims.length-2&&n.push(...Array(t[1].dims.length-2-n.length).fill(0));for(let e=2;e<t[1].dims.length;++e)0===n[e-2]&&(n[e-2]=t[1].dims[e]);let r=e.pads.slice();jn.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,r,"NHWC"===e.format,e.autoPad);let s=Object.assign({},e);return Object.assign(s,{kernelShape:n,pads:r}),s},Ea=e=>{let t=Xi(e),n=e.format;return{autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],format:n,dilations:e.dilations,group:e.group,kernelShape:e.kernel_shape,pads:e.pads,strides:e.strides,wIsConst:e.w_is_const(),...t,cacheKey:`${e.format};${t.activation};`}},Sa=(e,t,n,r)=>{let s="NHWC"===n.format,i=xa(t[0].dims,t[1].dims,n.dilations,n.pads,n.strides,s);if(1!==n.group){let a=[t[0]];if(s){let r=e.kernelCustomData.wT??e.compute(wr(t[1],va),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=r),a.push(r)}else a.push(t[1]);return 3===t.length&&a.push(t[2]),void(!e.adapterInfo.isArchitecture("ampere")&&s&&t[1].dims[0]===n.group&&1===t[1].dims[1]&&1===n.dilations[0]&&1===n.dilations[1]?e.compute(ba(a,n,i,r),{inputs:a}):e.compute(ya(a,n,i,r),{inputs:a}))}let a=3===t.length,o=t[0].dims[s?1:2],l=t[0].dims[s?2:3],u=t[0].dims[s?3:1],d=t[1].dims[2],c=t[1].dims[3],p=i[s?1:2],h=i[s?2:3],f=i[s?3:1],m=s&&d===o&&c===l&&0===n.pads[0]&&0===n.pads[1];if(m||1===d&&1===c&&1===n.dilations[0]&&1===n.dilations[1]&&1===n.strides[0]&&1===n.strides[1]&&0===n.pads[0]&&0===n.pads[1]){let d,c,_,g=i[0],w=[];if(s){let r=e.kernelCustomData.wT??e.compute(wr(t[1],va),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=r),m){let e=o*l*u;d=t[0].reshape([1,g,e]),c=r.reshape([1,e,f]),_=[1,g,f]}else d=t[0].reshape([g,o*l,u]),c=r.reshape([1,u,f]),_=[g,p*h,f];w.push(d),w.push(c)}else d=t[0].reshape([g,u,o*l]),c=t[1].reshape([1,f,u]),_=[g,f,p*h],w.push(c),w.push(d);a&&w.push(t[2]);let y=_[2],b=w[0].dims[w[0].dims.length-1];return void(y<8&&b<8?e.compute(ea(w,n,i,_,s,r),{inputs:w}):e.compute(la(w,n,i,_,s,r),{inputs:w}))}let _=e.kernelCustomData.wT??e.compute(wr(t[1],va),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=_);let g=[t[0],_];a&&g.push(t[2]);let w=s?p*h:f,y=s?f:p*h,b=d*c*u;e.compute(da(g,n,i,w,y,b,a,!0,r),{inputs:g})},za=(e,t)=>{let n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&r.push(e.inputs[2]);let s=[0,t.pads[0],0,t.pads[1]],i=[1].concat(t.strides),a=[1].concat(t.dilations),o=[1].concat(t.kernelShape),l=ka({...t,pads:s,strides:i,dilations:a,kernelShape:o},r);Sa(e,r,l,(e=>n?[e[0],e[2],e[3]]:[e[0],e[1],e[3]]))},Ca=(e,t,n)=>{let r="NHWC"===n.format?"channelsLast":"channelsFirst",s=ka(n,t),i="NOTSET"===n.autoPad?n.pads:n.autoPad,a=ga(t[0].dims,t[1].dims,n.strides,n.dilations,i,!1,r);e.compute(wa(t,s,a.outShape,[a.filterDepth,a.filterHeight,a.filterWidth],[a.padInfo.front,a.padInfo.top,a.padInfo.left],r))},Ta=(e,t)=>{if($a(e.inputs,t),3===e.inputs[0].dims.length)za(e,t);else if(5===e.inputs[0].dims.length)Ca(e,e.inputs,t);else{let n=ka(t,e.inputs);Sa(e,e.inputs,n)}}})),Yd=ut((()=>{vd(),kd(),Td(),Ad(),Aa=(e,t,n)=>{let r=e.length>2,s=t.outputShape,i="NHWC"===t.format,a=t.group,o=e[1].dims,l=o[2]/a,u=o[3],d=i?er(u):1,c=Wn.size(s)/d,p=[Math.ceil(c/64),1,1];Tn("verbose",(()=>`[conv2d_backprop_webgpu] dispatch = ${p}`));let h=["rank","rank"],f=[t.strides[0],t.strides[1]],m=[t.kernelShape[i?1:2],t.kernelShape[i?2:3]],_=[t.dilations[0],t.dilations[1]],g=[m[0]+(t.dilations[0]<=1?0:(t.kernelShape[i?1:2]-1)*(t.dilations[0]-1)),m[1]+(t.dilations[1]<=1?0:(t.kernelShape[i?2:3]-1)*(t.dilations[1]-1))],w=[g[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),g[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],y=[{type:12,data:c},{type:12,data:f},{type:12,data:m},{type:12,data:_},{type:12,data:g},{type:6,data:w},{type:12,data:l},{type:12,data:u},...Jn(e[0].dims,e[1].dims)];r&&(y.push(...Jn(e[2].dims)),h.push("rank")),y.push(...Jn(s));return{name:"ConvTranspose2D",shaderCache:{hint:`${t.cacheKey};${d}`,inputDependencies:h},getRunData:()=>({dispatchGroup:{x:p[0],y:p[1],z:p[2]},outputs:[{dims:n?n(s):s,dataType:e[0].dataType}],programUniforms:y}),getShaderSource:t=>{let n=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:f.length},{name:"filter_dims",type:"u32",length:m.length},{name:"dilations",type:"u32",length:m.length},{name:"effective_filter_dims",type:"u32",length:g.length},{name:"pads",type:"i32",length:w.length},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],a=Yn(e[0].dataType),o=i?1:2,l=i?2:3,u=i?3:1,c=ar("W",e[1].dataType,e[1].dims.length,d),p=ar("Dy",e[0].dataType,e[0].dims.length),h=[p,c];r&&h.push(ar("bias",e[2].dataType,[s[u]].length,d));let _=or("result",e[0].dataType,s.length,d),y=`\\n            let outputIndices = ${_.offsetToIndices(`global_idx * ${d}`)};\\n            let batch = ${_.indicesGet("outputIndices",0)};\\n            let d1 = ${_.indicesGet("outputIndices",u)};\\n            let r = ${_.indicesGet("outputIndices",o)};\\n            let c = ${_.indicesGet("outputIndices",l)};\\n            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\\n            let dyRCorner = dyCorner.x;\\n            let dyCCorner = dyCorner.y;\\n            let groupId = d1 / uniforms.output_channels_per_group;\\n            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\\n            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\\n            // ? = to be determined. : = across all values in that axis.\\n            var dotProd = ${_.type.value}(0.0);\\n            for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\\n              if (wR % uniforms.dilations.x != 0) {\\n                continue;\\n              }\\n              let dyR = (${a}(dyRCorner) + ${a}(wR)) / ${a}(uniforms.strides[0]);\\n              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\\n              if (dyR < 0.0 || dyR >= ${a}(uniforms.Dy_shape[${o}]) || fract(dyR) > 0.0 ||\\n                  wRPerm < 0) {\\n                continue;\\n              }\\n              let idyR: u32 = u32(dyR);\\n\\n              for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\\n                if (wC % uniforms.dilations.y != 0) {\\n                  continue;\\n                }\\n                let dyC = (${a}(dyCCorner) + ${a}(wC)) / ${a}(uniforms.strides.y);\\n                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\\n                if (dyC < 0.0 || dyC >= ${a}(uniforms.Dy_shape[${l}]) ||\\n                    fract(dyC) > 0.0 || wCPerm < 0) {\\n                  continue;\\n                }\\n                let idyC: u32 = u32(dyC);\\n                var inputChannel = groupId * uniforms.input_channels_per_group;\\n                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {\\n                  let xValue = ${i?p.get("batch","idyR","idyC","inputChannel"):p.get("batch","inputChannel","idyR","idyC")};\\n                  let w_offset = ${c.indicesToOffset(`${c.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};\\n                  let wValue = ${c.getByOffset(`w_offset / ${d}`)};\\n                  dotProd = dotProd + xValue * wValue;\\n                  inputChannel = inputChannel + 1;\\n                }\\n              }\\n            }\\n            let value = dotProd${r?` + bias[d1 / ${d}]`:""};\\n            ${_.setByOffset("global_idx","value")};\\n          `;return`\\n    ${t.registerUniforms(n).declareVariables(...h,_)}\\n      ${t.mainStart()}\\n      ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};\\n    ${y}}`}}}})),Zd=ut((()=>{Yd(),qd(),Id(),Ia=(e,t,n,r,s,i)=>(e-1)*t+n+(r-1)*s+1-i,Ma=(e,t,n,r,s)=>{let i=Math.floor(e/2);"SAME_UPPER"===t?(n[r]=i,n[s]=e-i):"SAME_LOWER"===t&&(n[r]=e-i,n[s]=i)},Oa=(e,t,n,r,s,i,a,o,l,u)=>{let d=e.length-2,c=0===u.length;l.length<d&&l.push(...Array(d-l.length).fill(0));let p=e[0],h=t[o?3:1]*s;for(let s=0,p=e.length-d-(o?1:0);s<d;++s,++p){let o=e[p],h=c?o*a[s]:u[s],f=Ia(o,a[s],i[s],t[p],n[s],h);Ma(f,r,i,s,s+d),c&&u.push(a[s]*(o-1)+l[s]+(t[p]-1)*n[s]+1-i[s]-i[s+d])}u.splice(0,0,p),u.splice(o?3:1,0,h)},Ba=(e,t)=>{let n=e.kernelShape.slice();if(0===e.kernelShape.length||0===e.kernelShape.reduce(((e,t)=>e*t),1)){n.length=0;for(let e=2;e<t[1].dims.length;++e)n.push(t[1].dims[e])}let r="NHWC"===e.format;n.splice(0,0,t[1].dims[0]),n.splice(r?3:1,0,t[1].dims[1]);let s=e.pads.slice(),i=e.outputShape.slice(),a=e.outputPadding.slice(),o=t[0].dims,l=e.dilations.slice();if(0===l.reduce(((e,t)=>e+t),0)){let e=t[0].dims.length-2;l=new Array(e).fill(1)}let u=e.strides.slice();if(0===u.reduce(((e,t)=>e+t),0)){let e=t[0].dims.length-2;u=new Array(e).fill(1)}Oa(o,n,l,e.autoPad,e.group,s,u,r,a,i);let d=Object.assign({},e);return Object.assign(d,{kernelShape:n,pads:s,outputPadding:a,outputShape:i,dilations:l,strides:u}),d},Na=e=>{let t=Xi(e),n=e.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],s=e.dilations,i=e.group,a=e.kernelShape,o=e.pads,l=e.strides,u=e.wIsConst();return{autoPad:r,format:n,dilations:s,group:i,kernelShape:a,outputPadding:e.outputPadding,outputShape:e.outputShape,pads:o,strides:l,wIsConst:u,...t,cacheKey:`${e.format};${t.activation};`}},Pa=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(3===e.length&&(1!==e[2].dims.length||e[2].dims[0]!==n))throw new Error("invalid bias");let r=e[0].dims.length-2;if(t.dilations.reduce(((e,t)=>e+t),0)>0&&t.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(t.strides.reduce(((e,t)=>e+t),0)>0&&t.strides.length!==r)throw new Error(`strides should be ${r}D`);if(t.pads.reduce(((e,t)=>e+t),0)>0&&t.pads.length!==2*r)throw new Error(`pads should be ${2*r}D`);if(t.outputPadding.length!==r&&0!==t.outputPadding.length)throw new Error(`output_padding should be ${r}D`);if(t.kernelShape.reduce(((e,t)=>e+t),0)>0&&0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==t.outputShape.length&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},Ra=(e,t,n,r)=>{let s=e.kernelCustomData.wT??e.compute(wr(t[1],[2,3,0,1]),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=s);let i=[t[0],s];3===t.length&&i.push(t[2]),e.compute(Aa(i,n,r),{inputs:i})},Da=(e,t)=>{let n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&r.push(e.inputs[2]);let s=t.kernelShape;(0===s.length||0===s[0])&&(s=[e.inputs[1].dims[2]]);let i=t.dilations;(0===i.length||0===i[0])&&(i=[1]);let a=t.strides;(0===a.length||0===a[0])&&(a=[1]);let o=t.pads;0===o.length&&(o=[0,0]),o=[0,o[0],0,o[1]],a=[1].concat(a),i=[1].concat(i),s=[1].concat(s);let l=Ba({...t,pads:o,strides:a,dilations:i,kernelShape:s},r);Ra(e,r,l,(e=>n?[e[0],e[2],e[3]]:[e[0],e[1],e[3]]))},La=(e,t)=>{if(Pa(e.inputs,t),3===e.inputs[0].dims.length)Da(e,t);else{let n=Ba(t,e.inputs);Ra(e,e.inputs,n)}}})),Jd=ut((()=>{vd(),Td(),Cd(),Ad(),Fa=(e,t,n,r)=>{let s=Wn.size(t),i=t.length,a=ar("input",e,i),o=or("output",e,i),l=6===n.dataType?n.getInt32Array()[0]:Number(n.getBigInt64Array()[0]),u=Wn.normalizeAxis(l,i);return{name:"CumSum",shaderCache:{hint:r.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:[{type:12,data:s},{type:12,data:u},...Jn(t,t)]}),getShaderSource:e=>{let t=` i32(${a.indicesGet("inputIndices","uniforms.axis")}) `,n=sr("uniforms.input_shape","uniforms.axis",i),s=r.reverse?t+(r.exclusive?" + 1":""):"0",l=r.reverse?n:t+(r.exclusive?"":" + 1");return`\\n                ${e.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(a,o)}\\n                ${e.mainStart()}\\n                  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n                  var inputIndices = ${o.offsetToIndices("global_idx")};\\n                  var sum = ${o.type.value}(0);\\n                  let first : i32 = ${s};\\n                  let last : i32 = ${l};\\n                  for (var i : i32 = first; i < last; i++) {\\n                    ${a.indicesSet("inputIndices","uniforms.axis","u32(i)")};\\n                    sum = sum + ${a.getByIndices("inputIndices")};\\n                  }\\n                  ${o.setByOffset("global_idx","sum")};\\n                }`}}},Ua=(e,t)=>{let n=e.inputs[0].dims,r=e.inputs[0].dataType,s=e.inputs[1];e.compute(Fa(r,n,s,t),{inputs:[0]})},qa=e=>{let t=1===e.exclusive,n=1===e.reverse;return Un({exclusive:t,reverse:n})}})),ec=ut((()=>{vd(),Td(),Cd(),Ad(),Va=e=>{if(!e||1!==e.length)throw new Error("DepthToSpace requires 1 input.");if(4!==e[0].dims.length)throw new Error("DepthToSpace requires 4D input.")},Wa=(e,t,n,r)=>{let s=[];s.push(`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {\\n    var a: ${n.type.indices};`);for(let r=0;r<t;++r)s.push(n.indicesSet("a",e[r],`i[${r}]`));return s.push("return a;}"),s.join("\\n")},ja=(e,t)=>{let n,r,s,i,a,o,l="NHWC"===t.format,u=t.blocksize,d="DCR"===t.mode;l?([n,r,s,i]=e.dims,a=d?[n,r,s,u,u,i/u**2]:[n,r,s,i/u**2,u,u],o=d?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([n,r,s,i]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],a=d?[n,u,u,i/u**2,r,s]:[n,i/u**2,u,u,r,s],o=d?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let c=e.reshape(a),p=c.dims.length,h=e.dataType,f=ar("a",h,p),m=or("output",h,p);return{name:"DepthToSpace",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:["rank"]},getRunData:e=>{let t=l?[n,r*u,s*u,i/u**2]:[n,i/u**2,r*u,s*u],a=Wn.size(t),d=c.dims,p=Wn.sortBasedOnPerm(d,o);return{outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:[{type:12,data:a},...Jn(d,p)]}},getShaderSource:e=>`\\n  ${e.registerUniform("output_size","u32").declareVariables(f,m)}\\n\\n  ${Wa(o,p,f,m)}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n\\n    let indices = ${m.offsetToIndices("global_idx")};\\n    let aIndices = perm(indices);\\n\\n    ${m.setByOffset("global_idx",f.getByIndices("aIndices"))}\\n  }`}},Ga=(e,t)=>{Va(e.inputs),e.compute(ja(e.inputs[0],t))},Ha=e=>Un({blocksize:e.blocksize,mode:e.mode,format:e.format})})),tc=ut((()=>{vd(),Td(),Cd(),Ad(),Qa="^"+(Xa="("+(Ka="[a-zA-Z]|\\\\.\\\\.\\\\.")+")+")+"$",Ya="^"+("("+Xa+",)*"+Xa)+"$",Za=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,t){let n=this.symbolToIndices.get(e);void 0===n?n=[t]:n.push(t),this.symbolToIndices.set(e,n)}},Ja=class{constructor(e,t){this.equation=t,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,r]=t.includes("->")?t.split("->",2):[t,""];if(!n.match(RegExp(Ya)))throw new Error("Invalid LHS term");if(n.split(",").forEach(((t,n)=>{let r=e[n].dims.slice();if(!t.match(RegExp(Qa)))throw new Error("Invalid LHS term");let s=this.processTerm(t,!0,r,n);this.lhs.push(s)})),""===r)r+=[...this.symbolToInfo.entries()].filter((([e,t])=>1===t.count||"..."===e)).map((([e])=>e)).join("");else if(!r.match(RegExp(Xa)))throw new Error("Invalid RHS");r.match(RegExp(Ka,"g"))?.forEach((e=>{if("..."===e)this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let t=this.symbolToInfo.get(e);if(void 0===t)throw new Error("Invalid RHS symbol");this.outputDims.push(t.dimValue)}})),this.rhs=this.processTerm(r,!1,this.outputDims)}addSymbol(e,t,n){let r=this.symbolToInfo.get(e);if(void 0!==r){if(r.dimValue!==t&&1!==r.count)throw new Error("Dimension mismatch");r.count++,r.inputIndices.push(n)}else r={count:1,dimValue:t,inputIndices:[n]};this.symbolToInfo.set(e,r)}processTerm(e,t,n,r=-1){let s=n.length,i=!1,a=[],o=0;if(!e.match(RegExp(Qa))&&!t&&""!==e)throw new Error("Invalid LHS term");let l=e.match(RegExp(Ka,"g")),u=new Za(r);return l?.forEach(((e,d)=>{if("..."===e){if(i)throw new Error("Only one ellipsis is allowed per input term");i=!0;let e=s-l.length+1;if(e<0)throw new Error("Ellipsis out of bounds");if(a=n.slice(o,o+e),this.hasEllipsis){if(this.ellipsisDims.length!==a.length||this.ellipsisDims.toString()!==a.toString())throw new Error("Ellipsis dimensions mismatch")}else{if(!t)throw new Error("Ellipsis must be specified in the LHS");this.hasEllipsis=!0,this.ellipsisDims=a}for(let e=0;e<a.length;e++){let t=String.fromCharCode("0".charCodeAt(0)+e);u.addSymbol(t,d+e),this.addSymbol(t,n[o++],r)}}else u.addSymbol(e,d+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(e,n[o++],r)})),u}},eo=e=>e+"_max",to=(e,t,n,r)=>{let s=e.map((e=>e.length)).map(((e,n)=>ar(`input${n}`,t,e))),i=Wn.size(r),a=or("output",t,r.length),o=[...n.symbolToInfo.keys()].filter((e=>!n.rhs.symbolToIndices.has(e)));return{name:"Einsum",shaderCache:{hint:n.equation,inputDependencies:e.map((()=>"rank"))},getRunData:()=>{let s=o.filter((e=>n.symbolToInfo.has(e))).map((e=>({type:12,data:n.symbolToInfo.get(e)?.dimValue||0})));s.push({type:12,data:i});let a=e.map(((e,t)=>[...Jn(e)])).reduce(((e,t)=>e.concat(t)),s);return a.push(...Jn(r)),{outputs:[{dims:r,dataType:t}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:a}},getShaderSource:e=>{let t=[],r=[],i=[],l=[],u=[],d=n.symbolToInfo.size===n.rhs.symbolToIndices.size;n.symbolToInfo.forEach(((e,o)=>{if(n.rhs.symbolToIndices.has(o)){let r=n.rhs.symbolToIndices.get(o)?.[0];void 0!==r&&n.lhs.forEach(((n,i)=>{if(e.inputIndices.includes(i)){let e=n.symbolToIndices.get(o);if(void 0===e)throw new Error("Invalid symbol error");e.forEach((e=>{t.push(`${s[i].indicesSet(`input${i}Indices`,e,a.indicesGet("outputIndices",r))}`)}))}}))}else n.lhs.forEach(((t,n)=>{if(e.inputIndices.includes(n)){let e=t.symbolToIndices.get(o);if(void 0===e)throw new Error("Invalid symbol error");e.forEach((e=>{r.push(`${s[n].indicesSet(`input${n}Indices`,e,`${o}`)}`)})),u.push(`prod *= ${s[n].getByIndices(`input${n}Indices`)};`)}})),i.push(`for(var ${o}: u32 = 0; ${o} < uniforms.${eo(o)}; ${o}++) {`),l.push("}")}));let c=d?[...t,`let sum = ${s.map(((e,t)=>e.getByIndices(`input${t}Indices`))).join(" * ")};`]:[...t,"var sum = 0.0;",...i,...r,"var prod = 1.0;",...u,"sum += prod;",...l];return`\\n            ${e.registerUniforms(o.map((e=>({name:`${eo(e)}`,type:"u32"})))).registerUniform("outputSize","u32").declareVariables(...s,a)}\\n\\n            ${e.mainStart()}\\n            ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n            var outputIndices = ${a.offsetToIndices("global_idx")};\\n            ${s.map(((e,t)=>`var input${t}Indices: ${s[t].type.indices};`)).join("\\n")}\\n            ${c.join("\\n")};\\n            ${a.setByOffset("global_idx","sum")};\\n          }`}}},no=(e,t)=>{let n=new Ja(e.inputs,t.equation),r=n.outputDims,s=e.inputs.map(((e,t)=>e.dims));e.compute(to(s,e.inputs[0].dataType,n,r))},ro=e=>{let t=e.equation.replace(/\\s+/g,"");return Un({equation:t})}})),nc=ut((()=>{vd(),Td(),Ad(),so=e=>{if(!e||2!==e.length)throw new Error("Expand requires 2 input.");let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=n.length<t.length?0:n.length-t.length,s=t.length<n.length?0:t.length-n.length;for(;r<n.length&&s<t.length;++r,++s)if(n[r]!==t[s]&&1!==n[r]&&1!==t[s])throw new Error("Expand requires shape to be broadcastable to input")},io=(e,t)=>{let n=e.length-t.length,r=[];for(let t=0;t<n;++t)r.push(e[t]);for(let s=0;s<t.length;++s)r.push(1===t[s]?e[s+n]:t[s]);return r},ao=(e,t)=>e.length>t.length?io(e,t):io(t,e),oo=e=>{let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=ao(t,n),s=e[0].dataType,i=9===s||1===Wn.size(t),a=9===s||t.length>0&&t[t.length-1]%4==0?4:1,o=i||r.length>0&&r[r.length-1]%4==0?4:1,l=Math.ceil(Wn.size(r)/o),u=[{type:12,data:l},...Jn(t,r)];return{name:"Expand",shaderCache:{hint:`${r.length};${a}${o}`,inputDependencies:["rank"]},getShaderSource:e=>{let n,i=ar("input",s,t.length,a),l=or("output",s,r.length,o);if(9===s){let e=(e,t,n="")=>`\\n          let outputIndices${t} = ${l.offsetToIndices(`outputOffset + ${t}u`)};\\n          let offset${t} = ${i.broadcastedIndicesToOffset(`outputIndices${t}`,l)};\\n          let index${t} = offset${t} / 4u;\\n          let component${t} = offset${t} % 4u;\\n          ${e}[${t}] = ${n}(${i.getByOffset(`index${t}`)}[component${t}]);\\n        `;n=`\\n        let outputOffset = global_idx * ${o};\\n        var data = vec4<u32>(0);\\n        ${e("data",0,"u32")}\\n        ${e("data",1,"u32")}\\n        ${e("data",2,"u32")}\\n        ${e("data",3,"u32")}\\n        ${l.setByOffset("global_idx","data")}\\n      }`}else n=`\\n        let outputIndices = ${l.offsetToIndices(`global_idx * ${o}`)};\\n        let inputOffset = ${i.broadcastedIndicesToOffset("outputIndices",l)};\\n        let data = ${l.type.value}(${i.getByOffset(`inputOffset / ${a}`)});\\n        ${l.setByOffset("global_idx","data")}\\n      }`;return`\\n    ${e.registerUniform("vec_size","u32").declareVariables(i,l)}\\n    ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\\n    ${n}`},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u})}},lo=e=>{so(e.inputs),e.compute(oo(e.inputs),{inputs:[0]})}})),rc=ut((()=>{vd(),Td(),Ad(),Dd(),uo=e=>{let t=e[0].dataType,n=Wn.size(e[0].dims),r=Wn.size(e[1].dims),s=r%4==0;return{name:"FastGeluWithBias",shaderCache:{hint:`${s}`,inputDependencies:["type","type"]},getShaderSource:e=>{let n=ar("x",t,[1],4),r=ar("bias",t,[1],4),i=or("y",t,[1],4),a=e=>`\\n      let bias${e}_offset: u32 = (global_idx * 4 + ${e}) % uniforms.bias_size;\\n      let bias${e} = ${r.getByOffset(`bias${e}_offset / 4`)}[bias${e}_offset % 4];`,o=s?`\\n      let bias = ${r.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${a(0)}${a(1)}${a(2)}${a(3)}\\n      let bias = ${n.type.value}(bias0, bias1, bias2, bias3);`;return`${e.registerUniforms([{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}]).declareVariables(n,r,i)}\\n\\n    ${_i(Zn(t))}\\n\\n    ${e.mainStart(Xn)}\\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}\\n\\n      let x = ${n.getByOffset("global_idx")};\\n      ${o}\\n      let x_in = x + bias;\\n      ${i.setByOffset("global_idx",gi("x_in"))}\\n    }`},getRunData:e=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],programUniforms:[{type:12,data:Math.ceil(n/4)},{type:12,data:r}],dispatchGroup:{x:Math.ceil(n/Xn/4)}})}},co=e=>{e.inputs.length<2||0===Wn.size(e.inputs[1].dims)?wi(e):e.compute(uo(e.inputs))}})),sc=ut((()=>{vd(),Td(),Cd(),Ad(),po=e=>{if(!e||2!==e.length)throw new Error("Gather requires 2 inputs.")},ho=(e,t)=>{let n=e[0].dims,r=e[1].dims,s=n.length,i=Wn.normalizeAxis(t.axis,s),a=n.slice(0);a.splice(i,1,...r);let o=n[i],l=9===e[0].dataType?4:1,u=Math.ceil(Wn.size(a)/l),d=[{type:12,data:u},{type:6,data:o},{type:12,data:i},...Jn(e[0].dims,e[1].dims,a)];return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:d}),getShaderSource:t=>{let n,o=ar("data",e[0].dataType,e[0].dims.length,l),u=ar("inputIndices",e[1].dataType,e[1].dims.length),d=or("output",e[0].dataType,a.length,l),c=e=>{let t=r.length,n=`var indicesIndices${e}  = ${u.type.indices}(0);`;for(let r=0;r<t;r++)n+=`${t>1?`indicesIndices${e}[${r}]`:`indicesIndices${e}`} = ${a.length>1?`outputIndices${e}[uniforms.axis + ${r}]`:`outputIndices${e}`};`;n+=`\\n          var idx${e} = ${u.getByIndices(`indicesIndices${e}`)};\\n          if (idx${e} < 0) {\\n            idx${e} = idx${e} + uniforms.axisDimLimit;\\n          }\\n          var dataIndices${e} : ${o.type.indices};\\n        `;for(let r=0,o=0;r<s;r++)r===i?(n+=`${s>1?`dataIndices${e}[${r}]`:`dataIndices${e}`} = u32(idx${e});`,o+=t):(n+=`${s>1?`dataIndices${e}[${r}]`:`dataIndices${e}`} = ${a.length>1?`outputIndices${e}[${o}]`:`outputIndices${e}`};`,o++);return n};if(9===e[0].dataType){let e=(e,t,n="")=>`\\n          let outputIndices${t} = ${d.offsetToIndices(`outputOffset + ${t}u`)};\\n          ${c(t)};\\n          let offset${t} = ${o.indicesToOffset(`dataIndices${t}`)};\\n          let index${t} = offset${t} / 4u;\\n          let component${t} = offset${t} % 4u;\\n          ${e}[${t}] = ${n}(${o.getByOffset(`index${t}`)}[component${t}]);\\n        `;n=`\\n        let outputOffset = global_idx * ${l};\\n        var value = vec4<u32>(0);\\n        ${e("value",0,"u32")}\\n        ${e("value",1,"u32")}\\n        ${e("value",2,"u32")}\\n        ${e("value",3,"u32")}\\n        ${d.setByOffset("global_idx","value")}\\n      `}else n=`\\n      let outputIndices = ${d.offsetToIndices("global_idx")};\\n      ${c("")};\\n      let value = ${o.getByIndices("dataIndices")};\\n      ${d.setByOffset("global_idx","value")};\\n      `;return`\\n      ${t.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(o,u,d)}\\n      ${t.mainStart()}\\n        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n        ${n}\\n      }`}}},fo=e=>Un({axis:e.axis}),mo=(e,t)=>{let n=e.inputs;po(n),e.compute(ho(e.inputs,t))}})),ic=ut((()=>{vd(),Td(),Ad(),_o=(e,t,n,r,s,i,a,o,l)=>{let u=[{type:12,data:i},{type:12,data:r},{type:12,data:s},{type:12,data:n},{type:12,data:a},{type:12,data:o},{type:12,data:l}],d=[i];u.push(...Jn(t.dims,d));return e.compute({name:"computeSliceOffsets",shaderCache:{hint:`${s.length}_${n.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:d,dataType:e.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:u}),getShaderSource:e=>{let r=[ar("indices_data",t.dataType,t.dims.length),or("input_slice_offsets_data",12,1,1)],i=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:s.length},{name:"sizes_from_slice_dims_data",type:"u32",length:n.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`\\n  ${e.registerUniforms(i).declareVariables(...r)}\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n    let batch_idx = global_idx / uniforms.num_slices_per_batch;\\n    let base_offset = batch_idx * uniforms.input_batch_stride;\\n\\n    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;\\n    var relative_slice_offset = 0;\\n    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {\\n      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);\\n      let input_dim_idx = uniforms.batch_dims + dim_idx;\\n      if (index < 0) {\\n        ${1===s.length?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}\\n      }\\n      ${1===n.length?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}\\n    }\\n\\n    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);\\n  }`}},{inputs:[t],outputs:[-1]})[0]},go=(e,t)=>{let n=e.inputs,r=n[0].dims,s=n[0].dataType,i=n[1].dims,a=i[i.length-1],o=Wn.sizeToDimension(i,i.length-1),l=Wn.sizeFromDimension(r,t.batchDims+a),u=Wn.sizeToDimension(r,t.batchDims),d=Wn.sizeFromDimension(r,t.batchDims),c=o/u,p=new Array(a),h=l;for(let e=0;e<a;++e)p[a-1-e]=h,h*=r[t.batchDims+a-1-e];let f=_o(e,n[1],p,t.batchDims,r,o,c,d,a),m=t.batchDims+a;if(m>r.length)throw new Error("last dimension of indices must not be larger than rank of input tensor");let _=i.slice(0,-1).concat(r.slice(m)),g=Wn.size(_),w=[{type:12,data:g},{type:12,data:l},...Jn(n[0].dims,f.dims,_)];e.compute({name:"GatherND",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:_,dataType:s}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:w}),getShaderSource:e=>{let t=ar("data",n[0].dataType,n[0].dims.length),r=ar("slice_offsets",12,f.dims.length),s=or("output",n[0].dataType,_.length);return`\\n          ${e.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(t,r,s)}\\n            ${e.mainStart()}\\n            ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];\\n          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];\\n        }`}},{inputs:[n[0],f]})},wo=e=>({batchDims:e.batch_dims,cacheKey:""})})),ac=ut((()=>{vd(),Td(),Cd(),Ad(),yo=(e,t)=>{if(e.length<3||e.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let n=Wn.normalizeAxis(t.quantizeAxis,e[0].dims.length),r=t.blockSize,s=e[0],i=e[2],a=4===e.length?e[3]:void 0;if(i.dims.length!==s.dims.length||!s.dims.map(((e,t)=>t===n?Math.ceil(e/r)===i.dims[t]:e===i.dims[t])).reduce(((e,t)=>e&&t),!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(a){if(a.dataType!==s.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(a.dims.length!==i.dims.length||!a.dims.map(((e,t)=>e===i.dims[t])).reduce(((e,t)=>e&&t),!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},bo=(e,t)=>{let n=e[0].dims,r=e[1].dims,s=n.length,i=Wn.normalizeAxis(t.gatherAxis,s),a=Wn.normalizeAxis(t.quantizeAxis,s),o=n.slice(0);o.splice(i,1,...r);let l=Wn.size(o),u=e[2].dataType,d=22===e[0].dataType,c=[{type:12,data:l},{type:12,data:a},{type:12,data:i},{type:12,data:t.blockSize},...Jn(...e.map(((e,t)=>e.dims)),o)];return{name:"GatherBlockQuantized",shaderCache:{hint:`${t.cacheKey};${e.filter(((e,t)=>1!==t)).map((e=>e.dims.join("_"))).join(";")}`,inputDependencies:Array.from({length:e.length},((e,t)=>"rank"))},getRunData:()=>({outputs:[{dims:o,dataType:u}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:c}),getShaderSource:t=>{let s=ar("data",e[0].dataType,e[0].dims.length),a=ar("inputIndices",e[1].dataType,e[1].dims.length),l=ar("scales",e[2].dataType,e[2].dims.length),c=e.length>3?ar("zeroPoint",e[3].dataType,e[3].dims.length):void 0,p=or("output",u,o.length),h=[s,a,l];c&&h.push(c);return`\\n        ${t.registerUniforms([{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}]).declareVariables(...h,p)}\\n        ${t.mainStart()}\\n        let output_indices = ${p.offsetToIndices("global_idx")};\\n        var indices_indices = ${a.type.indices}(0);\\n        ${r.length>1?`\\n          for (var i: u32 = 0; i < ${r.length}; i++) {\\n            let index = ${p.indicesGet("output_indices","uniforms.gather_axis + i")};\\n            ${a.indicesSet("indices_indices","i","index")};\\n          }`:`indices_indices = ${p.indicesGet("output_indices","uniforms.gather_axis")};`};\\n        var data_indices = ${s.type.indices}(0);\\n        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {\\n          let index = ${p.indicesGet("output_indices","i")};\\n          ${s.indicesSet("data_indices","i","index")};\\n        }\\n        var index_from_indices = ${a.getByIndices("indices_indices")};\\n        if (index_from_indices < 0) {\\n          index_from_indices += ${n[i]};\\n        }\\n        ${s.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};\\n        for (var i = uniforms.gather_axis + 1; i < ${o.length}; i++) {\\n          let index = ${p.indicesGet("output_indices",`i + ${r.length} - 1`)};\\n          ${s.indicesSet("data_indices","i","index")};\\n        }\\n        let data_offset = ${s.indicesToOffset("data_indices")};\\n        let data_index = data_offset % 8;\\n        // Convert 4-bit packed data to 8-bit packed data.\\n        let packed_4bit_quantized_data = ${s.getByOffset("data_offset / 8")};\\n        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;\\n        let quantized_data_vec = ${d?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));\\n        let quantized_data = quantized_data_vec[data_index / 2];\\n        var scale_indices = data_indices;\\n        let quantize_axis_index = ${l.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;\\n        ${l.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};\\n        var scale = ${l.getByIndices("scale_indices")};\\n        ${c?`\\n              let zero_point_indices = scale_indices;\\n              let zero_point_offset = ${c.indicesToOffset("zero_point_indices")};\\n              let zero_point_index = zero_point_offset % 8;\\n              let packed_4bit_zero_points = ${c.getByOffset("zero_point_offset / 8")};\\n              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;\\n              let zero_point_vec = ${d?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));\\n              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};\\n        let dequantized_data = ${Zn(u)}(quantized_data - zero_point) * scale;\\n        ${p.setByOffset("global_idx","dequantized_data")};\\n    }`}}},xo=(e,t)=>{let n=e.inputs;yo(n,t),e.compute(bo(e.inputs,t))},vo=e=>Un({blockSize:e.blockSize,gatherAxis:e.gatherAxis,quantizeAxis:e.quantizeAxis})})),oc=ut((()=>{vd(),Td(),Cd(),Ad(),$o=e=>{if(!e||2!==e.length)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error("GatherElements requires that the data input and\\n                     indices input tensors be of same rank.")},ko=(e,t)=>{let n=e[0].dims,r=e[0].dataType,s=n.length,i=e[1].dims,a=e[1].dataType,o=Wn.normalizeAxis(t.axis,s),l=n[o],u=i.slice(0),d=Wn.size(u),c=ar("input",r,s),p=ar("indicesInput",a,i.length),h=or("output",r,u.length),f=[{type:12,data:d},{type:6,data:l},{type:12,data:o}];return f.push(...Jn(n,i,u)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:f}),getShaderSource:e=>`\\n      ${e.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(c,p,h)}\\n      ${e.mainStart()}\\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n\\n      let outputIndices = ${h.offsetToIndices("global_idx")};\\n\\n      var idx = ${p.getByOffset("global_idx")};\\n      if (idx < 0) {\\n        idx = idx + uniforms.axisDimLimit;\\n      }\\n      var inputIndices = ${c.type.indices}(outputIndices);\\n      ${c.indicesSet("inputIndices","uniforms.axis","u32(idx)")};\\n      let value = ${c.getByIndices("inputIndices")};\\n\\n      ${h.setByOffset("global_idx","value")};\\n  }`}},Eo=e=>Un({axis:e.axis}),So=(e,t)=>{let n=e.inputs;$o(n),e.compute(ko(e.inputs,t))}})),lc=ut((()=>{vd(),Td(),Ad(),zo=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(3===e.length&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Co=(e,t)=>{let n=e[0].dims.slice(),r=e[1].dims.slice(),[s,i,a]=Gn.getShapeOfGemmResult(n,t.transA,r,t.transB,3===e.length?e[2].dims:void 0),o=[s,i];if(!o)throw new Error("Can\'t use gemm on the given tensors");let l=16,u=Math.ceil(i/l),d=Math.ceil(s/l),c=(Wn.size(o),[{type:12,data:u},{type:12,data:s},{type:12,data:i},{type:12,data:a},{type:1,data:t.alpha},{type:1,data:t.beta}]),p=["type","type"];3===e.length&&(c.push(...Jn(e[2].dims)),p.push("rank")),c.push(...Jn(o));return{name:"GemmShared",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:u*d},programUniforms:c}),getShaderSource:n=>{let r=ar("a",e[0].dataType,e[0].dims),s=ar("b",e[1].dataType,e[1].dims),i=null,a=[r,s];3===e.length&&(i=ar("c",e[2].dataType,e[2].dims.length),a.push(i));let u=or("output",e[0].dataType,o.length);a.push(u);let d="",c="";t.transA&&t.transB?(c=`\\n      var col = tile_row_start + local_id.x;\\n      var row = k_start + local_id.y;\\n      if (col < uniforms.M && row < uniforms.K) {\\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\\n      } else {\\n        tile_a[local_id.y][local_id.x] = ${r.type.value}(0);\\n      }\\n\\n      col = k_start + local_id.x;\\n      row = tile_col_start + local_id.y;\\n      if (col < uniforms.K && row < uniforms.N) {\\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\\n      } else {\\n        tile_b[local_id.y][local_id.x] = ${s.type.value}(0);\\n      }\\n      `,d="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):t.transA&&!t.transB?(c=`\\n      var col = tile_row_start + local_id.x;\\n      var row = k_start + local_id.y;\\n      if (col < uniforms.M && row < uniforms.K) {\\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\\n      } else {\\n        tile_a[local_id.y][local_id.x] = ${r.type.value}(0);\\n      }\\n\\n      col = tile_col_start + local_id.x;\\n      row = k_start + local_id.y;\\n      if (col < uniforms.N && row < uniforms.K) {\\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\\n      } else {\\n        tile_b[local_id.y][local_id.x] = ${s.type.value}(0);\\n      }\\n      `,d="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!t.transA&&t.transB?(c=`\\n      var col = k_start + local_id.x;\\n      var row = tile_row_start + local_id.y;\\n      if (col < uniforms.K && row < uniforms.M) {\\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\\n      } else {\\n        tile_a[local_id.y][local_id.x] = ${r.type.value}(0);\\n      }\\n\\n      col = k_start + local_id.x;\\n      row = tile_col_start + local_id.y;\\n      if (col < uniforms.K && row < uniforms.N) {\\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\\n      } else {\\n        tile_b[local_id.y][local_id.x] = ${s.type.value}(0);\\n      }\\n      `,d="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!t.transA&&!t.transB&&(c=`\\n      var col = k_start + local_id.x;\\n      var row = tile_row_start + local_id.y;\\n      if (col < uniforms.K && row < uniforms.M) {\\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\\n      } else {\\n        tile_a[local_id.y][local_id.x] = ${r.type.value}(0);\\n      }\\n\\n      col = tile_col_start + local_id.x;\\n      row = k_start + local_id.y;\\n      if (col < uniforms.N && row < uniforms.K) {\\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\\n      } else {\\n        tile_b[local_id.y][local_id.x] = ${s.type.value}(0);\\n      }\\n      `,d="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let p=1===t.alpha?"":"value *= uniforms.alpha;";return`\\n  ${n.registerUniforms([{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}]).declareVariables(...a)}\\n  var<workgroup> tile_a: array<array<${r.type.storage}, 16>, 16>;\\n  var<workgroup> tile_b: array<array<${s.type.storage}, 16>, 16>;\\n  ${n.mainStart([l,l,1])}\\n    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * 16;\\n    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * 16;\\n    let num_tiles = (uniforms.K - 1) / 16 + 1;\\n    var k_start = 0u;\\n    var value = ${u.type.value}(0);\\n    for (var t: u32 = 0u; t < num_tiles; t++) {\\n      ${c}\\n      k_start = k_start + 16;\\n      workgroupBarrier();\\n\\n      for (var k: u32 = 0u; k < 16; k++) {\\n        ${d}\\n      }\\n      workgroupBarrier();\\n    }\\n\\n    ${p}\\n    let m = tile_row_start + local_id.y;\\n    let n = tile_col_start + local_id.x;\\n    ${null!=i?`let cOffset = ${i.broadcastedIndicesToOffset("vec2(m, n)",u)}; value += ${u.type.value}(uniforms.beta) * ${i.getByOffset("cOffset")};`:""}\\n    if (m < uniforms.M && n < uniforms.N) {\\n      output[m * uniforms.N + n] = value;\\n    }\\n  }`}}},To=e=>({transA:e.transA,transB:e.transB,alpha:e.alpha,beta:e.beta,cacheKey:`${e.transA};${e.transB};${1===e.alpha}`}),Ao=(e,t)=>{zo(e.inputs),e.compute(Co(e.inputs,t))}})),uc=ut((()=>{vd(),Td(),Cd(),Ad(),[Io,Mo,Oo,Bo]=[0,1,2,3],No=e=>{if(4!==e[0].dims.length)throw new Error("only 4-D tensor is supported.");if(e[0].dims.length!==e[1].dims.length)throw new Error("input dimensions must be equal to grid dimensions");if(e[0].dims.length-2!==e[1].dims[e[1].dims.length-1])throw new Error("last dimension of grid must be equal to "+(e[0].dims.length-2));if(e[0].dims[0]!==e[1].dims[0])throw new Error("grid batch size must match input batch size")},Po=e=>`\\n  fn gs_bicubic_interpolate(p: mat4x4<${e}>, x: f32, y: f32) -> ${e} {\\n    var v: vec4<f32>;\\n    var coeffs = gs_get_cubic_coeffs(x);\\n    for (var i = 0; i < 4; i++) {\\n      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];\\n    }\\n    coeffs = gs_get_cubic_coeffs(y);\\n    let pixel = ${e}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);\\n    return pixel;\\n  }\\n`,Ro=e=>`\\n  fn gs_denormalize(n: f32, length: i32) -> f32 {\\n    ${0===e.alignCorners?"\\n    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]\\n    return ((n + 1.0) * f32(length) - 1.0) / 2.0;\\n    ":"\\n    // alignCorners: true => [-1, 1] to [0, length - 1]\\n    return (n + 1.0) / 2.0 * (f32(length - 1));\\n    "}\\n  }\\n`,Do=e=>`\\n  ${"reflection"===e.paddingMode?"\\n      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {\\n        var dx = 0.0;\\n        var fx = f32(x);\\n        let range = x_max - x_min;\\n        if (fx < x_min) {\\n          dx = x_min - fx;\\n          let n = u32(dx / range);\\n          let r = dx - f32(n) * range;\\n          if (n % 2 == 0) {\\n            fx = x_min + r;\\n          } else {\\n            fx = x_max - r;\\n          }\\n        } else if (fx > x_max) {\\n          dx = fx - x_max;\\n          let n = u32(dx / range);\\n          let r = dx - f32(n) * range;\\n          if (n % 2 == 0) {\\n            fx = x_max - r;\\n          } else {\\n            fx = x_min + r;\\n          }\\n        }\\n        return u32(fx);\\n      }":""}\\n`,Lo=(e,t,n)=>`\\n  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${t} {\\n     var pixel = ${t}(0);\\n     var indices = vec4<u32>(0);\\n     indices[${Io}] = batch;\\n     indices[${Mo}] = channel;`+(()=>{switch(n.paddingMode){case"zeros":return`\\n          if (r >= 0 && r < H && c >=0 && c < W) {\\n            indices[${Oo}] = u32(r);\\n            indices[${Bo}] = u32(c);\\n          }\\n        `;case"border":return`\\n          indices[${Oo}] = u32(clamp(r, 0, H - 1));\\n          indices[${Bo}] = u32(clamp(c, 0, W - 1));\\n        `;case"reflection":return`\\n          indices[${Oo}] = gs_reflect(r, border[1], border[3]);\\n          indices[${Bo}] = gs_reflect(c, border[0], border[2]);\\n        `;default:throw new Error(`padding mode ${n.paddingMode} is not supported`)}})()+`\\n    return ${e.getByIndices("indices")};\\n  }\\n`,Fo=(e,t,n)=>(()=>{switch(n.mode){case"nearest":return`\\n          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${Io}], indices[${Mo}], border);\\n        `;case"bilinear":return`\\n          let x1 = i32(floor(x));\\n          let y1 = i32(floor(y));\\n          let x2 = x1 + 1;\\n          let y2 = y1 + 1;\\n\\n          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${Io}], indices[${Mo}], border);\\n          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${Io}], indices[${Mo}], border);\\n          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${Io}], indices[${Mo}], border);\\n          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${Io}], indices[${Mo}], border);\\n\\n          let dx2 = ${t}(f32(x2) - x);\\n          let dx1 = ${t}(x - f32(x1));\\n          let dy2 = ${t}(f32(y2) - y);\\n          let dy1 = ${t}(y - f32(y1));\\n          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);\\n        `;case"bicubic":return`\\n          let x0 = i32(floor(x)) - 1;\\n          let y0 = i32(floor(y)) - 1;\\n          var p: mat4x4<${t}>;\\n          for (var h = 0; h < 4; h++) {\\n            for (var w = 0; w < 4; w++) {\\n              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${Io}], indices[${Mo}], border);\\n            }\\n          }\\n\\n          let dx = x - f32(x0 + 1);\\n          let dy = y - f32(y0 + 1);\\n          let result = gs_bicubic_interpolate(p, dx, dy);\\n        `;default:throw new Error(`mode ${n.mode} is not supported`)}})()+`${e.setByOffset("global_idx","result")}`,Uo=(e,t)=>{let n=ar("x",e[0].dataType,e[0].dims.length),r=[e[1].dims[0],e[1].dims[1],e[1].dims[2]],s=ar("grid",e[1].dataType,r.length,2),i=[e[0].dims[0],e[0].dims[1],e[1].dims[1],e[1].dims[2]];"NHWC"===t.format&&(i=[e[0].dims[0],e[1].dims[1],e[1].dims[2],e[0].dims[3]],[Io,Mo,Oo,Bo]=[0,3,1,2]);let a=or("output",e[0].dataType,i.length),o=n.type.value,l=[{type:12,data:Wn.size(i)},...Jn(e[0].dims,r,i)];return{name:"GridSample",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:["type","type"]},getRunData:e=>{let t=Wn.size(i);return{outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(t/64)},programUniforms:l}},getShaderSource:e=>`\\n  ${e.registerUniform("output_size","u32").declareVariables(n,s,a)}\\n  \\n  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {\\n    let cubic_alpha = -0.75f;\\n    let x_abs = abs(x);\\n    var coeffs: vec4<f32>;\\n    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);\\n    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);\\n    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);\\n    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);\\n    return coeffs;\\n  }\\n\\n  ${Po(o)}\\n  ${Ro(t)}\\n  ${Do(t)}\\n  ${Lo(n,o,t)}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n      let H_in = i32(uniforms.x_shape[${Oo}]);\\n      let W_in = i32(uniforms.x_shape[${Bo}]);\\n\\n      ${0===t.alignCorners?"\\n      let x_min = -0.5;\\n      let x_max = f32(W_in) - 0.5;\\n      let y_min = -0.5;\\n      let y_max = f32(H_in) - 0.5;\\n      ":"\\n      let x_min = 0.0;\\n      let x_max = f32(W_in) - 1.0;\\n      let y_min = 0.0;\\n      let y_max = f32(H_in) - 1.0;\\n      "};\\n      let border = vec4<f32>(x_min, y_min, x_max, y_max);\\n\\n      let indices = ${a.offsetToIndices("global_idx")};\\n      var grid_indices = vec3<u32>(indices[${Io}], indices[${Oo}], indices[${Bo}]);\\n      let nxy = ${s.getByIndices("grid_indices")};\\n      var x = gs_denormalize(f32(nxy[0]), W_in);\\n      var y = gs_denormalize(f32(nxy[1]), H_in);\\n\\n      ${Fo(a,o,t)}\\n  }`}},qo=(e,t)=>{No(e.inputs),e.compute(Uo(e.inputs,t))},Vo=e=>Un({alignCorners:e.align_corners,mode:e.mode,paddingMode:e.padding_mode,format:e.format})})),dc=ut((()=>{vd(),Td(),Cd(),Sd(),Nd(),Ad(),Id(),Wo=(e,t)=>e.length>t&&e[t].dims.length>0?e[t]:void 0,jo=(e,t)=>{let n=e[0],r=Wo(e,1),s=Wo(e,2),i=Wo(e,3),a=Wo(e,4),o=Wo(e,5),l=Wo(e,6),u=Wo(e,7);if(3!==n.dims.length&&5!==n.dims.length)throw new Error("Input query is expected to have 3 or 5 dimensions");let d,c=n.dims[0],p=n.dims[1],h=3===n.dims.length?n.dims[2]:t.numHeads*n.dims[4],f=p,m=0,_=0,g=Math.floor(h/t.numHeads);if(l&&u&&Wn.size(l.dims)&&Wn.size(u.dims)){if(4!==l.dims.length)throw new Error(\'Input "past_key" is expected to have 4 dimensions\');if(l.dims[0]!==c||l.dims[1]!==t.numHeads||l.dims[3]!==g)throw new Error(\'Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)\');if(u.dims[0]!==c||u.dims[1]!==t.numHeads||u.dims[3]!==g)throw new Error(\'Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)\');if(l.dims[2]!==u.dims[2])throw new Error(\'Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)\');if(4!==u.dims.length)throw new Error(\'Input "past_value" is expected to have 4 dimensions\');m=l.dims[2],_=l.dims[2]}else if(l&&Wn.size(l.dims)||u&&Wn.size(u.dims))throw new Error(\'Input "past_key" and "past_value" shall be both present or both absent\');if(r&&Wn.size(r.dims)>0){if(3!==n.dims.length)throw new Error(\'Input "query" is expected to have 3 dimensions when key is given\');if(r.dims.length<3||r.dims.length>5)throw new Error(\'Input "key" is expected to have 3, 4, or 5 dimensions\');if(n.dims[0]!==r.dims[0])throw new Error(\'Input "query" and "key" shall have same dim 0 (batch size)\');if(3===r.dims.length){if(r.dims[2]!==n.dims[2])throw new Error(\'Input "query" and "key" shall have same dim 2 (hidden_size)\');d=2,f=r.dims[1]}else if(5===r.dims.length){if(r.dims[2]!==t.numHeads||2!==r.dims[3]||r.dims[4]!==g)throw new Error(\'Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv\');if(s)throw new Error(\'Expect "value" be none when "key" has packed kv format.\');d=5,f=r.dims[1]}else{if(r.dims[1]!==t.numHeads||r.dims[3]!==g)throw new Error(\'Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key\');d=0,f=r.dims[2]}}else{if(5!==n.dims.length)throw new Error(\'Input "query" is expected to have 5 dimensions when key is empty\');if(n.dims[2]!==t.numHeads||3!==n.dims[3])throw new Error(\'Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv\');d=3}if(i&&Wn.size(i.dims)>0){if(1!==i.dims.length)throw new Error(\'Input "bias" is expected to have 1 dimension\');if(r&&5===r.dims.length&&2===r.dims[3])throw new Error("bias is not allowed for packed kv.")}let w=m+f,y=0;if(a&&Wn.size(a.dims)>0){y=8;let e=a.dims;throw 1===e.length?e[0]===c?y=1:e[0]===3*c+2&&(y=3):2===e.length&&e[0]===c&&e[1]===w&&(y=5),8===y?new Error(\'Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)\'):new Error("Mask not supported")}let b=!1,x=h;if(s&&Wn.size(s.dims)>0){if(3!==s.dims.length&&4!==s.dims.length)throw new Error(\'Input "value" is expected to have 3 or 4 dimensions\');if(n.dims[0]!==s.dims[0])throw new Error(\'Input "query" and "value" shall have same dim 0 (batch_size)\');if(3===s.dims.length){if(f!==s.dims[1])throw new Error(\'Input "key" and "value" shall have the same dim 1 (kv_sequence_length)\');x=s.dims[2]}else{if(f!==s.dims[2])throw new Error(\'Input "key" and "value" shall have the same dim 2 (kv_sequence_length)\');x=s.dims[1]*s.dims[3],b=!0}}if(a&&Wn.size(a.dims)>0)throw new Error("Key padding mask is not supported");if(o&&Wn.size(o.dims)>0){if(4!==o.dims.length)throw new Error(\'Input "attention_bias" is expected to have 4 dimensions\');if(o.dims[0]!==c||o.dims[1]!==t.numHeads||o.dims[2]!==p||o.dims[3]!==w)throw new Error(\'Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)\')}return{batchSize:c,sequenceLength:p,pastSequenceLength:m,kvSequenceLength:f,totalSequenceLength:w,maxSequenceLength:_,inputHiddenSize:0,hiddenSize:h,vHiddenSize:x,headSize:g,vHeadSize:Math.floor(x/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:y,scale:t.scale,broadcastResPosBias:!1,passPastInKv:b,qkvFormat:d}},Go=e=>Un({...e}),Ho=Un({perm:[0,2,1,3]}),Ko=(e,t,n,r,s,i,a)=>{let o=[r,s,i],l=Wn.size(o),u=[{type:12,data:l},{type:12,data:a},{type:12,data:i}];return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:o,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u}),getShaderSource:e=>{let r=or("qkv_with_bias",t.dataType,o),s=ar("qkv",t.dataType,o),i=ar("bias",n.dataType,o);return`\\n  ${e.registerUniforms([{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}]).declareVariables(s,i,r)}\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\\n\\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\\n  }`}},{inputs:[t,n],outputs:[-1]})[0]},Xo=(e,t,n,r,s,i,a,o)=>{let l=i;if(a&&Wn.size(a.dims)>0){if(1===r)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return l=Ko(e,i,a,t,r,n*s,o),l=l.reshape([t,r,n,s]),1===n||1===r?l:e.compute(wr(l,Ho.perm),{inputs:[l],outputs:[-1]})[0]}return 3===i.dims.length&&(l=i.reshape([t,r,n,s])),1===n||1===r?l:e.compute(wr(l,Ho.perm),{inputs:[l],outputs:[-1]})[0]},Qo=(e,t)=>{let n=jo(e.inputs,t),r=e.inputs[0],s=Wo(e.inputs,1),i=Wo(e.inputs,2),a=Wo(e.inputs,3),o=Wo(e.inputs,4),l=Wo(e.inputs,5),u=Wo(e.inputs,6),d=Wo(e.inputs,7);if(5===r.dims.length)throw new Error("Packed QKV is not implemented");if(5===s?.dims.length)throw new Error("Packed KV is not implemented");let c=s&&i&&4===s.dims.length&&4===i.dims.length,p=Xo(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,r,a,0);if(c)return $s(e,p,s,i,o,void 0,u,d,l,n);if(!s||!i)throw new Error("key and value must be provided");let h=Xo(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.headSize,s,a,n.hiddenSize),f=Xo(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.vHeadSize,i,a,2*n.hiddenSize);$s(e,p,h,f,o,void 0,u,d,l,n)}})),cc=ut((()=>{vd(),Td(),Cd(),Ad(),Yo=e=>{if(!e||e.length<1)throw new Error("too few inputs")},Zo=(e,t)=>{let n=[],r=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach((e=>n.push(Number(e)))),r=n.length),Un({numOutputs:r,axis:t.axis,splitSizes:n})},Jo=e=>`\\nfn calculateOutputIndex(index: u32) -> u32 {\\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\\n    if (index < ${sr("uniforms.size_in_split_axis","i",e)}) {\\n        return i;\\n    }\\n    }\\n    return ${e}u;\\n}`,el=e=>{let t=e.length,n=[];for(let r=0;r<t;++r){let s=e[r].setByIndices("indices","input[global_idx]");1===t?n.push(s):0===r?n.push(`if (output_number == ${r}u) { ${s} }`):r===t-1?n.push(`else { ${s} }`):n.push(`else if (output_number == ${r}) { ${s} }`)}return`\\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\\n        ${n.join("\\n")}\\n      }`},tl=(e,t)=>{let n=e[0].dims,r=Wn.size(n),s=e[0].dataType,i=Wn.normalizeAxis(t.axis,n.length),a=new Array(t.numOutputs),o=ar("input",s,n.length),l=new Array(t.numOutputs),u=[],d=[],c=0,p=[{type:12,data:r}];for(let r=0;r<t.numOutputs;r++){c+=t.splitSizes[r],l[r]=c;let o=n.slice();o[i]=t.splitSizes[r],d.push(o),a[r]=or(`output${r}`,s,o.length),u.push({dims:d[r],dataType:e[0].dataType})}p.push({type:12,data:l},...Jn(n,...d));return{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:e=>`\\n  ${e.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",l.length).declareVariables(o,...a)}\\n  ${Jo(l.length)}\\n  ${el(a)}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}\\n\\n    var indices = ${o.offsetToIndices("global_idx")};\\n    var index = ${o.indicesGet("indices",i)};\\n    let output_number = calculateOutputIndex(index);\\n    if (output_number != 0) {\\n      index -= ${sr("uniforms.size_in_split_axis","output_number - 1u",l.length)};\\n      ${o.indicesSet("indices",i,"index")};\\n    }\\n    writeBufferData(output_number, indices, global_idx);\\n  }`,getRunData:()=>({outputs:u,dispatchGroup:{x:Math.ceil(r/64)},programUniforms:p})}},nl=(e,t)=>{Yo(e.inputs);let n=1===e.inputs.length?t:Zo(e.inputs,t);e.compute(tl(e.inputs,n),{inputs:[0]})},rl=e=>{let t=e.axis,n=e.splitSizes,r=e.numOutputs<0?n.length:e.numOutputs;if(r!==n.length)throw new Error("numOutputs and splitSizes lengh must be equal");return Un({axis:t,numOutputs:r,splitSizes:n})}})),pc=ut((()=>{Cd(),Nd(),dc(),cc(),Id(),sl=(e,t)=>{if(t.doRotary&&e.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let n=e[0],r=e[1],s=e[2],i=e[3],a=e[4];if(-1!==t.localWindowSize)throw new Error("Local attention is not supported");if(0!==t.softcap)throw new Error("Softcap is not supported");if(0!==t.rotaryInterleaved)throw new Error("Rotary interleaved is not supported");if(t.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(3!==n.dims.length&&5!==n.dims.length)throw new Error("Input query is expected to have 3 or 5 dimensions");let o=n.dims[0],l=n.dims[1],u=3===n.dims.length?n.dims[2]:t.numHeads*n.dims[4],d=l,c=0,p=!r||0===r.dims.length,h=Math.floor(p?u/(t.numHeads+2*t.kvNumHeads):u/t.numHeads);p&&(u=h*t.numHeads);let f=i&&0!==i.dims.length,m=a&&0!==a.dims.length;if(f&&4===i.dims.length&&i.dims[0]===o&&i.dims[1]!==t.kvNumHeads&&i.dims[2]===t.kvNumHeads&&i.dims[3]===h)throw new Error("BSNH pastKey/pastValue is not supported");if(f&&m){if(4!==i.dims.length)throw new Error(\'Input "past_key" is expected to have 4 dimensions\');if(4!==a.dims.length)throw new Error(\'Input "past_value" is expected to have 4 dimensions\');c=i.dims[2]}else if(f||m)throw new Error(\'Input "past_key" and "past_value" shall be both present or both absent\');let _=1;if(r&&r.dims.length>0){if(3!==n.dims.length)throw new Error(\'Input "query" is expected to have 3 dimensions when key is given\');if(r.dims.length<3||r.dims.length>5)throw new Error(\'Input "key" is expected to have 3, 4, or 5 dimensions\');if(n.dims[0]!==r.dims[0])throw new Error(\'Input "query" and "key" shall have same dim 0 (batch size)\');if(3===r.dims.length){if(n.dims[2]%r.dims[2]!=0)throw new Error(\'Dimension 2 of "query" should be a multiple of "key"\');d=r.dims[1]}else if(5===r.dims.length){if(r.dims[2]!==t.numHeads||2!==r.dims[3]||r.dims[4]!==h)throw new Error(\'Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv\');if(s)throw new Error(\'Expect "value" be none when "key" has packed kv format.\');d=r.dims[1]}else{if(r.dims[1]!==t.numHeads||r.dims[3]!==h)throw new Error(\'Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key\');d=r.dims[2]}}else{if(3!==n.dims.length&&5!==n.dims.length)throw new Error(\'Input "query" is expected to have 3 or 5 dimensions when key is empty\');if(5===n.dims.length&&(n.dims[2]!==t.numHeads||3!==n.dims[3]))throw new Error(\'Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv\');_=3}let g=!1,w=t.kvNumHeads?h*t.kvNumHeads:u;if(s&&s.dims.length>0){if(3!==s.dims.length&&4!==s.dims.length)throw new Error(\'Input "value" is expected to have 3 or 4 dimensions\');if(n.dims[0]!==s.dims[0])throw new Error(\'Input "query" and "value" shall have same dim 0 (batch_size)\');if(3===s.dims.length){if(d!==s.dims[1])throw new Error(\'Input "key" and "value" shall have the same dim 1 (kv_sequence_length)\');w=s.dims[2]}else{if(d!==s.dims[2])throw new Error(\'Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)\');w=s.dims[1]*s.dims[3],g=!0}}let y=e.length>4?e[5]:void 0;if(y&&1!==y.dims.length&&y.dims[0]!==o)throw new Error(\'Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size\');return{batchSize:o,sequenceLength:l,pastSequenceLength:c,kvSequenceLength:d,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:u,vHiddenSize:w,headSize:h,vHeadSize:Math.floor(w/t.kvNumHeads),numHeads:t.numHeads,kvNumHeads:t.kvNumHeads,nReps:t.numHeads/t.kvNumHeads,pastPresentShareBuffer:!1,maskType:0,scale:t.scale,broadcastResPosBias:!1,passPastInKv:g,qkvFormat:_}},il=Un({perm:[0,2,1,3]}),al=(e,t,n)=>{let r=t,s=n.kvNumHeads;return 3===t.dims.length&&0!==n.kvSequenceLength&&(r=t.reshape([n.batchSize,n.kvSequenceLength,s,n.headSize]),r=e.compute(wr(r,il.perm),{inputs:[r],outputs:[-1]})[0]),r},ol=(e,t)=>{let n=sl(e.inputs,t);if(5===e.inputs[0].dims.length)throw new Error("Packed QKV is not implemented");if(5===e.inputs[1]?.dims.length)throw new Error("Packed KV is not implemented");let r=e.inputs[0],s=e.inputs[1]&&e.inputs[1].dims.length>0?e.inputs[1]:void 0,i=e.inputs[2]&&e.inputs[2].dims.length>0?e.inputs[2]:void 0,a=e.inputs[3]&&0!==e.inputs[3].dims.length?e.inputs[3]:void 0,o=e.inputs[4]&&0!==e.inputs[4].dims.length?e.inputs[4]:void 0,l=e.inputs.length>4?e.inputs[5]:void 0,u=e.inputs.length>5?e.inputs[6]:void 0,d=n.kvNumHeads?n.kvNumHeads:n.numHeads,c=Un({axis:2,numOutputs:3,splitSizes:[n.numHeads*n.headSize,d*n.headSize,d*n.headSize]}),[p,h,f]=s||i?[r,s,i]:e.compute(tl([r],c),{inputs:[r],outputs:[-1,-1,-1]}),m=Xo(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,p,void 0,0);$s(e,m,al(e,h,n),al(e,f,n),void 0,void 0,a,o,void 0,n,l,u)}})),hc=ut((()=>{vd(),Td(),Id(),Ad(),ll=(e,t,n,r,s,i,a,o)=>{let l=er(i),u=1===l?"f32":`vec${l}f`,d=1===l?"vec2f":`mat2x${l}f`,c=s*a,p=64;1===c&&(p=256);let h=[s,a,i/l],f=[s,a,2],m=[];m.push(...Jn(h,f));return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${l};${o};${p}`,inputDependencies:["rank","type","type"]},getRunData:()=>({outputs:[{dims:f,dataType:1}],dispatchGroup:{x:c},programUniforms:m}),getShaderSource:e=>{let s=ar("x",t.dataType,3,l),i=[s,ar("scale",n.dataType,n.dims),ar("bias",r.dataType,r.dims),or("output",1,3,2)];return`\\n  var<workgroup> workgroup_shared : array<${d}, ${p}>;\\n  const workgroup_size = ${p}u;\\n  ${e.declareVariables(...i)}\\n  ${e.mainStart(p)}\\n    let batch = workgroup_index / uniforms.x_shape[1];\\n    let channel = workgroup_index % uniforms.x_shape[1];\\n    let hight = uniforms.x_shape[2];\\n    // initialize workgroup memory\\n    var sum = ${u}(0);\\n    var squared_sum = ${u}(0);\\n    for (var h = local_idx; h < hight; h += workgroup_size) {\\n      let value = ${u}(${s.get("batch","channel","h")});\\n      sum += value;\\n      squared_sum += value * value;\\n    }\\n    workgroup_shared[local_idx] = ${d}(sum, squared_sum);\\n    workgroupBarrier();\\n\\n    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {\\n      if (local_idx < currSize) {\\n        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];\\n      }\\n      workgroupBarrier();\\n    }\\n    if (local_idx == 0) {\\n      let sum_final = ${rr("workgroup_shared[0][0]",l)} / f32(hight * ${l});\\n      let squared_sum_final = ${rr("workgroup_shared[0][1]",l)} / f32(hight * ${l});\\n\\n      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${o}));\\n      let channel_scale = inv_std_dev * f32(scale[channel]);\\n      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;\\n      output[workgroup_index] = vec2f(channel_scale, channel_shift);\\n    }\\n  }`}},{inputs:[t,n,r],outputs:[-1]})[0]},ul=(e,t,n)=>{let r=t[0].dims,s=r,i=r[0],a=r[1],o=Wn.sizeFromDimension(r,2),l=er(o),u=Wn.size(s)/l,d=ll(e,t[0],t[1],t[2],i,o,a,n.epsilon),c=[i,a,o/l],p=[i,a];e.compute({name:"InstanceNormalization",shaderCache:{hint:`${l}`,inputDependencies:["type","none"]},getRunData:()=>({outputs:[{dims:s,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:[{type:12,data:u},...Jn(c,p,c)]}),getShaderSource:e=>{let n=ar("x",t[0].dataType,c.length,l),r=ar("scale_shift",1,p.length,2),s=or("output",t[0].dataType,c.length,l),i=[n,r,s];return`\\n  ${e.registerUniform("output_size","u32").declareVariables(...i)}\\n  ${e.mainStart()}\\n  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n      let outputIndices = ${s.offsetToIndices("global_idx")};\\n      let batch = outputIndices[0];\\n      let channel = outputIndices[1];\\n      let scale_shift = ${r.getByIndices("vec2<u32>(batch, channel)")};\\n      let value = ${n.getByOffset("global_idx")} * ${s.type.value}(scale_shift.x) + ${s.type.value}(scale_shift.y);\\n      ${s.setByOffset("global_idx","value")};\\n  }`}},{inputs:[t[0],d]})},dl=(e,t,n)=>{let r=t[0].dims,s=r,i=r[0],a=r[r.length-1],o=Wn.sizeFromDimension(r,1)/a,l=er(a),u=Wn.size(s)/l,d=[{type:12,data:o},{type:12,data:Math.floor(a/l)}],c=!1,p=[0,r.length-1];for(let e=0;e<r.length-2;e++)c=c||1!==r[e+1],p.push(e+1);c=c&&1!==r[r.length-1];let h=c?e.compute(wr(e.inputs[0],p),{inputs:[e.inputs[0]],outputs:[-1]})[0]:e.inputs[0].reshape(Array.from({length:r.length},((e,t)=>r[p[t]]))),f=ll(e,h,t[1],t[2],i,o,a,n.epsilon);e.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${l}`,inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:s,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:d}),getShaderSource:e=>{let n=Yn(t[0].dataType),r=1===l?"vec2f":`mat${l}x2f`,i=e=>{let t=0===e?"x":"y",r=1===l?"f32":`vec${l}f`;switch(l){case 1:return`${n}(${r}(scale.${t}))`;case 2:return`vec2<${n}>(${r}(scale[0].${t}, scale[1].${t}))`;case 4:return`vec4<${n}>(${r}(scale[0].${t}, scale[1].${t}, scale[2].${t}, scale[3].${t}))`;default:throw new Error(`Not supported compoents ${l}`)}},a=ar("input",t[0].dataType,t[0].dims,l),o=or("output",t[0].dataType,s,l);return`\\n  @group(0) @binding(0) var<storage, read> input : array<${a.type.storage}>;\\n  @group(0) @binding(1) var<storage, read> scale_input : array<${r}>;\\n  @group(0) @binding(2) var<storage, read_write> output : array<${o.type.storage}>;\\n  struct Uniforms {H: u32, C : u32};\\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\\n\\n  ${e.mainStart()}\\n    let current_image_number = global_idx / (uniforms.C * uniforms.H);\\n    let current_channel_number = global_idx % uniforms.C;\\n\\n    let scale_offset = current_image_number * uniforms.C + current_channel_number;\\n    let scale = scale_input[scale_offset];\\n    output[global_idx] = fma(input[global_idx], ${i(0)}, ${i(1)});\\n  }`}},{inputs:[t[0],f]})},cl=(e,t)=>{"NHWC"===t.format?dl(e,e.inputs,t):ul(e,e.inputs,t)}})),fc=ut((()=>{vd(),Td(),Ad(),pl=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},hl=(e,t,n)=>{let r=t.simplified,s=e[0].dims,i=e[1],a=!r&&e[2],o=s,l=Wn.normalizeAxis(t.axis,s.length),u=Wn.sizeToDimension(s,l),d=Wn.sizeFromDimension(s,l),c=Wn.size(i.dims),p=a?Wn.size(a.dims):0;if(c!==d||a&&p!==d)throw new Error(`Size of X.shape()[axis:] == ${d}.\\n       Size of scale and bias (if provided) must match this.\\n       Got scale size of ${c} and bias size of ${p}`);let h=[];for(let e=0;e<s.length;++e)e<l?h.push(s[e]):h.push(1);let f=er(d),m=["type","type"],_=[{type:12,data:u},{type:1,data:d},{type:12,data:Math.floor(d/f)},{type:1,data:t.epsilon}];a&&m.push("type");let g=n>1,w=n>2,y=[{dims:o,dataType:e[0].dataType}];return g&&y.push({dims:h,dataType:1}),w&&y.push({dims:h,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${f};${n};${r}`,inputDependencies:m},getRunData:()=>({outputs:y,dispatchGroup:{x:Math.ceil(u/64)},programUniforms:_}),getShaderSource:t=>{let n=Yn(e[0].dataType),s=[ar("x",e[0].dataType,e[0].dims,f),ar("scale",i.dataType,i.dims,f)];a&&s.push(ar("bias",a.dataType,a.dims,f)),s.push(or("output",e[0].dataType,o,f)),g&&s.push(or("mean_data_output",1,h)),w&&s.push(or("inv_std_output",1,h));return`\\n  ${t.registerUniforms([{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}]).declareVariables(...s)}\\n  ${t.mainStart()}\\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}\\n    let offset = global_idx * uniforms.norm_size_vectorized;\\n    var mean_vector = ${tr("f32",f)};\\n    var mean_square_vector = ${tr("f32",f)};\\n\\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\\n      let value = ${nr(n,f,"x[h + offset]")};\\n      mean_vector += value;\\n      mean_square_vector += value * value;\\n    }\\n    let mean = ${rr("mean_vector",f)} / uniforms.norm_size;\\n    let inv_std_dev = inverseSqrt(${rr("mean_square_vector",f)} / uniforms.norm_size ${r?"":"- mean * mean"} + uniforms.epsilon);\\n\\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\\n      let f32input = ${nr(n,f,"x[j + offset]")};\\n      let f32scale = ${nr(n,f,"scale[j]")};\\n      output[j + offset] = ${s[0].type.value}((f32input ${r?"":"- mean"}) * inv_std_dev * f32scale\\n        ${a?`+ ${nr(n,f,"bias[j]")}`:""}\\n      );\\n    }\\n\\n    ${g?"mean_data_output[global_idx] = mean":""};\\n    ${w?"inv_std_output[global_idx] = inv_std_dev":""};\\n  }`}}},fl=(e,t)=>{pl(e.inputs),e.compute(hl(e.inputs,t,e.outputCount))}})),mc=ut((()=>{Td(),jd(),Gd(),ml=e=>{if(!e||2!==e.length)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},_l=e=>{ml(e.inputs);let t=Vn.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can\'t use matmul on the given tensors");let n=t[t.length-1],r=e.inputs[0].dims[e.inputs[0].dims.length-1];if(n<8&&r<8)e.compute(ea(e.inputs,{activation:""},t));else{let s=t[t.length-2],i=Wn.size(e.inputs[0].dims.slice(0,-2)),a=Wn.size(e.inputs[1].dims.slice(0,-2));if(1!==i&&1===s&&1===a){let s=[1,i,n],a=[e.inputs[0].reshape([1,i,r]),e.inputs[1].reshape([1,r,n])];e.compute(la(a,{activation:""},t,s),{inputs:a})}else e.compute(la(e.inputs,{activation:""},t))}}})),_c=ut((()=>{vd(),Td(),Cd(),Ad(),gl=(e,t)=>{if(e.length<3||e.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let n=e[0],r=n.dims.length;if(n.dims[r-1]!==t.k)throw new Error("The last dim of input shape does not match the k value");let s=Math.floor((t.k+t.blockSize-1)/t.blockSize),i=t.blockSize/8*t.bits,a=e[1];if(!Wn.areEqual(a.dims,[t.n,s,i]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let o=e[2].dims;if(Wn.size(o)!==t.n*s)throw new Error("scales input size error.");if(4===e.length){let n=e[3].dims,r=t.bits>4?t.n*s:t.n*Math.floor((s+1)/2);if(Wn.size(n)!==r)throw new Error("zeroPoints input size error.")}},wl=(e,t)=>{let n=e[0].dims,r=n.length,s=n[r-2],i=t.k,a=t.n,o=n.slice(0,r-2),l=Wn.size(o),u=e[1].dims[2]/4,d=e[0].dataType,c=er(t.k),p=er(u),h=er(a),f=o.concat([s,a]),m=s>1&&a/h%2==0?2:1,_=Wn.size(f)/h/m,g=64,w=[],y=[l,s,i/c],b=Wn.convertShape(e[1].dims).slice();b.splice(-1,1,u/p),w.push(...Jn(y)),w.push(...Jn(b)),w.push(...Jn(e[2].dims)),4===e.length&&w.push(...Jn(Wn.convertShape(e[3].dims)));let x=[l,s,a/h];w.push(...Jn(x));return{name:"MatMulNBits",shaderCache:{hint:`${t.blockSize};${t.bits};${c};${p};${h};${m};64`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:f,dataType:d}],dispatchGroup:{x:_},programUniforms:w}),getShaderSource:n=>{let r=y.length,s=ar("a",e[0].dataType,r,c),i=ar("b",12,b.length,p),a=ar("scales",e[2].dataType,e[2].dims.length),o=[s,i,a],l=4===e.length?ar("zero_points",12,e[3].dims.length):void 0;l&&o.push(l);let d=x.length,f=or("output",e[0].dataType,d,h),_=Yn(e[0].dataType),w=(()=>{switch(c){case 1:return`array<${_}, 8>`;case 2:return`mat4x2<${_}>`;case 4:return`mat2x4<${_}>`;default:throw new Error(`${c}-component is not supported.`)}})();return`\\n        var<workgroup> workgroup_shared: array<${f.type.value}, ${m*g}>;\\n        ${n.declareVariables(...o,f)}\\n        ${n.mainStart([g,1,1])}\\n          let output_indices = ${f.offsetToIndices(`(global_idx / 64) * ${m}`)};\\n          let col = output_indices[2];\\n          let row = output_indices[1];\\n          let batch = output_indices[0];\\n          let nBlocksPerCol = uniforms.b_shape[1];\\n\\n          for (var block = local_id.x; block < nBlocksPerCol; block += 64) {\\n            //process one block\\n            var word_offset: u32 = block * ${t.blockSize/c};\\n            ${(()=>{let e=`\\n            var col_index = col * ${h};\\n            ${l?"\\n            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;\\n            var zero_point_byte_count: u32;\\n            var zero_point_word_index: u32;\\n            var zero_point_byte_offset: u32;\\n            let zero_point_nibble_offset: u32 = block & 0x1u;\\n            var zero_point_bits_offset: u32;\\n            var zero_point_word: u32;":`\\n            // The default zero point is 8 for unsigned 4-bit quantization.\\n            let zero_point = ${_}(8);`}\\n            `;for(let t=0;t<h*m;t++)e+=`\\n            let scale${t} = ${a.getByOffset("col_index * nBlocksPerCol + block")};\\n            ${l?`\\n            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);\\n            zero_point_word_index = zero_point_byte_count >> 0x2u;\\n            zero_point_byte_offset = zero_point_byte_count & 0x3u;\\n            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\\n            zero_point_word = ${l.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;\\n            let zero_point${t} = ${_}((zero_point_word) & 0xFu);`:""}\\n            col_index += 1;`;return e})()}\\n            for (var word: u32 = 0; word < ${u}; word += ${p}) {\\n              ${(()=>{let e=`col_index = col * ${h};`;for(let t=0;t<h*m;t++)e+=`\\n            let b${t}_data = ${i.getByIndices(`${i.type.indices}(col_index, block, word)`)};\\n            col_index += 1;`;return e+=`\\n            var b_value: u32;\\n            let b_mask: u32 = 0x0F0F0F0Fu;\\n            var b_value_lower: vec4<u32>;\\n            var b_value_upper: vec4<u32>;\\n            var b_quantized_values: ${w};\\n            var b_dequantized_values: ${w};`,e})()}\\n              for (var i: u32 = 0; i < ${p}; i++) {\\n                ${(()=>{let e=`\\n          // reuse a data\\n            var input_offset = ${s.indicesToOffset(`${s.type.indices}(batch, row, word_offset)`)};\\n            var a_data: ${w};\\n            for (var j: u32 = 0; j < ${8/c}; j++) {\\n              a_data[j] = ${s.getByOffset("input_offset")};\\n              input_offset++;\\n            }\\n          `;for(let t=0;t<h*m;t++)e+=`\\n            b_value = ${1===p?`b${t}_data`:`b${t}_data[i]`};\\n            b_value_lower = unpack4xU8(b_value & b_mask);\\n            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);\\n            b_quantized_values = ${w}(${Array.from({length:4},((e,t)=>`${_}(b_value_lower[${t}]), ${_}(b_value_upper[${t}])`)).join(", ")});\\n            b_dequantized_values = ${1===c?`${w}(${Array.from({length:8},((e,n)=>`(b_quantized_values[${n}] - ${l?`zero_point${t}`:"zero_point"}) * scale${t}`)).join(", ")});`:`(b_quantized_values - ${w}(${Array(8).fill(l?`zero_point${t}`:"zero_point").join(",")})) * scale${t};`};\\n            workgroup_shared[local_id.x * ${m} + ${Math.floor(t/h)}]${h>1?`[${t%h}]`:""} += ${Array.from({length:8/c},((e,t)=>""+(1===c?`a_data[${t}] * b_dequantized_values[${t}]`:`dot(a_data[${t}], b_dequantized_values[${t}])`))).join(" + ")};\\n          `;return e})()}\\n                word_offset += ${8/c};\\n              }\\n            }\\n          }\\n          workgroupBarrier();\\n\\n          if (local_id.x < ${m}) {\\n            var output_value: ${f.type.value} = ${f.type.value}(0);\\n            var workgroup_shared_offset: u32 = local_id.x;\\n            for (var b: u32 = 0u; b < 64u; b++) {\\n              output_value += workgroup_shared[workgroup_shared_offset];\\n              workgroup_shared_offset += ${m};\\n            }\\n            ${f.setByIndices(`${f.type.indices}(batch, row, col + local_id.x)`,"output_value")};\\n          }\\n        }`}}},yl=(e,t)=>{let n=e[0].dims,r=n.length,s=n[r-2],i=t.k,a=t.n,o=n.slice(0,r-2),l=Wn.size(o),u=e[1].dims[2]/4,d=e[0].dataType,c=er(t.k),p=er(u),h=o.concat([s,a]),f=a%8==0?8:a%4==0?4:1,m=128/f,_=m*p*8,g=_/c,w=_/t.blockSize,y=Wn.size(h)/f,b=[],x=[l,s,i/c],v=Wn.convertShape(e[1].dims).slice();v.splice(-1,1,u/p),b.push(...Jn(x)),b.push(...Jn(v)),b.push(...Jn(e[2].dims)),4===e.length&&b.push(...Jn(Wn.convertShape(e[3].dims)));let $=[l,s,a];b.push(...Jn($));return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${t.blockSize};${c};${p};${m};${f}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:h,dataType:d}],dispatchGroup:{x:y},programUniforms:b}),getShaderSource:n=>{let r=x.length,s=ar("a",e[0].dataType,r,c),i=ar("b",12,v.length,p),a=ar("scales",e[2].dataType,e[2].dims.length),o=[s,i,a],l=4===e.length?ar("zero_points",12,e[3].dims.length):void 0;l&&o.push(l);let u=$.length,d=or("output",e[0].dataType,u),h=Yn(e[0].dataType);return`\\n        var<workgroup> sub_a: array<${s.type.value}, ${g}>;\\n        var<workgroup> inter_results: array<array<${d.type.value}, ${m}>, ${f}>;\\n        ${n.declareVariables(...o,d)}\\n        ${n.mainStart([m,f,1])}\\n          let output_indices = ${d.offsetToIndices(`workgroup_index * ${f}`)};\\n          let col = output_indices[2];\\n          let row = output_indices[1];\\n          let batch = output_indices[0];\\n          let n_blocks_per_col = uniforms.b_shape[1];\\n          let num_tiles =  (n_blocks_per_col - 1) / ${w} + 1;\\n\\n          // Loop over shared dimension.\\n          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {\\n            let a_col_start = tile * ${g};\\n            // load one tile A data into shared memory.\\n            for (var a_offset = local_idx; a_offset < ${g}; a_offset += 128)\\n            {\\n              let a_col = a_col_start + a_offset;\\n              if (a_col < uniforms.a_shape[2])\\n              {\\n                sub_a[a_offset] = ${s.getByIndices(`${s.type.indices}(batch, row, a_col)`)};\\n              } else {\\n                sub_a[a_offset] = ${s.type.value}(0);\\n              }\\n            }\\n            workgroupBarrier();\\n\\n            // each thread process one block\\n            let b_row = col + local_id.y;\\n            let block = tile * ${w} + local_id.x;\\n            ${l?`\\n            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;\\n            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);\\n            let zero_point_word_index = zero_point_byte_count >> 0x2u;\\n            let zero_point_byte_offset = zero_point_byte_count & 0x3u;\\n            let zero_point_nibble_offset: u32 = block & 0x1u;\\n            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\\n            let zero_point_word = ${l.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;\\n            let zero_point = ${h}((zero_point_word) & 0xFu);`:`\\n            // The default zero point is 8 for unsigned 4-bit quantization.\\n            let zero_point = ${h}(8);`}\\n            let scale = ${a.getByOffset("b_row * n_blocks_per_col + block")};\\n            let b_data = ${i.getByIndices(`${i.type.indices}(b_row, block, 0)`)};\\n            var word_offset = local_id.x * ${t.blockSize/c};\\n            for (var i: u32 = 0; i < ${p}; i++) {\\n              ${(()=>{switch(c){case 1:return`\\n          let a_data0 = vec4<${h}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);\\n          let a_data1 = vec4<${h}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`\\n          let a_data0 = vec4<${h}>(sub_a[word_offset], sub_a[word_offset + 1]);\\n          let a_data1 = vec4<${h}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return"\\n          let a_data0 = sub_a[word_offset];\\n          let a_data1 = sub_a[word_offset + 1];";default:throw new Error(`${c}-component is not supported.`)}})()}\\n              let b_value = ${1===p?"b_data":"b_data[i]"};\\n              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);\\n              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);\\n              let b_quantized_values = mat2x4<${h}>(${Array.from({length:4},((e,t)=>`${h}(b_value_lower[${t}]), ${h}(b_value_upper[${t}])`)).join(", ")});\\n              let b_dequantized_values = (b_quantized_values - mat2x4<${h}>(${Array(8).fill("zero_point").join(",")})) * scale;\\n              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},((e,t)=>`dot(a_data${t}, b_dequantized_values[${t}])`)).join(" + ")};\\n              word_offset += ${8/c};\\n            }\\n            workgroupBarrier();\\n          }\\n\\n          if (local_idx < ${f}) {\\n            var output_value: ${d.type.value} = ${d.type.value}(0);\\n            for (var b = 0u; b < ${m}; b++) {\\n              output_value += inter_results[local_idx][b];\\n            }\\n            if (col + local_idx < uniforms.output_shape[2])\\n            {\\n              ${d.setByIndices(`${d.type.indices}(batch, row, col + local_idx)`,"output_value")}\\n            }\\n          }\\n        }`}}},bl=(e,t)=>{gl(e.inputs,t),32===t.blockSize&&e.adapterInfo.isVendor("intel")&&e.adapterInfo.isArchitecture("gen-12lp")?e.compute(yl(e.inputs,t)):e.compute(wl(e.inputs,t))},xl=e=>Un(e)})),gc=ut((()=>{vd(),Td(),Ad(),vl=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(1!==e[0].dataType&&10!==e[0].dataType)throw new Error("Input type must be float or float16.");if(e.length>=2){let t=2*e[0].dims.length===e[1].dims[0];if(4===e.length&&(t=2*e[3].dims[0]===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},$l=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`\\n            k = i32(${e.indicesGet("indices",s)}) - ${sr("uniforms.pads",s,n)};\\n            if (k < 0) {\\n              break;\\n            }\\n            if (k >= i32(${sr("uniforms.x_shape",s,t)})) {\\n              break;\\n            }\\n            offset += k * i32(${sr("uniforms.x_strides",s,t)});\\n        `;return`\\n          value = ${e.type.value}(uniforms.constant_value);\\n          for (var i = 0; i < 1; i++) {\\n            var offset = 0;\\n            var k = 0;\\n            ${r}\\n            value = x[offset];\\n          }\\n      `},kl=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`\\n                k = i32(${e.indicesGet("indices",s)}) - ${sr("uniforms.pads",s,n)};\\n                if (k < 0) {\\n                  k = -k;\\n                }\\n                {\\n                  let _2n_1 = 2 * (i32(${sr("uniforms.x_shape",s,t)}) - 1);\\n                  k = k % _2n_1;\\n                  if(k >= i32(${sr("uniforms.x_shape",s,t)})) {\\n                    k = _2n_1 - k;\\n                  }\\n                }\\n                offset += k * i32(${sr("uniforms.x_strides",s,t)});\\n            `;return`\\n              var offset = 0;\\n              var k = 0;\\n              ${r}\\n              value = x[offset];\\n          `},El=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`\\n                k = i32(${e.indicesGet("indices",s)}) - ${sr("uniforms.pads",s,n)};\\n                if (k < 0) {\\n                  k = 0;\\n                }\\n                if (k >= i32(${sr("uniforms.x_shape",s,t)})) {\\n                  k = i32(${sr("uniforms.x_shape",s,t)}) - 1;\\n                }\\n                offset += k * i32(${sr("uniforms.x_strides",s,t)});\\n            `;return`\\n              var offset = 0;\\n              var k = 0;\\n              ${r}\\n              value = x[offset];\\n          `},Sl=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`\\n                k = i32(${e.indicesGet("indices",s)}) - ${sr("uniforms.pads",s,n)};\\n                if (k < 0)  {\\n                  k += i32(${sr("uniforms.x_shape",s,t)}]);\\n                }\\n                if (k >= i32(${sr("uniforms.x_shape",s,t)})) {\\n                  k -= i32(${sr("uniforms.x_shape",s,t)});\\n                }\\n                offset += k * i32(${sr("uniforms.x_strides",s,t)});\\n            `;return`\\n              var offset = 0;\\n              var k = 0;\\n              ${r}\\n              value = x[offset];\\n          `},zl=(e,t,n)=>{switch(n.mode){case 0:return $l(e,t,n.pads.length);case 1:return kl(e,t,n.pads.length);case 2:return El(e,t,n.pads.length);case 3:return Sl(e,t,n.pads.length);default:throw new Error("Invalid mode")}},Cl=(e,t)=>{let n=Wn.padShape(e[0].dims.slice(),t.pads),r=e[0].dims,s=[{type:12,data:Wn.size(n)},{type:6,data:t.pads}],i=e.length>=3&&e[2].data;0===t.mode&&s.push({type:i?e[2].dataType:1,data:t.value}),s.push(...Jn(e[0].dims,n));return{name:"Pad",shaderCache:{hint:`${t.mode}${i}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(Wn.size(n)/64)},programUniforms:s}),getShaderSource:s=>{let a=or("output",e[0].dataType,n.length),o=ar("x",e[0].dataType,r.length),l=o.type.value,u=zl(a,r.length,t),d=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:t.pads.length}];return 0===t.mode&&d.push({name:"constant_value",type:i?l:"f32"}),`\\n            ${s.registerUniforms(d).declareVariables(o,a)}\\n            ${s.mainStart()}\\n            ${s.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n\\n            let indices = ${a.offsetToIndices("global_idx")};\\n\\n            var value = ${l}(0);\\n            ${u}\\n            output[global_idx] = value;\\n        }`}}},Tl=(e,t)=>{if(e.length>1){let n=e[1].getBigInt64Array(),r=e.length>=3&&e[2].data?10===e[2].dataType?e[2].getUint16Array()[0]:e[2].getFloat32Array()[0]:0,s=e[0].dims.length,i=new Int32Array(2*s).fill(0);if(e.length>=4){let t=e[3].getBigInt64Array();for(let e=0;e<t.length;e++)i[Number(t[e])]=Number(n[e]),i[Number(t[e])+s]=Number(n[e+t.length])}else n.forEach(((e,t)=>i[Number(t)]=Number(e)));let a=[];return i.forEach((e=>a.push(e))),{mode:t.mode,value:r,pads:a}}return t},Al=(e,t)=>{vl(e.inputs);let n=Tl(e.inputs,t);e.compute(Cl(e.inputs,n),{inputs:[0]})}})),wc=ut((()=>{It(),vd(),Td(),Ad(),Il=e=>{if(Oe.webgpu.validateInputContent&&(!e||1!==e.length))throw new Error("Pool ops requires 1 input.")},Ml=(e,t,n)=>{let r="NHWC"===t.format,s=e.dims.slice();r&&s.splice(1,0,s.pop());let i=Object.hasOwnProperty.call(t,"dilations"),a=t.kernelShape.slice(),o=t.strides.slice(),l=i?t.dilations.slice():[],u=t.pads.slice();jn.adjustPoolAttributes(n,s,a,o,l,u);let d=jn.computePoolOutputShape(n,s,o,l,a,u,t.autoPad),c=Object.assign({},t);i?Object.assign(c,{kernelShape:a,strides:o,pads:u,dilations:l,cacheKey:t.cacheKey}):Object.assign(c,{kernelShape:a,strides:o,pads:u,cacheKey:t.cacheKey});let p=d.slice();return p.push(p.splice(1,1)[0]),[c,r?p:d]},Ol=(e,t)=>{let n="NHWC"===t.format,r=[{type:12,data:Wn.size(e)},{type:12,data:Wn.size(t.kernelShape)}],s=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let e=t.kernelShape[t.kernelShape.length-1],n=t.strides[t.strides.length-1],i=t.pads[t.pads.length/2-1],a=t.pads[t.pads.length-1],o=!!(i+a);r.push({type:12,data:e},{type:12,data:n},{type:12,data:i},{type:12,data:a}),s.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let l=!1;if(2===t.kernelShape.length){let e=t.kernelShape[t.kernelShape.length-2],n=t.strides[t.strides.length-2],i=t.pads[t.pads.length/2-2],a=t.pads[t.pads.length-2];l=!!(i+a),r.push({type:12,data:e},{type:12,data:n},{type:12,data:i},{type:12,data:a}),s.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[r,s,!0,o,l]}{if(n)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let e=Wn.computeStrides(t.kernelShape);return r.push({type:12,data:e},{type:12,data:t.pads},{type:12,data:t.strides}),s.push({name:"kernelStrides",type:"u32",length:e.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length}),[r,s,!!t.pads.reduce(((e,t)=>e+t)),!1,!1]}},Bl=(e,t,n,r,s,i,a,o,l,u,d,c)=>{let p="NHWC"===s.format,h=t.type.value,f=or("output",t.type.tensor,r);if(s.kernelShape.length<=2){let r="",u="",m="",_=n-(p?2:1);if(r=d?`\\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\\n                  xIndices[${_}] = indices[${_}] * uniforms.sw - uniforms.pwStart + i;\\n                  if (xIndices[${_}] < 0 || xIndices[${_}]\\n                      >= uniforms.x_shape[${_}]) {\\n                    pad++;\\n                    continue;\\n                  }\\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\\n                  ${i}\\n                }`:`\\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\\n                  xIndices[${_}] = indices[${_}] * uniforms.sw - uniforms.pwStart + i;\\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\\n                  ${i}\\n                }`,2===s.kernelShape.length){let e=n-(p?3:2);u=c?`\\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\\n                  xIndices[${e}] = indices[${e}] * uniforms.sh - uniforms.phStart + j;\\n                  if (xIndices[${e}] < 0 || xIndices[${e}] >= uniforms.x_shape[${e}]) {\\n                    pad += i32(uniforms.kw);\\n                    continue;\\n                  }\\n              `:`\\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\\n                  xIndices[${e}] = indices[${e}] * uniforms.sh - uniforms.phStart + j;\\n                `,m="\\n              }\\n            "}return`\\n            ${e.registerUniforms(l).declareVariables(t,f)}\\n\\n            ${e.mainStart()}\\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n\\n              let indices = ${f.offsetToIndices("global_idx")};\\n              var xIndices = ${f.offsetToIndices("global_idx")};\\n\\n              var value = ${h}(${o});\\n              var pad = 0;\\n              ${u}\\n              ${r}\\n              ${m}\\n              ${a}\\n\\n              output[global_idx] = value;\\n            }`}{if(p)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let r=s.kernelShape.length,d=s.pads.length,c="";return c=u?`\\n                if (xIndices[j] >= uniforms.x_shape[j]) {\\n                  pad++;\\n                  isPad = true;\\n                  break;\\n                }\\n              }\\n              if (!isPad) {\\n                let x_val = x[${t.indicesToOffset("xIndices")}];\\n                ${i}\\n              }`:`\\n              }\\n              let x_val = x[${t.indicesToOffset("xIndices")}];\\n              ${i}\\n            `,`\\n            ${e.registerUniforms(l).declareVariables(t,f)}\\n\\n            ${e.mainStart()}\\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n              let indices = ${f.offsetToIndices("global_idx")};\\n              var xIndices = ${f.offsetToIndices("global_idx")};\\n\\n              var offsets: array<u32, ${r}>;\\n\\n              var value = ${h}(${o});\\n              var pad = 0;\\n              var isPad = false;\\n\\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\\n                var offset = i;\\n                for (var j = 0u; j < ${r-1}u; j++) {\\n                  offsets[j] = offset / ${sr("uniforms.kernelStrides","j",r)};\\n                  offset -= offsets[j] * ${sr("uniforms.kernelStrides","j",r)};\\n                }\\n                offsets[${r-1}] = offset;\\n\\n                isPad = false;\\n                for (var j = ${n-r}u; j < ${n}u; j++) {\\n                  xIndices[j] = indices[j] * ${sr("uniforms.strides",`j - ${n-r}u`,r)}\\n                    + offsets[j - ${n-r}u] - ${sr("uniforms.pads","j - 2u",d)};\\n                  ${c}\\n              }\\n              ${a}\\n\\n              output[global_idx] = value;\\n            }`}},Nl=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,Pl=e=>`${Nl(e)};${e.countIncludePad}`,Rl=e=>`${Nl(e)};${e.storageOrder};${e.dilations}`,Dl=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Ll=(e,t,n,r)=>{let[s,i]=Ml(t,r,n),a=ar("x",t.dataType,t.dims.length),o=a.type.value,l="";s.countIncludePad?l+=`value /= ${o}(uniforms.kernelSize);`:l+=`value /= ${o}(i32(uniforms.kernelSize) - pad);`;let[u,d,c,p,h]=Ol(i,s);u.push(...Jn(t.dims,i));return{name:e,shaderCache:{hint:`${r.cacheKey};${c};${p};${h}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(Wn.size(i)/64)},programUniforms:u}),getShaderSource:e=>Bl(e,a,t.dims.length,i.length,s,"value += x_val;",l,0,d,c,p,h)}},Fl=e=>{let t=0!==e.count_include_pad,n=Dl(e);if(0!==n.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let r={countIncludePad:t,...n,cacheKey:""};return{...r,cacheKey:Pl(r)}},Ul=(e,t)=>{Il(e.inputs),e.compute(Ll("AveragePool",e.inputs[0],!1,t))},ql={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},Vl=e=>{let t=e.format;return{format:t,...ql,cacheKey:t}},Wl=(e,t)=>{Il(e.inputs),e.compute(Ll("GlobalAveragePool",e.inputs[0],!0,t))},jl=(e,t,n,r)=>{let[s,i]=Ml(t,r,n),a=ar("x",t.dataType,t.dims.length),[o,l,u,d,c]=Ol(i,s);return o.push(...Jn(t.dims,i)),{name:e,shaderCache:{hint:`${r.cacheKey};${u};${d};${c}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(Wn.size(i)/64)},programUniforms:o}),getShaderSource:e=>Bl(e,a,t.dims.length,i.length,s,"\\n      value = max(x_val, value);\\n    ","",10===t.dataType?-65504:-1e5,l,u,d,c)}},Gl=(e,t)=>{Il(e.inputs),e.compute(jl("MaxPool",e.inputs[0],!1,t))},Hl=e=>{let t=e.storage_order,n=e.dilations,r=Dl(e);if(0!==t)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==r.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let s={storageOrder:t,dilations:n,...r,cacheKey:""};return{...s,cacheKey:Rl(s)}},Kl=e=>{let t=e.format;return{format:t,...ql,cacheKey:t}},Xl=(e,t)=>{Il(e.inputs),e.compute(jl("GlobalMaxPool",e.inputs[0],!0,t))}})),yc=ut((()=>{vd(),Td(),Cd(),Ad(),Ql=(e,t)=>{if(e.length<2||e.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(3===e.length&&e[1].dims===e[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(6===e[0].dataType&&e.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(0!==e[1].dims.length&&1!==e[1].dims.length&&e[1].dims.length!==e[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(e.length>2){if(e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(e[1].dims.length!==e[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!e[1].dims.map(((t,n)=>t===e[2].dims[n])).reduce(((e,t)=>e&&t),!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(t.blockSize>0){if(0===e[1].dims.length||1===e[1].dims.length&&1===e[1].dims[0])throw new Error("blockSize must be set only for block quantization.");if(!e[1].dims.map(((n,r)=>r===t.axis||n===e[0].dims[r])).reduce(((e,t)=>e&&t),!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(e[1].dims.length!==e[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let n=e[0].dims[t.axis],r=e[1].dims[t.axis];if(t.blockSize<Math.ceil(n/r)||t.blockSize>Math.ceil(n/(r-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},Yl=(e,t)=>{let n=Wn.normalizeAxis(t.axis,e[0].dims.length),r=e[0].dataType,s=3===r,i=e[0].dims,a=e[1].dataType,o=Wn.size(i),l=3===r||2===r,u=l?[Math.ceil(Wn.size(e[0].dims)/4)]:e[0].dims,d=e[1].dims,c=e.length>2?e[2]:void 0,p=c?l?[Math.ceil(Wn.size(c.dims)/4)]:c.dims:void 0,h=0===d.length||1===d.length&&1===d[0],f=!1===h&&1===d.length,m=er(o),_=h&&(!l||4===m),g=_?m:1,w=_&&!l?m:1,y=ar("input",l?12:r,u.length,w),b=ar("scale",a,d.length),x=c?ar("zero_point",l?12:r,p.length):void 0,v=or("output",a,i.length,g),$=[y,b];x&&$.push(x);let k=[u,d];c&&k.push(p);let E=[{type:12,data:o/g},{type:12,data:n},{type:12,data:t.blockSize},...Jn(...k,i)];return{name:"DequantizeLinear",shaderCache:{hint:t.cacheKey,inputDependencies:x?["rank","rank","rank"]:["rank","rank"]},getShaderSource:e=>`\\n      ${e.registerUniforms([{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}]).declareVariables(...$,v)}\\n      ${e.mainStart()}\\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n          let output_indices = ${v.offsetToIndices("global_idx")};\\n\\n          // Set input x\\n          ${l?`\\n            let input = ${y.getByOffset("global_idx / 4")};\\n            let x_vec = ${s?"unpack4xI8(input)":"unpack4xU8(input)"};\\n            let x_value = ${1===g?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${y.getByOffset("global_idx")};`};\\n\\n          // Set scale input\\n          ${h?`let scale_value= ${b.getByOffset("0")}`:f?`\\n            let scale_index = ${v.indicesGet("output_indices","uniforms.axis")};\\n            let scale_value= ${b.getByOffset("scale_index")};`:`\\n            var scale_indices: ${b.type.indices} = output_indices;\\n            let index = ${b.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;\\n            ${b.indicesSet("scale_indices","uniforms.axis","index")};\\n            let scale_value= ${b.getByIndices("scale_indices")};`};\\n\\n          // Set zero-point input\\n          ${x?h?l?`\\n                let zero_point_input = ${x.getByOffset("0")};\\n                let zero_point_vec =  ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\\n                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${x.getByOffset("0")}`:f?l?`\\n                let zero_point_index = ${v.indicesGet("output_indices","uniforms.axis")};\\n                let zero_point_input = ${x.getByOffset("zero_point_index / 4")};\\n                let zero_point_vec =  ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\\n                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`\\n                let zero_point_index = ${v.indicesGet("output_indices","uniforms.axis")};\\n                let zero_point_value = ${x.getByOffset("zero_point_index")};`:l?`\\n                let zero_point_offset = ${b.indicesToOffset("scale_indices")};\\n                let zero_point_input = ${x.getByOffset("zero_point_offset / 4")};\\n                let zero_point_vec = ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\\n                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${x.getByIndices("scale_indices")};`:`let zero_point_value = ${l?s?"i32":"u32":y.type.value}(0);`};\\n      // Compute and write output\\n      ${v.setByOffset("global_idx",`${v.type.value}(x_value - zero_point_value) * scale_value`)};\\n      }`,getRunData:()=>({outputs:[{dims:i,dataType:a}],dispatchGroup:{x:Math.ceil(o/g/64),y:1,z:1},programUniforms:E})}},Zl=(e,t)=>{Ql(e.inputs,t),e.compute(Yl(e.inputs,t))},Jl=e=>Un({axis:e.axis,blockSize:e.blockSize})})),bc=ut((()=>{It(),vd(),Ad(),eu=(e,t,n)=>{if(e===t||e<t&&n<0||e>t&&n>0)throw new Error("Range these inputs\' contents are invalid.")},tu=(e,t,n,r)=>{let s=Math.abs(Math.ceil((t-e)/n)),i=[s],a=s,o=[{type:12,data:a},{type:r,data:e},{type:r,data:n},...Jn(i)];return{name:"Range",shaderCache:{hint:`${r}`},getShaderSource:e=>{let t=or("output",r,i.length),n=t.type.value,s=[{name:"outputSize",type:"u32"},{name:"start",type:n},{name:"delta",type:n}];return`\\n        ${e.registerUniforms(s).declareVariables(t)}\\n        ${e.mainStart()}\\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n        output[global_idx] = uniforms.start + ${n}(global_idx) * uniforms.delta;\\n      }`},getRunData:()=>({outputs:[{dims:i,dataType:r}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:o})}},nu=e=>{let t=0,n=0,r=0;6===e.inputs[0].dataType?(t=e.inputs[0].getInt32Array()[0],n=e.inputs[1].getInt32Array()[0],r=e.inputs[2].getInt32Array()[0]):1===e.inputs[0].dataType&&(t=e.inputs[0].getFloat32Array()[0],n=e.inputs[1].getFloat32Array()[0],r=e.inputs[2].getFloat32Array()[0]),Oe.webgpu.validateInputContent&&eu(t,n,r),e.compute(tu(t,n,r,e.inputs[0].dataType),{inputs:[]})}})),xc=ut((()=>{vd(),Td(),Cd(),Ad(),ru=(e,t,n,r)=>{if("none"!==e&&"i32"!==r&&"u32"!==r&&"f32"!==r)throw new Error(`Input ${r} is not supported with reduction ${e}.`);let s="{\\n                var oldValue = 0;\\n                loop {\\n                  let newValueF32 =",i=`;\\n                  let newValue = bitcast<i32>(newValueF32);\\n                  let res = atomicCompareExchangeWeak(&${t}, oldValue, newValue);\\n                  if res.exchanged {\\n                    break;\\n                  }\\n                  oldValue = res.old_value;\\n                }\\n              }`;switch(e){case"none":return`${t}=${n};`;case"add":return"i32"===r||"u32"===r?`atomicAdd(&${t}, bitcast<${r}>(${n}));`:`\\n              ${s}bitcast<${r}>(oldValue) + (${n})${i}`;case"max":return"i32"===r||"u32"===r?`atomicMax(&${t}, bitcast<${r}>(${n}));`:`\\n                ${s}max(bitcast<f32>(oldValue), (${n}))${i}`;case"min":return"i32"===r||"u32"===r?`atomicMin(&${t}, bitcast<${r}>(${n}));`:`${s}min(bitcast<${r}>(oldValue), (${n}))${i}`;case"mul":return`${s}(bitcast<${r}>(oldValue) * (${n}))${i}`;default:throw new Error(`Reduction ${e} is not supported.`)}},su=(e,t)=>{let n=e[0].dims,r=e[1].dims,s=n,i=Math.ceil(Wn.size(r)/1),a=r[r.length-1],o=Wn.sizeFromDimension(n,a),l=[{type:12,data:i},{type:12,data:a},{type:12,data:o},...Jn(e[1].dims,e[2].dims,s)];return{name:"ScatterND",shaderCache:{hint:`${t.cacheKey}_${t.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:l}),getShaderSource:n=>{let r=ar("indices",e[1].dataType,e[1].dims.length),i=ar("updates",e[2].dataType,e[2].dims.length,1),a="none"!==t.reduction&&""!==t.reduction?lr("output",e[0].dataType,s.length):or("output",e[0].dataType,s.length,1);return`\\n      ${n.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(r,i,a)}\\n      ${n.mainStart()}\\n        ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n  var data_offset = 0u;\\n  let indices_start = uniforms.last_index_dimension * global_idx;\\n  let indices_end = indices_start + uniforms.last_index_dimension;\\n  for (var i = indices_start; i < indices_end; i++) {\\n    var index = i32(indices[i].x);\\n    ${1===e[0].dims.length?"\\n    let element_count_dim = uniforms.output_strides;\\n    let dim_value = uniforms.output_shape;":"\\n    let element_count_dim = uniforms.output_strides[i - indices_start];\\n    let dim_value = uniforms.output_shape[i - indices_start + uniforms.last_index_dimension];"}\\n    if (index >= 0) {\\n      if (index >= i32(dim_value)) {\\n        index = i32(dim_value - 1);\\n      }\\n    } else {\\n      if (index < -i32(dim_value)) {\\n        index = 0;\\n      } else {\\n        index += i32(dim_value);\\n      }\\n    }\\n    data_offset += u32((u32(index) * element_count_dim));\\n  }\\n\\n  for (var i = 0u; i < uniforms.num_updates_elements; i++) {\\n    let value = updates[uniforms.num_updates_elements * global_idx + i];\\n    ${ru(t.reduction,"output[data_offset + i]","value",a.type.value)}\\n  }\\n\\n      }`}}},iu=e=>Un({reduction:e.reduction}),au=(e,t)=>{e.compute(su(e.inputs,t),{inputs:[e.inputs[1],e.inputs[2]],outputs:[]})}})),vc=ut((()=>{vd(),Td(),Cd(),Ad(),ou=(e,t)=>{if(e.every((e=>e>0||(()=>{throw new Error("Resize requires scales input values to be positive")}))),e.length>0)if("linear"===t.mode){if(!(2===e.length||3===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]||5===e.length&&1===e[0]&&1===e[1]))throw new Error("For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1")}else if("cubic"===t.mode&&!(2===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")},lu=(e,t,n)=>{t.every((e=>e>=0&&e<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")})));let r=new Array(n).fill(1);return t.forEach(((t,n)=>r[t]=e[n])),r},uu=(e,t,n,r,s,i)=>{let[a,o,l]=n>10?[1,2,3]:[-1,e.length>1?1:-1,-1],u=e[0].dims.length;if(a>0&&e.length>a&&e[a].dims.length>0)e[a].getFloat32Array().forEach((e=>i.push(e)));else if("tf_crop_and_resize"===t.coordinateTransformMode)throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(o>0&&e.length>o&&1===e[o].dims.length&&e[o].dims[0]>0){if(e[o].getFloat32Array().forEach((e=>r.push(e))),0!==r.length&&r.length!==u&&n>=18&&r.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");ou(r,t),t.axes.length>0&&lu(r,t.axes,u).forEach(((e,t)=>r[t]=e))}if(l>0&&e.length>l&&1===e[l].dims.length&&e[l].dims[0]>0&&(e[l].getBigInt64Array().forEach((e=>s.push(Number(e)))),0!==s.length&&s.length!==u&&n>=18&&s.length!==t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(0!==r.length&&r.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(0!==s.length&&s.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof r<"u"&&typeof s<"u"&&r.length>0&&s.length>u)throw new Error("Resize requires only of scales or sizes to be specified")},du=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case"asymmetric":return`return ${t}(xResized) / ${t}(xScale);`;case"pytorch_half_pixel":return`if (lengthResized > 1) {\\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\\n                  } else {\\n                    return 0.0;\\n                  }`;case"tf_half_pixel_for_nn":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case"align_corners":return`if (lengthResized == 1) {\\n                    return 0.0;\\n                  } else {\\n                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating\\n                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\\n                    // offset-by-one error later in floor().\\n                    let whole = ${t}(xResized * (lengthOriginal - 1) / (lengthResized - 1));\\n                    let fract =\\n                        ${t}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${t}(lengthResized - 1);\\n                    return whole + fract;\\n                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {\\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\\n                        ${t}(lengthResized - 1);\\n                  } else {\\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\\n                  }`;case"half_pixel_symmetric":return`const outputWidth = ${t}xScale * ${t}(lengthResized);\\n                  const adjustment = ${t}(lengthResized) / outputWidth;\\n                  const center = ${t}(lengthOriginal) / 2;\\n                  const offset = center * (1 - adjustment);\\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case"half_pixel":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",cu=(e,t,n)=>`fn getNearestPixelFromOriginal(xOriginal: ${n}, isDownSample: bool) -> ${n} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",pu=(e,t,n)=>{let r=new Array(n).fill(0).concat(new Array(n).fill(1)),s=0===e.length?r:e.slice();return t.length>0?(t.forEach(((e,i)=>{r[e]=s[i],r[i+n]=s[t.length+i]})),r):s},hu=(e,t,n,r)=>{let s=[];if(n.length>0)if(r.length>0){if(e.forEach((e=>s.push(e))),Math.max(...r)>e.length)throw new Error("axes is out of bound");r.forEach(((e,t)=>s[e]=n[t]))}else n.forEach((e=>s.push(e)));else{if(0===t.length)throw new Error("Resize requires either scales or sizes.");s=e.map(((e,n)=>Math.round(e*t[n])))}return s},fu=(e,t,n)=>{let r=(()=>{switch(n.keepAspectRatioPolicy){case"not_larger":return n.axes.length>0?Math.min(...n.axes.map((e=>t[e])),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return n.axes.length>0?Math.max(...n.axes.map((e=>t[e])),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${n.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let s=e.slice();return n.axes.length>0?(n.axes.forEach((e=>t[e]=r)),n.axes.forEach((n=>s[n]=Math.round(e[n]*t[n])))):(t.fill(r,0,t.length),s.forEach(((e,n)=>s[n]=Math.round(e*t[n])))),s},mu=(e,t,n,r,s)=>`\\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${n.length}> {\\n      var original_indices: array<${e.type.value}, ${n.length}>;\\n      for (var i:u32 = 0; i < ${n.length}; i++) {\\n        var output_index = ${e.indicesGet("output_indices","i")};\\n        var scale = ${sr("uniforms.scales","i",r)};\\n        var roi_low = ${sr("uniforms.roi","i",s)};\\n        var roi_hi = ${sr("uniforms.roi",`i + ${t.length}`,s)};\\n        if (scale == 1.0) {\\n          original_indices[i] = ${e.type.value}(output_index);\\n        } else {\\n          var input_shape_i = ${sr("uniforms.input_shape","i",t.length)};\\n          var output_shape_i = ${sr("uniforms.output_shape","i",n.length)};\\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\\n                                                                           input_shape_i, roi_low, roi_hi);\\n        }\\n      }\\n      return original_indices;\\n    }`,_u=(e,t,n,r,s,i,a)=>`\\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\\n      var input_indices: ${e.type.indices};\\n      for (var i:u32 = 0; i < ${r.length}; i++) {\\n        var output_index = ${t.indicesGet("output_indices","i")};\\n        var input_index: u32;\\n        var scale = ${sr("uniforms.scales","i",s)};\\n        if (scale == 1.0) {\\n          input_index = output_index;\\n        } else {\\n          var roi_low = ${sr("uniforms.roi","i",i)};\\n          var roi_hi = ${sr("uniforms.roi",`i + ${n.length}`,i)};\\n          var input_shape_i = ${sr("uniforms.input_shape","i",n.length)};\\n          var output_shape_i = ${sr("uniforms.output_shape","i",r.length)};\\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\\n                                                                        input_shape_i, roi_low, roi_hi);\\n          if (!${a} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\\n            if (original_idx < 0) {\\n              input_index = 0;\\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\\n              input_index = input_shape_i - 1;\\n            } else {\\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\\n            }\\n          } else {\\n            input_index = u32(original_idx);\\n          }\\n        }\\n        ${e.indicesSet("input_indices","i"," input_index")}\\n      }\\n      return input_indices;\\n    }`,gu=(e,t)=>`\\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\\n      for (var i:u32 = 0; i < ${t.length}; i++) {\\n        var input_index = ${e.indicesGet("input_indices","i")};\\n        if (input_index < 0 || input_index >= ${sr("uniforms.input_shape","i",t.length)}) {\\n          return false;\\n        }\\n      }\\n      return true;\\n    }`,wu=(e,t,n,r)=>e.rank>r?`\\n    ${e.indicesSet("input_indices",t,"channel")};\\n    ${e.indicesSet("input_indices",n,"batch")};\\n`:"",yu=(e,t,n,r,s)=>{let[i,a,o,l]=2===n.length?[-1,0,1,-1]:[0,2,3,1],u=e.type.value;return`\\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${u} {\\n      var input_indices: ${e.type.indices};\\n      ${e.indicesSet("input_indices",a,`max(0, min(row, ${n[a]} - 1))`)};\\n      ${e.indicesSet("input_indices",o,`max(0, min(col, ${n[o]} - 1))`)};\\n      ${wu(e,l,i,2)}\\n      return ${e.getByIndices("input_indices")};\\n    }\\n\\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${u} {\\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\\n      var row:${u} = originalIndices[${a}];\\n      var col:${u} = originalIndices[${o}];\\n      ${r?`if (row < 0 || row > (${n[a]} - 1) || col < 0 || col > (${n[o]} - 1)) {\\n        return ${s};\\n      }`:""};\\n      row = max(0, min(row, ${n[a]} - 1));\\n      col = max(0, min(col, ${n[o]} - 1));\\n      var row1: u32 = u32(row);\\n      var col1: u32 = u32(col);\\n      var row2: u32 = u32(row + 1);\\n      var col2: u32 = u32(col + 1);\\n      var channel: u32 = ${n.length>2?`u32(originalIndices[${l}])`:"0"};\\n      var batch: u32 =  ${n.length>2?`u32(originalIndices[${i}])`:"0"};\\n      var x11: ${u} = getInputValue(batch, channel, row1, col1);\\n      var x12: ${u} = getInputValue(batch, channel, row1, col2);\\n      var x21: ${u} = getInputValue(batch, channel, row2, col1);\\n      var x22: ${u} = getInputValue(batch, channel, row2, col2);\\n      var dx1: ${u} = abs(row - ${u}(row1));\\n      var dx2: ${u} = abs(${u}(row2) - row);\\n      var dy1: ${u} = abs(col - ${u}(col1));\\n      var dy2: ${u} = abs(${u}(col2) - col);\\n      if (row1 == row2) {\\n        dx1 = 0.5;\\n        dx2 = 0.5;\\n      }\\n      if (col1 == col2) {\\n        dy1 = 0.5;\\n        dy2 = 0.5;\\n      }\\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\\n    }`},bu=(e,t,n,r,s,i,a,o,l,u)=>{let d=2===n.length,[c,p]=d?[0,1]:[2,3],h=e.type.value,f=a=>{let d=a===c?"row":"col";return`\\n      fn ${d}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${h} {\\n        var output_index = ${t.indicesGet("output_indices",a)};\\n        var originalIdx: ${h} = getOriginalCoordinateFromResizedCoordinate(output_index, ${s[a]},\\n        ${r[a]}, ${n[a]}, ${i[a]}, ${i[a]} + ${n.length});\\n        var fractOriginalIdx: ${h} = originalIdx - floor(originalIdx);\\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\\n\\n        if (${o} && (originalIdx < 0 || originalIdx > (${n[a]} - 1))) {\\n          return ${l};\\n        }\\n        var data: array<${h}, 4> = array<${h}, 4>(0.0, 0.0, 0.0, 0.0);\\n        for (var i: i32 = -1; i < 3; i++) {\\n          var ${d}: ${h} = originalIdx + ${h}(i);\\n          if (${d} < 0 || ${d} >= ${n[a]}) {\\n            ${u?"coefs[i + 1] = 0.0;\\n                        continue;":o?`return ${l};`:`${d} = max(0, min(${d}, ${n[a]} - 1));`};\\n          }\\n        var input_indices_copy: ${e.type.indices} = input_indices;\\n          ${e.indicesSet("input_indices_copy",a,`u32(${d})`)};\\n          data[i + 1] = ${a===c?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};\\n        }\\n        return cubicInterpolation1D(data, coefs);\\n      }`};return`\\n    ${f(c)};\\n    ${f(p)};\\n  fn getCubicInterpolationCoefs(s: ${h}) -> array<${h}, 4> {\\n    var absS = abs(s);\\n    var coeffs: array<${h}, 4> = array<${h}, 4>(0.0, 0.0, 0.0, 0.0);\\n    var oneMinusAbsS: ${h} = 1.0 - absS;\\n    var twoMinusAbsS: ${h} = 2.0 - absS;\\n    var onePlusAbsS: ${h} = 1.0 + absS;\\n    coeffs[0] = ((${a} * onePlusAbsS - 5 * ${a}) * onePlusAbsS + 8 * ${a}) * onePlusAbsS - 4 * ${a};\\n    coeffs[1] = ((${a} + 2) * absS - (${a} + 3)) * absS * absS + 1;\\n    coeffs[2] = ((${a} + 2) * oneMinusAbsS - (${a} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\\n    coeffs[3] = ((${a} * twoMinusAbsS - 5 * ${a}) * twoMinusAbsS + 8 * ${a}) * twoMinusAbsS - 4 * ${a};\\n    return coeffs;\\n  }\\n\\n  fn cubicInterpolation1D(x: array<${h}, 4>, coefs: array<${h}, 4>) -> ${h} {\\n    var coefsSum: ${h} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\\n  }\\n\\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${h} {\\n    var input_indices: ${e.type.indices} = output_indices;\\n    return colCubicInterpolation(input_indices, output_indices);\\n  }\\n    `},xu=(e,t,n,r,s)=>{let[i,a,o,l,u]=3===n.length?[-1,0,1,2,-1]:[0,2,3,4,1],d=e.type.value;return`\\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${d} {\\n      var input_indices: ${e.type.indices};\\n      ${e.indicesSet("input_indices",a,`max(0, min(depth, ${n[a]} - 1))`)};\\n      ${e.indicesSet("input_indices",o,`max(0, min(height, ${n[o]} - 1))`)};\\n      ${e.indicesSet("input_indices",l,`max(0, min(width, ${n[l]} - 1))`)};\\n      ${wu(e,u,i,3)}\\n      return ${e.getByIndices("input_indices")};\\n    }\\n\\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${d} {\\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\\n      var depth:${d} = originalIndices[${a}];\\n      var height:${d} = originalIndices[${o}];\\n      var width:${d} = originalIndices[${l}];\\n      ${r?`if (depth < 0 || depth > (${n[a]} - 1) || height < 0 || height > (${n[o]} - 1) || width < 0 || (width > ${n[l]} - 1)) {\\n      return ${s};\\n        }`:""};\\n\\n    depth = max(0, min(depth, ${n[a]} - 1));\\n      height = max(0, min(height, ${n[o]} - 1));\\n      width = max(0, min(width, ${n[l]} - 1));\\n      var depth1: u32 = u32(depth);\\n      var height1: u32 = u32(height);\\n      var width1: u32 = u32(width);\\n      var depth2: u32 = u32(depth + 1);\\n      var height2: u32 = u32(height + 1);\\n      var width2: u32 = u32(width + 1);\\n      var channel: u32 = ${n.length>3?`u32(originalIndices[${u}])`:"0"};\\n      var batch: u32 =  ${n.length>3?`u32(originalIndices[${i}])`:"0"};\\n\\n      var x111: ${d} = getInputValue(batch, channel, depth1, height1, width1);\\n      var x112: ${d} = getInputValue(batch, channel, depth1, height1, width2);\\n      var x121: ${d} = getInputValue(batch, channel, depth1, height2, width1);\\n      var x122: ${d} = getInputValue(batch, channel, depth1, height2, width2);\\n      var x211: ${d} = getInputValue(batch, channel, depth2, height1, width1);\\n      var x212: ${d} = getInputValue(batch, channel, depth2, height1, width2);\\n      var x221: ${d} = getInputValue(batch, channel, depth2, height2, width1);\\n      var x222: ${d} = getInputValue(batch, channel, depth2, height2, width2);\\n      var dx1: ${d} = abs(depth - ${d}(depth1));\\n      var dx2: ${d} = abs(${d}(depth2) - depth);\\n      var dy1: ${d} = abs(height - ${d}(height1));\\n      var dy2: ${d} = abs(${d}(height2) - height);\\n      var dz1: ${d} = abs(width - ${d}(width1));\\n      var dz2: ${d} = abs(${d}(width2) - width);\\n      if (depth1 == depth2) {\\n        dx1 = 0.5;\\n        dx2 = 0.5;\\n      }\\n      if (height1 == height2) {\\n        dy1 = 0.5;\\n        dy2 = 0.5;\\n      }\\n      if (width1 == width2) {\\n        dz1 = 0.5;\\n        dz2 = 0.5;\\n      }\\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\\n    }`},vu=(e,t,n,r,s,i)=>{let a=e.dims,o=pu(i,t.axes,a.length),l=hu(a,r,s,t.axes),u=r.slice();0===r.length&&(u=a.map(((e,t)=>0===e?1:l[t]/e)),"stretch"!==t.keepAspectRatioPolicy&&(l=fu(a,u,t)));let d=or("output",e.dataType,l.length),c=ar("input",e.dataType,a.length),p=Wn.size(l),h=a.length===l.length&&a.every(((e,t)=>e===l[t])),f="tf_crop_and_resize"===t.coordinateTransformMode,m=t.extrapolationValue,_=c.type.value;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${n}|${u.length>0?u:""}|${s.length>0?s:""}|${o.length>0?o:""}|${h}|${a}`,inputDependencies:["rank"]},getShaderSource:e=>`\\n      ${h?"":`\\n      ${du(t.coordinateTransformMode,_)};\\n      ${(()=>{switch(t.mode){case"nearest":return`\\n              ${gu(c,a)};\\n              ${cu(t.nearestMode,n,_)};\\n              ${_u(c,d,a,l,u.length,o.length,f)};\\n              `;case"linear":return`\\n              ${mu(d,a,l,u.length,o.length)};\\n              ${(()=>{if(2===a.length||4===a.length)return`${yu(c,d,a,f,m)}`;if(3===a.length||5===a.length)return`${xu(c,d,a,f,m)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};\\n            `;case"cubic":return`\\n            ${(()=>{if(2===a.length||4===a.length)return`${bu(c,d,a,l,u,o,t.cubicCoeffA,f,t.extrapolationValue,t.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};\\n            `;default:throw Error("Invalid resize mode")}})()};\\n      `}\\n      ${e.registerUniform("output_size","u32").registerUniform("scales","f32",u.length).registerUniform("roi","f32",o.length).declareVariables(c,d)}\\n      ${e.mainStart()}\\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n        ${h?"output[global_idx] = input[global_idx];":`\\n        let output_indices = ${d.offsetToIndices("global_idx")};\\n        var input_indices: ${c.type.indices};\\n        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\\n                if (checkInputIndices(input_indices)) {\\n                  output[global_idx] = ${c.getByIndices("input_indices")};\\n                } else {\\n                  output[global_idx] = ${t.extrapolationValue};\\n                }`;case"linear":return`output[global_idx] = ${2===a.length||4===a.length?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\\n`}\\n      }`,getRunData:()=>({outputs:[{dims:l,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:[{type:12,data:p},{type:1,data:u},{type:1,data:o},...Jn(a,l)]})}},$u=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},ku=(e,t)=>{let n=[],r=[],s=[],i=$u(e);if(0!==t.antialias)throw Error("Only default value (0) for Antialias attribute is supported");uu(e.inputs,t,i,n,r,s),e.compute(vu(e.inputs[0],t,i,n,r,s),{inputs:[0]})},Eu=e=>{let t=e.antialias,n=e.axes,r=e.coordinateTransformMode,s=e.cubicCoeffA,i=0!==e.excludeOutside,a=e.extrapolationValue,o=e.keepAspectRatioPolicy,l=e.mode,u=""===e.nearestMode?"simple":e.nearestMode;return Un({antialias:t,axes:n,coordinateTransformMode:r,cubicCoeffA:s,excludeOutside:i,extrapolationValue:a,keepAspectRatioPolicy:o,mode:l,nearestMode:u})}})),$c=ut((()=>{vd(),Td(),Cd(),Ad(),Su=(e,t)=>{let[n,r,s,i]=e,{numHeads:a,rotaryEmbeddingDim:o}=t;if(3!==n.dims.length&&4!==n.dims.length)throw new Error(`Input \'x\' is expected to have 3 or 4 dimensions, got ${n.dims.length}`);if(!Wn.areEqual(r.dims,[])&&!Wn.areEqual(r.dims,[1])&&2!==r.dims.length)throw new Error(`Input \'position_ids\' is expected to have 0, 1, or 2 dimensions, got ${r.dims.length}`);if(2!==s.dims.length)throw new Error(`Input \'cos_cache\' is expected to have 2 dimensions, got ${s.dims.length}`);if(2!==i.dims.length)throw new Error(`Input \'sin_cache\' is expected to have 2 dimensions, got ${i.dims.length}`);if(!Wn.areEqual(s.dims,i.dims))throw new Error("Inputs \'cos_cache\' and \'sin_cache\' are expected to have the same shape");if(o>0&&0===a)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let l=n.dims[0],u=n.dims[n.dims.length-2],d=s.dims[0],c=Wn.sizeFromDimension(n.dims,1)/u,p=0===o?2*s.dims[1]:c/a;if(o>p)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(2===r.dims.length){if(l!==r.dims[0])throw new Error(`Input \'position_ids\' dimension 0 should be of size batch_size, got ${r.dims[0]}`);if(u!==r.dims[1])throw new Error(`Input \'position_ids\' dimension 1 should be of size sequence_length, got ${r.dims[1]}`)}if(p/2!==s.dims[1]&&o/2!==s.dims[1])throw new Error(`Input \'cos_cache\' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${s.dims[1]}`);if(u>d)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},zu=(e,t)=>{let{interleaved:n,numHeads:r,rotaryEmbeddingDim:s,scale:i}=t,a=e[0].dims[0],o=Wn.sizeFromDimension(e[0].dims,1),l=e[0].dims[e[0].dims.length-2],u=o/l,d=e[2].dims[1],c=0===s?2*d:u/r,p=new Array(a,l,u/c,c-d),h=Wn.computeStrides(p),f=[{type:1,data:i},{type:12,data:p},{type:12,data:h},...3===e[0].dims.length?new Array({type:12,data:[o,u,c,1]}):[],...4===e[0].dims.length?new Array({type:12,data:[o,c,l*c,1]}):[],...Jn(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)];return{name:"RotaryEmbedding",shaderCache:{hint:Un({interleaved:n}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:t=>{let r=ar("input",e[0].dataType,e[0].dims.length),s=ar("position_ids",e[1].dataType,e[1].dims.length),i=ar("cos_cache",e[2].dataType,e[2].dims.length),a=ar("sin_cache",e[3].dataType,e[3].dims.length),o=or("output",e[0].dataType,e[0].dims.length);return t.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:p.length},{name:"global_strides",type:"u32",length:h.length},{name:"input_output_strides",type:"u32",length:h.length}]),`\\n        ${t.declareVariables(r,s,i,a,o)}\\n\\n        ${t.mainStart(Xn)}\\n          let half_rotary_emb_dim = uniforms.${i.name}_shape[1];\\n          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;\\n          let size = uniforms.global_shape[0] * uniforms.global_strides[0];\\n          ${t.guardAgainstOutOfBoundsWorkgroupSizes("size")}\\n\\n          if (bsnh[3] < half_rotary_emb_dim) {\\n            let position_ids_idx =\\n                ${s.broadcastedIndicesToOffset("bsnh.xy",or("",s.type.tensor,2))};\\n            let position_id =\\n                u32(${s.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);\\n            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${n});\\n            let j = i + select(half_rotary_emb_dim, 1, ${n});\\n            let re = ${r.getByOffset("i")} * ${i.get("position_id","bsnh[3]")} -\\n                ${r.getByOffset("j")} * ${a.get("position_id","bsnh[3]")};\\n            ${o.setByOffset("i","re")}\\n            let im = ${r.getByOffset("i")} * ${a.get("position_id","bsnh[3]")} +\\n                ${r.getByOffset("j")} * ${i.get("position_id","bsnh[3]")};\\n            ${o.setByOffset("j","im")}\\n          } else {\\n            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;\\n            ${o.setByOffset("k",r.getByOffset("k"))}\\n          }\\n        }`},getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(Wn.size(p)/Xn)},programUniforms:f})}},Cu=(e,t)=>{Su(e.inputs,t),e.compute(zu(e.inputs,t))}})),kc=ut((()=>{vd(),Td(),Ad(),Tu=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],n=e[1],r=e[2];if(t.dataType!==n.dataType||t.dataType!==r.dataType)throw new Error("All inputs must have the same data type");if(3!==t.dims.length&&2!==t.dims.length)throw new Error("Input must be 2D or 3D");if(3!==n.dims.length&&2!==n.dims.length)throw new Error("Skip must be 2D or 3D");let s=t.dims[t.dims.length-1],i=t.dims[t.dims.length-2];if(n.dims[n.dims.length-1]!==s)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==i)throw new Error("Skip must have the same sequence length as input");if(1!==r.dims.length)throw new Error("Gamma must be 1D");if(r.dims[r.dims.length-1]!==s)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let t=e[3];if(1!==t.dims.length)throw new Error("Beta must be 1D");if(t.dims[t.dims.length-1]!==s)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let t=e[4];if(1!==t.dims.length)throw new Error("Bias must be 1D");if(t.dims[t.dims.length-1]!==s)throw new Error("Bias must have the same hidden size as input")}},Au=(e,t,n,r)=>{let s=t.simplified,i=e[0].dims,a=Wn.size(i),o=i,l=a,u=i.slice(-1)[0],d=r?i.slice(0,-1).concat(1):[],c=!s&&e.length>3,p=e.length>4,h=r&&n>1,f=r&&n>2,m=n>3,_=64,g=er(u),w=[{type:12,data:l},{type:12,data:g},{type:12,data:u},{type:1,data:t.epsilon}],y=[{dims:o,dataType:e[0].dataType}];return n>1&&y.push({dims:d,dataType:1}),n>2&&y.push({dims:d,dataType:1}),n>3&&y.push({dims:i,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${g};${h};${f};${m}`,inputDependencies:e.map(((e,t)=>"type"))},getShaderSource:t=>{let n=[ar("x",e[0].dataType,e[0].dims,g),ar("skip",e[1].dataType,e[1].dims,g),ar("gamma",e[2].dataType,e[2].dims,g)];c&&n.push(ar("beta",e[3].dataType,e[3].dims,g)),p&&n.push(ar("bias",e[4].dataType,e[4].dims,g)),n.push(or("output",e[0].dataType,o,g)),h&&n.push(or("mean_output",1,d)),f&&n.push(or("inv_std_output",1,d)),m&&n.push(or("input_skip_bias_sum",e[0].dataType,o,g));let r=Yn(e[0].dataType),i=Yn(1,g);return`\\n\\n      ${t.registerUniforms([{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}]).declareVariables(...n)}\\n      var<workgroup> sum_shared : array<${i}, 64>;\\n      var<workgroup> sum_squared_shared : array<${i}, 64>;\\n\\n      ${t.mainStart([_,1,1])}\\n        let ix = local_id.x;\\n        let iy = global_id.x / 64;\\n\\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\\n        var stride = hidden_size_vectorized / 64;\\n        let offset = ix * stride + iy * hidden_size_vectorized;\\n        let offset1d = stride * ix;\\n        if (ix == 63) {\\n          stride = hidden_size_vectorized - stride * ix;\\n        }\\n        for (var i: u32 = 0; i < stride; i++) {\\n          let skip_value = skip[offset + i];\\n          let bias_value = ${p?"bias[offset1d + i]":r+"(0.0)"};\\n          let input_value = x[offset + i];\\n          let value = input_value + skip_value + bias_value;\\n          ${m?"input_skip_bias_sum[offset + i] = value;":""}\\n          output[offset + i] = value;\\n          let f32_value = ${nr(r,g,"value")};\\n          sum_shared[ix] += f32_value;\\n          sum_squared_shared[ix] += f32_value * f32_value;\\n        }\\n        workgroupBarrier();\\n\\n        var reduce_size : u32 = 64;\\n        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {\\n          reduce_size = curr_size + (reduce_size & 1);\\n          if (ix < curr_size) {\\n            sum_shared[ix] += sum_shared[ix + reduce_size];\\n            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];\\n          }\\n          workgroupBarrier();\\n        }\\n\\n        let sum = sum_shared[0];\\n        let square_sum = sum_squared_shared[0];\\n        let mean = ${rr("sum",g)} / f32(uniforms.hidden_size);\\n        let inv_std_dev = inverseSqrt(${rr("square_sum",g)} / f32(uniforms.hidden_size) ${s?"":"- mean * mean"} + uniforms.epsilon);\\n        ${h?"mean_output[global_idx] = mean;":""}\\n        ${f?"inv_std_output[global_idx] = inv_std_dev;":""}\\n\\n        for (var i: u32 = 0; i < stride; i++) {\\n          output[offset + i] = (output[offset + i] ${s?"":`- ${r}(mean)`}) *\\n            ${r}(inv_std_dev) * gamma[offset1d + i]\\n            ${c?"+ beta[offset1d + i]":""};\\n        }\\n      }`},getRunData:()=>({outputs:y,dispatchGroup:{x:Math.ceil(l/u)},programUniforms:w})}},Iu=(e,t)=>{Tu(e.inputs);let n=[0];e.outputCount>1&&n.push(-3),e.outputCount>2&&n.push(-3),e.outputCount>3&&n.push(3),e.compute(Au(e.inputs,t,e.outputCount,!1),{outputs:n})}})),Ec=ut((()=>{vd(),Td(),Cd(),Ad(),Mu=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(0!==t.axes.length){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach(((t,n)=>{if(6!==e[n+1].dataType&&7!==e[n+1].dataType)throw new Error(`Input ${n} must be an array of int32 or int64`)}))},Ou=(e,t)=>{let n=[];if(e.length>t)if(7===e[t].dataType)e[t].getBigInt64Array().forEach((e=>n.push(Number(e))));else{if(6!==e[t].dataType)throw new Error(`Input ${t} must be an array of int32 or int64`);e[t].getInt32Array().forEach((e=>n.push(Number(e))))}return n},Bu=(e,t)=>{if(e.length>1){let t=Ou(e,1),n=Ou(e,2),r=Ou(e,3);return 0===r.length&&(r=[...Array(e[0].dims.length).keys()]),Un({starts:t,ends:n,axes:r})}return t},Nu=(e,t,n,r,s)=>{let i=e;return e<0&&(i+=n[r[t]]),s[t]<0?Math.max(0,Math.min(i,n[r[t]]-1)):Math.max(0,Math.min(i,n[r[t]]))},Pu=(e,t,n)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\\n          var input_indices: ${e.type.indices};\\n          var carry = 0u;\\n          for (var i = ${n.length}; i >= 0; i--) {\\n            let input_shape_i = ${sr("uniforms.input_shape","i",n.length)};\\n            let steps_i = ${sr("uniforms.steps","i",n.length)};\\n            let signs_i = ${sr("uniforms.signs","i",n.length)};\\n            let starts_i = ${sr("uniforms.starts","i",n.length)};\\n            var output_index = ${t.indicesGet("output_indices","i")};\\n            var input_index = output_index * steps_i + starts_i + carry;\\n            carry = input_index / input_shape_i;\\n            input_index = input_index % input_shape_i;\\n            if (signs_i < 0) {\\n              input_index = input_shape_i - input_index - 1u + starts_i;\\n            }\\n            ${e.indicesSet("input_indices","i","input_index")};\\n          }\\n          return input_indices;\\n      }`,Ru=(e,t)=>{let n=e[0].dims,r=Wn.size(n),s=t.axes.length>0?Wn.normalizeAxes(t.axes,n.length):[...Array(n.length).keys()],i=Ou(e,4);i.forEach((e=>0!==e||(()=>{throw new Error("step cannot be 0")}))),0===i.length&&(i=Array(s.length).fill(1));let a=t.starts.map(((e,t)=>Nu(e,t,n,s,i))),o=t.ends.map(((e,t)=>Nu(e,t,n,s,i)));if(s.length!==a.length||s.length!==o.length)throw new Error("start, ends and axes should have the same number of elements");if(s.length!==n.length)for(let e=0;e<n.length;++e)s.includes(e)||(a.splice(e,0,0),o.splice(e,0,n[e]),i.splice(e,0,1));let l=i.map((e=>Math.sign(e)));i.forEach(((e,t,n)=>{if(e<0){let r=(o[t]-a[t])/e,s=a[t],l=s+r*i[t];a[t]=l,o[t]=s,n[t]=-e}}));let u=n.slice(0);s.forEach(((e,t)=>{u[e]=Math.ceil((o[e]-a[e])/i[e])}));let d={dims:u,dataType:e[0].dataType},c=or("output",e[0].dataType,u.length),p=ar("input",e[0].dataType,e[0].dims.length),h=Wn.size(u),f=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:a.length},{name:"signs",type:"i32",length:l.length},{name:"steps",type:"u32",length:i.length}],m=[{type:12,data:h},{type:12,data:a},{type:6,data:l},{type:12,data:i},...Jn(e[0].dims,u)];return{name:"Slice",shaderCache:{hint:`${l.length}_${a.length}_${i.length}`,inputDependencies:["rank"]},getShaderSource:e=>`\\n      ${e.registerUniforms(f).declareVariables(p,c)}\\n        ${Pu(p,c,n)}\\n        ${e.mainStart()}\\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n          let output_indices = ${c.offsetToIndices("global_idx")};\\n          let input_indices = calculateInputIndices(output_indices);\\n          ${c.setByOffset("global_idx",p.getByIndices("input_indices"))}\\n      }`,getRunData:()=>({outputs:[d],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:m})}},Du=(e,t)=>{Mu(e.inputs,t);let n=Bu(e.inputs,t);e.compute(Ru(e.inputs,n),{inputs:[0]})},Lu=e=>{let t=e.starts,n=e.ends,r=e.axes;return Un({starts:t,ends:n,axes:r})}})),Sc=ut((()=>{vd(),Td(),Cd(),Id(),Ad(),Fu=e=>{if(!e||1!==e.length)throw new Error("Softmax op requires 1 input.")},Uu=(e,t)=>{let n,r=e.inputs[0],s=r.dims,i=Wn.size(s),a=s.length,o=Wn.normalizeAxis(t.axis,a),l=o<s.length-1,u=[];l?(u=Array.from({length:a},((e,t)=>t)),u[o]=a-1,u[a-1]=o,n=e.compute(wr(r,u),{inputs:[r],outputs:[-1]})[0]):n=r;let d=n.dims,c=d[a-1],p=i/c,h=er(c),f=c/h,m=64;1===p&&(m=256);let _=ar("x",n.dataType,n.dims,h),g=or("result",n.dataType,n.dims,h),w=_.type.value,y="f32"===Yn(n.dataType)?`var threadMax = ${w}(-3.402823e+38f);`:`var threadMax = ${w}(-65504.0h);`,b=e.compute({name:"Softmax",shaderCache:{hint:`${h};${m}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:d,dataType:n.dataType}],dispatchGroup:{x:p},programUniforms:[{type:6,data:f}]}),getShaderSource:e=>`\\n      var<workgroup> rowMaxShared : ${w};\\n      var<workgroup> rowSumShared : ${w};\\n      var<workgroup> threadShared : array<${w}, ${m}>;\\n\\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${w} {\\n        let index = row * row_stride + col;\\n        return x[index];\\n      }\\n\\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${w}) {\\n        let index = row * row_stride + col;\\n        result[index] = value;\\n      }\\n      ${e.registerUniform("packedCols","i32").declareVariables(_,g)}\\n      ${e.mainStart(m)}\\n        let gindex = i32(global_idx);\\n        let lindex = i32(local_idx);\\n        const wg = ${m};\\n        let row = gindex / wg;\\n        let cols = uniforms.packedCols;\\n        let row_stride : i32 = uniforms.packedCols;\\n\\n        // find the rows max\\n        ${y}\\n        for (var col = lindex; col < cols; col += wg) {\\n          let value = getValue(row, col, row_stride);\\n          threadMax = max(threadMax, value);\\n        }\\n        if (lindex < cols) {\\n          threadShared[lindex] = threadMax;\\n        }\\n        workgroupBarrier();\\n\\n        var reduceSize = min(cols, wg);\\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\\n          reduceSize = currSize + (reduceSize & 1);\\n          if (lindex < currSize) {\\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\\n          }\\n          workgroupBarrier();\\n        }\\n        if (lindex == 0) {\\n          rowMaxShared = ${w}(${((e,t)=>4===t?`max(max(${e}.x, ${e}.y), max(${e}.z, ${e}.w))`:2===t?`max(${e}.x, ${e}.y)`:3===t?`max(max(${e}.x, ${e}.y), ${e}.z)`:e)("threadShared[0]",h)});\\n        }\\n        workgroupBarrier();\\n\\n        // find the rows sum\\n        var threadSum = ${w}(0.0);\\n        for (var col = lindex; col < cols; col += wg) {\\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\\n          threadSum += subExp;\\n        }\\n        threadShared[lindex] = threadSum;\\n        workgroupBarrier();\\n\\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\\n          if (lindex < currSize) {\\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\\n          }\\n          workgroupBarrier();\\n        }\\n        if (lindex == 0) {\\n          rowSumShared = ${w}(${rr("threadShared[0]",h)});\\n        }\\n        workgroupBarrier();\\n\\n        // calculate final value for each element in the row\\n        for (var col = lindex; col < cols; col += wg) {\\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\\n          setValue(row, col, row_stride, value);\\n        }\\n      }`},{inputs:[n],outputs:[l?-1:0]})[0];l&&e.compute(wr(b,u),{inputs:[b]})},qu=(e,t)=>{Fu(e.inputs),Uu(e,t)},Vu=e=>Un({axis:e.axis})})),zc=ut((()=>{vd(),Td(),Ad(),Wu=e=>Array.from(e.getBigInt64Array(),Number),ju=e=>{if(!e||2!==e.length)throw new Error("Tile requires 2 inputs.");if(1!==e[0].dataType&&10!==e[0].dataType&&6!==e[0].dataType&&12!==e[0].dataType)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(7!==e[1].dataType)throw new Error("Tile `repeats` input should be of int64 data type");if(1!==e[1].dims.length)throw new Error("Tile `repeats` input should be 1-D");if(Wu(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Gu=(e,t)=>{let n=[];for(let r=0;r<e.length;++r)n.push(e[r]*t[r]);return n},Hu=(e,t)=>{let n=e[0].dims,r=t??Wu(e[1]),s=Gu(n,r),i=Wn.size(s),a=e[0].dataType,o=ar("input",a,n.length),l=or("output",a,s.length);return{name:"Tile",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:12,data:i},...Jn(e[0].dims,s)]}),getShaderSource:e=>`\\n      const inputShape = ${o.indices(...n)};\\n      ${e.registerUniform("output_size","u32").declareVariables(o,l)}\\n      ${e.mainStart()}\\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n      let output_indices = ${l.offsetToIndices("global_idx")};\\n      var input_indices: ${o.type.indices};\\n      for (var i = 0; i < ${n.length}; i++) {\\n        let input_dim_i = ${o.indicesGet("uniforms.input_shape","i")};\\n        let input_dim_value = ${l.indicesGet("output_indices","i")}  % input_dim_i;\\n\\n        ${o.indicesSet("input_indices","i","input_dim_value")}\\n      }\\n      ${l.setByOffset("global_idx",o.getByIndices("input_indices"))}\\n    }`}},Ku=e=>{ju(e.inputs),e.compute(Hu(e.inputs),{inputs:[0]})}})),Cc=ut((()=>{vd(),Td(),Ad(),Xu=(e,t,n,r,s)=>{let i,a=or("output_data",s,n.length,4),o=ar("a_data",t[1].dataType,t[1].dims.length,4),l=ar("b_data",t[2].dataType,t[2].dims.length,4),u=ar("c_data",t[0].dataType,t[0].dims.length,4),d=(e,t,n)=>`select(${t}, ${e}, ${n})`;if(r){let e=(e,t,n="")=>{let r=`a_data[index_a${t}][component_a${t}]`,s=`b_data[index_b${t}][component_b${t}]`,i=`bool(c_data[index_c${t}] & (0xffu << (component_c${t} * 8)))`;return`\\n            let output_indices${t} = ${a.offsetToIndices(`global_idx * 4u + ${t}u`)};\\n            let offset_a${t} = ${o.broadcastedIndicesToOffset(`output_indices${t}`,a)};\\n            let offset_b${t} = ${l.broadcastedIndicesToOffset(`output_indices${t}`,a)};\\n            let offset_c${t} = ${u.broadcastedIndicesToOffset(`output_indices${t}`,a)};\\n            let index_a${t} = offset_a${t} / 4u;\\n            let index_b${t} = offset_b${t} / 4u;\\n            let index_c${t} = offset_c${t} / 4u;\\n            let component_a${t} = offset_a${t} % 4u;\\n            let component_b${t} = offset_b${t} % 4u;\\n            let component_c${t} = offset_c${t} % 4u;\\n            ${e}[${t}] = ${n}(${d(r,s,i)});\\n          `};i=9===s?`\\n            var data = vec4<u32>(0);\\n            ${e("data",0,"u32")}\\n            ${e("data",1,"u32")}\\n            ${e("data",2,"u32")}\\n            ${e("data",3,"u32")}\\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\\n            ${e("output_data[global_idx]",0)}\\n            ${e("output_data[global_idx]",1)}\\n            ${e("output_data[global_idx]",2)}\\n            ${e("output_data[global_idx]",3)}\\n          `}else i=a.setByOffset("global_idx",d(o.getByOffset("global_idx"),l.getByOffset("global_idx"),u.getByOffset("global_idx")));return`\\n        ${e.registerUniform("vec_size","u32").declareVariables(u,o,l,a)}\\n        ${e.mainStart()}\\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\\n        ${i}\\n      }`},Qu=e=>{let t=e[1].dims,n=e[2].dims,r=e[0].dims,s=e[1].dataType,i=!(Wn.areEqual(t,n)&&Wn.areEqual(n,r)),a=t,o=Wn.size(t);if(i){let e=Vn.calcShape(Vn.calcShape(t,n,!1),r,!1);if(!e)throw new Error("Can\'t perform where op on the given tensors");a=e,o=Wn.size(a)}let l=Math.ceil(o/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:t=>Xu(t,e,a,i,s),getRunData:()=>({outputs:[{dims:a,dataType:s}],dispatchGroup:{x:Math.ceil(o/64/4)},programUniforms:[{type:12,data:l},...Jn(r,t,n,a)]})}},Yu=e=>{e.compute(Qu(e.inputs))}})),Tc=ut((()=>{Bd(),Nd(),Pd(),Rd(),Ld(),Fd(),Ud(),Qd(),Zd(),Jd(),ec(),tc(),nc(),rc(),sc(),ic(),ac(),oc(),lc(),uc(),pc(),hc(),fc(),mc(),_c(),dc(),gc(),wc(),yc(),bc(),xc(),Od(),vc(),$c(),kc(),Ec(),Sc(),cc(),zc(),Id(),Dd(),Cc(),Zu=new Map([["Abs",[Ns]],["Acos",[Ps]],["Acosh",[Rs]],["Add",[Ai]],["ArgMax",[_s,gs]],["ArgMin",[ms,gs]],["Asin",[Ds]],["Asinh",[Ls]],["Atan",[Fs]],["Atanh",[Us]],["Attention",[Es]],["AveragePool",[Ul,Fl]],["BatchNormalization",[Ts]],["BiasAdd",[Ms]],["BiasSplitGelu",[Si]],["Cast",[Vs,qs]],["Ceil",[Gs]],["Clip",[js]],["Concat",[Wi,ji]],["Conv",[Ta,Ea]],["ConvTranspose",[La,Na]],["Cos",[Hs]],["Cosh",[Ks]],["CumSum",[Ua,qa]],["DepthToSpace",[Ga,Ha]],["DequantizeLinear",[Zl,Jl]],["Div",[Ii]],["Einsum",[no,ro]],["Elu",[Qs,Xs]],["Equal",[Mi]],["Erf",[Zs]],["Exp",[Js]],["Expand",[lo]],["FastGelu",[co]],["Floor",[ei]],["FusedConv",[Ta,Ea]],["Gather",[mo,fo]],["GatherElements",[So,Eo]],["GatherBlockQuantized",[xo,vo]],["GatherND",[go,wo]],["Gelu",[ti]],["Gemm",[Ao,To]],["GlobalAveragePool",[Wl,Vl]],["GlobalMaxPool",[Xl,Kl]],["Greater",[Pi]],["GreaterOrEqual",[Di]],["GridSample",[qo,Vo]],["GroupQueryAttention",[ol]],["HardSigmoid",[ui,li]],["InstanceNormalization",[cl]],["LayerNormalization",[fl]],["LeakyRelu",[ni,Xs]],["Less",[Ri]],["LessOrEqual",[Li]],["Log",[bi]],["MatMul",[_l]],["MatMulNBits",[bl,xl]],["MaxPool",[Gl,Hl]],["Mul",[Oi]],["MultiHeadAttention",[Qo,Go]],["Neg",[si]],["Not",[ri]],["Pad",[Al]],["Pow",[Bi]],["QuickGelu",[$i,Xs]],["Range",[nu]],["Reciprocal",[ii]],["ReduceMin",[us]],["ReduceMean",[ss]],["ReduceMax",[ls]],["ReduceSum",[cs]],["ReduceProd",[ds]],["ReduceL1",[is]],["ReduceL2",[as]],["ReduceLogSum",[hs]],["ReduceLogSumExp",[os]],["ReduceSumSquare",[ps]],["Relu",[ai]],["Resize",[ku,Eu]],["RotaryEmbedding",[Cu]],["ScatterND",[au,iu]],["Sigmoid",[oi]],["Sin",[di]],["Sinh",[ci]],["Slice",[Du,Lu]],["SkipLayerNormalization",[Iu]],["Split",[nl,rl]],["Sqrt",[pi]],["Softmax",[qu,Vu]],["Sub",[Ni]],["Tan",[hi]],["Tanh",[mi]],["ThresholdedRelu",[yi,Xs]],["Tile",[Ku]],["Transpose",[yr,br]],["Where",[Yu]]])})),Ac=ut((()=>{It(),kd(),Ad(),Ju=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n,r,s){Ze(e.programInfo.name);let i=this.backend.device,a=this.backend.getComputePassEncoder();this.backend.writeTimestamp(2*this.backend.pendingDispatchNumber);let o=[];for(let e of t)o.push({binding:o.length,resource:{buffer:e.buffer}});for(let e of n)o.push({binding:o.length,resource:{buffer:e.buffer}});s&&o.push({binding:o.length,resource:s});let l=i.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:o,label:e.programInfo.name});if("capturing"===this.backend.sessionStatus){let t={kernelId:this.backend.currentKernelId,computePipeline:e.computePipeline,bindGroup:l,dispatchGroup:r};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(t)}a.setPipeline(e.computePipeline),a.setBindGroup(0,l),a.dispatchWorkgroups(...r),this.backend.writeTimestamp(2*this.backend.pendingDispatchNumber+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||"at-passes"===this.backend.queryType)&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Je(e.programInfo.name)}dispose(){}build(e,t){Ze(e.name);let n=this.backend.device,r=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"},{feature:"subgroups-f16",extension:"subgroups_f16"}].forEach((e=>{n.features.has(e.feature)&&r.push(`enable ${e.extension};`)}));let s=cr(t,this.backend.device.limits),i=e.getShaderSource(s),a=`${r.join("\\n")}\\n${s.additionalImplementations}\\n${i}`,o=n.createShaderModule({code:a,label:e.name});Tn("verbose",(()=>`[WebGPU] ${e.name} shader code: ${a}`));let l=n.createComputePipeline({compute:{module:o,entryPoint:"main"},layout:"auto",label:e.name});return Je(e.name),{programInfo:e,computePipeline:l,uniformVariablesInfo:s.variablesInfo}}normalizeDispatchGroupSize(e){let t="number"==typeof e?e:e.x,n="number"==typeof e?1:e.y||1,r="number"==typeof e?1:e.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=s&&n<=s&&r<=s)return[t,n,r];let i=t*n*r,a=Math.ceil(Math.sqrt(i));if(a>s){if(a=Math.ceil(Math.cbrt(i)),a>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[a,a,a]}return[a,a,1]}}})),Ic=ut((()=>{It(),vd(),kd(),Ed(),zd(),Tc(),Ac(),ed=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let n=[];for(let r=0;r<e.length;++r){let s=e[r].dataType;switch(t[r]){case"none":n.push("");break;case"type":n.push(`${s}`);break;case"rank":{let t=e[r].dims.length;n.push(`${s};${t}`);break}case"dims":{let t=e[r].dims.join(",");n.push(`${s};${t}`);break}default:throw new Error(`unsupported input dependency: ${t[r]}`)}}return n.join("|")},td=(e,t,n)=>{let r=e.name;return e.shaderCache?.hint&&(r+="["+e.shaderCache.hint+"]"),r+=":"+n+`:${ed(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,r},nd=class{constructor(e){e&&(this.architecture=e.architecture,this.vendor=e.vendor)}isArchitecture(e){return this.architecture===e}isVendor(e){return this.vendor===e}},rd=class{constructor(e){this.subgroupsSupported=e.features.has("subgroups"),this.subgroupsF16Supported=e.features.has("subgroups");let t=e.limits;this.subgroupsSupported&&t.minSubgroupSize&&t.maxSubgroupSize?this.subgroupSizeRange=[t.minSubgroupSize,t.maxSubgroupSize]:this.subgroupSizeRange=void 0}},sd=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(null===this.currentKernelId)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e,t){this.env=e;let n=[],r={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize,maxBufferSize:t.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:t.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n},s=e=>t.features.has(e)&&n.push(e)&&!0;s("chromium-experimental-timestamp-query-inside-passes")||s("timestamp-query"),s("shader-f16"),s("subgroups")&&s("subgroups-f16"),this.device=await t.requestDevice(r),this.deviceInfo=new rd(this.device),this.adapterInfo=new nd(t.info||await t.requestAdapterInfo()),this.gpuDataManager=Ln(this),this.programManager=new Ju(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,zn(e.logLevel,!!e.debug),this.device.onuncapturederror=e=>{e.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${e.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:t,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let e=this.getCommandEncoder(),t={};"at-passes"===this.queryType&&(t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:2*this.pendingDispatchNumber,endOfPassWriteIndex:2*this.pendingDispatchNumber+1}),this.computePassEncoder=e.beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;let e;Ze(),this.endComputePass(),"none"!==this.queryType&&(this.commandEncoder.resolveQuerySet(this.querySet,0,2*this.pendingDispatchNumber,this.queryResolveBuffer,0),e=this.device.createBuffer({size:2*this.pendingDispatchNumber*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(e,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,2*this.pendingDispatchNumber*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,"none"!==this.queryType&&e.mapAsync(GPUMapMode.READ).then((()=>{let t=new BigUint64Array(e.getMappedRange()),n=this.pendingQueries.get(e);for(let e=0;e<t.length/2;e++){let r=n[e],s=r.kernelId,i=this.kernels.get(s),a=i.kernelType,o=i.kernelName,l=r.programName,u=r.inputTensorViews,d=r.outputTensorViews,c=t[2*e],p=t[2*e+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=c);let h=Number(c-this.queryTimeBase),f=Number(p-this.queryTimeBase);if(!Number.isSafeInteger(h)||!Number.isSafeInteger(f))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:u.map((e=>({dims:e.dims,dataType:mn(e.dataType)}))),outputsMetadata:d.map((e=>({dims:e.dims,dataType:mn(e.dataType)}))),kernelId:s,kernelType:a,kernelName:o,programName:l,startTime:h,endTime:f});else{let e="";u.forEach(((t,n)=>{e+=`input[${n}]: [${t.dims}] | ${mn(t.dataType)}, `}));let t="";d.forEach(((e,n)=>{t+=`output[${n}]: [${e.dims}] | ${mn(e.dataType)}, `})),console.log(`[profiling] kernel "${s}|${a}|${o}|${l}" ${e}${t}execution time: ${f-h} ns`)}Qe("GPU",`${l}::${c}::${p}`)}e.unmap(),this.pendingQueries.delete(e)})),Je()}run(e,t,n,r,s,i){Ze(e.name);let a=[];for(let e=0;e<t.length;++e){let n=t[e].data;if(0===n)continue;let r=this.gpuDataManager.get(n);if(!r)throw new Error(`no GPU data for input: ${n}`);a.push(r)}let{outputs:o,dispatchGroup:l,programUniforms:u}=e.getRunData(t),d=0===n.length?o.map(((e,t)=>t)):n;if(d.length!==o.length)throw new Error(`Output size ${d.length} must be equal to ${o.length}.`);let c,p=[],h=[];for(let e=0;e<o.length;++e){if(!Number.isInteger(d[e])||d[e]<-3||d[e]>=i)throw new Error(`Invalid output index: ${d[e]}`);if(-3===d[e])continue;let t=-1===d[e],n=-2===d[e],a=t||n?s(o[e].dataType,o[e].dims):r(d[e],o[e].dataType,o[e].dims);if(p.push(a),0===a.data)continue;let l=this.gpuDataManager.get(a.data);if(!l)throw new Error(`no GPU data for output: ${a.data}`);if(t&&this.temporaryData.push(l),n){let e=this.kernelPersistentData.get(this.currentKernelId);e||(e=[],this.kernelPersistentData.set(this.currentKernelId,e)),e.push(l)}h.push(l)}if(a.length!==t.length||h.length!==p.length){if(0===h.length)return Je(e.name),p;throw new Error(`Program ${e.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}if(u){let e=0,t=[];u.forEach((n=>{let r="number"==typeof n.data?[n.data]:n.data;if(0===r.length)return;let s,i,a=10===n.type?2:4;10===n.type?(i=r.length>4?16:r.length>2?8:r.length*a,s=r.length>4?16:a*r.length):(i=r.length<=2?r.length*a:16,s=16),e=Math.ceil(e/i)*i,t.push(e);let o=10===n.type?8:4;e+=r.length>4?Math.ceil(r.length/o)*s:r.length*a}));let n=16;e=Math.ceil(e/n)*n;let r=new ArrayBuffer(e);u.forEach(((e,n)=>{let s=t[n],i="number"==typeof e.data?[e.data]:e.data;if(6===e.type)new Int32Array(r,s,i.length).set(i);else if(12===e.type)new Uint32Array(r,s,i.length).set(i);else if(10===e.type)new Uint16Array(r,s,i.length).set(i);else{if(1!==e.type)throw new Error(`Unsupported uniform type: ${mn(e.type)}`);new Float32Array(r,s,i.length).set(i)}}));let s=this.gpuDataManager.create(e,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(s.buffer,0,r,0,e),this.gpuDataManager.release(s.id),c={offset:0,size:e,buffer:s.buffer}}let f=this.programManager.normalizeDispatchGroupSize(l),m=1===f[1]&&1===f[2],_=td(e,t,m),g=this.programManager.getArtifact(_);if(g||(g=this.programManager.build(e,f),this.programManager.setArtifact(_,g),Tn("info",(()=>`[artifact] key: ${_}, programName: ${e.name}`))),u&&g.uniformVariablesInfo){if(u.length!==g.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${g.uniformVariablesInfo.length}, got ${u.length} in program "${g.programInfo.name}".`);for(let e=0;e<u.length;e++){let t=u[e],n=t.type,r="number"==typeof t.data?1:t.data.length,[s,i]=g.uniformVariablesInfo[e];if(n!==s||r!==i)throw new Error(`Uniform variable ${e} mismatch: expect type ${s} with size ${i}, got type ${n} with size ${r} in program "${g.programInfo.name}".`)}}if(Tn("info",(()=>`[ProgramManager] run "${e.name}" (key=${_}) with ${f[0]}x${f[1]}x${f[2]}`)),"none"!==this.queryType||"capturing"===this.sessionStatus){let e={kernelId:this.currentKernelId,programName:g.programInfo.name,inputTensorViews:t,outputTensorViews:p};this.pendingKernels.push(e),"capturing"===this.sessionStatus&&this.capturedPendingKernels.get(this.currentSessionId).push(e)}return this.programManager.run(g,a,h,f,c),Je(e.name),p}upload(e,t){this.gpuDataManager.upload(e,t)}memcpy(e,t){this.gpuDataManager.memcpy(e,t)}async download(e,t){await this.gpuDataManager.download(e,t)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,t,n,r){let s=Zu.get(e);if(!s)throw new Error(`kernel not implemented: ${e}`);let i={kernelType:e,kernelName:r,kernelEntry:s[0],attributes:[s[1],n]};this.kernels.set(t,i)}releaseKernel(e){let t=this.kernelPersistentData.get(e);if(t){for(let e of t)this.gpuDataManager.release(e.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,t,n){let r=this.kernels.get(e);if(!r)throw new Error(`kernel not created: ${e}`);let s=r.kernelType,i=r.kernelName,a=r.kernelEntry,o=r.attributes;if(null!==this.currentKernelId)throw new Error(`kernel "[${s}] ${i}" is not allowed to be called recursively`);this.currentKernelId=e,o[0]&&(o[1]=o[0](o[1]),o[0]=void 0),Tn("info",(()=>`[WebGPU] Start to run kernel "[${s}] ${i}"...`));let l=this.env.debug;this.temporaryData=[];try{return l&&this.device.pushErrorScope("validation"),a(t,o[1]),0}catch(e){return n.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${i}" failed. ${e}`)),1}finally{l&&n.push(this.device.popErrorScope().then((e=>e?`GPU validation error for kernel "[${s}] ${i}": ${e.message}`:null)));for(let e of this.temporaryData)this.gpuDataManager.release(e.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,t,n,r){let s=this.sessionExternalDataMapping.get(e);s||(s=new Map,this.sessionExternalDataMapping.set(e,s));let i=s.get(t),a=this.gpuDataManager.registerExternalBuffer(n,r,i);return s.set(t,[a,n]),a}unregisterBuffers(e){let t=this.sessionExternalDataMapping.get(e);t&&(t.forEach((e=>this.gpuDataManager.unregisterExternalBuffer(e[0]))),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let t=this.gpuDataManager.get(e);if(!t)throw new Error(`no GPU data for buffer: ${e}`);return t.buffer}createDownloader(e,t,n){return async()=>{let r=await Rn(this,e,t);return An(r.buffer,n)}}writeTimestamp(e){"inside-passes"===this.queryType&&this.computePassEncoder.writeTimestamp(this.querySet,e)}setQueryType(){this.queryType="none",("default"===this.env.webgpu.profiling?.mode||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),"none"!==this.queryType&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2*this.maxDispatchNumber}),this.queryResolveBuffer=this.device.createBuffer({size:2*this.maxDispatchNumber*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){Tn("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){Tn("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){Tn("info","replay"),this.sessionStatus="replaying";let e=this.capturedCommandList.get(this.currentSessionId),t=this.capturedPendingKernels.get(this.currentSessionId),n=e.length;this.pendingKernels=[];for(let r=0;r<n;r++){let n=this.getComputePassEncoder(),s=e[r];this.writeTimestamp(2*this.pendingDispatchNumber),n.setPipeline(s.computePipeline),n.setBindGroup(0,s.bindGroup),n.dispatchWorkgroups(...s.dispatchGroup),this.writeTimestamp(2*this.pendingDispatchNumber+1),this.pendingDispatchNumber++,"none"!==this.queryType&&this.pendingKernels.push(t[r]),(this.pendingDispatchNumber>=this.maxDispatchNumber||"at-passes"===this.queryType)&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(e){this.unregisterBuffers(e),this.capturedCommandList.has(e)&&this.capturedCommandList.delete(e),this.capturedPendingKernels.has(e)&&this.capturedPendingKernels.delete(e),this.gpuDataManager.onReleaseSession(e)}onRunStart(e){this.currentSessionId=e,this.setQueryType()}}})),Mc=ut((()=>{kd(),id=1,ad=()=>id++,od=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),ld=(e,t)=>{let n=od.get(e);if(!n)throw new Error("Unsupported data type.");return t.length>0?Math.ceil(t.reduce(((e,t)=>e*t))*n/8):0},ud=class{constructor(e){this.sessionId=e.sessionId,this.mlContext=e.context,this.mlTensor=e.tensor,this.dataType=e.dataType,this.tensorShape=e.shape}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return ld(this.dataType,this.tensorShape)}destroy(){Tn("verbose",(()=>"[WebNN] TensorWrapper.destroy")),this.mlTensor.destroy()}write(e){this.mlContext.writeTensor(this.mlTensor,e)}async read(e){return e?this.mlContext.readTensor(this.mlTensor,e):this.mlContext.readTensor(this.mlTensor)}sameTypeAndShape(e,t){return this.dataType===e&&this.tensorShape.length===t.length&&this.tensorShape.every(((e,n)=>e===t[n]))}},dd=class{constructor(e,t){this.tensorManager=e,this.wrapper=t}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(e,t,n){if(this.wrapper){if(this.wrapper.sameTypeAndShape(e,t))return this.wrapper.tensor;if(n){if(this.wrapper.byteLength!==ld(e,t))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let r=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(e,t,r,!0,!0),n&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(e){if(this.wrapper){if(e.byteLength===this.wrapper.byteLength)return void this.wrapper.write(e);Tn("verbose",(()=>"Data size does not match tensor size. Releasing tensor.")),this.releaseTensor()}this.activeUpload?this.activeUpload.set(e):this.activeUpload=new Uint8Array(e)}async download(e){if(this.activeUpload)return e?void(e instanceof ArrayBuffer?new Uint8Array(e).set(this.activeUpload):new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(this.activeUpload)):this.activeUpload.buffer;if(!this.wrapper)throw new Error("Tensor has not been created.");return e?this.wrapper.read(e):this.wrapper.read()}},cd=class{constructor(e){this.backend=e,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}reserveTensorId(){let e=ad();return this.tensorTrackersById.set(e,new dd(this)),e}releaseTensorId(e){let t=this.tensorTrackersById.get(e);t&&(this.tensorTrackersById.delete(e),t.tensorWrapper&&this.releaseTensor(t.tensorWrapper))}async ensureTensor(e,t,n,r){Tn("verbose",(()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${e}, dataType: ${t}, shape: ${n}, copyOld: ${r}}`));let s=this.tensorTrackersById.get(e);if(!s)throw new Error("Tensor not found.");return s.ensureTensor(t,n,r)}upload(e,t){let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");n.upload(t)}async download(e,t){Tn("verbose",(()=>`[WebNN] TensorManager.download {tensorId: ${e}, dstBuffer: ${t?.byteLength}}`));let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");return n.download(t)}releaseTensorsForSession(e){for(let t of this.freeTensors)t.sessionId===e&&t.destroy();this.freeTensors=this.freeTensors.filter((t=>t.sessionId!==e))}registerTensor(e,t,n,r){let s=ad(),i=new ud({sessionId:this.backend.currentSessionId,context:e,tensor:t,dataType:n,shape:r});return this.tensorTrackersById.set(s,new dd(this,i)),this.externalTensors.add(i),s}async getCachedTensor(e,t,n,r,s){let i=this.backend.currentSessionId;for(let[n,r]of this.freeTensors.entries())if(r.sameTypeAndShape(e,t)){Tn("verbose",(()=>`[WebNN] Reusing tensor {dataType: ${e}, shape: ${t}}`));let r=this.freeTensors.splice(n,1)[0];return r.sessionId=i,r}let a=this.backend.currentContext;Tn("verbose",(()=>`[WebNN] MLContext.createTensor {dataType: ${e}, shape: ${t}}`));let o=await a.createTensor({dataType:e,shape:t,dimensions:t,usage:n,writable:r,readable:s});return new ud({sessionId:i,context:a,tensor:o,dataType:e,shape:t})}releaseTensor(e){this.externalTensors.has(e)&&this.externalTensors.delete(e),this.freeTensors.push(e)}},pd=(...e)=>new cd(...e)})),Oc=ut((()=>{vd(),wd(),Ed(),Mc(),kd(),hd=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),fd=(e,t)=>{if(e===t)return!0;if(void 0===e||void 0===t)return!1;let n=Object.keys(e).sort(),r=Object.keys(t).sort();return n.length===r.length&&n.every(((n,s)=>n===r[s]&&e[n]===t[n]))},md=class{constructor(e){this.tensorManager=pd(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],zn(e.logLevel,!!e.debug)}get currentSessionId(){if(void 0===this.activeSessionId)throw new Error("No active session");return this.activeSessionId}onRunStart(e){this.activeSessionId=e}async createMLContext(e){if(e instanceof GPUDevice){let t=this.mlContextCache.findIndex((t=>t.gpuDevice===e));if(-1!==t)return this.mlContextCache[t].mlContext;{let t=await navigator.ml.createContext(e);return this.mlContextCache.push({gpuDevice:e,mlContext:t}),t}}if(void 0===e){let e=this.mlContextCache.findIndex((e=>void 0===e.options&&void 0===e.gpuDevice));if(-1!==e)return this.mlContextCache[e].mlContext;{let e=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:e}),e}}let t=this.mlContextCache.findIndex((t=>fd(t.options,e)));if(-1!==t)return this.mlContextCache[t].mlContext;{let t=await navigator.ml.createContext(e);return this.mlContextCache.push({options:e,mlContext:t}),t}}get currentContext(){let e=this.getMLContext(this.currentSessionId);if(!e)throw new Error(`No MLContext found for session ${this.currentSessionId}`);return e}registerMLContext(e,t){this.mlContextBySessionId.set(e,t);let n=this.sessionIdsByMLContext.get(t);n||(n=new Set,this.sessionIdsByMLContext.set(t,n)),n.add(e)}onReleaseSession(e){let t=this.mlContextBySessionId.get(e);if(!t)return;this.tensorManager.releaseTensorsForSession(e),this.mlContextBySessionId.delete(e);let n=this.sessionIdsByMLContext.get(t);if(n.delete(e),0===n.size){this.sessionIdsByMLContext.delete(t);let e=this.mlContextCache.findIndex((e=>e.mlContext===t));-1!==e&&this.mlContextCache.splice(e,1)}}getMLContext(e){return this.mlContextBySessionId.get(e)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(e){Tn("verbose",(()=>`[WebNN] releaseTensorId {tensorId: ${e}}`)),this.tensorManager.releaseTensorId(e)}async ensureTensor(e,t,n,r){let s=hd.get(t);if(!s)throw new Error(`Unsupported ONNX data type: ${t}`);return this.tensorManager.ensureTensor(e,s,n,r)}uploadTensor(e,t){if(!rn().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");Tn("verbose",(()=>`[WebNN] uploadTensor {tensorId: ${e}, data: ${t.byteLength}}`)),this.tensorManager.upload(e,t)}async downloadTensor(e,t){return this.tensorManager.download(e,t)}createMLTensorDownloader(e,t){return async()=>{let n=await this.tensorManager.download(e);return An(n,t)}}registerMLTensor(e,t,n){let r=hd.get(t);if(!r)throw new Error(`Unsupported ONNX data type: ${t}`);let s=this.tensorManager.registerTensor(this.currentContext,e,r,n);return Tn("verbose",(()=>`[WebNN] registerMLTensor {tensor: ${e}, dataType: ${r}, dimensions: ${n}} -> {tensorId: ${s}}`)),s}registerMLConstant(e,t,n,r,s,i){if(!i)throw new Error("External mounted files are not available.");let a=e;e.startsWith("./")&&(a=e.substring(2));let o=i.get(a);if(!o)throw new Error(`File with name ${a} not found in preloaded files.`);if(t+n>o.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let l,u=o.slice(t,t+n).buffer;switch(s.dataType){case"float32":l=new Float32Array(u);break;case"float16":l=new Uint16Array(u);break;case"int32":l=new Int32Array(u);break;case"uint32":l=new Uint32Array(u);break;case"int64":l=new BigInt64Array(u);break;case"uint64":l=new BigUint64Array(u);break;case"int8":l=new Int8Array(u);break;case"int4":case"uint4":case"uint8":l=new Uint8Array(u);break;default:throw new Error(`Unsupported data type: ${s.dataType} in creating WebNN Constant from external data.`)}return Tn("verbose",(()=>`[WebNN] registerMLConstant {dataType: ${s.dataType}, shape: ${s.shape}}}`)),r.constant(s,l)}flush(){}}})),Bc={};dt(Bc,{init:()=>Rc});var Nc,Pc,Rc,Dc,Lc,Fc,Uc,qc,Vc,Wc,jc,Gc,Hc,Kc,Xc,Qc,Yc,Zc,Jc,ep,tp,np,rp,sp,ip,ap,op,lp,up,dp,cp,pp,hp,fp,mp,_p,gp=ut((()=>{vd(),Ic(),kd(),Td(),Oc(),Nc=class e{constructor(e,t,n,r){this.module=e,this.dataType=t,this.data=n,this.dims=r}getFloat32Array(){if(1!==this.dataType)throw new Error("Invalid data type");let e=Wn.size(this.dims);return 0===e?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(7!==this.dataType)throw new Error("Invalid data type");let e=Wn.size(this.dims);return 0===e?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(6!==this.dataType)throw new Error("Invalid data type");let e=Wn.size(this.dims);return 0===e?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}getUint16Array(){if(10!==this.dataType&&4!==this.dataType)throw new Error("Invalid data type");let e=Wn.size(this.dims);return 0===e?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,e)}reshape(t){if(Wn.size(t)!==Wn.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},Pc=class{constructor(e,t,n){this.module=e,this.backend=t,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=t.adapterInfo,this.deviceInfo=t.deviceInfo;let r=e.PTR_SIZE,s=n/e.PTR_SIZE,i=4===r?"i32":"i64";this.opKernelContext=Number(e.getValue(r*s++,i));let a=Number(e.getValue(r*s++,i));this.outputCount=Number(e.getValue(r*s++,i)),this.customDataOffset=Number(e.getValue(r*s++,"*")),this.customDataSize=Number(e.getValue(r*s++,i));let o=[];for(let t=0;t<a;t++){let t=Number(e.getValue(r*s++,i)),n=Number(e.getValue(r*s++,"*")),a=Number(e.getValue(r*s++,i)),l=[];for(let t=0;t<a;t++)l.push(Number(e.getValue(r*s++,i)));o.push(new Nc(e,t,n,l))}this.inputs=o}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(e,t){let n=t?.inputs?.map((e=>"number"==typeof e?this.inputs[e]:e))??this.inputs,r=t?.outputs??[];return this.backend.run(e,n,r,((e,t,n)=>new Nc(this.module,t,this.output(e,n),n)),((e,t)=>{let n=_n(e,t);if(!n)throw new Error(`Unsupported data type: ${e}`);let r=n>0?this.backend.gpuDataManager.create(n).id:0;return new Nc(this.module,e,r,t)}),this.outputCount)}output(e,t){let n=this.module.stackSave();try{let n=this.module.PTR_SIZE,r=4===n?"i32":"i64",s=this.module.stackAlloc((1+t.length)*n);this.module.setValue(s,t.length,r);for(let e=0;e<t.length;e++)this.module.setValue(s+n*(e+1),t[e],r);return this.module._JsepOutput(this.opKernelContext,e,s)}catch(n){throw new Error(`Failed to generate kernel\'s output[${e}] with dims [${t}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(n)}}},Rc=async(e,t,n,r)=>{let s=t.jsepInit;if(!s)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if("webgpu"===e){let e=new sd;await e.initialize(n,r),s("webgpu",[e,t=>e.alloc(Number(t)),t=>e.free(t),(n,r,s,i=!1)=>{if(i)Tn("verbose",(()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(n)}, dst=${Number(r)}, size=${Number(s)}`)),e.memcpy(Number(n),Number(r));else{Tn("verbose",(()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(n)}, gpuDataId=${Number(r)}, size=${Number(s)}`));let i=t.HEAPU8.subarray(Number(n>>>0),Number(n>>>0)+Number(s));e.upload(Number(r),i)}},async(n,r,s)=>{Tn("verbose",(()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${n}, dataOffset=${r}, size=${s}`)),await e.download(Number(n),(()=>t.HEAPU8.subarray(Number(r)>>>0,Number(r+s)>>>0)))},(n,r,s)=>e.createKernel(n,Number(r),s,t.UTF8ToString(t._JsepGetNodeName(Number(r)))),t=>e.releaseKernel(t),(n,r,s,i)=>{Tn("verbose",(()=>`[WebGPU] jsepRun: sessionHandle=${s}, kernel=${n}, contextDataOffset=${r}`));let a=new Pc(t,e,Number(r));return e.computeKernel(Number(n),a,i)},()=>e.captureBegin(),()=>e.captureEnd(),()=>e.replay()])}else{let e=new md(n);s("webnn",[e,()=>e.reserveTensorId(),t=>e.releaseTensorId(t),async(t,n,r,s)=>e.ensureTensor(t,n,r,s),(t,n)=>{e.uploadTensor(t,n)},async(t,n)=>e.downloadTensor(t,n)])}}})),wp=ut((()=>{bd(),xd(),vd(),wd(),yd(),$d(),Dc=(e,t)=>{0!==rn()._OrtInit(e,t)&&on("Can\'t initialize onnxruntime.")},Lc=async e=>{Dc(e.wasm.numThreads,wn(e.logLevel))},Fc=async(e,t)=>{{let n=(gp(),ct(Bc)).init;if("webgpu"===t){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let t=e.webgpu.adapter;if(t){if("object"!=typeof t.limits||"object"!=typeof t.features||"function"!=typeof t.requestDevice)throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let n=e.webgpu.powerPreference;if(void 0!==n&&"low-power"!==n&&"high-performance"!==n)throw new Error(`Invalid powerPreference setting: "${n}"`);let r=e.webgpu.forceFallbackAdapter;if(void 0!==r&&"boolean"!=typeof r)throw new Error(`Invalid forceFallbackAdapter setting: "${r}"`);if(t=await navigator.gpu.requestAdapter({powerPreference:n,forceFallbackAdapter:r}),!t)throw new Error(\'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.\')}await n("webgpu",rn(),e,t)}if("webnn"===t){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await n("webnn",rn(),e)}}},Uc=new Map,qc=e=>{let t=rn(),n=t.stackSave();try{let n=t.PTR_SIZE,r=t.stackAlloc(2*n);0!==t._OrtGetInputOutputCount(e,r,r+n)&&on("Can\'t get session input/output count.");let s=4===n?"i32":"i64";return[Number(t.getValue(r,s)),Number(t.getValue(r+n,s))]}finally{t.stackRestore(n)}},Vc=e=>{let t=rn(),n=t._malloc(e.byteLength);if(0===n)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},Wc=async(e,t)=>{let n,r,s=rn();Array.isArray(e)?[n,r]=e:e.buffer===s.HEAPU8.buffer?[n,r]=[e.byteOffset,e.byteLength]:[n,r]=Vc(e);let i=0,a=0,o=0,l=[],u=[],d=[];try{if([a,l]=hn(t),t?.externalData&&s.mountExternalData){let e=[];for(let n of t.externalData){let t="string"==typeof n?n:n.path;e.push(vn("string"==typeof n?n:n.data).then((e=>{s.mountExternalData(t,e)})))}await Promise.all(e)}for(let e of t?.executionProviders??[])if("webnn"===("string"==typeof e?e:e.name)){if(s.shouldTransferToMLTensor=!1,"string"!=typeof e){let t=e,n=t?.context,r=t?.gpuDevice,i=t?.deviceType,a=t?.powerPreference;s.currentContext=n||(r?await s.jsepCreateMLContext(r):await s.jsepCreateMLContext({deviceType:i,powerPreference:a}))}else s.currentContext=await s.jsepCreateMLContext();break}i=await s._OrtCreateSession(n,r,a),0===i&&on("Can\'t create a session."),s.jsepOnCreateSession?.(),s.currentContext&&(s.jsepRegisterMLContext(i,s.currentContext),s.currentContext=void 0,s.shouldTransferToMLTensor=!0);let[e,c]=qc(i),p=!!t?.enableGraphCapture,h=[],f=[],m=[];for(let t=0;t<e;t++){let e=s._OrtGetInputName(i,t);0===e&&on("Can\'t get an input name."),u.push(e),h.push(s.UTF8ToString(e))}for(let e=0;e<c;e++){let n=s._OrtGetOutputName(i,e);0===n&&on("Can\'t get an output name."),d.push(n);let r=s.UTF8ToString(n);f.push(r);{if(p&&void 0===t?.preferredOutputLocation){m.push("gpu-buffer");continue}let e="string"==typeof t?.preferredOutputLocation?t.preferredOutputLocation:t?.preferredOutputLocation?.[r]??"cpu";if("cpu"!==e&&"cpu-pinned"!==e&&"gpu-buffer"!==e&&"ml-tensor"!==e)throw new Error(`Not supported preferred output location: ${e}.`);if(p&&"gpu-buffer"!==e)throw new Error(`Not supported preferred output location: ${e}. Only \'gpu-buffer\' location is supported when enableGraphCapture is true.`);m.push(e)}}let _=null;return m.some((e=>"gpu-buffer"===e||"ml-tensor"===e))&&(o=s._OrtCreateBinding(i),0===o&&on("Can\'t create IO binding."),_={handle:o,outputPreferredLocations:m,outputPreferredLocationsEncoded:m.map((e=>xn(e)))}),Uc.set(i,[i,u,d,_,p,!1]),[i,h,f]}catch(e){throw u.forEach((e=>s._OrtFree(e))),d.forEach((e=>s._OrtFree(e))),0!==o&&0!==s._OrtReleaseBinding(o)&&on("Can\'t release IO binding."),0!==i&&0!==s._OrtReleaseSession(i)&&on("Can\'t release session."),e}finally{s._free(n),0!==a&&0!==s._OrtReleaseSessionOptions(a)&&on("Can\'t release session options."),l.forEach((e=>s._free(e))),s.unmountExternalData?.()}},jc=e=>{let t=rn(),n=Uc.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[r,s,i,a,o]=n;a&&(o&&0!==t._OrtClearBoundOutputs(a.handle)&&on("Can\'t clear bound outputs."),0!==t._OrtReleaseBinding(a.handle)&&on("Can\'t release IO binding.")),t.jsepOnReleaseSession?.(e),s.forEach((e=>t._OrtFree(e))),i.forEach((e=>t._OrtFree(e))),0!==t._OrtReleaseSession(r)&&on("Can\'t release session."),Uc.delete(e)},Gc=(e,t,n,r,s,i=!1)=>{if(!e)return void t.push(0);let a,o,l=rn(),u=l.PTR_SIZE,d=e[0],c=e[1],p=e[3];if("string"===d&&("gpu-buffer"===p||"ml-tensor"===p))throw new Error("String tensor is not supported on GPU.");if(i&&"gpu-buffer"!==p)throw new Error(`External buffer must be provided for input/output index ${s} when enableGraphCapture is true.`);if("gpu-buffer"===p){let t=e[2].gpuBuffer;o=_n(fn(d),c);let n=l.jsepRegisterBuffer;if(!n)throw new Error(\'Tensor location "gpu-buffer" is not supported without using WebGPU.\');a=n(r,s,t,o)}else if("ml-tensor"===p){let t=e[2].mlTensor;o=_n(fn(d),c);let n=l.jsepRegisterMLTensor;if(!n)throw new Error(\'Tensor location "ml-tensor" is not supported without using WebNN.\');a=n(t,fn(d),c)}else{let t=e[2];if(Array.isArray(t)){o=u*t.length,a=l._malloc(o),n.push(a);for(let e=0;e<t.length;e++){if("string"!=typeof t[e])throw new TypeError(`tensor data at index ${e} is not a string`);l.setValue(a+e*u,sn(t[e],n),"*")}}else o=t.byteLength,a=l._malloc(o),n.push(a),l.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),a)}let h=l.stackSave(),f=l.stackAlloc(4*c.length);try{c.forEach(((e,t)=>l.setValue(f+t*u,e,4===u?"i32":"i64")));let e=l._OrtCreateTensor(fn(d),a,o,f,c.length,xn(p));0===e&&on(`Can\'t create tensor for input/output. session=${r}, index=${s}.`),t.push(e)}finally{l.stackRestore(h)}},Hc=async(e,t,n,r,s,i)=>{let a=rn(),o=a.PTR_SIZE,l=Uc.get(e);if(!l)throw new Error(`cannot run inference. invalid session id: ${e}`);let u=l[0],d=l[1],c=l[2],p=l[3],h=l[4],f=l[5],m=t.length,_=r.length,g=0,w=[],y=[],b=[],x=[],v=a.stackSave(),$=a.stackAlloc(m*o),k=a.stackAlloc(m*o),E=a.stackAlloc(_*o),S=a.stackAlloc(_*o);try{a.jsepOnRunStart?.(u),[g,w]=ln(i);for(let r=0;r<m;r++)Gc(n[r],y,x,e,t[r],h);for(let t=0;t<_;t++)Gc(s[t],b,x,e,m+r[t],h);for(let e=0;e<m;e++)a.setValue($+e*o,y[e],"*"),a.setValue(k+e*o,d[t[e]],"*");for(let e=0;e<_;e++)a.setValue(E+e*o,b[e],"*"),a.setValue(S+e*o,c[r[e]],"*");if(p&&!f){let{handle:n,outputPreferredLocations:i,outputPreferredLocationsEncoded:o}=p;if(d.length!==m)throw new Error(`input count from feeds (${m}) is expected to be always equal to model\'s input count (${d.length}).`);for(let r=0;r<m;r++){let s=t[r];0!==await a._OrtBindInput(n,d[s],y[r])&&on(`Can\'t bind input[${r}] for session=${e}.`)}for(let t=0;t<_;t++){let l=r[t];s[t]?.[3]?0!==a._OrtBindOutput(n,c[l],b[t],0)&&on(`Can\'t bind pre-allocated output[${t}] for session=${e}.`):0!==a._OrtBindOutput(n,c[l],0,o[l])&&on(`Can\'t bind output[${t}] to ${i[t]} for session=${e}.`)}Uc.set(e,[u,d,c,p,h,!0])}let l;l=p?await a._OrtRunWithBinding(u,p.handle,_,E,g):await a._OrtRun(u,k,$,m,S,_,E,g),0!==l&&on("failed to call OrtRun().");let v=[];for(let e=0;e<_;e++){let t=Number(a.getValue(E+e*o,"*"));if(t===b[e]){v.push(s[e]);continue}let n,i=a.stackSave(),l=a.stackAlloc(4*o),u=!1,d=0;try{0!==a._OrtGetTensorData(t,l,l+o,l+2*o,l+3*o)&&on(`Can\'t access output tensor data on index ${e}.`);let s=4===o?"i32":"i64",i=Number(a.getValue(l,s));d=a.getValue(l+o,"*");let c=a.getValue(l+2*o,"*"),h=Number(a.getValue(l+3*o,s)),f=[];for(let e=0;e<h;e++)f.push(Number(a.getValue(c+e*o,s)));0!==a._OrtFree(c)&&on("Can\'t free memory for tensor dims.");let m=f.reduce(((e,t)=>e*t),1);n=mn(i);let _=p?.outputPreferredLocations[r[e]];if("string"===n){if("gpu-buffer"===_||"ml-tensor"===_)throw new Error("String tensor is not supported on GPU.");let e=[];for(let t=0;t<m;t++){let n=a.getValue(d+t*o,"*"),r=a.getValue(d+(t+1)*o,"*"),s=t===m-1?void 0:r-n;e.push(a.UTF8ToString(n,s))}v.push([n,f,e,"cpu"])}else if("gpu-buffer"===_&&m>0){let e=a.jsepGetBuffer;if(!e)throw new Error(\'preferredLocation "gpu-buffer" is not supported without using WebGPU.\');let r=e(d),s=_n(i,m);if(void 0===s||!yn(n))throw new Error(`Unsupported data type: ${n}`);u=!0,v.push([n,f,{gpuBuffer:r,download:a.jsepCreateDownloader(r,s,n),dispose:()=>{0!==a._OrtReleaseTensor(t)&&on("Can\'t release tensor.")}},"gpu-buffer"])}else if("ml-tensor"===_&&m>0){let e=a.jsepEnsureTensor;if(!e)throw new Error(\'preferredLocation "ml-tensor" is not supported without using WebNN.\');if(void 0===_n(i,m)||!bn(n))throw new Error(`Unsupported data type: ${n}`);let r=await e(d,i,f,!1);u=!0,v.push([n,f,{mlTensor:r,download:a.jsepCreateMLTensorDownloader(d,n),dispose:()=>{a.jsepReleaseTensorId(d),a._OrtReleaseTensor(t)}},"ml-tensor"])}else{let e=new(gn(n))(m);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(a.HEAPU8.subarray(d,d+e.byteLength)),v.push([n,f,e,"cpu"])}}finally{a.stackRestore(i),"string"===n&&d&&a._free(d),u||a._OrtReleaseTensor(t)}}return p&&!h&&(0!==a._OrtClearBoundOutputs(p.handle)&&on("Can\'t clear bound outputs."),Uc.set(e,[u,d,c,p,h,!1])),v}finally{a.stackRestore(v),y.forEach((e=>a._OrtReleaseTensor(e))),b.forEach((e=>a._OrtReleaseTensor(e))),x.forEach((e=>a._free(e))),0!==g&&a._OrtReleaseRunOptions(g),w.forEach((e=>a._free(e)))}},Kc=e=>{let t=rn(),n=Uc.get(e);if(!n)throw new Error("invalid session id");let r=n[0],s=t._OrtEndProfiling(r);0===s&&on("Can\'t get an profile file name."),t._OrtFree(s)},Xc=e=>{let t=[];for(let n of e){let e=n[2];!Array.isArray(e)&&"buffer"in e&&t.push(e.buffer)}return t}})),yp=ut((()=>{It(),wp(),wd(),gd(),Qc=()=>!!Oe.wasm.proxy&&typeof document<"u",Zc=!1,Jc=!1,ep=!1,rp=new Map,sp=(e,t)=>{let n=rp.get(e);n?n.push(t):rp.set(e,[t])},ip=()=>{if(Zc||!Jc||ep||!Yc)throw new Error("worker not ready")},ap=e=>{switch(e.data.type){case"init-wasm":Zc=!1,e.data.err?(ep=!0,np[1](e.data.err)):(Jc=!0,np[0]()),tp&&(URL.revokeObjectURL(tp),tp=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let t=rp.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}}},op=async()=>{if(!Jc){if(Zc)throw new Error("multiple calls to \'initWasm()\' detected.");if(ep)throw new Error("previous call to \'initWasm()\' failed.");if(Zc=!0,Qc())return new Promise(((e,t)=>{Yc?.terminate(),Ht().then((([n,r])=>{try{(Yc=r).onerror=e=>t(e),Yc.onmessage=ap,np=[e,t];let s={type:"init-wasm",in:Oe};Yc.postMessage(s),tp=n}catch(e){t(e)}}),t)}));try{await nn(Oe.wasm),await Lc(Oe),Jc=!0}catch(e){throw ep=!0,e}finally{Zc=!1}}},lp=async e=>{if(Qc())return ip(),new Promise(((t,n)=>{sp("init-ep",[t,n]);let r={type:"init-ep",in:{epName:e,env:Oe}};Yc.postMessage(r)}));await Fc(Oe,e)},up=async e=>Qc()?(ip(),new Promise(((t,n)=>{sp("copy-from",[t,n]);let r={type:"copy-from",in:{buffer:e}};Yc.postMessage(r,[e.buffer])}))):Vc(e),dp=async(e,t)=>{if(Qc()){if(t?.preferredOutputLocation)throw new Error(\'session option "preferredOutputLocation" is not supported for proxy.\');return ip(),new Promise(((n,r)=>{sp("create",[n,r]);let s={type:"create",in:{model:e,options:{...t}}},i=[];e instanceof Uint8Array&&i.push(e.buffer),Yc.postMessage(s,i)}))}return Wc(e,t)},cp=async e=>{if(Qc())return ip(),new Promise(((t,n)=>{sp("release",[t,n]);let r={type:"release",in:e};Yc.postMessage(r)}));jc(e)},pp=async(e,t,n,r,s,i)=>{if(Qc()){if(n.some((e=>"cpu"!==e[3])))throw new Error("input tensor on GPU is not supported for proxy.");if(s.some((e=>e)))throw new Error("pre-allocated output tensor is not supported for proxy.");return ip(),new Promise(((s,a)=>{sp("run",[s,a]);let o=n,l={type:"run",in:{sessionId:e,inputIndices:t,inputs:o,outputIndices:r,options:i}};Yc.postMessage(l,Xc(o))}))}return Hc(e,t,n,r,s,i)},hp=async e=>{if(Qc())return ip(),new Promise(((t,n)=>{sp("end-profiling",[t,n]);let r={type:"end-profiling",in:e};Yc.postMessage(r)}));Kc(e)}})),bp=ut((()=>{It(),yp(),vd(),Mt(),$d(),fp=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},mp=e=>{switch(e[3]){case"cpu":return new Xe(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!yn(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:r,dispose:s}=e[2];return Xe.fromGpuBuffer(n,{dataType:t,dims:e[1],download:r,dispose:s})}case"ml-tensor":{let t=e[0];if(!bn(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:n,download:r,dispose:s}=e[2];return Xe.fromMLTensor(n,{dataType:t,dims:e[1],download:r,dispose:s})}default:throw new Error(`invalid data location: ${e[3]}`)}},_p=class{async fetchModelAndCopyToWasmMemory(e){return up(await vn(e))}async loadModel(e,t){let n;Ze(),n="string"==typeof e?await this.fetchModelAndCopyToWasmMemory(e):e,[this.sessionId,this.inputNames,this.outputNames]=await dp(n,t),Je()}async dispose(){return cp(this.sessionId)}async run(e,t,n){Ze();let r=[],s=[];Object.entries(e).forEach((e=>{let t=e[0],n=e[1],i=this.inputNames.indexOf(t);if(-1===i)throw new Error(`invalid input \'${t}\'`);r.push(n),s.push(i)}));let i=[],a=[];Object.entries(t).forEach((e=>{let t=e[0],n=e[1],r=this.outputNames.indexOf(t);if(-1===r)throw new Error(`invalid output \'${t}\'`);i.push(n),a.push(r)}));let o=r.map(((e,t)=>fp(e,(()=>`input "${this.inputNames[s[t]]}"`)))),l=i.map(((e,t)=>e?fp(e,(()=>`output "${this.outputNames[a[t]]}"`)):null)),u=await pp(this.sessionId,s,o,a,l,n),d={};for(let e=0;e<u.length;e++)d[this.outputNames[a[e]]]=i[e]??mp(u[e]);return Je(),d}startProfiling(){}endProfiling(){hp(this.sessionId)}}})),xp={};dt(xp,{OnnxruntimeWebAssemblyBackend:()=>$p,initializeFlags:()=>vp,wasmBackend:()=>kp});var vp,$p,kp,Ep=ut((()=>{It(),yp(),bp(),gd(),vp=()=>{if(("number"!=typeof Oe.wasm.initTimeout||Oe.wasm.initTimeout<0)&&(Oe.wasm.initTimeout=0),!1===Oe.wasm.simd&&console.warn(\'Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.\'),"boolean"!=typeof Oe.wasm.proxy&&(Oe.wasm.proxy=!1),"boolean"!=typeof Oe.wasm.trace&&(Oe.wasm.trace=!1),"number"!=typeof Oe.wasm.numThreads||!Number.isInteger(Oe.wasm.numThreads)||Oe.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)Oe.wasm.numThreads=1;else{let e=typeof navigator>"u"?lt("node:os").cpus().length:navigator.hardwareConcurrency;Oe.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},$p=class{async init(e){vp(),await op(),await lp(e)}async createInferenceSessionHandler(e,t){let n=new _p;return await n.loadModel(e,t),Promise.resolve(n)}},kp=new $p}));It(),It(),It();var Sp=At;{let e=(Ep(),ct(xp)).wasmBackend;ze("webgpu",e,5),ze("webnn",e,5),ze("cpu",e,10),ze("wasm",e,10)}Object.defineProperty(Oe.versions,"web",{value:"1.21.0-dev.20241205-d27fecd3d3",enumerable:!0});new Map;let zp="warning";const Cp={wasm:{},webgl:{},webgpu:{},versions:{common:"1.20.1"},set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);zp=e}},get logLevel(){return zp}};Object.defineProperty(Cp,"logLevel",{enumerable:!0});const Tp=(e,t)=>{if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");const{height:n,width:r}=t,s=t.norm??{mean:255,bias:0};let i,a;i="number"==typeof s.mean?[s.mean,s.mean,s.mean,s.mean]:[s.mean[0],s.mean[1],s.mean[2],s.mean[3]??255],a="number"==typeof s.bias?[s.bias,s.bias,s.bias,s.bias]:[s.bias[0],s.bias[1],s.bias[2],s.bias[3]??0];const o=void 0!==t.format?t.format:"RGBA",l=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",u=n*r,d="RGBA"===l?new Float32Array(4*u):new Float32Array(3*u);let c=4,p=0,h=1,f=2,m=3,_=0,g=u,w=2*u,y=-1;"RGB"===o&&(c=3,p=0,h=1,f=2,m=-1),"RGBA"===l?y=3*u:"RBG"===l?(_=0,w=u,g=2*u):"BGR"===l&&(w=0,g=u,_=2*u);for(let t=0;t<u;t++,p+=c,f+=c,h+=c,m+=c)d[_++]=(e[p]+a[0])/i[0],d[g++]=(e[h]+a[1])/i[1],d[w++]=(e[f]+a[2])/i[2],-1!==y&&-1!==m&&(d[y++]=(e[m]+a[3])/i[3]);return new Op("float32",d,"RGBA"===l?[1,4,n,r]:[1,3,n,r])},Ap=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Ip=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let Mp=!1;class Op{constructor(e,t,n){let r,s;if((()=>{if(!Mp){Mp=!0;const e="undefined"!=typeof BigInt64Array&&BigInt64Array.from,t="undefined"!=typeof BigUint64Array&&BigUint64Array.from,n="undefined"!=typeof Float16Array&&Float16Array.from;e&&(Ap.set("int64",BigInt64Array),Ip.set(BigInt64Array,"int64")),t&&(Ap.set("uint64",BigUint64Array),Ip.set(BigUint64Array,"uint64")),n?(Ap.set("float16",Float16Array),Ip.set(Float16Array,"float16")):Ap.set("float16",Uint16Array)}})(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,r=e.type,s=e.dims,e.location){case"cpu-pinned":{const t=Ap.get(r);if(!t)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw new TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"uint8"!==r&&"bool"!==r&&"uint4"!==r&&"int4"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;case"ml-tensor":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"uint64"!==r&&"int8"!==r&&"uint8"!==r&&"bool"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break;default:throw new Error(`Tensor constructor: unsupported location \'${this.dataLocation}\'`)}else{let i,a;if("string"==typeof e)if(r=e,a=n,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor\'s data must be a string array.");i=t}else{const n=Ap.get(e);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e&&n===Uint16Array||"uint4"===e||"int4"===e)throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${n.name} as data.`);i="uint64"===e||"int64"===e?n.from(t,BigInt):n.from(t)}else if(t instanceof n)i=t;else{if(!(t instanceof Uint8ClampedArray))throw new TypeError(`A ${r} tensor\'s data must be type of ${n}`);if("uint8"!==e)throw new TypeError("A Uint8ClampedArray tensor\'s data must be type of uint8");i=Uint8Array.from(t)}}else if(a=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");const t=typeof e[0];if("string"===t)r="string",i=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);r="bool",i=Uint8Array.from(e)}}else if(e instanceof Uint8ClampedArray)r="uint8",i=Uint8Array.from(e);else{const t=Ip.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=t,i=e}if(void 0===a)a=[i.length];else if(!Array.isArray(a))throw new TypeError("A tensor\'s dims must be a number array");s=a,this.cpuData=i,this.dataLocation="cpu"}const i=(e=>{let t=1;for(let n=0;n<e.length;n++){const r=e[n];if("number"!=typeof r||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t})(s);if(this.cpuData&&i!==this.cpuData.length&&("uint4"!==r&&"int4"!==r||Math.ceil(i/2)!==this.cpuData.length))throw new Error(`Tensor\'s size(${i}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=s,this.size=i}static async fromImage(e,t){return(async(e,t)=>{const n="undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement,r="undefined"!=typeof ImageData&&e instanceof ImageData,s="undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap,i="string"==typeof e;let a,o=t??{};const l=()=>{if("undefined"!=typeof document)return document.createElement("canvas");if("undefined"!=typeof OffscreenCanvas)return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},u=e=>"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas?e.getContext("2d"):null;if(n){const n=l();n.width=e.width,n.height=e.height;const r=u(n);if(null==r)throw new Error("Can not access image data");{let n=e.height,s=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(n=t.resizedHeight,s=t.resizedWidth),void 0!==t){if(o=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");o.tensorFormat="RGBA",o.height=n,o.width=s}else o.tensorFormat="RGBA",o.height=n,o.width=s;r.drawImage(e,0,0),a=r.getImageData(0,0,s,n).data}}else{if(!r){if(s){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");const n=l();n.width=e.width,n.height=e.height;const r=u(n);if(null!=r){const t=e.height,n=e.width;return r.drawImage(e,0,0,n,t),a=r.getImageData(0,0,n,t).data,o.height=t,o.width=n,Tp(a,o)}throw new Error("Can not access image data")}if(i)return new Promise(((t,n)=>{const r=l(),s=u(r);if(!e||!s)return n();const i=new Image;i.crossOrigin="Anonymous",i.src=e,i.onload=()=>{r.width=i.width,r.height=i.height,s.drawImage(i,0,0,r.width,r.height);const e=s.getImageData(0,0,r.width,r.height);o.height=r.height,o.width=r.width,t(Tp(e.data,o))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{let n,r;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(n=t.resizedHeight,r=t.resizedWidth):(n=e.height,r=e.width),void 0!==t&&(o=t),o.format="RGBA",o.height=n,o.width=r,void 0!==t){const t=l();t.width=r,t.height=n;const s=u(t);if(null==s)throw new Error("Can not access image data");s.putImageData(e,0,0),a=s.getImageData(0,0,r,n).data}else a=e.data}}if(void 0!==a)return Tp(a,o);throw new Error("Input data provided is not supported - aborted tensor creation")})(e,t)}static fromTexture(e,t){return((e,t)=>{const{width:n,height:r,download:s,dispose:i}=t;return new Op({location:"texture",type:"float32",texture:e,dims:[1,r,n,4],download:s,dispose:i})})(e,t)}static fromGpuBuffer(e,t){return((e,t)=>{const{dataType:n,dims:r,download:s,dispose:i}=t;return new Op({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:r,download:s,dispose:i})})(e,t)}static fromMLTensor(e,t){return((e,t)=>{const{dataType:n,dims:r,download:s,dispose:i}=t;return new Op({location:"ml-tensor",type:n??"float32",mlTensor:e,dims:r,download:s,dispose:i})})(e,t)}static fromPinnedBuffer(e,t,n){return((e,t,n)=>new Op({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]}))(e,t,n)}toDataURL(e){return((e,t)=>{const n="undefined"!=typeof document?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];const r=n.getContext("2d");if(null!=r){let s,i;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(s=e.dims[2],i=e.dims[3]):(s=e.dims[3],i=e.dims[2]);const a=void 0!==t?.format?t.format:"RGB",o=t?.norm;let l,u;void 0===o||void 0===o.mean?l=[255,255,255,255]:"number"==typeof o.mean?l=[o.mean,o.mean,o.mean,o.mean]:(l=[o.mean[0],o.mean[1],o.mean[2],0],void 0!==o.mean[3]&&(l[3]=o.mean[3])),void 0===o||void 0===o.bias?u=[0,0,0,0]:"number"==typeof o.bias?u=[o.bias,o.bias,o.bias,o.bias]:(u=[o.bias[0],o.bias[1],o.bias[2],0],void 0!==o.bias[3]&&(u[3]=o.bias[3]));const d=i*s;let c=0,p=d,h=2*d,f=-1;"RGBA"===a?(c=0,p=d,h=2*d,f=3*d):"RGB"===a?(c=0,p=d,h=2*d):"RBG"===a&&(c=0,h=d,p=2*d);for(let t=0;t<i;t++)for(let n=0;n<s;n++){const s=(e.data[c++]-u[0])*l[0],i=(e.data[p++]-u[1])*l[1],a=(e.data[h++]-u[2])*l[2],o=-1===f?255:(e.data[f++]-u[3])*l[3];r.fillStyle="rgba("+s+","+i+","+a+","+o+")",r.fillRect(n,t,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}throw new Error("Can not access image data")})(this,e)}toImageData(e){return((e,t)=>{const n="undefined"!=typeof document?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let r;if(null==n)throw new Error("Can not access image data");{let s,i,a;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(s=e.dims[2],i=e.dims[1],a=e.dims[3]):(s=e.dims[3],i=e.dims[2],a=e.dims[1]);const o=void 0!==t&&void 0!==t.format?t.format:"RGB",l=t?.norm;let u,d;void 0===l||void 0===l.mean?u=[255,255,255,255]:"number"==typeof l.mean?u=[l.mean,l.mean,l.mean,l.mean]:(u=[l.mean[0],l.mean[1],l.mean[2],255],void 0!==l.mean[3]&&(u[3]=l.mean[3])),void 0===l||void 0===l.bias?d=[0,0,0,0]:"number"==typeof l.bias?d=[l.bias,l.bias,l.bias,l.bias]:(d=[l.bias[0],l.bias[1],l.bias[2],0],void 0!==l.bias[3]&&(d[3]=l.bias[3]));const c=i*s;if(void 0!==t&&(void 0!==t.format&&4===a&&"RGBA"!==t.format||3===a&&"RGB"!==t.format&&"BGR"!==t.format))throw new Error("Tensor format doesn\'t match input tensor dims");const p=4;let h=0,f=1,m=2,_=3,g=0,w=c,y=2*c,b=-1;"RGBA"===o?(g=0,w=c,y=2*c,b=3*c):"RGB"===o?(g=0,w=c,y=2*c):"RBG"===o&&(g=0,y=c,w=2*c),r=n.createImageData(s,i);for(let t=0;t<i*s;h+=p,f+=p,m+=p,_+=p,t++)r.data[h]=(e.data[g++]-d[0])*u[0],r.data[f]=(e.data[w++]-d[1])*u[1],r.data[m]=(e.data[y++]-d[2])*u[2],r.data[_]=-1===b?255:(e.data[b++]-d[3])*u[3]}return r})(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return((e,t)=>{switch(e.location){case"cpu":return new Op(e.type,e.data,t);case"cpu-pinned":return new Op({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new Op({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new Op({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new Op({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}})(this,e)}}const Bp=Op;const Np=Object.freeze({auto:null,gpu:null,cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:{name:"webnn",deviceType:"cpu"},"webnn-npu":{name:"webnn",deviceType:"npu"},"webnn-gpu":{name:"webnn",deviceType:"gpu"},"webnn-cpu":{name:"webnn",deviceType:"cpu"}}),Pp=[];let Rp,Dp;const Lp=Symbol.for("onnxruntime");if(Lp in globalThis)Dp=globalThis[Lp];else if(D.IS_NODE_ENV){switch(Dp=nt??rt,process.platform){case"win32":Pp.push("dml");break;case"linux":"x64"===process.arch&&Pp.push("cuda")}Pp.push("cpu"),Rp=["cpu"]}else Dp=e,D.IS_WEBNN_AVAILABLE&&Pp.push("webnn-npu","webnn-gpu","webnn-cpu","webnn"),D.IS_WEBGPU_AVAILABLE&&Pp.push("webgpu"),Pp.push("wasm"),Rp=["wasm"];const Fp=Dp.InferenceSession;let Up=null;async function qp(e,t,n){Up&&await Up;const r=Fp.create(e,t);Up??=r;const s=await r;return s.config=n,s}function Vp(e){return e instanceof Dp.Tensor}const Wp=Dp?.env;function jp(){return Wp?.wasm?.proxy}Wp?.wasm&&(Wp.wasm.wasmPaths=`https://cdn.jsdelivr.net/npm/@huggingface/transformers@${V.version}/dist/`,Wp.wasm.proxy=!1,"undefined"!=typeof crossOriginIsolated&&crossOriginIsolated||(Wp.wasm.numThreads=1)),Wp?.webgpu&&(Wp.webgpu.powerPreference="high-performance"),V.backends.onnx=Wp;const Gp=async(e,t,n)=>{const r=await qp(new Uint8Array(e),t);return async e=>{const t=Object.fromEntries(Object.entries(e).map((([e,t])=>[e,t.ort_tensor]))),s=await r.run(t);return Array.isArray(n)?n.map((e=>new Xp(s[e]))):new Xp(s[n])}};class Hp{static session_options={};static get bilinear_interpolate_4d(){return this._bilinear_interpolate_4d||(this._bilinear_interpolate_4d=Gp([8,9,18,0,58,128,1,10,40,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,17,10,4,109,111,100,101,34,6,108,105,110,101,97,114,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bilinear_interpolate_4d}static get bicubic_interpolate_4d(){return this._bicubic_interpolate_4d||(this._bicubic_interpolate_4d=Gp([8,9,18,0,58,127,10,39,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,16,10,4,109,111,100,101,34,5,99,117,98,105,99,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bicubic_interpolate_4d}static get matmul(){return this._matmul||(this._matmul=Gp([8,9,18,0,58,55,10,17,10,1,97,10,1,98,18,1,99,34,6,77,97,116,77,117,108,18,1,114,90,9,10,1,97,18,4,10,2,8,1,90,9,10,1,98,18,4,10,2,8,1,98,9,10,1,99,18,4,10,2,8,1,66,2,16,20],this.session_options,"c")),this._matmul}static get stft(){return this._stft||(this._stft=Gp([8,7,18,0,58,148,1,10,38,10,1,115,10,1,106,10,1,119,10,1,108,18,1,111,34,4,83,84,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,115,90,26,10,1,115,18,21,10,19,8,1,18,15,10,3,18,1,98,10,3,18,1,115,10,3,18,1,99,90,11,10,1,106,18,6,10,4,8,7,18,0,90,16,10,1,119,18,11,10,9,8,1,18,5,10,3,18,1,119,90,11,10,1,108,18,6,10,4,8,7,18,0,98,31,10,1,111,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,102,10,3,18,1,100,10,3,18,1,99,66,2,16,17],this.session_options,"o")),this._stft}static get rfft(){return this._rfft||(this._rfft=Gp([8,9,18,0,58,97,10,33,10,1,120,10,0,10,1,97,18,1,121,34,3,68,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,100,90,21,10,1,120,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,90,11,10,1,97,18,6,10,4,8,7,18,0,98,21,10,1,121,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,66,2,16,20],this.session_options,"y")),this._rfft}static get top_k(){return this._top_k||(this._top_k=Gp([8,10,18,0,58,73,10,18,10,1,120,10,1,107,18,1,118,18,1,105,34,4,84,111,112,75,18,1,116,90,9,10,1,120,18,4,10,2,8,1,90,15,10,1,107,18,10,10,8,8,7,18,4,10,2,8,1,98,9,10,1,118,18,4,10,2,8,1,98,9,10,1,105,18,4,10,2,8,7,66,2,16,21],this.session_options,["v","i"])),this._top_k}static get slice(){return this._slice||(this._slice=Gp([8,7,18,0,58,96,10,25,10,1,120,10,1,115,10,1,101,10,1,97,10,1,116,18,1,121,34,5,83,108,105,99,101,18,1,114,90,9,10,1,120,18,4,10,2,8,1,90,9,10,1,115,18,4,10,2,8,7,90,9,10,1,101,18,4,10,2,8,7,90,9,10,1,97,18,4,10,2,8,7,90,9,10,1,116,18,4,10,2,8,7,98,9,10,1,121,18,4,10,2,8,1,66,2,16,13],this.session_options,"y")),this._slice}}const Kp=Object.freeze({float32:Float32Array,float16:Uint16Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array,uint4:Uint8Array,int4:Int8Array});class Xp{get dims(){return this.ort_tensor.dims}set dims(e){this.ort_tensor.dims=e}get type(){return this.ort_tensor.type}get data(){return this.ort_tensor.data}get size(){return this.ort_tensor.size}get location(){return this.ort_tensor.location}ort_tensor;constructor(...e){return Vp(e[0])?this.ort_tensor=e[0]:this.ort_tensor=new Bp(e[0],e[1],e[2]),new Proxy(this,{get:(e,t)=>{if("string"==typeof t){let n=Number(t);if(Number.isInteger(n))return e._getitem(n)}return e[t]},set:(e,t,n)=>e[t]=n})}dispose(){this.ort_tensor.dispose()}*[Symbol.iterator](){const[e,...t]=this.dims;if(t.length>0){const n=t.reduce(((e,t)=>e*t));for(let r=0;r<e;++r)yield this._subarray(r,n,t)}else yield*this.data}_getitem(e){const[t,...n]=this.dims;if(e=rh(e,t),n.length>0){const t=n.reduce(((e,t)=>e*t));return this._subarray(e,t,n)}return new Xp(this.type,[this.data[e]],n)}indexOf(e){const t=this.data;for(let n=0;n<t.length;++n)if(t[n]==e)return n;return-1}_subarray(e,t,n){const r=e*t,s=(e+1)*t,i="subarray"in this.data?this.data.subarray(r,s):this.data.slice(r,s);return new Xp(this.type,i,n)}item(){const e=this.data;if(1!==e.length)throw new Error(`a Tensor with ${e.length} elements cannot be converted to Scalar`);return e[0]}tolist(){return function e(t,n){const r=t.length,s=n.reduce(((e,t)=>e*t));if(r!==s)throw Error(`cannot reshape array of size ${r} into shape (${n})`);let i=t;for(let e=n.length-1;e>=0;e--)i=i.reduce(((t,r)=>{let s=t[t.length-1];return s.length<n[e]?s.push(r):t.push([r]),t}),[[]]);return i[0]}(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){const e=this.data;for(let t=0;t<e.length;++t)e[t]=1/(1+Math.exp(-e[t]));return this}map(e){return this.clone().map_(e)}map_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]=e(t[n],n,t);return this}mul(e){return this.clone().mul_(e)}mul_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]*=e;return this}div(e){return this.clone().div_(e)}div_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]/=e;return this}add(e){return this.clone().add_(e)}add_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]+=e;return this}sub(e){return this.clone().sub_(e)}sub_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]-=e;return this}clone(){return new Xp(this.type,this.data.slice(),this.dims.slice())}slice(...e){const t=[],n=[];for(let r=0;r<this.dims.length;++r){let s=e[r];if(null==s)n.push([0,this.dims[r]]),t.push(this.dims[r]);else if("number"==typeof s)s=rh(s,this.dims[r],r),n.push([s,s+1]);else{if(!Array.isArray(s)||2!==s.length)throw new Error(`Invalid slice: ${s}`);{let[e,i]=s;if(e=null===e?0:rh(e,this.dims[r],r,!1),i=null===i?this.dims[r]:rh(i,this.dims[r],r,!1),e>i)throw new Error(`Invalid slice: ${s}`);const a=[Math.max(e,0),Math.min(i,this.dims[r])];n.push(a),t.push(a[1]-a[0])}}}const r=n.map((([e,t])=>t-e)),s=r.reduce(((e,t)=>e*t)),i=this.data,a=new i.constructor(s),o=this.stride();for(let e=0;e<s;++e){let t=0;for(let s=r.length-1,i=e;s>=0;--s){const e=r[s];t+=(i%e+n[s][0])*o[s],i=Math.floor(i/e)}a[e]=i[t]}return new Xp(this.type,a,t)}permute(...e){return function t(e,n){const[r,s]=function i(e,t,n){const r=new Array(n.length),s=new Array(n.length);for(let e=n.length-1,i=1;e>=0;--e)s[e]=i,r[e]=t[n[e]],i*=r[e];const i=n.map(((e,t)=>s[n.indexOf(t)])),a=new e.constructor(e.length);for(let n=0;n<e.length;++n){let r=0;for(let e=t.length-1,s=n;e>=0;--e)r+=s%t[e]*i[e],s=Math.floor(s/t[e]);a[r]=e[n]}return[a,r]}(e.data,e.dims,n);return new Xp(e.type,r,s)}(this,e)}transpose(...e){return this.permute(...e)}sum(e=null,t=!1){return this.norm(1,e,t)}norm(e="fro",t=null,n=!1){if("fro"===e)e=2;else if("string"==typeof e)throw Error(`Unsupported norm: ${e}`);const r=this.data;if(null===t){let t=r.reduce(((t,n)=>t+n**e),0)**(1/e);return new Xp(this.type,[t],[])}t=rh(t,this.dims.length);const s=this.dims.slice();s[t]=1;const i=new r.constructor(r.length/this.dims[t]);for(let n=0;n<r.length;++n){let a=0;for(let e=this.dims.length-1,r=n,i=1;e>=0;--e){const n=this.dims[e];if(e!==t){a+=r%n*i,i*=s[e]}r=Math.floor(r/n)}i[a]+=r[n]**e}if(1!==e)for(let t=0;t<i.length;++t)i[t]=i[t]**(1/e);return n||s.splice(t,1),new Xp(this.type,i,s)}normalize_(e=2,t=1){t=rh(t,this.dims.length);const n=this.norm(e,t,!0),r=this.data,s=n.data;for(let e=0;e<r.length;++e){let n=0;for(let r=this.dims.length-1,s=e,i=1;r>=0;--r){const e=this.dims[r];if(r!==t){n+=s%e*i,i*=this.dims[r]}s=Math.floor(s/e)}r[e]/=s[n]}return this}normalize(e=2,t=1){return this.clone().normalize_(e,t)}stride(){return function e(t){const n=new Array(t.length);for(let e=t.length-1,r=1;e>=0;--e)n[e]=r,r*=t[e];return n}(this.dims)}squeeze(e=null){return new Xp(this.type,this.data,th(this.dims,e))}squeeze_(e=null){return this.dims=th(this.dims,e),this}unsqueeze(e=null){return new Xp(this.type,this.data,nh(this.dims,e))}unsqueeze_(e=null){return this.dims=nh(this.dims,e),this}flatten_(e=0,t=-1){t=(t+this.dims.length)%this.dims.length;let n=this.dims.slice(0,e),r=this.dims.slice(e,t+1),s=this.dims.slice(t+1);return this.dims=[...n,r.reduce(((e,t)=>e*t),1),...s],this}flatten(e=0,t=-1){return this.clone().flatten_(e,t)}view(...e){let t=-1;for(let n=0;n<e.length;++n)if(-1===e[n]){if(-1!==t)throw new Error("Only one dimension can be inferred");t=n}const n=this.data;if(-1!==t){const r=e.reduce(((e,n,r)=>r!==t?e*n:e),1);e[t]=n.length/r}return new Xp(this.type,n,e)}neg_(){const e=this.data;for(let t=0;t<e.length;++t)e[t]=-e[t];return this}neg(){return this.clone().neg_()}clamp_(e,t){const n=this.data;for(let r=0;r<n.length;++r)n[r]=Math.min(Math.max(n[r],e),t);return this}clamp(e,t){return this.clone().clamp_(e,t)}round_(){const e=this.data;for(let t=0;t<e.length;++t)e[t]=Math.round(e[t]);return this}round(){return this.clone().round_()}mean(e=null,t=!1){return oh(this,e,t)}to(e){if(this.type===e)return this;if(!Kp.hasOwnProperty(e))throw new Error(`Unsupported type: ${e}`);let t;const n=["int64","uint64"].includes(this.type),r=["int64","uint64"].includes(e);return n&&!r?t=Number:!n&&r&&(t=BigInt),new Xp(e,Kp[e].from(this.data,t),this.dims)}}function Qp(e,[t,n],r="bilinear",s=!1){const i=e.dims.at(-3)??1,a=e.dims.at(-2),o=e.dims.at(-1);let l=function u(e,[t,n,r],[s,i],a="bilinear",o=!1){const l=i/r,u=s/n,d=new e.constructor(s*i*t),c=n*r,p=s*i;for(let a=0;a<s;++a)for(let s=0;s<i;++s){const o=a*i+s,h=(s+.5)/l-.5,f=(a+.5)/u-.5;let m=Math.floor(h),_=Math.floor(f);const g=Math.min(m+1,r-1),w=Math.min(_+1,n-1);m=Math.max(m,0),_=Math.max(_,0);const y=h-m,b=f-_,x=(1-y)*(1-b),v=y*(1-b),$=(1-y)*b,k=y*b,E=_*r,S=w*r,z=E+m,C=E+g,T=S+m,A=S+g;for(let n=0;n<t;++n){const t=n*c;d[n*p+o]=x*e[t+z]+v*e[t+C]+$*e[t+T]+k*e[t+A]}}return d}(e.data,[i,a,o],[t,n],r,s);return new Xp(e.type,l,[i,t,n])}async function Yp(e,{size:t=null,mode:n="bilinear"}={}){if(4!==e.dims.length)throw new Error("`interpolate_4d` currently only supports 4D input.");if(!t)throw new Error("`interpolate_4d` requires a `size` argument.");let r,s;if(2===t.length)r=[...e.dims.slice(0,2),...t];else if(3===t.length)r=[e.dims[0],...t];else{if(4!==t.length)throw new Error("`size` must be of length 2, 3, or 4.");r=t}if("bilinear"===n)s=await Hp.bilinear_interpolate_4d;else{if("bicubic"!==n)throw new Error(`Unsupported mode: ${n}`);s=await Hp.bicubic_interpolate_4d}const i=new Xp("int64",new BigInt64Array(r.map(BigInt)),[r.length]);return await s({x:e,s:i})}async function Zp(e,t){const n=await Hp.top_k;return t=null===t?e.dims.at(-1):Math.min(t,e.dims.at(-1)),await n({x:e,k:new Xp("int64",[BigInt(t)],[1])})}const Jp=e=>new Xp("int64",e,[e.length]);async function eh(e,t,n,r,s){const i=await Hp.slice;return await i({x:e,s:Jp(t),e:Jp(n),a:Jp(r),t:Jp(s??new Array(r.length).fill(1))})}function th(e,t){return e=e.slice(),null===t?e=e.filter((e=>1!==e)):"number"==typeof t?1===e[t]&&e.splice(t,1):Array.isArray(t)&&(e=e.filter(((e,n)=>1!==e||!t.includes(n)))),e}function nh(e,t){return t=rh(t,e.length+1),(e=e.slice()).splice(t,0,1),e}function rh(e,t,n=null,r=!0){if(r&&(e<-t||e>=t))throw new Error(`IndexError: index ${e} is out of bounds for dimension${null===n?"":" "+n} with size ${t}`);return e<0&&(e=(e%t+t)%t),e}function sh(e,t=0){t=rh(t,e[0].dims.length);const n=e[0].dims.slice();n[t]=e.reduce(((e,n)=>e+n.dims[t]),0);const r=n.reduce(((e,t)=>e*t),1),s=new e[0].data.constructor(r),i=e[0].type;if(0===t){let t=0;for(const n of e){const e=n.data;s.set(e,t),t+=e.length}}else{let r=0;for(let i=0;i<e.length;++i){const{data:a,dims:o}=e[i];for(let e=0;e<a.length;++e){let i=0;for(let s=o.length-1,a=e,l=1;s>=0;--s){const e=o[s];let u=a%e;s===t&&(u+=r),i+=u*l,l*=n[s],a=Math.floor(a/e)}s[i]=a[e]}r+=o[t]}}return new Xp(i,s,n)}function ih(e,t=0){return sh(e.map((e=>e.unsqueeze(t))),t)}function ah(e,t=null,n=1,r=!1){const s=e.data,i=e.dims;if(null===t){const t=s.reduce(((e,t)=>e+t),0)/s.length,r=Math.sqrt(s.reduce(((e,n)=>e+(n-t)**2),0)/(s.length-n)),i=new Xp(e.type,[t],[]);return[new Xp(e.type,[r],[]),i]}const a=oh(e,t=rh(t,i.length),r),o=a.data,l=i.slice();l[t]=1;const u=new s.constructor(s.length/i[t]);for(let e=0;e<s.length;++e){let n=0;for(let r=i.length-1,s=e,a=1;r>=0;--r){const e=i[r];if(r!==t){n+=s%e*a,a*=l[r]}s=Math.floor(s/e)}u[n]+=(s[e]-o[n])**2}for(let e=0;e<u.length;++e)u[e]=Math.sqrt(u[e]/(i[t]-n));r||l.splice(t,1);return[new Xp(e.type,u,l),a]}function oh(e,t=null,n=!1){const r=e.data;if(null===t){const t=r.reduce(((e,t)=>e+t),0);return new Xp(e.type,[t/r.length],[])}const s=e.dims;t=rh(t,s.length);const i=s.slice();i[t]=1;const a=new r.constructor(r.length/s[t]);for(let e=0;e<r.length;++e){let n=0;for(let r=s.length-1,a=e,o=1;r>=0;--r){const e=s[r];if(r!==t){n+=a%e*o,o*=i[r]}a=Math.floor(a/e)}a[n]+=r[e]}if(1!==s[t])for(let e=0;e<a.length;++e)a[e]=a[e]/s[t];return n||i.splice(t,1),new Xp(e.type,a,i)}function lh(e,t,n,r){const s=e.reduce(((e,t)=>e*t),1);return new Xp(n,new r(s).fill(t),e)}function uh(e,t){let n,r;if("number"==typeof t)n="float32",r=Float32Array;else if("bigint"==typeof t)n="int64",r=BigInt64Array;else{if("boolean"!=typeof t)throw new Error("Unsupported data type: "+typeof t);n="bool",r=Uint8Array}return lh(e,t,n,r)}function dh(e,t){return uh(e.dims,t)}function ch(e){return lh(e,1n,"int64",BigInt64Array)}function ph(e){return ch(e.dims)}function hh(e){return lh(e,0n,"int64",BigInt64Array)}class fh{constructor(e=((e,t)=>e>t),t=Infinity){this._heap=[],this._comparator=e,this._maxSize=t}get size(){return this._heap.length}isEmpty(){return 0===this.size}peek(){return this._heap[0]}push(...e){return this.extend(e)}extend(e){for(const t of e)if(this.size<this._maxSize)this._heap.push(t),this._siftUp();else{const e=this._smallest();this._comparator(t,this._heap[e])&&(this._heap[e]=t,this._siftUpFrom(e))}return this.size}pop(){const e=this.peek(),t=this.size-1;return t>0&&this._swap(0,t),this._heap.pop(),this._siftDown(),e}replace(e){const t=this.peek();return this._heap[0]=e,this._siftDown(),t}_parent(e){return(e+1>>>1)-1}_left(e){return 1+(e<<1)}_right(e){return e+1<<1}_greater(e,t){return this._comparator(this._heap[e],this._heap[t])}_swap(e,t){const n=this._heap[e];this._heap[e]=this._heap[t],this._heap[t]=n}_siftUp(){this._siftUpFrom(this.size-1)}_siftUpFrom(e){for(;e>0&&this._greater(e,this._parent(e));)this._swap(e,this._parent(e)),e=this._parent(e)}_siftDown(){let e=0;for(;this._left(e)<this.size&&this._greater(this._left(e),e)||this._right(e)<this.size&&this._greater(this._right(e),e);){const t=this._right(e)<this.size&&this._greater(this._right(e),this._left(e))?this._right(e):this._left(e);this._swap(e,t),e=t}}_smallest(){return 2**Math.floor(Math.log2(this.size))-1}}class mh{constructor(){this.root=_h.default()}extend(e){for(const t of e)this.push(t)}push(e){let t=this.root;for(const n of e){let e=t.children.get(n);void 0===e&&(e=_h.default(),t.children.set(n,e)),t=e}t.isLeaf=!0}*commonPrefixSearch(e){let t=this.root;if(void 0===t)return;let n="";for(const r of e){if(n+=r,t=t.children.get(r),void 0===t)return;t.isLeaf&&(yield n)}}}class _h{constructor(e,t){this.isLeaf=e,this.children=t}static default(){return new _h(!1,new Map)}}class gh{constructor(e,t,n){this.chars=Array.from(e),this.len=this.chars.length,this.bosTokenId=t,this.eosTokenId=n,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},(()=>[])),this.endNodes=Array.from({length:this.len+1},(()=>[]));const r=new wh(this.bosTokenId,0,0,0,0),s=new wh(this.eosTokenId,1,this.len,0,0);this.nodes.push(r.clone()),this.nodes.push(s.clone()),this.beginNodes[this.len].push(s),this.endNodes[0].push(r)}insert(e,t,n,r){const s=this.nodes.length,i=new wh(r,s,e,t,n);this.beginNodes[e].push(i),this.endNodes[e+t].push(i),this.nodes.push(i)}viterbi(){const e=this.len;let t=0;for(;t<=e;){if(0==this.beginNodes[t].length)return[];for(let e of this.beginNodes[t]){e.prev=null;let n=0,r=null;for(let s of this.endNodes[t]){const t=s.backtraceScore+e.score;(null===r||t>n)&&(r=s.clone(),n=t)}if(null===r)return[];e.prev=r,e.backtraceScore=n}++t}const n=[],r=this.beginNodes[e][0].prev;if(null===r)return[];let s=r.clone();for(;null!==s.prev;){n.push(s.clone());const e=s.clone();s=e.prev.clone()}return n.reverse(),n}piece(e){return this.chars.slice(e.pos,e.pos+e.length).join("")}tokens(){return this.viterbi().map((e=>this.piece(e)))}tokenIds(){return this.viterbi().map((e=>e.tokenId))}}class wh{constructor(e,t,n,r,s){this.tokenId=e,this.nodeId=t,this.pos=n,this.length=r,this.score=s,this.prev=null,this.backtraceScore=0}clone(){const e=new wh(this.tokenId,this.nodeId,this.pos,this.length,this.score);return e.prev=this.prev,e.backtraceScore=this.backtraceScore,e}}var yh=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",NullLiteral:"NullLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",Is:"Is",NotIn:"NotIn",Else:"Else",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator",Macro:"Macro",EndMacro:"EndMacro"}),bh=Object.freeze({set:yh.Set,for:yh.For,in:yh.In,is:yh.Is,if:yh.If,else:yh.Else,endif:yh.EndIf,elif:yh.ElseIf,endfor:yh.EndFor,and:yh.And,or:yh.Or,not:yh.Not,"not in":yh.NotIn,macro:yh.Macro,endmacro:yh.EndMacro,true:yh.BooleanLiteral,false:yh.BooleanLiteral,none:yh.NullLiteral,True:yh.BooleanLiteral,False:yh.BooleanLiteral,None:yh.NullLiteral}),xh=class{constructor(e,t){this.value=e,this.type=t}};function vh(e){return/\\w/.test(e)}function $h(e){return/[0-9]/.test(e)}var kh=[["{%",yh.OpenStatement],["%}",yh.CloseStatement],["{{",yh.OpenExpression],["}}",yh.CloseExpression],["(",yh.OpenParen],[")",yh.CloseParen],["{",yh.OpenCurlyBracket],["}",yh.CloseCurlyBracket],["[",yh.OpenSquareBracket],["]",yh.CloseSquareBracket],[",",yh.Comma],[".",yh.Dot],[":",yh.Colon],["|",yh.Pipe],["<=",yh.ComparisonBinaryOperator],[">=",yh.ComparisonBinaryOperator],["==",yh.ComparisonBinaryOperator],["!=",yh.ComparisonBinaryOperator],["<",yh.ComparisonBinaryOperator],[">",yh.ComparisonBinaryOperator],["+",yh.AdditiveBinaryOperator],["-",yh.AdditiveBinaryOperator],["*",yh.MultiplicativeBinaryOperator],["/",yh.MultiplicativeBinaryOperator],["%",yh.MultiplicativeBinaryOperator],["=",yh.Equals]],Eh=new Map([["n","\\n"],["t","\\t"],["r","\\r"],["b","\\b"],["f","\\f"],["v","\\v"],["\'","\'"],[\'"\',\'"\'],["\\\\","\\\\"]]);var Sh=class{type="Statement"},zh=class extends Sh{constructor(e){super(),this.body=e}type="Program"},Ch=class extends Sh{constructor(e,t,n){super(),this.test=e,this.body=t,this.alternate=n}type="If"},Th=class extends Sh{constructor(e,t,n,r){super(),this.loopvar=e,this.iterable=t,this.body=n,this.defaultBlock=r}type="For"},Ah=class extends Sh{constructor(e,t){super(),this.assignee=e,this.value=t}type="Set"},Ih=class extends Sh{constructor(e,t,n){super(),this.name=e,this.args=t,this.body=n}type="Macro"},Mh=class extends Sh{type="Expression"},Oh=class extends Mh{constructor(e,t,n){super(),this.object=e,this.property=t,this.computed=n}type="MemberExpression"},Bh=class extends Mh{constructor(e,t){super(),this.callee=e,this.args=t}type="CallExpression"},Nh=class extends Mh{constructor(e){super(),this.value=e}type="Identifier"},Ph=class extends Mh{constructor(e){super(),this.value=e}type="Literal"},Rh=class extends Ph{type="NumericLiteral"},Dh=class extends Ph{type="StringLiteral"},Lh=class extends Ph{type="BooleanLiteral"},Fh=class extends Ph{type="NullLiteral"},Uh=class extends Ph{type="ArrayLiteral"},qh=class extends Ph{type="TupleLiteral"},Vh=class extends Ph{type="ObjectLiteral"},Wh=class extends Mh{constructor(e,t,n){super(),this.operator=e,this.left=t,this.right=n}type="BinaryExpression"},jh=class extends Mh{constructor(e,t){super(),this.operand=e,this.filter=t}type="FilterExpression"},Gh=class extends Mh{constructor(e,t){super(),this.iterable=e,this.test=t}type="SelectExpression"},Hh=class extends Mh{constructor(e,t,n){super(),this.operand=e,this.negate=t,this.test=n}type="TestExpression"},Kh=class extends Mh{constructor(e,t){super(),this.operator=e,this.argument=t}type="UnaryExpression"},Xh=class extends Mh{constructor(e=void 0,t=void 0,n=void 0){super(),this.start=e,this.stop=t,this.step=n}type="SliceExpression"},Qh=class extends Mh{constructor(e,t){super(),this.key=e,this.value=t}type="KeywordArgumentExpression"};function Yh(e){const t=new zh([]);let n=0;function r(t,r){const s=e[n++];if(!s||s.type!==t)throw new Error(`Parser Error: ${r}. ${s.type} !== ${t}.`);return s}function s(){switch(e[n].type){case yh.Text:return function t(){return new Dh(r(yh.Text,"Expected text token").value)}();case yh.OpenStatement:return function c(){let t;switch(r(yh.OpenStatement,"Expected opening statement token"),e[n].type){case yh.Set:++n,t=o(),r(yh.CloseStatement,"Expected closing statement token");break;case yh.If:++n,t=l(),r(yh.OpenStatement,"Expected {% token"),r(yh.EndIf,"Expected endif token"),r(yh.CloseStatement,"Expected %} token");break;case yh.Macro:++n,t=function c(){const e=x();if("Identifier"!==e.type)throw new SyntaxError("Expected identifier following macro statement");const t=g();r(yh.CloseStatement,"Expected closing statement token");const n=[];for(;i(yh.OpenStatement,yh.EndMacro);)n.push(s());return new Ih(e,t,n)}(),r(yh.OpenStatement,"Expected {% token"),r(yh.EndMacro,"Expected endmacro token"),r(yh.CloseStatement,"Expected %} token");break;case yh.For:++n,t=function p(){const e=u(!0);if(!(e instanceof Nh||e instanceof qh))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${e.type} instead`);r(yh.In,"Expected `in` keyword following loop variable");const t=d();r(yh.CloseStatement,"Expected closing statement token");const o=[];for(;i(yh.OpenStatement,yh.EndFor)&&i(yh.OpenStatement,yh.Else);)o.push(s());const l=[];if(a(yh.OpenStatement,yh.Else))for(++n,++n,r(yh.CloseStatement,"Expected closing statement token");i(yh.OpenStatement,yh.EndFor);)l.push(s());return new Th(e,t,o,l)}(),r(yh.OpenStatement,"Expected {% token"),r(yh.EndFor,"Expected endfor token"),r(yh.CloseStatement,"Expected %} token");break;default:throw new SyntaxError(`Unknown statement type: ${e[n].type}`)}return t}();case yh.OpenExpression:return function p(){r(yh.OpenExpression,"Expected opening expression token");const e=d();return r(yh.CloseExpression,"Expected closing expression token"),e}();default:throw new SyntaxError(`Unexpected token type: ${e[n].type}`)}}function i(...t){return n+t.length<=e.length&&t.some(((t,r)=>t!==e[n+r].type))}function a(...t){return n+t.length<=e.length&&t.every(((t,r)=>t===e[n+r].type))}function o(){const e=d();if(a(yh.Equals)){++n;const t=o();return new Ah(e,t)}return e}function l(){const t=d();r(yh.CloseStatement,"Expected closing statement token");const i=[],o=[];for(;e[n]?.type!==yh.OpenStatement||e[n+1]?.type!==yh.ElseIf&&e[n+1]?.type!==yh.Else&&e[n+1]?.type!==yh.EndIf;)i.push(s());if(e[n]?.type===yh.OpenStatement&&e[n+1]?.type!==yh.EndIf)if(++n,a(yh.ElseIf))r(yh.ElseIf,"Expected elseif token"),o.push(l());else for(r(yh.Else,"Expected else token"),r(yh.CloseStatement,"Expected closing statement token");e[n]?.type!==yh.OpenStatement||e[n+1]?.type!==yh.EndIf;)o.push(s());return new Ch(t,i,o)}function u(e=!1){const t=e?x:d,r=[t()],s=a(yh.Comma);for(;s&&(++n,r.push(t()),a(yh.Comma)););return s?new qh(r):r[0]}function d(){return function e(){const e=c();if(a(yh.If)){++n;const t=c();if(a(yh.Else)){++n;const r=c();return new Ch(t,[e],[r])}return new Gh(e,t)}return e}()}function c(){let t=p();for(;a(yh.Or);){const r=e[n];++n;const s=p();t=new Wh(r,t,s)}return t}function p(){let t=h();for(;a(yh.And);){const r=e[n];++n;const s=h();t=new Wh(r,t,s)}return t}function h(){let t;for(;a(yh.Not);){const r=e[n];++n;const s=h();t=new Kh(r,s)}return t??function r(){let t=f();for(;a(yh.ComparisonBinaryOperator)||a(yh.In)||a(yh.NotIn);){const r=e[n];++n;const s=f();t=new Wh(r,t,s)}return t}()}function f(){let t=y();for(;a(yh.AdditiveBinaryOperator);){const r=e[n];++n;const s=y();t=new Wh(r,t,s)}return t}function m(){const t=function s(){let t=x();for(;a(yh.Dot)||a(yh.OpenSquareBracket);){const s=e[n];let i;++n;const a=s.type!==yh.Dot;if(a)i=w(),r(yh.CloseSquareBracket,"Expected closing square bracket");else if(i=x(),"Identifier"!==i.type)throw new SyntaxError("Expected identifier following dot operator");t=new Oh(t,i,a)}return t}();return a(yh.OpenParen)?_(t):t}function _(e){let t=new Bh(e,g());return a(yh.OpenParen)&&(t=_(t)),t}function g(){r(yh.OpenParen,"Expected opening parenthesis for arguments list");const e=function t(){const e=[];for(;!a(yh.CloseParen);){let t=d();if(a(yh.Equals)){if(++n,!(t instanceof Nh))throw new SyntaxError("Expected identifier for keyword argument");const e=d();t=new Qh(t,e)}e.push(t),a(yh.Comma)&&++n}return e}();return r(yh.CloseParen,"Expected closing parenthesis for arguments list"),e}function w(){const e=[];let t=!1;for(;!a(yh.CloseSquareBracket);)a(yh.Colon)?(e.push(void 0),++n,t=!0):(e.push(d()),a(yh.Colon)&&(++n,t=!0));if(0===e.length)throw new SyntaxError("Expected at least one argument for member/slice expression");if(t){if(e.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new Xh(...e)}return e[0]}function y(){let t=b();for(;a(yh.MultiplicativeBinaryOperator);){const r=e[n];++n;const s=b();t=new Wh(r,t,s)}return t}function b(){let e=function t(){let e=m();for(;a(yh.Pipe);){++n;let t=x();if(!(t instanceof Nh))throw new SyntaxError("Expected identifier for the filter");a(yh.OpenParen)&&(t=_(t)),e=new jh(e,t)}return e}();for(;a(yh.Is);){++n;const t=a(yh.Not);t&&++n;let r=x();if(r instanceof Lh?r=new Nh(r.value.toString()):r instanceof Fh&&(r=new Nh("none")),!(r instanceof Nh))throw new SyntaxError("Expected identifier for the test");e=new Hh(e,t,r)}return e}function x(){const t=e[n];switch(t.type){case yh.NumericLiteral:return++n,new Rh(Number(t.value));case yh.StringLiteral:return++n,new Dh(t.value);case yh.BooleanLiteral:return++n,new Lh("true"===t.value.toLowerCase());case yh.NullLiteral:return++n,new Fh(null);case yh.Identifier:return++n,new Nh(t.value);case yh.OpenParen:{++n;const t=u();if(e[n].type!==yh.CloseParen)throw new SyntaxError(`Expected closing parenthesis, got ${e[n].type} instead`);return++n,t}case yh.OpenSquareBracket:{++n;const e=[];for(;!a(yh.CloseSquareBracket);)e.push(d()),a(yh.Comma)&&++n;return++n,new Uh(e)}case yh.OpenCurlyBracket:{++n;const e=new Map;for(;!a(yh.CloseCurlyBracket);){const t=d();r(yh.Colon,"Expected colon between key and value in object literal");const s=d();e.set(t,s),a(yh.Comma)&&++n}return++n,new Vh(e)}default:throw new SyntaxError(`Unexpected token: ${t.type}`)}}for(;n<e.length;)t.body.push(s());return t}function Zh(e,t,n=1){void 0===t&&(t=e,e=0);const r=[];for(let s=e;s<t;s+=n)r.push(s);return r}function Jh(e,t,n,r=1){const s=Math.sign(r);s>=0?(t=(t??=0)<0?Math.max(e.length+t,0):Math.min(t,e.length),n=(n??=e.length)<0?Math.max(e.length+n,0):Math.min(n,e.length)):(t=(t??=e.length-1)<0?Math.max(e.length+t,-1):Math.min(t,e.length-1),n=(n??=-1)<-1?Math.max(e.length+n,-1):Math.min(n,e.length-1));const i=[];for(let a=t;s*a<s*n;a+=r)i.push(e[a]);return i}function ef(e){return e.replace(/\\b\\w/g,(e=>e.toUpperCase()))}var tf=class{type="RuntimeValue";value;builtins=new Map;constructor(e=void 0){this.value=e}__bool__(){return new sf(!!this.value)}},nf=class extends tf{type="NumericValue"},rf=class extends tf{type="StringValue";builtins=new Map([["upper",new df((()=>new rf(this.value.toUpperCase())))],["lower",new df((()=>new rf(this.value.toLowerCase())))],["strip",new df((()=>new rf(this.value.trim())))],["title",new df((()=>new rf(ef(this.value))))],["length",new nf(this.value.length)],["rstrip",new df((()=>new rf(this.value.trimEnd())))],["lstrip",new df((()=>new rf(this.value.trimStart())))]])},sf=class extends tf{type="BooleanValue"},af=class extends tf{type="ObjectValue";__bool__(){return new sf(this.value.size>0)}builtins=new Map([["get",new df((([e,t])=>{if(!(e instanceof rf))throw new Error(`Object key must be a string: got ${e.type}`);return this.value.get(e.value)??t??new cf}))],["items",new df((()=>new lf(Array.from(this.value.entries()).map((([e,t])=>new lf([new rf(e),t]))))))]])},of=class extends af{type="KeywordArgumentsValue"},lf=class extends tf{type="ArrayValue";builtins=new Map([["length",new nf(this.value.length)]]);__bool__(){return new sf(this.value.length>0)}},uf=class extends lf{type="TupleValue"},df=class extends tf{type="FunctionValue"},cf=class extends tf{type="NullValue"},pf=class extends tf{type="UndefinedValue"},hf=class{constructor(e){this.parent=e}variables=new Map([["namespace",new df((e=>{if(0===e.length)return new af(new Map);if(1!==e.length||!(e[0]instanceof af))throw new Error("`namespace` expects either zero arguments or a single object argument");return e[0]}))]]);tests=new Map([["boolean",e=>"BooleanValue"===e.type],["callable",e=>e instanceof df],["odd",e=>{if("NumericValue"!==e.type)throw new Error(`Cannot apply test "odd" to type: ${e.type}`);return e.value%2!=0}],["even",e=>{if("NumericValue"!==e.type)throw new Error(`Cannot apply test "even" to type: ${e.type}`);return e.value%2==0}],["false",e=>"BooleanValue"===e.type&&!e.value],["true",e=>"BooleanValue"===e.type&&e.value],["none",e=>"NullValue"===e.type],["string",e=>"StringValue"===e.type],["number",e=>"NumericValue"===e.type],["integer",e=>"NumericValue"===e.type&&Number.isInteger(e.value)],["iterable",e=>"ArrayValue"===e.type||"StringValue"===e.type],["mapping",e=>"ObjectValue"===e.type],["lower",e=>{const t=e.value;return"StringValue"===e.type&&t===t.toLowerCase()}],["upper",e=>{const t=e.value;return"StringValue"===e.type&&t===t.toUpperCase()}],["none",e=>"NullValue"===e.type],["defined",e=>"UndefinedValue"!==e.type],["undefined",e=>"UndefinedValue"===e.type],["equalto",(e,t)=>e.value===t.value],["eq",(e,t)=>e.value===t.value]]);set(e,t){return this.declareVariable(e,mf(t))}declareVariable(e,t){if(this.variables.has(e))throw new SyntaxError(`Variable already declared: ${e}`);return this.variables.set(e,t),t}setVariable(e,t){return this.variables.set(e,t),t}resolve(e){if(this.variables.has(e))return this;if(this.parent)return this.parent.resolve(e);throw new Error(`Unknown variable: ${e}`)}lookupVariable(e){try{return this.resolve(e).variables.get(e)??new pf}catch{return new pf}}},ff=class{global;constructor(e){this.global=e??new hf}run(e){return this.evaluate(e,this.global)}evaluateBinaryExpression(e,t){const n=this.evaluate(e.left,t);switch(e.operator.value){case"and":return n.__bool__().value?this.evaluate(e.right,t):n;case"or":return n.__bool__().value?n:this.evaluate(e.right,t)}const r=this.evaluate(e.right,t);switch(e.operator.value){case"==":return new sf(n.value==r.value);case"!=":return new sf(n.value!=r.value)}if(n instanceof pf||r instanceof pf)throw new Error("Cannot perform operation on undefined values");if(n instanceof cf||r instanceof cf)throw new Error("Cannot perform operation on null values");if(n instanceof nf&&r instanceof nf)switch(e.operator.value){case"+":return new nf(n.value+r.value);case"-":return new nf(n.value-r.value);case"*":return new nf(n.value*r.value);case"/":return new nf(n.value/r.value);case"%":return new nf(n.value%r.value);case"<":return new sf(n.value<r.value);case">":return new sf(n.value>r.value);case">=":return new sf(n.value>=r.value);case"<=":return new sf(n.value<=r.value)}else if(n instanceof lf&&r instanceof lf){if("+"===e.operator.value)return new lf(n.value.concat(r.value))}else if(r instanceof lf){const t=void 0!==r.value.find((e=>e.value===n.value));switch(e.operator.value){case"in":return new sf(t);case"not in":return new sf(!t)}}if((n instanceof rf||r instanceof rf)&&"+"===e.operator.value)return new rf(n.value.toString()+r.value.toString());if(n instanceof rf&&r instanceof rf)switch(e.operator.value){case"in":return new sf(r.value.includes(n.value));case"not in":return new sf(!r.value.includes(n.value))}if(n instanceof rf&&r instanceof af)switch(e.operator.value){case"in":return new sf(r.value.has(n.value));case"not in":return new sf(!r.value.has(n.value))}throw new SyntaxError(`Unknown operator "${e.operator.value}" between ${n.type} and ${r.type}`)}evaluateArguments(e,t){const n=[],r=new Map;for(const s of e)if("KeywordArgumentExpression"===s.type){const e=s;r.set(e.key.value,this.evaluate(e.value,t))}else{if(r.size>0)throw new Error("Positional arguments must come before keyword arguments");n.push(this.evaluate(s,t))}return[n,r]}evaluateFilterExpression(e,t){const n=this.evaluate(e.operand,t);if("Identifier"===e.filter.type){const t=e.filter;if("tojson"===t.value)return new rf(_f(n));if(n instanceof lf)switch(t.value){case"list":return n;case"first":return n.value[0];case"last":return n.value[n.value.length-1];case"length":return new nf(n.value.length);case"reverse":return new lf(n.value.reverse());case"sort":return new lf(n.value.sort(((e,t)=>{if(e.type!==t.type)throw new Error(`Cannot compare different types: ${e.type} and ${t.type}`);switch(e.type){case"NumericValue":return e.value-t.value;case"StringValue":return e.value.localeCompare(t.value);default:throw new Error(`Cannot compare type: ${e.type}`)}})));default:throw new Error(`Unknown ArrayValue filter: ${t.value}`)}else if(n instanceof rf)switch(t.value){case"length":return new nf(n.value.length);case"upper":return new rf(n.value.toUpperCase());case"lower":return new rf(n.value.toLowerCase());case"title":return new rf(ef(n.value));case"capitalize":return new rf(n.value.charAt(0).toUpperCase()+n.value.slice(1));case"trim":return new rf(n.value.trim());case"indent":return new rf(n.value.split("\\n").map(((e,t)=>0===t||0===e.length?e:"    "+e)).join("\\n"));case"string":return n;default:throw new Error(`Unknown StringValue filter: ${t.value}`)}else{if(n instanceof nf){if("abs"===t.value)return new nf(Math.abs(n.value));throw new Error(`Unknown NumericValue filter: ${t.value}`)}if(n instanceof af)switch(t.value){case"items":return new lf(Array.from(n.value.entries()).map((([e,t])=>new lf([new rf(e),t]))));case"length":return new nf(n.value.size);default:throw new Error(`Unknown ObjectValue filter: ${t.value}`)}}throw new Error(`Cannot apply filter "${t.value}" to type: ${n.type}`)}if("CallExpression"===e.filter.type){const r=e.filter;if("Identifier"!==r.callee.type)throw new Error(`Unknown filter: ${r.callee.type}`);const s=r.callee.value;if("tojson"===s){const[,e]=this.evaluateArguments(r.args,t),s=e.get("indent")??new cf;if(!(s instanceof nf||s instanceof cf))throw new Error("If set, indent must be a number");return new rf(_f(n,s.value))}if(n instanceof lf){switch(s){case"selectattr":case"rejectattr":{const e="selectattr"===s;if(n.value.some((e=>!(e instanceof af))))throw new Error(`\\`${s}\\` can only be applied to array of objects`);if(r.args.some((e=>"StringLiteral"!==e.type)))throw new Error(`arguments of \\`${s}\\` must be strings`);const[i,a,o]=r.args.map((e=>this.evaluate(e,t)));let l;if(a){const e=t.tests.get(a.value);if(!e)throw new Error(`Unknown test: ${a.value}`);l=e}else l=(...e)=>e[0].__bool__().value;const u=n.value.filter((t=>{const n=t.value.get(i.value),r=!!n&&l(n,o);return e?r:!r}));return new lf(u)}case"map":{const[,e]=this.evaluateArguments(r.args,t);if(e.has("attribute")){const t=e.get("attribute");if(!(t instanceof rf))throw new Error("attribute must be a string");const r=e.get("default"),s=n.value.map((e=>{if(!(e instanceof af))throw new Error("items in map must be an object");return e.value.get(t.value)??r??new pf}));return new lf(s)}throw new Error("`map` expressions without `attribute` set are not currently supported.")}}throw new Error(`Unknown ArrayValue filter: ${s}`)}if(n instanceof rf){if("indent"===s){const[e,s]=this.evaluateArguments(r.args,t),i=e.at(0)??s.get("width")??new nf(4);if(!(i instanceof nf))throw new Error("width must be a number");const a=e.at(1)??s.get("first")??new sf(!1),o=e.at(2)??s.get("blank")??new sf(!1),l=n.value.split("\\n"),u=" ".repeat(i.value),d=l.map(((e,t)=>!a.value&&0===t||!o.value&&0===e.length?e:u+e));return new rf(d.join("\\n"))}throw new Error(`Unknown StringValue filter: ${s}`)}throw new Error(`Cannot apply filter "${s}" to type: ${n.type}`)}throw new Error(`Unknown filter: ${e.filter.type}`)}evaluateTestExpression(e,t){const n=this.evaluate(e.operand,t),r=t.tests.get(e.test.value);if(!r)throw new Error(`Unknown test: ${e.test.value}`);const s=r(n);return new sf(e.negate?!s:s)}evaluateUnaryExpression(e,t){const n=this.evaluate(e.argument,t);if("not"===e.operator.value)return new sf(!n.value);throw new SyntaxError(`Unknown operator: ${e.operator.value}`)}evalProgram(e,t){return this.evaluateBlock(e.body,t)}evaluateBlock(e,t){let n="";for(const r of e){const e=this.evaluate(r,t);"NullValue"!==e.type&&"UndefinedValue"!==e.type&&(n+=e.value)}return new rf(n)}evaluateIdentifier(e,t){return t.lookupVariable(e.value)}evaluateCallExpression(e,t){const[n,r]=this.evaluateArguments(e.args,t);r.size>0&&n.push(new of(r));const s=this.evaluate(e.callee,t);if("FunctionValue"!==s.type)throw new Error(`Cannot call something that is not a function: got ${s.type}`);return s.value(n,t)}evaluateSliceExpression(e,t,n){if(!(e instanceof lf||e instanceof rf))throw new Error("Slice object must be an array or string");const r=this.evaluate(t.start,n),s=this.evaluate(t.stop,n),i=this.evaluate(t.step,n);if(!(r instanceof nf||r instanceof pf))throw new Error("Slice start must be numeric or undefined");if(!(s instanceof nf||s instanceof pf))throw new Error("Slice stop must be numeric or undefined");if(!(i instanceof nf||i instanceof pf))throw new Error("Slice step must be numeric or undefined");return e instanceof lf?new lf(Jh(e.value,r.value,s.value,i.value)):new rf(Jh(Array.from(e.value),r.value,s.value,i.value).join(""))}evaluateMemberExpression(e,t){const n=this.evaluate(e.object,t);let r,s;if(e.computed){if("SliceExpression"===e.property.type)return this.evaluateSliceExpression(n,e.property,t);r=this.evaluate(e.property,t)}else r=new rf(e.property.value);if(n instanceof af){if(!(r instanceof rf))throw new Error(`Cannot access property with non-string: got ${r.type}`);s=n.value.get(r.value)??n.builtins.get(r.value)}else if(n instanceof lf||n instanceof rf)if(r instanceof nf)s=n.value.at(r.value),n instanceof rf&&(s=new rf(n.value.at(r.value)));else{if(!(r instanceof rf))throw new Error(`Cannot access property with non-string/non-number: got ${r.type}`);s=n.builtins.get(r.value)}else{if(!(r instanceof rf))throw new Error(`Cannot access property with non-string: got ${r.type}`);s=n.builtins.get(r.value)}return s instanceof tf?s:new pf}evaluateSet(e,t){const n=this.evaluate(e.value,t);if("Identifier"===e.assignee.type){const r=e.assignee.value;t.setVariable(r,n)}else{if("MemberExpression"!==e.assignee.type)throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(e.assignee)}`);{const r=e.assignee,s=this.evaluate(r.object,t);if(!(s instanceof af))throw new Error("Cannot assign to member of non-object");if("Identifier"!==r.property.type)throw new Error("Cannot assign to member with non-identifier property");s.value.set(r.property.value,n)}}return new cf}evaluateIf(e,t){const n=this.evaluate(e.test,t);return this.evaluateBlock(n.__bool__().value?e.body:e.alternate,t)}evaluateFor(e,t){const n=new hf(t);let r,s;if("SelectExpression"===e.iterable.type){const t=e.iterable;s=this.evaluate(t.iterable,n),r=t.test}else s=this.evaluate(e.iterable,n);if(!(s instanceof lf))throw new Error(`Expected iterable type in for loop: got ${s.type}`);const i=[],a=[];for(let t=0;t<s.value.length;++t){const o=new hf(n),l=s.value[t];let u;if("Identifier"===e.loopvar.type)u=t=>t.setVariable(e.loopvar.value,l);else{if("TupleLiteral"!==e.loopvar.type)throw new Error(`Invalid loop variable(s): ${e.loopvar.type}`);{const t=e.loopvar;if("ArrayValue"!==l.type)throw new Error(`Cannot unpack non-iterable type: ${l.type}`);const n=l;if(t.value.length!==n.value.length)throw new Error(`Too ${t.value.length>n.value.length?"few":"many"} items to unpack`);u=e=>{for(let r=0;r<t.value.length;++r){if("Identifier"!==t.value[r].type)throw new Error(`Cannot unpack non-identifier type: ${t.value[r].type}`);e.setVariable(t.value[r].value,n.value[r])}}}}if(r){u(o);if(!this.evaluate(r,o).__bool__().value)continue}i.push(l),a.push(u)}let o="",l=!0;for(let t=0;t<i.length;++t){const r=new Map([["index",new nf(t+1)],["index0",new nf(t)],["revindex",new nf(i.length-t)],["revindex0",new nf(i.length-t-1)],["first",new sf(0===t)],["last",new sf(t===i.length-1)],["length",new nf(i.length)],["previtem",t>0?i[t-1]:new pf],["nextitem",t<i.length-1?i[t+1]:new pf]]);n.setVariable("loop",new af(r)),a[t](n);o+=this.evaluateBlock(e.body,n).value,l=!1}if(l){o+=this.evaluateBlock(e.defaultBlock,n).value}return new rf(o)}evaluateMacro(e,t){return t.setVariable(e.name.value,new df(((t,n)=>{const r=new hf(n);let s;t=t.slice(),"KeywordArgumentsValue"===t.at(-1)?.type&&(s=t.pop());for(let n=0;n<e.args.length;++n){const i=e.args[n],a=t[n];if("Identifier"===i.type){const e=i;if(!a)throw new Error(`Missing positional argument: ${e.value}`);r.setVariable(e.value,a)}else{if("KeywordArgumentExpression"!==i.type)throw new Error(`Unknown argument type: ${i.type}`);{const e=i,t=a??s?.value.get(e.key.value)??this.evaluate(e.value,r);r.setVariable(e.key.value,t)}}}return this.evaluateBlock(e.body,r)}))),new cf}evaluate(e,t){if(void 0===e)return new pf;switch(e.type){case"Program":return this.evalProgram(e,t);case"Set":return this.evaluateSet(e,t);case"If":return this.evaluateIf(e,t);case"For":return this.evaluateFor(e,t);case"Macro":return this.evaluateMacro(e,t);case"NumericLiteral":return new nf(Number(e.value));case"StringLiteral":return new rf(e.value);case"BooleanLiteral":return new sf(e.value);case"NullLiteral":return new cf(e.value);case"ArrayLiteral":return new lf(e.value.map((e=>this.evaluate(e,t))));case"TupleLiteral":return new uf(e.value.map((e=>this.evaluate(e,t))));case"ObjectLiteral":{const n=new Map;for(const[r,s]of e.value){const e=this.evaluate(r,t);if(!(e instanceof rf))throw new Error(`Object keys must be strings: got ${e.type}`);n.set(e.value,this.evaluate(s,t))}return new af(n)}case"Identifier":return this.evaluateIdentifier(e,t);case"CallExpression":return this.evaluateCallExpression(e,t);case"MemberExpression":return this.evaluateMemberExpression(e,t);case"UnaryExpression":return this.evaluateUnaryExpression(e,t);case"BinaryExpression":return this.evaluateBinaryExpression(e,t);case"FilterExpression":return this.evaluateFilterExpression(e,t);case"TestExpression":return this.evaluateTestExpression(e,t);default:throw new SyntaxError(`Unknown node type: ${e.type}`)}}};function mf(e){switch(typeof e){case"number":return new nf(e);case"string":return new rf(e);case"boolean":return new sf(e);case"undefined":return new pf;case"object":return null===e?new cf:Array.isArray(e)?new lf(e.map(mf)):new af(new Map(Object.entries(e).map((([e,t])=>[e,mf(t)]))));case"function":return new df(((t,n)=>mf(e(...t.map((e=>e.value)))??null)));default:throw new Error(`Cannot convert to runtime value: ${e}`)}}function _f(e,t,n){const r=n??0;switch(e.type){case"NullValue":case"UndefinedValue":return"null";case"NumericValue":case"StringValue":case"BooleanValue":return JSON.stringify(e.value);case"ArrayValue":case"ObjectValue":{const n=t?" ".repeat(t):"",s="\\n"+n.repeat(r),i=s+n;if("ArrayValue"===e.type){const n=e.value.map((e=>_f(e,t,r+1)));return t?`[${i}${n.join(`,${i}`)}${s}]`:`[${n.join(", ")}]`}{const n=Array.from(e.value.entries()).map((([e,n])=>{const s=`"${e}": ${_f(n,t,r+1)}`;return t?`${i}${s}`:s}));return t?`{${n.join(",")}${s}}`:`{${n.join(", ")}}`}}default:throw new Error(`Cannot convert to JSON: ${e.type}`)}}var gf=class{parsed;constructor(e){const t=function n(e,t={}){const n=[],r=function s(e,t={}){return e.endsWith("\\n")&&(e=e.slice(0,-1)),e=e.replace(/{#.*?#}/gs,"{##}"),t.lstrip_blocks&&(e=e.replace(/^[ \\t]*({[#%])/gm,"$1")),t.trim_blocks&&(e=e.replace(/([#%]})\\n/g,"$1")),e.replace(/{##}/g,"").replace(/-%}\\s*/g,"%}").replace(/\\s*{%-/g,"{%").replace(/-}}\\s*/g,"}}").replace(/\\s*{{-/g,"{{")}(e,t);let i=0;const a=e=>{let t="";for(;e(r[i]);)if("\\\\"!==r[i]){if(t+=r[i++],i>=r.length)throw new SyntaxError("Unexpected end of input")}else{if(++i,i>=r.length)throw new SyntaxError("Unexpected end of input");const e=r[i++],n=Eh.get(e);if(void 0===n)throw new SyntaxError(`Unexpected escaped character: ${e}`);t+=n}return t};e:for(;i<r.length;){const e=n.at(-1)?.type;if(void 0===e||e===yh.CloseStatement||e===yh.CloseExpression){let e="";for(;i<r.length&&("{"!==r[i]||"%"!==r[i+1]&&"{"!==r[i+1]);)e+=r[i++];if(e.length>0){n.push(new xh(e,yh.Text));continue}}a((e=>/\\s/.test(e)));const t=r[i];if("-"===t||"+"===t){const e=n.at(-1)?.type;if(e===yh.Text||void 0===e)throw new SyntaxError(`Unexpected character: ${t}`);switch(e){case yh.Identifier:case yh.NumericLiteral:case yh.BooleanLiteral:case yh.NullLiteral:case yh.StringLiteral:case yh.CloseParen:case yh.CloseSquareBracket:break;default:{++i;const e=a($h);n.push(new xh(`${t}${e}`,e.length>0?yh.NumericLiteral:yh.UnaryOperator));continue}}}for(const[e,t]of kh)if(r.slice(i,i+e.length)===e){n.push(new xh(e,t)),i+=e.length;continue e}if("\'"!==t&&\'"\'!==t)if($h(t)){const e=a($h);n.push(new xh(e,yh.NumericLiteral))}else{if(!vh(t))throw new SyntaxError(`Unexpected character: ${t}`);{const e=a(vh),t=Object.hasOwn(bh,e)?bh[e]:yh.Identifier;t===yh.In&&n.at(-1)?.type===yh.Not?(n.pop(),n.push(new xh("not in",yh.NotIn))):n.push(new xh(e,t))}}else{++i;const e=a((e=>e!==t));n.push(new xh(e,yh.StringLiteral)),++i}}return n}(e,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=Yh(t)}render(e){const t=new hf;t.set("false",!1),t.set("true",!0),t.set("raise_exception",(e=>{throw new Error(e)})),t.set("range",Zh);for(const[n,r]of Object.entries(e))t.set(n,r);return new ff(t).run(this.parsed).value}};const wf=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],yf=new Map(wf),bf=new Map([...wf.map((([e,t])=>[t,e])),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);async function xf(e,t){const n=await Promise.all([ce(e,"tokenizer.json",!0,t),ce(e,"tokenizer_config.json",!0,t)]);return null!==t.legacy&&(n[1].legacy=t.legacy),n}function vf(e,t=!0){if(void 0!==e.Regex){let t=e.Regex.replace(/\\\\([#&~])/g,"$1");for(const[e,n]of If)t=t.replaceAll(e,n);return new RegExp(t,"gu")}if(void 0!==e.String){const n=H(e.String);return new RegExp(t?n:`(${n})`,"gu")}return console.warn("Unknown pattern type:",e),null}function $f(e){return new Map(Object.entries(e))}function kf(e){const t=e.dims;switch(t.length){case 1:return e.tolist();case 2:if(1!==t[0])throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return e.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${t.length}.`)}}function Ef(e){return e.replace(/ \\./g,".").replace(/ \\?/g,"?").replace(/ \\!/g,"!").replace(/ ,/g,",").replace(/ \\\' /g,"\'").replace(/ n\\\'t/g,"n\'t").replace(/ \\\'m/g,"\'m").replace(/ \\\'s/g,"\'s").replace(/ \\\'ve/g,"\'ve").replace(/ \\\'re/g,"\'re")}function Sf(e){return e.replace(/\\p{M}/gu,"")}function zf(e){return e>=19968&&e<=40959||e>=13312&&e<=19903||e>=131072&&e<=173791||e>=173824&&e<=177983||e>=177984&&e<=178207||e>=178208&&e<=183983||e>=63744&&e<=64255||e>=194560&&e<=195103}const Cf="\\\\p{P}\\\\u0021-\\\\u002F\\\\u003A-\\\\u0040\\\\u005B-\\\\u0060\\\\u007B-\\\\u007E",Tf=new RegExp(`^[${Cf}]+$`,"gu"),Af=".,!?",If=new Map([["(?i:\'s|\'t|\'re|\'ve|\'m|\'ll|\'d)","(?:\'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"],[` ?[^(\\\\s|[${Af}])]+`,` ?[^\\\\s${Af}]+`]]);class Mf{constructor(e){this.content=e.content,this.id=e.id,this.single_word=e.single_word??!1,this.lstrip=e.lstrip??!1,this.rstrip=e.rstrip??!1,this.special=e.special??!1,this.normalized=e.normalized??null}}class Of extends j{constructor(e){super(),this.config=e,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(e,...t){switch(e.type){case"WordPiece":return new Bf(e);case"Unigram":return new Nf(e,...t);case"BPE":return new Lf(e);default:if(e.vocab)return Array.isArray(e.vocab)?new Nf(e,...t):new Ff(e,...t);throw new Error(`Unknown TokenizerModel type: ${e.type}`)}}_call(e){return e=this.encode(e),this.fuse_unk&&(e=function t(e,n,r){const s=[];let i=0;for(;i<e.length;)if(s.push(e[i]),(n.get(e[i])??r)===r)for(;++i<e.length&&(n.get(e[i])??r)===r;)n.get(s.at(-1))!==r&&(s[s.length-1]+=e[i]);else++i;return s}(e,this.tokens_to_ids,this.unk_token_id)),e}encode(e){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(e){return e.map((e=>this.tokens_to_ids.get(e)??this.unk_token_id))}convert_ids_to_tokens(e){return e.map((e=>this.vocab[e]??this.unk_token))}}class Bf extends Of{constructor(e){super(e),this.tokens_to_ids=$f(e.vocab),this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.max_input_chars_per_word=e.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e}encode(e){const t=[];for(const n of e){const e=[...n];if(e.length>this.max_input_chars_per_word){t.push(this.unk_token);continue}let r=!1,s=0;const i=[];for(;s<e.length;){let t=e.length,n=null;for(;s<t;){let r=e.slice(s,t).join("");if(s>0&&(r=this.config.continuing_subword_prefix+r),this.tokens_to_ids.has(r)){n=r;break}--t}if(null===n){r=!0;break}i.push(n),s=t}r?t.push(this.unk_token):t.push(...i)}return t}}class Nf extends Of{constructor(e,t){super(e);const n=e.vocab.length;this.vocab=new Array(n),this.scores=new Array(n);for(let t=0;t<n;++t){const n=e.vocab[t];this.vocab[t]=n[0],this.scores[t]=n[1]}this.unk_token_id=e.unk_id,this.unk_token=this.vocab[e.unk_id],this.tokens_to_ids=new Map(this.vocab.map(((e,t)=>[e,t]))),this.bos_token=" ",this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=t.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.unk_token=this.vocab[this.unk_token_id],this.minScore=me(this.scores)[0],this.unk_score=this.minScore-10,this.scores[this.unk_token_id]=this.unk_score,this.trie=new mh,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(e){const t=e.chars;let n=0;for(;n<t.length;){let r=!1;const s=[],i=t.slice(n).join(""),a=this.trie.commonPrefixSearch(i);for(const t of a){s.push(t);const i=this.tokens_to_ids.get(t),a=this.scores[i],o=ee(t);e.insert(n,o,a,i),r||1!==o||(r=!0)}r||e.insert(n,1,this.unk_score,this.unk_token_id),n+=1}}tokenize(e){const t=new gh(e,this.bos_token_id,this.eos_token_id);return this.populateNodes(t),t.tokens()}encode(e){const t=[];for(const n of e){const e=this.tokenize(n);t.push(...e)}return t}}const Pf=(()=>{const e=[...Array.from({length:"~".charCodeAt(0)-"!".charCodeAt(0)+1},((e,t)=>t+"!".charCodeAt(0))),...Array.from({length:"".charCodeAt(0)-"".charCodeAt(0)+1},((e,t)=>t+"".charCodeAt(0))),...Array.from({length:"".charCodeAt(0)-"".charCodeAt(0)+1},((e,t)=>t+"".charCodeAt(0)))],t=e.slice();let n=0;for(let r=0;r<256;++r)e.includes(r)||(e.push(r),t.push(256+n),n+=1);const r=t.map((e=>String.fromCharCode(e)));return Object.fromEntries(e.map(((e,t)=>[e,r[t]])))})(),Rf=function Df(e){return Object.fromEntries(Object.entries(e).map((([e,t])=>[t,e])))}(Pf);class Lf extends Of{constructor(e){super(e),this.tokens_to_ids=$f(e.vocab),this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e;const t=Array.isArray(e.merges[0]);this.merges=t?e.merges:e.merges.map((e=>e.split(" ",2))),this.bpe_ranks=new Map(this.merges.map(((e,t)=>[JSON.stringify(e),t]))),this.end_of_word_suffix=e.end_of_word_suffix,this.continuing_subword_suffix=e.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.cache=new Map}bpe(e){if(0===e.length)return[];const t=this.cache.get(e);if(void 0!==t)return t;const n=Array.from(e);this.end_of_word_suffix&&(n[n.length-1]+=this.end_of_word_suffix);let r=[];if(n.length>1){const e=new fh(((e,t)=>e.score<t.score));let t={token:n[0],bias:0,prev:null,next:null},s=t;for(let t=1;t<n.length;++t){const r={bias:t/n.length,token:n[t],prev:s,next:null};s.next=r,this._add_node(e,s),s=r}for(;!e.isEmpty();){const n=e.pop();if(n.deleted||!n.next||n.next.deleted)continue;if(n.deleted=!0,n.next.deleted=!0,n.prev){const e={...n.prev};n.prev.deleted=!0,n.prev=e,e.prev?e.prev.next=e:t=e}const r={token:n.token+n.next.token,bias:n.bias,prev:n.prev,next:n.next.next};r.prev?(r.prev.next=r,this._add_node(e,r.prev)):t=r,r.next&&(r.next.prev=r,this._add_node(e,r))}for(let e=t;null!==e;e=e.next)r.push(e.token)}else r=n;if(this.continuing_subword_suffix)for(let e=0;e<r.length-1;++e)r[e]+=this.continuing_subword_suffix;return this.cache.set(e,r),r}_add_node(e,t){const n=this.bpe_ranks.get(JSON.stringify([t.token,t.next.token]));void 0!==n&&(t.score=n+t.bias,e.push(t))}encode(e){const t=[];for(const n of e){if(this.ignore_merges&&this.tokens_to_ids.has(n)){t.push(n);continue}const e=this.bpe(n);for(const n of e)if(this.tokens_to_ids.has(n))t.push(n);else if(this.byte_fallback){const e=Array.from(this.text_encoder.encode(n)).map((e=>`<0x${e.toString(16).toUpperCase().padStart(2,"0")}>`));e.every((e=>this.tokens_to_ids.has(e)))?t.push(...e):t.push(this.unk_token)}else t.push(this.unk_token)}return t}}class Ff extends Of{constructor(e,t){super(e),this.tokens_to_ids=$f(t.target_lang?e.vocab[t.target_lang]:e.vocab),this.bos_token=t.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=t.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=t.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=t.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e}encode(e){return e}}class Uf extends j{constructor(e){super(),this.config=e}static fromConfig(e){if(null===e)return null;switch(e.type){case"BertNormalizer":return new Yf(e);case"Precompiled":return new $m(e);case"Sequence":return new Qf(e);case"Replace":return new qf(e);case"NFC":return new Vf(e);case"NFKC":return new Wf(e);case"NFKD":return new jf(e);case"Strip":return new Gf(e);case"StripAccents":return new Hf(e);case"Lowercase":return new Kf(e);case"Prepend":return new Xf(e);default:throw new Error(`Unknown Normalizer type: ${e.type}`)}}normalize(e){throw Error("normalize should be implemented in subclass.")}_call(e){return this.normalize(e)}}class qf extends Uf{normalize(e){const t=vf(this.config.pattern);return null===t?e:e.replaceAll(t,this.config.content)}}class Vf extends Uf{normalize(e){return e=e.normalize("NFC")}}class Wf extends Uf{normalize(e){return e=e.normalize("NFKC")}}class jf extends Uf{normalize(e){return e=e.normalize("NFKD")}}class Gf extends Uf{normalize(e){return this.config.strip_left&&this.config.strip_right?e=e.trim():(this.config.strip_left&&(e=e.trimStart()),this.config.strip_right&&(e=e.trimEnd())),e}}class Hf extends Uf{normalize(e){return e=Sf(e)}}class Kf extends Uf{normalize(e){return e=e.toLowerCase()}}class Xf extends Uf{normalize(e){return e=this.config.prepend+e}}class Qf extends Uf{constructor(e){super(e),this.normalizers=e.normalizers.map((e=>Uf.fromConfig(e)))}normalize(e){return this.normalizers.reduce(((e,t)=>t.normalize(e)),e)}}class Yf extends Uf{_tokenize_chinese_chars(e){const t=[];for(let n=0;n<e.length;++n){const r=e[n];zf(r.charCodeAt(0))?(t.push(" "),t.push(r),t.push(" ")):t.push(r)}return t.join("")}stripAccents(e){return e.normalize("NFD").replace(/\\p{Mn}/gu,"")}_is_control(e){switch(e){case"\\t":case"\\n":case"\\r":return!1;default:return/^\\p{Cc}|\\p{Cf}|\\p{Co}|\\p{Cs}$/u.test(e)}}_clean_text(e){const t=[];for(const n of e){const e=n.charCodeAt(0);0===e||65533===e||this._is_control(n)||(/^\\s$/.test(n)?t.push(" "):t.push(n))}return t.join("")}normalize(e){return this.config.clean_text&&(e=this._clean_text(e)),this.config.handle_chinese_chars&&(e=this._tokenize_chinese_chars(e)),this.config.lowercase?(e=e.toLowerCase(),!1!==this.config.strip_accents&&(e=this.stripAccents(e))):this.config.strip_accents&&(e=this.stripAccents(e)),e}}class Zf extends j{static fromConfig(e){if(null===e)return null;switch(e.type){case"BertPreTokenizer":return new Jf(e);case"Sequence":return new km(e);case"Whitespace":return new Em(e);case"WhitespaceSplit":return new Sm(e);case"Metaspace":return new xm(e);case"ByteLevel":return new em(e);case"Split":return new tm(e);case"Punctuation":return new nm(e);case"Digits":return new rm(e);case"Replace":return new zm(e);default:throw new Error(`Unknown PreTokenizer type: ${e.type}`)}}pre_tokenize_text(e,t){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(e,t){return(Array.isArray(e)?e.map((e=>this.pre_tokenize_text(e,t))):this.pre_tokenize_text(e,t)).flat()}_call(e,t){return this.pre_tokenize(e,t)}}class Jf extends Zf{constructor(e){super(),this.pattern=new RegExp(`[^\\\\s${Cf}]+|[${Cf}]`,"gu")}pre_tokenize_text(e,t){return e.trim().match(this.pattern)||[]}}class em extends Zf{constructor(e){super(),this.config=e,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=/\'s|\'t|\'re|\'ve|\'m|\'ll|\'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+/gu,this.byte_encoder=Pf,this.text_encoder=new TextEncoder}pre_tokenize_text(e,t){this.add_prefix_space&&!e.startsWith(" ")&&(e=" "+e);return(this.use_regex?e.match(this.pattern)||[]:[e]).map((e=>Array.from(this.text_encoder.encode(e),(e=>this.byte_encoder[e])).join("")))}}class tm extends Zf{constructor(e){super(),this.config=e,this.pattern=vf(this.config.pattern,this.config.invert)}pre_tokenize_text(e,t){return null===this.pattern?[]:this.config.invert?e.match(this.pattern)||[]:"removed"===this.config.behavior?.toLowerCase()?e.split(this.pattern).filter((e=>e)):function n(e,t){const n=[];let r=0;for(const s of e.matchAll(t)){const t=s[0];r<s.index&&n.push(e.slice(r,s.index)),t.length>0&&n.push(t),r=s.index+t.length}return r<e.length&&n.push(e.slice(r)),n}(e,this.pattern)}}class nm extends Zf{constructor(e){super(),this.config=e,this.pattern=new RegExp(`[^${Cf}]+|[${Cf}]+`,"gu")}pre_tokenize_text(e,t){return e.match(this.pattern)||[]}}class rm extends Zf{constructor(e){super(),this.config=e;const t="[^\\\\d]+|\\\\d"+(this.config.individual_digits?"":"+");this.pattern=new RegExp(t,"gu")}pre_tokenize_text(e,t){return e.match(this.pattern)||[]}}class sm extends j{constructor(e){super(),this.config=e}static fromConfig(e){if(null===e)return null;switch(e.type){case"TemplateProcessing":return new om(e);case"ByteLevel":return new lm(e);case"RobertaProcessing":return new am(e);case"BertProcessing":return new im(e);case"Sequence":return new um(e);default:throw new Error(`Unknown PostProcessor type: ${e.type}`)}}post_process(e,...t){throw Error("post_process should be implemented in subclass.")}_call(e,...t){return this.post_process(e,...t)}}class im extends sm{constructor(e){super(e),this.cls=e.cls[0],this.sep=e.sep[0]}post_process(e,t=null,{add_special_tokens:n=!0}={}){n&&(e=Q([this.cls],e,[this.sep]));let r=new Array(e.length).fill(0);if(null!==t){const s=n&&this instanceof am?[this.sep]:[],i=n?[this.sep]:[];e=Q(e,s,t,i),r=Q(r,new Array(t.length+s.length+i.length).fill(1))}return{tokens:e,token_type_ids:r}}}class am extends im{}class om extends sm{constructor(e){super(e),this.single=e.single,this.pair=e.pair}post_process(e,t=null,{add_special_tokens:n=!0}={}){const r=null===t?this.single:this.pair;let s=[],i=[];for(const a of r)"SpecialToken"in a?n&&(s.push(a.SpecialToken.id),i.push(a.SpecialToken.type_id)):"Sequence"in a&&("A"===a.Sequence.id?(s=Q(s,e),i=Q(i,new Array(e.length).fill(a.Sequence.type_id))):"B"===a.Sequence.id&&(s=Q(s,t),i=Q(i,new Array(t.length).fill(a.Sequence.type_id))));return{tokens:s,token_type_ids:i}}}class lm extends sm{post_process(e,t=null){return t&&(e=Q(e,t)),{tokens:e}}}class um extends sm{constructor(e){super(e),this.processors=e.processors.map((e=>sm.fromConfig(e)))}post_process(e,t=null,n={}){let r;for(const s of this.processors)if(s instanceof lm){if(e=s.post_process(e).tokens,t){t=s.post_process(t).tokens}}else{const i=s.post_process(e,t,n);e=i.tokens,r=i.token_type_ids}return{tokens:e,token_type_ids:r}}}class dm extends j{constructor(e){super(),this.config=e,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=e.trim_offsets}static fromConfig(e){if(null===e)return null;switch(e.type){case"WordPiece":return new mm(e);case"Metaspace":return new vm(e);case"ByteLevel":return new _m(e);case"Replace":return new cm(e);case"ByteFallback":return new pm(e);case"Fuse":return new hm(e);case"Strip":return new fm(e);case"Sequence":return new wm(e);case"CTC":return new gm(e);case"BPEDecoder":return new ym(e);default:throw new Error(`Unknown Decoder type: ${e.type}`)}}_call(e){return this.decode(e)}decode(e){return this.decode_chain(e).join("")}decode_chain(e){throw Error("`decode_chain` should be implemented in subclass.")}}class cm extends dm{decode_chain(e){const t=vf(this.config.pattern);return null===t?e:e.map((e=>e.replaceAll(t,this.config.content)))}}class pm extends dm{constructor(e){super(e),this.text_decoder=new TextDecoder}decode_chain(e){const t=[];let n=[];for(const r of e){let e=null;if(6===r.length&&r.startsWith("<0x")&&r.endsWith(">")){const t=parseInt(r.slice(3,5),16);isNaN(t)||(e=t)}if(null!==e)n.push(e);else{if(n.length>0){const e=this.text_decoder.decode(Uint8Array.from(n));t.push(e),n=[]}t.push(r)}}if(n.length>0){const e=this.text_decoder.decode(Uint8Array.from(n));t.push(e),n=[]}return t}}class hm extends dm{decode_chain(e){return[e.join("")]}}class fm extends dm{constructor(e){super(e),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(e){return e.map((e=>{let t=0;for(let n=0;n<this.start&&e[n]===this.content;++n)t=n+1;let n=e.length;for(let t=0;t<this.stop;++t){const r=e.length-t-1;if(e[r]!==this.content)break;n=r}return e.slice(t,n)}))}}class mm extends dm{constructor(e){super(e),this.cleanup=e.cleanup}decode_chain(e){return e.map(((e,t)=>(0!==t&&(e=e.startsWith(this.config.prefix)?e.replace(this.config.prefix,""):" "+e),this.cleanup&&(e=Ef(e)),e)))}}class _m extends dm{constructor(e){super(e),this.byte_decoder=Rf,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(e){const t=e.join(""),n=new Uint8Array([...t].map((e=>this.byte_decoder[e])));return this.text_decoder.decode(n)}decode_chain(e){const t=[];let n=[];for(const r of e)void 0!==this.added_tokens.find((e=>e.content===r))?(n.length>0&&(t.push(this.convert_tokens_to_string(n)),n=[]),t.push(r)):n.push(r);return n.length>0&&t.push(this.convert_tokens_to_string(n)),t}}class gm extends dm{constructor(e){super(e),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(e){if(0===e.length)return"";const t=[e[0]];for(let n=1;n<e.length;++n)e[n]!==t.at(-1)&&t.push(e[n]);let n=t.filter((e=>e!==this.pad_token)).join("");return this.cleanup&&(n=Ef(n).replaceAll(this.word_delimiter_token," ").trim()),n}decode_chain(e){return[this.convert_tokens_to_string(e)]}}class wm extends dm{constructor(e){super(e),this.decoders=e.decoders.map((e=>dm.fromConfig(e)))}decode_chain(e){return this.decoders.reduce(((e,t)=>t.decode_chain(e)),e)}}class ym extends dm{constructor(e){super(e),this.suffix=this.config.suffix}decode_chain(e){return e.map(((t,n)=>t.replaceAll(this.suffix,n===e.length-1?"":" ")))}}class bm extends dm{decode_chain(e){let t="";for(let n=1;n<e.length;n+=2)t+=e[n];return[t]}}class xm extends Zf{constructor(e){super(),this.addPrefixSpace=e.add_prefix_space,this.replacement=e.replacement,this.strRep=e.str_rep||this.replacement,this.prepend_scheme=e.prepend_scheme??"always"}pre_tokenize_text(e,{section_index:t}={}){let n=e.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!n.startsWith(this.replacement)&&("always"===this.prepend_scheme||"first"===this.prepend_scheme&&0===t)&&(n=this.strRep+n),[n]}}class vm extends dm{constructor(e){super(e),this.addPrefixSpace=e.add_prefix_space,this.replacement=e.replacement}decode_chain(e){const t=[];for(let n=0;n<e.length;++n){let r=e[n].replaceAll(this.replacement," ");this.addPrefixSpace&&0==n&&r.startsWith(" ")&&(r=r.substring(1)),t.push(r)}return t}}class $m extends Uf{constructor(e){super(e),this.charsmap=e.precompiled_charsmap}normalize(e){if((e=(e=e.replace(/[\\u0001-\\u0008\\u000B\\u000E-\\u001F\\u007F\\u008F\\u009F]/gm,"")).replace(/[\\u0009\\u000A\\u000C\\u000D\\u00A0\\u1680\\u2000-\\u200F\\u2028\\u2029\\u202F\\u205F\\u2581\\u3000\\uFEFF\\uFFFD]/gm," ")).includes("")){const t=e.split("");e=t.map((e=>e.normalize("NFKC"))).join("")}else e=e.normalize("NFKC");return e}}class km extends Zf{constructor(e){super(),this.tokenizers=e.pretokenizers.map((e=>Zf.fromConfig(e)))}pre_tokenize_text(e,t){return this.tokenizers.reduce(((e,n)=>n.pre_tokenize(e,t)),[e])}}class Em extends Zf{constructor(e){super()}pre_tokenize_text(e,t){return e.match(/\\w+|[^\\w\\s]+/g)||[]}}class Sm extends Zf{constructor(e){super()}pre_tokenize_text(e,t){return function n(e){return e.match(/\\S+/g)||[]}(e)}}class zm extends Zf{constructor(e){super(),this.config=e,this.pattern=vf(this.config.pattern),this.content=this.config.content}pre_tokenize_text(e,t){return null===this.pattern?[e]:[e.replaceAll(this.pattern,this.config.content)]}}const Cm=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function Tm(e,t,n,r){for(const s of Object.keys(e)){const i=t-e[s].length,a=n(s),o=new Array(i).fill(a);e[s]="right"===r?Q(e[s],o):Q(o,e[s])}}function Am(e,t){for(const n of Object.keys(e))e[n].length=t}class Im extends j{return_token_type_ids=!1;padding_side="right";constructor(e,t){super(),this._tokenizer_config=t,this.normalizer=Uf.fromConfig(e.normalizer),this.pre_tokenizer=Zf.fromConfig(e.pre_tokenizer),this.model=Of.fromConfig(e.model,t),this.post_processor=sm.fromConfig(e.post_processor),this.decoder=dm.fromConfig(e.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const t of e.added_tokens){const e=new Mf(t);this.added_tokens.push(e),this.model.tokens_to_ids.set(e.content,e.id),this.model.vocab[e.id]=e.content,e.special&&(this.special_tokens.push(e.content),this.all_special_ids.push(e.id))}if(this.additional_special_tokens=t.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_regex=this.added_tokens.length>0?new RegExp(this.added_tokens.slice().sort(((e,t)=>t.content.length-e.content.length)).map((e=>`${e.lstrip?"\\\\s*":""}(${H(e.content)})${e.rstrip?"\\\\s*":""}`)).join("|")):null,this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.bos_token=this.getToken("bos_token"),this.bos_token_id=this.model.tokens_to_ids.get(this.bos_token),this.eos_token=this.getToken("eos_token"),this.eos_token_id=this.model.tokens_to_ids.get(this.eos_token),this.model_max_length=t.model_max_length,this.remove_space=t.remove_space,this.clean_up_tokenization_spaces=t.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=t.do_lowercase_and_remove_accent??!1,t.padding_side&&(this.padding_side=t.padding_side),this.legacy=!1,this.chat_template=t.chat_template??null,Array.isArray(this.chat_template)){const e=Object.create(null);for(const{name:t,template:n}of this.chat_template){if("string"!=typeof t||"string"!=typeof n)throw new Error(\'Chat template must be a list of objects with "name" and "template" properties\');e[t]=n}this.chat_template=e}this._compiled_template_cache=new Map}getToken(...e){for(const t of e){const e=this._tokenizer_config[t];if(e){if("object"==typeof e){if("AddedToken"===e.__type)return e.content;throw Error(`Unknown token: ${e}`)}return e}}return null}static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:i="main",legacy:a=null}={}){return new this(...await xf(e,{progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:i,legacy:a}))}_call(e,{text_pair:t=null,add_special_tokens:n=!0,padding:r=!1,truncation:s=null,max_length:i=null,return_tensor:a=!0,return_token_type_ids:o=null}={}){const l=Array.isArray(e);let u;if(l){if(0===e.length)throw Error("text array must be non-empty");if(null!==t){if(!Array.isArray(t))throw Error("text_pair must also be an array");if(e.length!==t.length)throw Error("text and text_pair must have the same length");u=e.map(((e,r)=>this._encode_plus(e,{text_pair:t[r],add_special_tokens:n,return_token_type_ids:o})))}else u=e.map((e=>this._encode_plus(e,{add_special_tokens:n,return_token_type_ids:o})))}else{if(null==e)throw Error("text may not be null or undefined");if(Array.isArray(t))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");u=[this._encode_plus(e,{text_pair:t,add_special_tokens:n,return_token_type_ids:o})]}if(null===i?i="max_length"===r?this.model_max_length:_e(u.map((e=>e.input_ids.length)))[0]:s||console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=true` to explicitly truncate examples to max length."),i=Math.min(i,this.model_max_length??Infinity),r||s)for(let e=0;e<u.length;++e)u[e].input_ids.length!==i&&(u[e].input_ids.length>i?s&&Am(u[e],i):r&&Tm(u[e],i,(e=>"input_ids"===e?this.pad_token_id:0),this.padding_side));const d={};if(a){if((!r||!s)&&u.some((e=>{for(const t of Object.keys(e))if(e[t].length!==u[0][t]?.length)return!0;return!1})))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with \'padding=true\' and \'truncation=true\' to have batched tensors with the same length.");const e=[u.length,u[0].input_ids.length];for(const t of Object.keys(u[0]))d[t]=new Xp("int64",BigInt64Array.from(u.flatMap((e=>e[t])).map(BigInt)),e)}else{for(const e of Object.keys(u[0]))d[e]=u.map((t=>t[e]));if(!l)for(const e of Object.keys(d))d[e]=d[e][0]}return d}_encode_text(e){if(null===e)return null;const t=(this.added_tokens_regex?e.split(this.added_tokens_regex).filter((e=>e)):[e]).map(((e,t)=>{const n=this.added_tokens.find((t=>t.content===e));if(void 0!==n)return e;{if(!0===this.remove_space&&(e=e.trim().split(/\\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(e=function n(e){return Sf(e.toLowerCase())}(e)),null!==this.normalizer&&(e=this.normalizer(e)),0===e.length)return[];const r=null!==this.pre_tokenizer?this.pre_tokenizer(e,{section_index:t}):[e];return this.model(r)}})).flat();return t}_encode_plus(e,{text_pair:t=null,add_special_tokens:n=!0,return_token_type_ids:r=null}={}){const{tokens:s,token_type_ids:i}=this._tokenize_helper(e,{pair:t,add_special_tokens:n}),a=this.model.convert_tokens_to_ids(s),o={input_ids:a,attention_mask:new Array(a.length).fill(1)};return(r??this.return_token_type_ids)&&i&&(o.token_type_ids=i),o}_tokenize_helper(e,{pair:t=null,add_special_tokens:n=!1}={}){const r=this._encode_text(e),s=this._encode_text(t);return this.post_processor?this.post_processor(r,s,{add_special_tokens:n}):{tokens:Q(r??[],s??[])}}tokenize(e,{pair:t=null,add_special_tokens:n=!1}={}){return this._tokenize_helper(e,{pair:t,add_special_tokens:n}).tokens}encode(e,{text_pair:t=null,add_special_tokens:n=!0,return_token_type_ids:r=null}={}){return this._encode_plus(e,{text_pair:t,add_special_tokens:n,return_token_type_ids:r}).input_ids}batch_decode(e,t={}){return e instanceof Xp&&(e=e.tolist()),e.map((e=>this.decode(e,t)))}decode(e,t={}){if(e instanceof Xp&&(e=kf(e)),!Array.isArray(e)||0===e.length||!function n(e){return Number.isInteger(e)||"bigint"==typeof e}(e[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(e,t)}decode_single(e,{skip_special_tokens:t=!1,clean_up_tokenization_spaces:n=null}){let r=this.model.convert_ids_to_tokens(e);t&&(r=r.filter((e=>!this.special_tokens.includes(e))));let s=this.decoder?this.decoder(r):r.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(s=s.replaceAll(this.decoder.end_of_word_suffix," "),t&&(s=s.trim())),(n??this.clean_up_tokenization_spaces)&&(s=Ef(s)),s}get_chat_template({chat_template:e=null,tools:t=null}={}){if(this.chat_template&&"object"==typeof this.chat_template){const n=this.chat_template;if(null!==e&&Object.hasOwn(n,e))e=n[e];else if(null===e)if(null!==t&&"tool_use"in n)e=n.tool_use;else{if(!("default"in n))throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the \'chat_template\' argument. Available template names are ${Object.keys(n).sort()}.`);e=n.default}}else if(null===e){if(!this.chat_template)throw Error("Cannot use apply_chat_template() because tokenizer.chat_template is not set and no template argument was passed! For information about writing templates and setting the tokenizer.chat_template attribute, please see the documentation at https://huggingface.co/docs/transformers/main/en/chat_templating");e=this.chat_template}return e}apply_chat_template(e,{tools:t=null,documents:n=null,chat_template:r=null,add_generation_prompt:s=!1,tokenize:i=!0,padding:a=!1,truncation:o=!1,max_length:l=null,return_tensor:u=!0,return_dict:d=!1,tokenizer_kwargs:c={},...p}={}){if("string"!=typeof(r=this.get_chat_template({chat_template:r,tools:t})))throw Error("chat_template must be a string, but got "+typeof r);let h=this._compiled_template_cache.get(r);void 0===h&&(h=new gf(r),this._compiled_template_cache.set(r,h));const f=Object.create(null);for(const e of Cm){const t=this.getToken(e);t&&(f[e]=t)}const m=h.render({messages:e,add_generation_prompt:s,tools:t,documents:n,...f,...p});if(i){const e=this._call(m,{add_special_tokens:!1,padding:a,truncation:o,max_length:l,return_tensor:u,...c});return d?e:e.input_ids}return m}}class Mm extends Im{return_token_type_ids=!0}class Om extends Im{return_token_type_ids=!0}class Bm extends Im{return_token_type_ids=!0}class Nm extends Im{return_token_type_ids=!0}class Pm extends Im{return_token_type_ids=!0}class Rm extends Im{return_token_type_ids=!0}class Dm extends Im{return_token_type_ids=!0}class Lm extends Im{return_token_type_ids=!0}class Fm extends Im{return_token_type_ids=!0}class Um extends Im{}class qm extends Im{}class Vm extends Im{return_token_type_ids=!0;constructor(e,t){super(e,t),console.warn(\'WARNING: `XLMTokenizer` is not yet supported by Hugging Face\\\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.\')}}class Wm extends Im{return_token_type_ids=!0}class jm extends Im{}class Gm extends Im{}class Hm extends Im{}class Km extends Im{constructor(e,t){super(e,t),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter((e=>this.languageRegex.test(e))),this.lang_to_token=e=>e}_build_translation_inputs(e,t,n){return u_(this,e,t,n)}}class Xm extends Km{}class Qm extends Im{}class Ym extends Im{}const Zm="";class Jm extends Im{padding_side="left";constructor(e,t){super(e,t),this.legacy=t.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new xm({replacement:Zm,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(e){if(null===e)return null;if(this.legacy||0===e.length)return super._encode_text(e);let t=super._encode_text(Zm+e.replaceAll(Zm," "));return t.length>1&&t[0]===Zm&&this.special_tokens.includes(t[1])&&(t=t.slice(1)),t}}class e_ extends Im{}class t_ extends Im{}class n_ extends Im{}class r_ extends Im{}class s_ extends Im{}class i_ extends Im{}class a_ extends Im{}class o_ extends Im{}class l_ extends Im{}function u_(e,t,n,r){if(!("language_codes"in e)||!Array.isArray(e.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in e&&e.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in e)||"function"!=typeof e.lang_to_token)throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const s=r.src_lang,i=r.tgt_lang;if(!e.language_codes.includes(i))throw new Error(`Target language code "${i}" is not valid. Must be one of: {${e.language_codes.join(", ")}}`);if(void 0!==s){if(!e.language_codes.includes(s))throw new Error(`Source language code "${s}" is not valid. Must be one of: {${e.language_codes.join(", ")}}`);for(const t of e.post_processor.config.single)if("SpecialToken"in t&&e.languageRegex.test(t.SpecialToken.id)){t.SpecialToken.id=e.lang_to_token(s);break}}return r.forced_bos_token_id=e.model.convert_tokens_to_ids([e.lang_to_token(i)])[0],e._call(t,n)}class d_ extends Im{constructor(e,t){super(e,t),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter((e=>this.languageRegex.test(e))),this.lang_to_token=e=>e}_build_translation_inputs(e,t,n){return u_(this,e,t,n)}}class c_ extends Im{constructor(e,t){super(e,t),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter((e=>this.languageRegex.test(e))).map((e=>e.slice(2,-2))),this.lang_to_token=e=>`__${e}__`}_build_translation_inputs(e,t,n){return u_(this,e,t,n)}}class p_ extends Im{get timestamp_begin(){return this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1}_decode_asr(e,{return_timestamps:t=!1,return_language:n=!1,time_precision:r=null,force_full_sequences:s=!0}={}){if(null===r)throw Error("Must specify time_precision");let i=null;const a="word"===t;function o(){return{language:i,timestamp:[null,null],text:""}}const l=[];let u=o(),d=0;const c=this.timestamp_begin,p=c+1500;let h=[],f=[],m=!1,_=null;const g=new Set(this.all_special_ids);for(const n of e){const e=n.tokens,s=a?n.token_timestamps:null;let w=null,y=c;if("stride"in n){const[t,s,i]=n.stride;if(d-=s,_=t-i,s&&(y=s/r+c),i)for(let t=e.length-1;t>=0;--t){const n=Number(e[t]);if(n>=c){if(null!==w&&(n-c)*r<_)break;w=n}}}let b=[],x=[];for(let n=0;n<e.length;++n){const _=Number(e[n]);if(g.has(_)){const e=this.decode([_]),n=yf.get(e.slice(2,-2));if(void 0!==n){if(null!==i&&n!==i&&!t){h.push(b);const e=this.findLongestCommonSequence(h)[0],t=this.decode(e);u.text=t,l.push(u),h=[],b=[],u=o()}i=u.language=n}}else if(_>=c&&_<=p){const e=ve((_-c)*r+d,2);if(null!==w&&_>=w)m=!0;else if(m||h.length>0&&_<y)m=!1;else if(null===u.timestamp[0])u.timestamp[0]=e;else if(e===u.timestamp[0]);else{u.timestamp[1]=e,h.push(b),a&&f.push(x);const[t,n]=this.findLongestCommonSequence(h,f),r=this.decode(t);u.text=r,a&&(u.words=this.collateWordTimestamps(t,n,i)),l.push(u),h=[],b=[],f=[],x=[],u=o()}}else if(b.push(_),a){let e,t=ve(s[n]+d,2);if(n+1<s.length){e=ve(s[n+1]+d,2);const i=this.decode([_]);Tf.test(i)&&(e=ve(Math.min(t+r,e),2))}else e=null;x.push([t,e])}}if("stride"in n){const[e,t,r]=n.stride;d+=e-r}b.length>0?(h.push(b),a&&f.push(x)):h.every((e=>0===e.length))&&(u=o(),h=[],b=[],f=[],x=[])}if(h.length>0){if(s&&t)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[e,n]=this.findLongestCommonSequence(h,f),r=this.decode(e);u.text=r,a&&(u.words=this.collateWordTimestamps(e,n,i)),l.push(u)}let w=Object.create(null);const y=l.map((e=>e.text)).join("");if(t||n){for(let e=0;e<l.length;++e){const r=l[e];t||delete r.timestamp,n||delete r.language}if(a){const e=[];for(const t of l)for(const n of t.words)e.push(n);w={chunks:e}}else w={chunks:l}}return[y,w]}findLongestCommonSequence(e,t=null){let n=e[0],r=n.length,s=[];const i=Array.isArray(t)&&t.length>0;let a=i?[]:null,o=i?t[0]:null;for(let l=1;l<e.length;++l){const u=e[l];let d=0,c=[r,r,0,0];const p=u.length;for(let e=1;e<r+p;++e){const s=Math.max(0,r-e),a=Math.min(r,r+p-e),h=n.slice(s,a),f=Math.max(0,e-r),m=Math.min(p,e),_=u.slice(f,m);if(h.length!==_.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");let g;g=i?h.filter(((e,n)=>e===_[n]&&o[s+n]<=t[l][f+n])).length:h.filter(((e,t)=>e===_[t])).length;const w=g/e+e/1e4;g>1&&w>d&&(d=w,c=[s,a,f,m])}const[h,f,m,_]=c,g=Math.floor((f+h)/2),w=Math.floor((_+m)/2);s.push(...n.slice(0,g)),n=u.slice(w),r=n.length,i&&(a.push(...o.slice(0,g)),o=t[l].slice(w))}return s.push(...n),i?(a.push(...o),[s,a]):[s,[]]}collateWordTimestamps(e,t,n){const[r,s,i]=this.combineTokensIntoWords(e,n),a=[];for(let e=0;e<r.length;++e){const n=i[e];a.push({text:r[e],timestamp:[t[n.at(0)][0],t[n.at(-1)][1]]})}return a}combineTokensIntoWords(e,t,n="\\"\'([{-",r="\\"\'.,!?:)]}"){let s,i,a;return["chinese","japanese","thai","lao","myanmar"].includes(t=t??"english")?[s,i,a]=this.splitTokensOnUnicode(e):[s,i,a]=this.splitTokensOnSpaces(e),this.mergePunctuations(s,i,a,n,r)}decode(e,t){let n;return t?.decode_with_timestamps?(e instanceof Xp&&(e=kf(e)),n=this.decodeWithTimestamps(e,t)):n=super.decode(e,t),n}decodeWithTimestamps(e,t){const n=t?.time_precision??.02,r=Array.from(this.all_special_ids).at(-1)+1;let s=[[]];for(let t of e)if(t=Number(t),t>=r){const e=((t-r)*n).toFixed(2);s.push(`<|${e}|>`),s.push([])}else s[s.length-1].push(t);return s=s.map((e=>"string"==typeof e?e:super.decode(e,t))),s.join("")}splitTokensOnUnicode(e){const t=this.decode(e,{decode_with_timestamps:!0}),n=[],r=[],s=[];let i=[],a=[],o=0;for(let l=0;l<e.length;++l){const u=e[l];i.push(u),a.push(l);const d=this.decode(i,{decode_with_timestamps:!0});d.includes("")&&""!==t[o+d.indexOf("")]||(n.push(d),r.push(i),s.push(a),i=[],a=[],o+=d.length)}return[n,r,s]}splitTokensOnSpaces(e){const[t,n,r]=this.splitTokensOnUnicode(e),s=[],i=[],a=[],o=new RegExp(`^[${Cf}]$`,"gu");for(let e=0;e<t.length;++e){const l=t[e],u=n[e],d=r[e],c=u[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),p=l.startsWith(" "),h=l.trim(),f=o.test(h);if(c||p||f||0===s.length)s.push(l),i.push(u),a.push(d);else{const e=s.length-1;s[e]+=l,i[e].push(...u),a[e].push(...d)}}return[s,i,a]}mergePunctuations(e,t,n,r,s){const i=structuredClone(e),a=structuredClone(t),o=structuredClone(n);let l=i.length-2,u=i.length-1;for(;l>=0;)i[l].startsWith(" ")&&r.includes(i[l].trim())?(i[u]=i[l]+i[u],a[u]=Q(a[l],a[u]),o[u]=Q(o[l],o[u]),i[l]="",a[l]=[],o[l]=[]):u=l,--l;for(l=0,u=1;u<i.length;)!i[l].endsWith(" ")&&s.includes(i[u])?(i[l]+=i[u],a[l]=Q(a[l],a[u]),o[l]=Q(o[l],o[u]),i[u]="",a[u]=[],o[u]=[]):l=u,++u;return[i.filter((e=>e)),a.filter((e=>e.length>0)),o.filter((e=>e.length>0))]}}class h_ extends Im{}class f_ extends Im{}class m_ extends Im{}class __ extends Im{constructor(e,t){super(e,t),this.languageRegex=/^(>>\\w+<<)\\s*/g,this.supported_language_codes=this.model.vocab.filter((e=>this.languageRegex.test(e))),console.warn(\'WARNING: `MarianTokenizer` is not yet supported by Hugging Face\\\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.\')}_encode_text(e){if(null===e)return null;const[t,...n]=e.trim().split(this.languageRegex);if(0===n.length)return super._encode_text(t);if(2===n.length){const[e,t]=n;return this.supported_language_codes.includes(e)||console.warn(`Unsupported language code "${e}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),Q([e],super._encode_text(t))}}}class g_ extends Im{}class w_ extends Im{}class y_ extends Im{}class b_ extends Im{}class x_ extends Im{}class v_ extends Im{constructor(e,t){super(e,t),this.decoder=new bm({})}}class $_ extends Im{}class k_ extends Im{}class E_{static TOKENIZER_CLASS_MAPPING={T5Tokenizer:jm,DistilBertTokenizer:Um,CamembertTokenizer:qm,DebertaTokenizer:Pm,DebertaV2Tokenizer:Rm,BertTokenizer:Mm,HerbertTokenizer:Dm,ConvBertTokenizer:Lm,RoFormerTokenizer:Fm,XLMTokenizer:Vm,ElectraTokenizer:Wm,MobileBertTokenizer:Bm,SqueezeBertTokenizer:Nm,AlbertTokenizer:Om,GPT2Tokenizer:Gm,BartTokenizer:Hm,MBartTokenizer:Km,MBart50Tokenizer:Xm,RobertaTokenizer:Qm,WhisperTokenizer:p_,CodeGenTokenizer:h_,CLIPTokenizer:f_,SiglipTokenizer:m_,MarianTokenizer:__,BloomTokenizer:Ym,NllbTokenizer:d_,M2M100Tokenizer:c_,LlamaTokenizer:Jm,CodeLlamaTokenizer:e_,XLMRobertaTokenizer:t_,MPNetTokenizer:n_,FalconTokenizer:r_,GPTNeoXTokenizer:s_,EsmTokenizer:i_,Wav2Vec2CTCTokenizer:g_,BlenderbotTokenizer:w_,BlenderbotSmallTokenizer:y_,SpeechT5Tokenizer:b_,NougatTokenizer:x_,VitsTokenizer:v_,Qwen2Tokenizer:a_,GemmaTokenizer:o_,Grok1Tokenizer:l_,CohereTokenizer:$_,MgpstrTokenizer:k_,PreTrainedTokenizer:Im};static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:i="main",legacy:a=null}={}){const[o,l]=await xf(e,{progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:i,legacy:a}),u=l.tokenizer_class?.replace(/Fast$/,"")??"PreTrainedTokenizer";let d=this.TOKENIZER_CLASS_MAPPING[u];return d||(console.warn(`Unknown tokenizer class "${u}", attempting to construct from base class.`),d=Im),new d(o,l)}}function S_(e){const t={};let n={};switch(e.model_type){case"llava":case"paligemma":case"florence2":case"llava_onevision":case"idefics3":n=S_(e.text_config);break;case"moondream1":n=S_(e.phi_config);break;case"musicgen":n=S_(e.decoder);break;case"multi_modality":n=S_(e.language_config);break;case"gpt2":case"gptj":case"jais":case"codegen":case"gpt_bigcode":t.num_heads="n_head",t.num_layers="n_layer",t.hidden_size="n_embd";break;case"gpt_neox":case"stablelm":case"opt":case"falcon":t.num_heads="num_attention_heads",t.num_layers="num_hidden_layers",t.hidden_size="hidden_size";break;case"llama":case"olmo":case"olmo2":case"mobilellm":case"granite":case"cohere":case"mistral":case"starcoder2":case"qwen2":case"qwen2_vl":case"phi":case"phi3":case"phi3_v":t.num_heads="num_key_value_heads",t.num_layers="num_hidden_layers",t.hidden_size="hidden_size",t.num_attention_heads="num_attention_heads";break;case"gemma":case"gemma2":t.num_heads="num_key_value_heads",t.num_layers="num_hidden_layers",t.dim_kv="head_dim";break;case"openelm":t.num_heads="num_kv_heads",t.num_layers="num_transformer_layers",t.dim_kv="head_dim";break;case"gpt_neo":case"donut-swin":t.num_heads="num_heads",t.num_layers="num_layers",t.hidden_size="hidden_size";break;case"bloom":t.num_heads="n_head",t.num_layers="n_layer",t.hidden_size="hidden_size";break;case"mpt":t.num_heads="n_heads",t.num_layers="n_layers",t.hidden_size="d_model";break;case"exaone":t.num_heads="num_key_value_heads",t.num_layers="num_layers",t.dim_kv="head_dim",t.num_attention_heads="num_attention_heads";break;case"t5":case"mt5":case"longt5":t.num_decoder_layers="num_decoder_layers",t.num_decoder_heads="num_heads",t.decoder_dim_kv="d_kv",t.num_encoder_layers="num_layers",t.num_encoder_heads="num_heads",t.encoder_dim_kv="d_kv";break;case"bart":case"mbart":case"marian":case"whisper":case"m2m_100":case"blenderbot":case"blenderbot-small":case"florence2_language":t.num_decoder_layers="decoder_layers",t.num_decoder_heads="decoder_attention_heads",t.decoder_hidden_size="d_model",t.num_encoder_layers="encoder_layers",t.num_encoder_heads="encoder_attention_heads",t.encoder_hidden_size="d_model";break;case"speecht5":t.num_decoder_layers="decoder_layers",t.num_decoder_heads="decoder_attention_heads",t.decoder_hidden_size="hidden_size",t.num_encoder_layers="encoder_layers",t.num_encoder_heads="encoder_attention_heads",t.encoder_hidden_size="hidden_size";break;case"trocr":t.num_encoder_layers=t.num_decoder_layers="decoder_layers",t.num_encoder_heads=t.num_decoder_heads="decoder_attention_heads",t.encoder_hidden_size=t.decoder_hidden_size="d_model";break;case"musicgen_decoder":case"moonshine":t.num_encoder_layers=t.num_decoder_layers="num_hidden_layers",t.num_encoder_heads=t.num_decoder_heads="num_attention_heads",t.encoder_hidden_size=t.decoder_hidden_size="hidden_size";break;case"vision-encoder-decoder":const r=S_(e.decoder),s="num_decoder_layers"in r,i=J(e,["model_type","is_encoder_decoder"]);return s?(i.num_decoder_layers=r.num_decoder_layers,i.num_decoder_heads=r.num_decoder_heads,i.decoder_hidden_size=r.decoder_hidden_size,i.num_encoder_layers=r.num_encoder_layers,i.num_encoder_heads=r.num_encoder_heads,i.encoder_hidden_size=r.encoder_hidden_size):(i.num_layers=r.num_layers,i.num_heads=r.num_heads,i.hidden_size=r.hidden_size),i}const r={...n,...J(e,["model_type","multi_query","is_encoder_decoder"])};for(const n in t)r[n]=e[t[n]];return r}function z_(e,{prefix:t="past_key_values",batch_size:n=1}={}){const r={},s=e.normalized_config;if(s.is_encoder_decoder&&"num_encoder_heads"in s&&"num_decoder_heads"in s){const e=s.encoder_dim_kv??s.encoder_hidden_size/s.num_encoder_heads,i=s.decoder_dim_kv??s.decoder_hidden_size/s.num_decoder_heads,a=[n,s.num_encoder_heads,0,e],o=[n,s.num_decoder_heads,0,i];for(let e=0;e<s.num_decoder_layers;++e)r[`${t}.${e}.encoder.key`]=a,r[`${t}.${e}.encoder.value`]=a,r[`${t}.${e}.decoder.key`]=o,r[`${t}.${e}.decoder.value`]=o}else{const e=s.num_heads,i=s.num_layers,a=s.dim_kv??s.hidden_size/(s.num_attention_heads??e);if("falcon"===s.model_type){const s=[n*e,0,a];for(let e=0;e<i;++e)r[`${t}.${e}.key`]=s,r[`${t}.${e}.value`]=s}else if(s.multi_query){const s=[n*e,0,2*a];for(let e=0;e<i;++e)r[`${t}.${e}.key_value`]=s}else if("bloom"===s.model_type){const s=[n*e,a,0],o=[n*e,0,a];for(let e=0;e<i;++e)r[`${t}.${e}.key`]=s,r[`${t}.${e}.value`]=o}else if("openelm"===s.model_type)for(let s=0;s<i;++s){const i=[n,e[s],0,a];r[`${t}.${s}.key`]=i,r[`${t}.${s}.value`]=i}else{const s=[n,e,0,a];for(let e=0;e<i;++e)r[`${t}.${e}.key`]=s,r[`${t}.${e}.value`]=s}}return r}class C_{model_type=null;is_encoder_decoder=!1;max_position_embeddings;"transformers.js_config";constructor(e){Object.assign(this,e),this.normalized_config=S_(this)}static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:i="main"}={}){!n||n instanceof C_||(n=new C_(n));const a=n??await async function o(e,t){return await ce(e,"config.json",!0,t)}(e,{progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:i});return new this(a)}}class T_{static async from_pretrained(...e){return C_.from_pretrained(...e)}}const A_=Object.freeze({auto:"auto",gpu:"gpu",cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:"webnn","webnn-npu":"webnn-npu","webnn-gpu":"webnn-gpu","webnn-cpu":"webnn-cpu"}),I_=function(){let e;return async function(){if(void 0===e)if(D.IS_WEBGPU_AVAILABLE)try{const t=await navigator.gpu.requestAdapter();e=t.features.has("shader-f16")}catch(t){e=!1}else e=!1;return e}}(),M_=Object.freeze({auto:"auto",fp32:"fp32",fp16:"fp16",q8:"q8",int8:"int8",uint8:"uint8",q4:"q4",bnb4:"bnb4",q4f16:"q4f16"}),O_=Object.freeze({[A_.wasm]:M_.q8}),B_=Object.freeze({[M_.fp32]:"",[M_.fp16]:"_fp16",[M_.int8]:"_int8",[M_.uint8]:"_uint8",[M_.q8]:"_quantized",[M_.q4]:"_q4",[M_.q4f16]:"_q4f16",[M_.bnb4]:"_bnb4"}),N_="https://github.com/huggingface/transformers.js/issues/new/choose",P_="preprocessor_config.json",R_=P_;class D_ extends j{_call(e,t){throw Error("`_call` should be implemented in a subclass")}}class L_ extends j{_call(e,t){throw Error("`_call` should be implemented in a subclass")}}class F_ extends j{constructor(){super(),this.processors=[]}push(e){this.processors.push(e)}extend(e){this.processors.push(...e)}_call(e,t){let n=t;for(const t of this.processors)n=t(e,n);return n}[Symbol.iterator](){return this.processors.values()}}class U_ extends D_{constructor(e){super(),this.bos_token_id=e}_call(e,t){for(let n=0;n<e.length;++n)if(1===e[n].length){const e=t[n].data;e.fill(-Infinity),e[this.bos_token_id]=0}return t}}class q_ extends D_{constructor(e,t){super(),this.max_length=e,this.eos_token_id=Array.isArray(t)?t:[t]}_call(e,t){for(let n=0;n<e.length;++n)if(e[n].length===this.max_length-1){const e=t[n].data;e.fill(-Infinity);for(const t of this.eos_token_id)e[t]=0}return t}}class V_ extends D_{constructor(e,t){super(),this.begin_suppress_tokens=e,this.begin_index=t}_call(e,t){for(let n=0;n<e.length;++n)if(e[n].length===this.begin_index){const e=t[n].data;for(const t of this.begin_suppress_tokens)e[t]=-Infinity}return t}}class W_ extends D_{constructor(e,t){super(),this.eos_token_id=Array.isArray(e.eos_token_id)?e.eos_token_id[0]:e.eos_token_id,this.no_timestamps_token_id=e.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=t.length,t.at(-1)===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=e.max_initial_timestamp_index}_call(e,t){for(let n=0;n<e.length;++n){const r=t[n].data;if(r[this.no_timestamps_token_id]=-Infinity,e[n].length===this.begin_index-1){r.fill(-Infinity),r[this.timestamp_begin]=0;continue}const s=e[n].slice(this.begin_index),i=s.length>=1&&s[s.length-1]>=this.timestamp_begin,a=s.length<2||s[s.length-2]>=this.timestamp_begin;if(i&&(a?r.subarray(this.timestamp_begin).fill(-Infinity):r.subarray(0,this.eos_token_id).fill(-Infinity)),e[n].length===this.begin_index&&null!==this.max_initial_timestamp_index){const e=this.timestamp_begin+this.max_initial_timestamp_index;r.subarray(e+1).fill(-Infinity)}const o=fe(r);Math.log(o.subarray(this.timestamp_begin).map(Math.exp).reduce(((e,t)=>e+t)))>_e(o.subarray(0,this.timestamp_begin))[0]&&r.subarray(0,this.timestamp_begin).fill(-Infinity)}return t}}class j_ extends D_{constructor(e){super(),this.no_repeat_ngram_size=e}getNgrams(e){const t=e.length,n=[];for(let r=0;r<t+1-this.no_repeat_ngram_size;++r){const t=[];for(let n=0;n<this.no_repeat_ngram_size;++n)t.push(e[r+n]);n.push(t.map(Number))}const r=new Map;for(const e of n){const t=e.slice(0,e.length-1),n=JSON.stringify(t),s=r.get(n)??[];s.push(e[e.length-1]),r.set(n,s)}return r}getGeneratedNgrams(e,t){const n=t.slice(t.length+1-this.no_repeat_ngram_size,t.length);return e.get(JSON.stringify(n.map(Number)))??[]}calcBannedNgramTokens(e){const t=[];if(e.length+1<this.no_repeat_ngram_size)return t;{const t=this.getNgrams(e);return this.getGeneratedNgrams(t,e)}}_call(e,t){for(let n=0;n<e.length;++n){const r=t[n].data,s=this.calcBannedNgramTokens(e[n]);for(const e of s)r[e]=-Infinity}return t}}class G_ extends D_{constructor(e){super(),this.penalty=e}_call(e,t){for(let n=0;n<e.length;++n){const r=t[n].data;for(const t of new Set(e[n])){const e=Number(t);r[e]<0?r[e]*=this.penalty:r[e]/=this.penalty}}return t}}class H_ extends D_{constructor(e,t){super(),this.min_length=e,this.eos_token_id=Array.isArray(t)?t:[t]}_call(e,t){for(let n=0;n<e.length;++n)if(e[n].length<this.min_length){const e=t[n].data;for(const t of this.eos_token_id)e[t]=-Infinity}return t}}class K_ extends D_{constructor(e,t,n){super(),this.prompt_length_to_skip=e,this.min_new_tokens=t,this.eos_token_id=Array.isArray(n)?n:[n]}_call(e,t){for(let n=0;n<e.length;++n){if(e[n].length-this.prompt_length_to_skip<this.min_new_tokens){const e=t[n].data;for(const t of this.eos_token_id)e[t]=-Infinity}}return t}}class X_ extends D_{constructor(e,t){super(),this.bad_words_ids=e,this.eos_token_id=Array.isArray(t)?t:[t]}_call(e,t){for(let n=0;n<e.length;++n){const r=t[n].data,s=e[n];for(const e of this.bad_words_ids){let t=!0;for(let n=1;n<=e.length-1&&e.length<s.length;++n)if(e.at(-n-1)!=s.at(-n)){t=!1;break}t&&(r[e.at(-1)]=-Infinity)}}return t}}class Q_ extends D_{constructor(e){if(super(),e<=1)throw new Error(`Require guidance scale >1 to use the classifier free guidance processor, got guidance scale ${e}.`);this.guidance_scale=e}_call(e,t){if(t.dims[0]!==2*e.length)throw new Error(`Logits should have twice the batch size of the input ids, the first half of batches corresponding to the conditional inputs, and the second half of batches corresponding to the unconditional inputs. Got batch size ${t.dims[0]} for the logits and ${e.length} for the input ids.`);const n=e.length,r=t.slice([0,n],null),s=t.slice([n,t.dims[0]],null);for(let e=0;e<s.data.length;++e)s.data[e]+=(r.data[e]-s.data[e])*this.guidance_scale;return s}}class Y_ extends L_{constructor(e){if(super(),"number"!=typeof e||e<=0){let t=`\\`temperature\\` (=${e}) must be a strictly positive float, otherwise your next token scores will be invalid.`;0===e&&(t+=" If you\'re looking for greedy decoding strategies, set `do_sample=false`.")}this.temperature=e}_call(e,t){const n=t.data;for(let e=0;e<n.length;++e)n[e]/=this.temperature;return t}}class Z_ extends L_{constructor(e,{filter_value:t=-Infinity,min_tokens_to_keep:n=1}={}){if(super(),e<0||e>1)throw new Error(`\\`top_p\\` must be a float > 0 and < 1, but is ${e}`);if(!Number.isInteger(n)||n<1)throw new Error(`\\`min_tokens_to_keep\\` must be a positive integer, but is ${n}`);this.top_p=e,this.filter_value=t,this.min_tokens_to_keep=n}}class J_ extends L_{constructor(e,{filter_value:t=-Infinity,min_tokens_to_keep:n=1}={}){if(super(),!Number.isInteger(e)||e<0)throw new Error(`\\`top_k\\` must be a positive integer, but is ${e}`);this.top_k=Math.max(e,n),this.filter_value=t}}class eg{max_length=20;max_new_tokens=null;min_length=0;min_new_tokens=null;early_stopping=!1;max_time=null;do_sample=!1;num_beams=1;num_beam_groups=1;penalty_alpha=null;use_cache=!0;temperature=1;top_k=50;top_p=1;typical_p=1;epsilon_cutoff=0;eta_cutoff=0;diversity_penalty=0;repetition_penalty=1;encoder_repetition_penalty=1;length_penalty=1;no_repeat_ngram_size=0;bad_words_ids=null;force_words_ids=null;renormalize_logits=!1;constraints=null;forced_bos_token_id=null;forced_eos_token_id=null;remove_invalid_values=!1;exponential_decay_length_penalty=null;suppress_tokens=null;streamer=null;begin_suppress_tokens=null;forced_decoder_ids=null;guidance_scale=null;num_return_sequences=1;output_attentions=!1;output_hidden_states=!1;output_scores=!1;return_dict_in_generate=!1;pad_token_id=null;bos_token_id=null;eos_token_id=null;encoder_no_repeat_ngram_size=0;decoder_start_token_id=null;generation_kwargs={};constructor(e){Object.assign(this,J(e,Object.getOwnPropertyNames(this)))}}var tg=s(655);let ng,rg,sg;const ig=D.IS_BROWSER_ENV||D.IS_WEBWORKER_ENV;if(ig)ng=(e,t)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(e,t)},sg=self.createImageBitmap,rg=self.ImageData;else{if(!tg)throw new Error("Unable to load image processing library.");sg=async e=>{const t=(await e.metadata()).channels,{data:n,info:r}=await e.rotate().raw().toBuffer({resolveWithObject:!0}),s=new lg(new Uint8ClampedArray(n),r.width,r.height,r.channels);return void 0!==t&&t!==r.channels&&s.convert(t),s}}const ag={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},og=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class lg{constructor(e,t,n,r){this.data=e,this.width=t,this.height=n,this.channels=r}get size(){return[this.width,this.height]}static async read(e){if(e instanceof lg)return e;if("string"==typeof e||e instanceof URL)return await this.fromURL(e);throw new Error("Unsupported input type: "+typeof e)}static fromCanvas(e){if(!ig)throw new Error("fromCanvas() is only supported in browser environments.");const t=e.getContext("2d").getImageData(0,0,e.width,e.height).data;return new lg(t,e.width,e.height,4)}static async fromURL(e){const t=await oe(e);if(200!==t.status)throw new Error(`Unable to read image from "${e}" (${t.status} ${t.statusText})`);const n=await t.blob();return this.fromBlob(n)}static async fromBlob(e){if(ig){const t=await sg(e),n=ng(t.width,t.height).getContext("2d");return n.drawImage(t,0,0),new this(n.getImageData(0,0,t.width,t.height).data,t.width,t.height,4)}{const t=tg(await e.arrayBuffer());return await sg(t)}}static fromTensor(e,t="CHW"){if(3!==e.dims.length)throw new Error(`Tensor should have 3 dimensions, but has ${e.dims.length} dimensions.`);if("CHW"===t)e=e.transpose(1,2,0);else if("HWC"!==t)throw new Error(`Unsupported channel format: ${t}`);if(!(e.data instanceof Uint8ClampedArray||e.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${e.type}`);switch(e.dims[2]){case 1:case 2:case 3:case 4:return new lg(e.data,e.dims[1],e.dims[0],e.dims[2]);default:throw new Error(`Unsupported number of channels: ${e.dims[2]}`)}}grayscale(){if(1===this.channels)return this;const e=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let t=0,n=0;t<this.data.length;t+=this.channels){const r=this.data[t],s=this.data[t+1],i=this.data[t+2];e[n++]=Math.round(.2989*r+.587*s+.114*i)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,1)}rgb(){if(3===this.channels)return this;const e=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let t=0,n=0;t<this.data.length;++t)e[n++]=this.data[t],e[n++]=this.data[t],e[n++]=this.data[t];break;case 4:for(let t=0,n=0;t<this.data.length;t+=4)e[n++]=this.data[t],e[n++]=this.data[t+1],e[n++]=this.data[t+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,3)}rgba(){if(4===this.channels)return this;const e=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let t=0,n=0;t<this.data.length;++t)e[n++]=this.data[t],e[n++]=this.data[t],e[n++]=this.data[t],e[n++]=255;break;case 3:for(let t=0,n=0;t<this.data.length;t+=3)e[n++]=this.data[t],e[n++]=this.data[t+1],e[n++]=this.data[t+2],e[n++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,4)}putAlpha(e){if(e.width!==this.width||e.height!==this.height)throw new Error(`Expected mask size to be ${this.width}x${this.height}, but got ${e.width}x${e.height}`);if(1!==e.channels)throw new Error(`Expected mask to have 1 channel, but got ${e.channels}`);const t=this.data,n=e.data,r=this.width*this.height;if(3===this.channels){const e=new Uint8ClampedArray(4*r);for(let s=0,i=0,a=0;s<r;++s)e[a++]=t[i++],e[a++]=t[i++],e[a++]=t[i++],e[a++]=n[s];return this._update(e,this.width,this.height,4)}if(4===this.channels){for(let e=0;e<r;++e)t[4*e+3]=n[e];return this}throw new Error(`Expected image to have 3 or 4 channels, but got ${this.channels}`)}async resize(e,t,{resample:n=2}={}){if(this.width===e&&this.height===t)return this;let r=ag[n]??n;const s=K(e),i=K(t);if(s&&i)return this;if(s?e=t/this.height*this.width:i&&(t=e/this.width*this.height),ig){const n=this.channels,r=this.toCanvas(),s=ng(e,t).getContext("2d");s.drawImage(r,0,0,e,t);return new lg(s.getImageData(0,0,e,t).data,e,t,4).convert(n)}{let n=this.toSharp();switch(r){case"box":case"hamming":"box"!==r&&"hamming"!==r||(console.warn(`Resampling method ${r} is not yet supported. Using bilinear instead.`),r="bilinear");case"nearest":case"bilinear":case"bicubic":n=n.affine([e/this.width,0,0,t/this.height],{interpolator:r});break;case"lanczos":n=n.resize({width:e,height:t,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${r} is not supported.`)}return await sg(n)}}async pad([e,t,n,r]){if(e=Math.max(e,0),t=Math.max(t,0),n=Math.max(n,0),r=Math.max(r,0),0===e&&0===t&&0===n&&0===r)return this;if(ig){const s=this.channels,i=this.toCanvas(),a=this.width+e+t,o=this.height+n+r,l=ng(a,o).getContext("2d");l.drawImage(i,0,0,this.width,this.height,e,n,this.width,this.height);return new lg(l.getImageData(0,0,a,o).data,a,o,4).convert(s)}{const s=this.toSharp().extend({left:e,right:t,top:n,bottom:r});return await sg(s)}}async crop([e,t,n,r]){if(e=Math.max(e,0),t=Math.max(t,0),n=Math.min(n,this.width-1),r=Math.min(r,this.height-1),0===e&&0===t&&n===this.width-1&&r===this.height-1)return this;const s=n-e+1,i=r-t+1;if(ig){const n=this.channels,r=this.toCanvas(),a=ng(s,i).getContext("2d");a.drawImage(r,e,t,s,i,0,0,s,i);return new lg(a.getImageData(0,0,s,i).data,s,i,4).convert(n)}{const n=this.toSharp().extract({left:e,top:t,width:s,height:i});return await sg(n)}}async center_crop(e,t){if(this.width===e&&this.height===t)return this;const n=(this.width-e)/2,r=(this.height-t)/2;if(ig){const s=this.channels,i=this.toCanvas(),a=ng(e,t).getContext("2d");let o=0,l=0,u=0,d=0;n>=0?o=n:u=-n,r>=0?l=r:d=-r,a.drawImage(i,o,l,e,t,u,d,e,t);return new lg(a.getImageData(0,0,e,t).data,e,t,4).convert(s)}{let s=this.toSharp();if(n>=0&&r>=0)s=s.extract({left:Math.floor(n),top:Math.floor(r),width:e,height:t});else if(n<=0&&r<=0){const i=Math.floor(-r),a=Math.floor(-n);s=s.extend({top:i,left:a,right:e-this.width-a,bottom:t-this.height-i})}else{let i=[0,0],a=0;r<0?(i[0]=Math.floor(-r),i[1]=t-this.height-i[0]):a=Math.floor(r);let o=[0,0],l=0;n<0?(o[0]=Math.floor(-n),o[1]=e-this.width-o[0]):l=Math.floor(n),s=s.extend({top:i[0],bottom:i[1],left:o[0],right:o[1]}).extract({left:l,top:a,width:e,height:t})}return await sg(s)}}async toBlob(e="image/png",t=1){if(!ig)throw new Error("toBlob() is only supported in browser environments.");const n=this.toCanvas();return await n.convertToBlob({type:e,quality:t})}toTensor(e="CHW"){let t=new Xp("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if("HWC"===e);else{if("CHW"!==e)throw new Error(`Unsupported channel format: ${e}`);t=t.permute(2,0,1)}return t}toCanvas(){if(!ig)throw new Error("toCanvas() is only supported in browser environments.");const e=this.clone().rgba(),t=ng(e.width,e.height),n=new rg(e.data,e.width,e.height);return t.getContext("2d").putImageData(n,0,0),t}split(){const{data:e,width:t,height:n,channels:r}=this,s=e.constructor,i=e.length/r,a=Array.from({length:r},(()=>new s(i)));for(let t=0;t<i;++t){const n=r*t;for(let s=0;s<r;++s)a[s][t]=e[n+s]}return a.map((e=>new lg(e,t,n,1)))}_update(e,t,n,r=null){return this.data=e,this.width=t,this.height=n,null!==r&&(this.channels=r),this}clone(){return new lg(this.data.slice(),this.width,this.height,this.channels)}convert(e){if(this.channels===e)return this;switch(e){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(e){if(!ig){if(V.useFS){const t=this.toSharp();return await t.toFile(e)}throw new Error("Unable to save the image because filesystem is disabled in this environment.")}{if(D.IS_WEBWORKER_ENV)throw new Error("Unable to save an image from a Web Worker.");const t=e.split(".").pop().toLowerCase(),n=og.get(t)??"image/png",r=await this.toBlob(n),s=URL.createObjectURL(r),i=document.createElement("a");i.href=s,i.download=e,i.click(),i.remove()}}toSharp(){if(ig)throw new Error("toSharp() is only supported in server-side environments.");return tg(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}lg.read.bind(lg);class ug extends j{_call(e,t){throw Error("StoppingCriteria needs to be subclassed")}}class dg extends j{constructor(){super(),this.criteria=[]}push(e){this.criteria.push(e)}extend(e){e instanceof dg?e=e.criteria:e instanceof ug&&(e=[e]),this.criteria.push(...e)}_call(e,t){const n=new Array(e.length).fill(!1);for(const r of this.criteria){const s=r(e,t);for(let e=0;e<n.length;++e)n[e]||=s[e]}return n}[Symbol.iterator](){return this.criteria.values()}}class cg extends ug{constructor(e,t=null){super(),this.max_length=e,this.max_position_embeddings=t}_call(e){return e.map((e=>e.length>=this.max_length))}}class pg extends ug{constructor(e){super(),Array.isArray(e)||(e=[e]),this.eos_token_id=e}_call(e,t){return e.map((e=>{const t=e.at(-1);return this.eos_token_id.some((e=>t==e))}))}}class hg extends j{constructor(e){super(),this.generation_config=e}async _call(e){return this.sample(e)}async sample(e){throw Error("sample should be implemented in subclasses.")}getLogits(e,t){let n=e.dims.at(-1),r=e.data;if(-1===t)r=r.slice(-n);else{let e=t*n;r=r.slice(e,e+n)}return r}randomSelect(e){let t=0;for(let n=0;n<e.length;++n)t+=e[n];let n=Math.random()*t;for(let t=0;t<e.length;++t)if(n-=e[t],n<=0)return t;return 0}static getSampler(e){if(e.do_sample)return new mg(e);if(e.num_beams>1)return new _g(e);if(e.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${e.num_return_sequences}.`);return new fg(e)}}class fg extends hg{async sample(e){const t=_e(e.data)[1];return[[BigInt(t),0]]}}class mg extends hg{async sample(e){let t=e.dims.at(-1);this.generation_config.top_k>0&&(t=Math.min(this.generation_config.top_k,t));const[n,r]=await Zp(e,t),s=he(n.data);return Array.from({length:this.generation_config.num_beams},(()=>{const e=this.randomSelect(s);return[r.data[e],Math.log(s[e])]}))}}class _g extends hg{async sample(e){let t=e.dims.at(-1);this.generation_config.top_k>0&&(t=Math.min(this.generation_config.top_k,t));const[n,r]=await Zp(e,t),s=he(n.data);return Array.from({length:this.generation_config.num_beams},((e,t)=>[r.data[t],Math.log(s[t])]))}}class gg extends eg{return_timestamps=null;return_token_timestamps=null;num_frames=null;alignment_heads=null;task=null;language=null;no_timestamps_token_id=null;prompt_ids=null;is_multilingual=null;lang_to_id=null;task_to_id=null;max_initial_timestamp_index=1}const wg=0,yg=1,bg=2,xg=3,vg=4,$g=5,kg=6,Eg=7,Sg=8,zg=9,Cg=new Map,Tg=new Map,Ag=new Map;async function Ig(e,t,n){const r=n.config?.["transformers.js_config"]??{};let s=n.device??r.device;s&&"string"!=typeof s&&(s.hasOwnProperty(t)?s=s[t]:(console.warn(`device not specified for "${t}". Using the default device.`),s=null));const i=s??(D.IS_NODE_ENV?"cpu":"wasm"),a=function o(e=null){if(!e)return Rp;switch(e){case"auto":return Pp;case"gpu":return Pp.filter((e=>["webgpu","cuda","dml","webnn-gpu"].includes(e)))}if(Pp.includes(e))return[Np[e]??e];throw new Error(`Unsupported device: "${e}". Should be one of: ${Pp.join(", ")}.`)}(i);let l=n.dtype??r.dtype;if("string"!=typeof l&&(l&&l.hasOwnProperty(t)?l=l[t]:(l=O_[i]??M_.fp32,console.warn(`dtype not specified for "${t}". Using the default dtype (${l}) for this device (${i}).`))),l===M_.auto){let e=r.dtype;"string"!=typeof e&&(e=e[t]),l=e&&e!==M_.auto&&M_.hasOwnProperty(e)?e:O_[i]??M_.fp32}const u=l;if(!B_.hasOwnProperty(u))throw new Error(`Invalid dtype: ${u}. Should be one of: ${Object.keys(M_).join(", ")}`);if(u===M_.fp16&&"webgpu"===i&&!await I_())throw new Error(`The device (${i}) does not support fp16.`);const d=r.kv_cache_dtype?"string"==typeof r.kv_cache_dtype?r.kv_cache_dtype:r.kv_cache_dtype[u]??"float32":void 0;if(d&&!["float32","float16"].includes(d))throw new Error(`Invalid kv_cache_dtype: ${d}. Should be one of: float32, float16`);const c={dtype:u,kv_cache_dtype:d},p=B_[u],h=`${n.subfolder??""}/${t}${p}.onnx`,f={...n.session_options};f.executionProviders??=a;const m=r.free_dimension_overrides;m?f.freeDimensionOverrides??=m:i.startsWith("webnn")&&!f.freeDimensionOverrides&&console.warn(\'WebNN does not currently support dynamic shapes and requires `free_dimension_overrides` to be set in config.json as a field within "transformers.js_config". When `free_dimension_overrides` is not set, you may experience significant performance degradation.\');const _=de(e,h,!0,n),g=n.use_external_data_format??r.use_external_data_format;let w=[];if(g&&(!0===g||"object"==typeof g&&g.hasOwnProperty(t)&&!0===g[t])){if(D.IS_NODE_ENV)throw new Error("External data format is not yet supported in Node.js");const r=`${t}${p}.onnx_data`,s=`${n.subfolder??""}/${r}`;w.push(new Promise((async(t,i)=>{const a=await de(e,s,!0,n);t({path:r,data:a})})))}else void 0!==f.externalData&&(w=f.externalData.map((async t=>{if("string"==typeof t.data){const r=await de(e,t.data,!0,n);return{...t,data:r}}return t})));if(w.length>0&&(f.externalData=await Promise.all(w)),"webgpu"===i){const e=z_(n.config,{prefix:"present"});if(Object.keys(e).length>0&&!jp()){const t={};for(const n in e)t[n]="gpu-buffer";f.preferredOutputLocation=t}}return{buffer:await _,session_options:f,session_config:c}}async function Mg(e,t,n){return Object.fromEntries(await Promise.all(Object.keys(t).map((async r=>{const{buffer:s,session_options:i,session_config:a}=await Ig(e,t[r],n);return[r,await qp(s,i,a)]}))))}async function Og(e,t,n){return Object.fromEntries(await Promise.all(Object.keys(t).map((async r=>[r,await ce(e,t[r],!1,n)]))))}async function Bg(e,t){const n=function r(e,t){const n=Object.create(null),r=[];for(const s of e.inputNames){const e=t[s];e instanceof Xp?n[s]=jp()?e.clone():e:r.push(s)}if(r.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${r.join(", ")}.`);const s=Object.keys(t).length,i=e.inputNames.length;if(s>i){let n=Object.keys(t).filter((t=>!e.inputNames.includes(t)));console.warn(`WARNING: Too many inputs were provided (${s} > ${i}). The following inputs will be ignored: "${n.join(", ")}".`)}return n}(e,t);try{const t=Object.fromEntries(Object.entries(n).map((([e,t])=>[e,t.ort_tensor])));let r=await e.run(t);return r=Ng(r),r}catch(e){const t=Object.fromEntries(Object.entries(n).map((([e,{type:t,dims:n,data:r}])=>[e,{type:t,dims:n,data:r}])));throw console.error(`An error occurred during model execution: "${e}".`),console.error("Inputs given to model:",t),e}}function Ng(e){for(let t in e)Vp(e[t])?e[t]=new Xp(e[t]):"object"==typeof e[t]&&Ng(e[t]);return e}function Pg(e){if(e instanceof Xp)return e;if(0===e.length)throw Error("items must be non-empty");if(Array.isArray(e[0])){if(e.some((t=>t.length!==e[0].length)))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with \'padding=True\' and/or \'truncation=True\' to have batched tensors with the same length.");return new Xp("int64",BigInt64Array.from(e.flat().map((e=>BigInt(e)))),[e.length,e[0].length])}return new Xp("int64",BigInt64Array.from(e.map((e=>BigInt(e)))),[1,e.length])}function Rg(e){return new Xp("bool",[e],[1])}async function Dg(e,t){let{encoder_outputs:n,input_ids:r,decoder_input_ids:s,...i}=t;if(!n){const r=J(t,e.sessions.model.inputNames);n=(await Lg(e,r)).last_hidden_state}i.input_ids=s,i.encoder_hidden_states=n,e.sessions.decoder_model_merged.inputNames.includes("encoder_attention_mask")&&(i.encoder_attention_mask=t.attention_mask);return await Fg(e,i,!0)}async function Lg(e,t){const n=e.sessions.model,r=J(t,n.inputNames);if(n.inputNames.includes("inputs_embeds")&&!r.inputs_embeds){if(!t.input_ids)throw new Error("Both `input_ids` and `inputs_embeds` are missing in the model inputs.");r.inputs_embeds=await e.encode_text({input_ids:t.input_ids})}return n.inputNames.includes("token_type_ids")&&!r.token_type_ids&&(r.token_type_ids=new Xp("int64",new BigInt64Array(r.input_ids.data.length),r.input_ids.dims)),await Bg(n,r)}async function Fg(e,t,n=!1){const r=e.sessions[n?"decoder_model_merged":"model"],{past_key_values:s,...i}=t;if(r.inputNames.includes("use_cache_branch")&&(i.use_cache_branch=Rg(!!s)),r.inputNames.includes("position_ids")&&i.attention_mask&&!i.position_ids){const t="paligemma"===e.config.model_type?1:0;i.position_ids=function n(e,t=null,r=0){const{input_ids:s,inputs_embeds:i,attention_mask:a}=e,{data:o,dims:l}=Vg(a,r);let u=new Xp("int64",o,l);if(t){const e=-(s??i).dims.at(1);u=u.slice(null,[e,null])}return u}(i,s,t)}e.addPastKeyValues(i,s);const a=J(i,r.inputNames);return await Bg(r,a)}function Ug({image_token_id:e,inputs_embeds:t,image_features:n,input_ids:r,attention_mask:s}){const i=r.tolist().map((t=>t.reduce(((t,n,r)=>(n==e&&t.push(r),t)),[]))),a=i.reduce(((e,t)=>e+t.length),0),o=n.dims[0];if(a!==o)throw new Error(`Image features and image tokens do not match: tokens: ${a}, features ${o}`);let l=0;for(let e=0;e<i.length;++e){const r=i[e],s=t[e];for(let e=0;e<r.length;++e)s[r[e]].data.set(n[l++].data)}return{inputs_embeds:t,attention_mask:s}}async function qg(e,{input_ids:t=null,attention_mask:n=null,pixel_values:r=null,position_ids:s=null,inputs_embeds:i=null,past_key_values:a=null,generation_config:o=null,logits_processor:l=null,...u}){if(!i)if(i=await e.encode_text({input_ids:t,...u}),r&&1!==t.dims[1]){const s=await e.encode_image({pixel_values:r,...u});({inputs_embeds:i,attention_mask:n}=e._merge_input_ids_with_image_features({image_features:s,inputs_embeds:i,input_ids:t,attention_mask:n}))}else if(a&&r&&1===t.dims[1]){const e=t.dims[1],r=Object.values(a)[0].dims.at(-2);n=sh([ch([t.dims[0],r]),n.slice(null,[n.dims[1]-e,n.dims[1]])],1)}if(!s&&"qwen2_vl"===e.config.model_type){const{image_grid_thw:r,video_grid_thw:i}=u;[s]=e.get_rope_index(t,r,i,n)}return await Fg(e,{inputs_embeds:i,past_key_values:a,attention_mask:n,position_ids:s,generation_config:o,logits_processor:l},!0)}function Vg(e,t=0){const[n,r]=e.dims,s=e.data,i=new BigInt64Array(s.length);for(let e=0;e<n;++e){const n=e*r;let a=BigInt(t);for(let e=0;e<r;++e){const t=n+e;0n===s[t]?i[t]=BigInt(1):(i[t]=a,a+=s[t])}}return{data:i,dims:e.dims}}function Wg(e,t,n,r){if(n.past_key_values){const t=Object.values(n.past_key_values)[0].dims.at(-2),{input_ids:r,attention_mask:s}=n;if(s&&s.dims[1]>r.dims[1]);else if(t<r.dims[1])n.input_ids=r.slice(null,[t,null]);else if(null!=e.config.image_token_index&&r.data.some((t=>t==e.config.image_token_index))){const s=e.config.num_image_tokens;if(!s)throw new Error("`num_image_tokens` is missing in the model configuration.");const i=r.dims[1]-(t-s);n.input_ids=r.slice(null,[-i,null]),n.attention_mask=ch([1,t+i])}}return n}function jg(e,t,n,r){return n.past_key_values&&(t=t.map((e=>[e.at(-1)]))),{...n,decoder_input_ids:Pg(t)}}function Gg(e,...t){return e.config.is_encoder_decoder?jg(e,...t):Wg(e,...t)}function Hg(e,t,n,r){const s=!!n.past_key_values;if(null!==r.guidance_scale&&r.guidance_scale>1&&(s?n.input_ids=sh([n.input_ids,n.input_ids],0):(n.input_ids=sh([n.input_ids,dh(n.input_ids,BigInt(r.pad_token_id))],0),n.attention_mask=sh([n.attention_mask,dh(n.attention_mask,0n)],0))),!s&&n.pixel_values||(n.pixel_values=uh([0,0,3,384,384],1)),s){const e=0,t=1,r=e>0?1:0,s=1;n.images_seq_mask=new Xp("bool",new Array(e+t).fill(!0).fill(!1,0,t),[s,e+t]),n.images_emb_mask=new Xp("bool",new Array(e).fill(!!r),[s,1,e])}return n}class Kg extends j{main_input_name="input_ids";forward_params=["input_ids","attention_mask"];constructor(e,t,n){super(),this.config=e,this.sessions=t,this.configs=n;const r=Ag.get(this.constructor),s=Cg.get(r);switch(this.can_generate=!1,this._forward=null,this._prepare_inputs_for_generation=null,s){case vg:this.can_generate=!0,this._forward=Fg,this._prepare_inputs_for_generation=Wg;break;case bg:case xg:case Eg:this.can_generate=!0,this._forward=Dg,this._prepare_inputs_for_generation=jg;break;case yg:this._forward=Dg;break;case kg:this.can_generate=!0,this._forward=qg,this._prepare_inputs_for_generation=Gg;break;case zg:this.can_generate=!0,this._prepare_inputs_for_generation=Gg;break;case Sg:this.can_generate=!0,this._prepare_inputs_for_generation=Hg;break;default:this._forward=Lg}this.can_generate&&this.forward_params.push("past_key_values"),this.custom_config=this.config["transformers.js_config"]??{}}async dispose(){const e=[];for(const t of Object.values(this.sessions))t?.handler?.dispose&&e.push(t.handler.dispose());return await Promise.all(e)}static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:i="main",model_file_name:a=null,subfolder:o="onnx",device:l=null,dtype:u=null,use_external_data_format:d=null,session_options:c={}}={}){let p={progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:i,model_file_name:a,subfolder:o,device:l,dtype:u,use_external_data_format:d,session_options:c};const h=Ag.get(this),f=Cg.get(h);let m;if(n=p.config=await T_.from_pretrained(e,p),f===vg)m=await Promise.all([Mg(e,{model:p.model_file_name??"model"},p),Og(e,{generation_config:"generation_config.json"},p)]);else if(f===bg||f===xg)m=await Promise.all([Mg(e,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},p),Og(e,{generation_config:"generation_config.json"},p)]);else if(f===$g)m=await Promise.all([Mg(e,{model:"vision_encoder",prompt_encoder_mask_decoder:"prompt_encoder_mask_decoder"},p)]);else if(f===yg)m=await Promise.all([Mg(e,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},p)]);else if(f===kg){const t={embed_tokens:"embed_tokens",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};n.is_encoder_decoder&&(t.model="encoder_model"),m=await Promise.all([Mg(e,t,p),Og(e,{generation_config:"generation_config.json"},p)])}else if(f===Eg)m=await Promise.all([Mg(e,{model:"text_encoder",decoder_model_merged:"decoder_model_merged",encodec_decode:"encodec_decode"},p),Og(e,{generation_config:"generation_config.json"},p)]);else if(f===Sg)m=await Promise.all([Mg(e,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"language_model",lm_head:"lm_head",gen_head:"gen_head",gen_img_embeds:"gen_img_embeds",image_decode:"image_decode"},p),Og(e,{generation_config:"generation_config.json"},p)]);else if(f===zg)m=await Promise.all([Mg(e,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"model",vision_encoder:"vision_encoder"},p),Og(e,{generation_config:"generation_config.json"},p)]);else{if(f!==wg){const e=h??n?.model_type;"custom"!==e&&console.warn(`Model type for \'${e}\' not found, assuming encoder-only architecture. Please report this at ${N_}.`)}m=await Promise.all([Mg(e,{model:p.model_file_name??"model"},p)])}return new this(n,...m)}async _call(e){return await this.forward(e)}async forward(e){return await this._forward(this,e)}get generation_config(){return this.configs?.generation_config??null}_get_logits_warper(e){const t=new F_;return null!==e.temperature&&1!==e.temperature&&t.push(new Y_(e.temperature)),null!==e.top_k&&0!==e.top_k&&t.push(new J_(e.top_k)),null!==e.top_p&&e.top_p<1&&t.push(new Z_(e.top_p)),t}_get_logits_processor(e,t,n=null){const r=new F_;if(null!==e.repetition_penalty&&1!==e.repetition_penalty&&r.push(new G_(e.repetition_penalty)),null!==e.no_repeat_ngram_size&&e.no_repeat_ngram_size>0&&r.push(new j_(e.no_repeat_ngram_size)),null!==e.bad_words_ids&&r.push(new X_(e.bad_words_ids,e.eos_token_id)),null!==e.min_length&&null!==e.eos_token_id&&e.min_length>0&&r.push(new H_(e.min_length,e.eos_token_id)),null!==e.min_new_tokens&&null!==e.eos_token_id&&e.min_new_tokens>0&&r.push(new K_(t,e.min_new_tokens,e.eos_token_id)),null!==e.forced_bos_token_id&&r.push(new U_(e.forced_bos_token_id)),null!==e.forced_eos_token_id&&r.push(new q_(e.max_length,e.forced_eos_token_id)),null!==e.begin_suppress_tokens){const n=t>1||null===e.forced_bos_token_id?t:t+1;r.push(new V_(e.begin_suppress_tokens,n))}return null!==e.guidance_scale&&e.guidance_scale>1&&r.push(new Q_(e.guidance_scale)),null!==n&&r.extend(n),r}_prepare_generation_config(e,t,n=eg){const r={...this.config};for(const e of["decoder","generator","text_config"])e in r&&Object.assign(r,r[e]);const s=new n(r);return Object.assign(s,this.generation_config??{}),e&&Object.assign(s,e),t&&Object.assign(s,J(t,Object.getOwnPropertyNames(s))),s}_get_stopping_criteria(e,t=null){const n=new dg;return null!==e.max_length&&n.push(new cg(e.max_length,this.config.max_position_embeddings??null)),null!==e.eos_token_id&&n.push(new pg(e.eos_token_id)),t&&n.extend(t),n}_validate_model_class(){if(!this.can_generate){const e=[k$,Nk,f$,Tv],t=Ag.get(this.constructor),n=new Set,r=this.config.model_type;for(const t of e){const e=t.get(r);e&&n.add(e[0])}let s=`The current model class (${t}) is not compatible with \\`.generate()\\`, as it doesn\'t have a language model head.`;throw n.size>0&&(s+=` Please use the following class instead: ${[...n].join(", ")}`),Error(s)}}prepare_inputs_for_generation(...e){return this._prepare_inputs_for_generation(this,...e)}_update_model_kwargs_for_generation({generated_input_ids:e,outputs:t,model_inputs:n,is_encoder_decoder:r}){return n.past_key_values=this.getPastKeyValues(t,n.past_key_values),n.input_ids=new Xp("int64",e.flat(),[e.length,1]),r||(n.attention_mask=sh([n.attention_mask,ch([n.attention_mask.dims[0],1])],1)),n.position_ids=null,n}_prepare_model_inputs({inputs:e,bos_token_id:t,model_kwargs:n}){const r=J(n,this.forward_params),s=this.main_input_name;if(s in r){if(e)throw new Error("`inputs`: {inputs}` were passed alongside {input_name} which is not allowed. Make sure to either pass {inputs} or {input_name}=...")}else r[s]=e;return{inputs_tensor:r[s],model_inputs:r,model_input_name:s}}async _prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:e,model_inputs:t,model_input_name:n,generation_config:r}){if(this.sessions.model.inputNames.includes("inputs_embeds")&&!t.inputs_embeds&&"_prepare_inputs_embeds"in this){const{input_ids:e,pixel_values:n,attention_mask:r,...s}=t;t={...s,...J(await this._prepare_inputs_embeds(t),["inputs_embeds","attention_mask"])}}let{last_hidden_state:s}=await Lg(this,t);if(null!==r.guidance_scale&&r.guidance_scale>1)s=sh([s,dh(s,0)],0),"attention_mask"in t&&(t.attention_mask=sh([t.attention_mask,(i=t.attention_mask,hh(i.dims))],0));else if(t.decoder_input_ids){const e=Pg(t.decoder_input_ids).dims[0];if(e!==s.dims[0]){if(1!==s.dims[0])throw new Error(`The encoder outputs have a different batch size (${s.dims[0]}) than the decoder inputs (${e}).`);s=sh(Array.from({length:e},(()=>s)),0)}}var i;return t.encoder_outputs=s,t}_prepare_decoder_input_ids_for_generation({batch_size:e,model_input_name:t,model_kwargs:n,decoder_start_token_id:r,bos_token_id:s,generation_config:i}){let{decoder_input_ids:a,...o}=n;if(!(a instanceof Xp)){if(a)Array.isArray(a[0])||(a=Array.from({length:e},(()=>a)));else if(r??=s,"musicgen"===this.config.model_type)a=Array.from({length:e*this.config.decoder.num_codebooks},(()=>[r]));else if(Array.isArray(r)){if(r.length!==e)throw new Error(`\\`decoder_start_token_id\\` expcted to have length ${e} but got ${r.length}`);a=r}else a=Array.from({length:e},(()=>[r]));a=Pg(a)}return n.decoder_attention_mask=ph(a),{input_ids:a,model_inputs:o}}async generate({inputs:e=null,generation_config:t=null,logits_processor:n=null,stopping_criteria:r=null,streamer:s=null,...i}){this._validate_model_class(),t=this._prepare_generation_config(t,i);let{inputs_tensor:a,model_inputs:o,model_input_name:l}=this._prepare_model_inputs({inputs:e,model_kwargs:i});const u=this.config.is_encoder_decoder;let d;u&&("encoder_outputs"in o||(o=await this._prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:a,model_inputs:o,model_input_name:l,generation_config:t}))),u?({input_ids:d,model_inputs:o}=this._prepare_decoder_input_ids_for_generation({batch_size:o[l].dims.at(0),model_input_name:l,model_kwargs:o,decoder_start_token_id:t.decoder_start_token_id,bos_token_id:t.bos_token_id,generation_config:t})):d=o[l];let c=d.dims.at(-1);null!==t.max_new_tokens&&(t.max_length=c+t.max_new_tokens);const p=this._get_logits_processor(t,c,n),h=this._get_stopping_criteria(t,r),f=o[l].dims.at(0),m=hg.getSampler(t),_=new Array(f).fill(0),g=d.tolist();let w;s&&s.put(g);let y={};for(;;){if(o=this.prepare_inputs_for_generation(g,o,t),w=await this.forward(o),t.output_attentions&&t.return_dict_in_generate){const e=this.getAttentions(w);for(const t in e)t in y||(y[t]=[]),y[t].push(e[t])}const e=p(g,w.logits.slice(null,-1,null)),n=[];for(let t=0;t<e.dims.at(0);++t){const r=e[t],s=await m(r);for(const[e,r]of s){const s=BigInt(e);_[t]+=r,g[t].push(s),n.push([s]);break}}s&&s.put(n);if(h(g).every((e=>e)))break;o=this._update_model_kwargs_for_generation({generated_input_ids:n,outputs:w,model_inputs:o,is_encoder_decoder:u})}s&&s.end();const b=this.getPastKeyValues(w,o.past_key_values,!0),x=new Xp("int64",g.flat(),[g.length,g[0].length]);if(t.return_dict_in_generate)return{sequences:x,past_key_values:b,...y};for(const e of Object.values(w))"gpu-buffer"===e.location&&e.dispose();return x}getPastKeyValues(e,t,n=!1){const r=Object.create(null);for(const s in e)if(s.startsWith("present")){const i=s.replace("present","past_key_values"),a=s.includes("encoder");if(r[i]=a&&t?t[i]:e[s],t&&(!a||n)){const e=t[i];"gpu-buffer"===e.location&&e.dispose()}}return r}getAttentions(e){const t={};for(const n of["cross_attentions","encoder_attentions","decoder_attentions"])for(const r in e)r.startsWith(n)&&(n in t||(t[n]=[]),t[n].push(e[r]));return t}addPastKeyValues(e,t){if(t)Object.assign(e,t);else{const t=this.sessions.decoder_model_merged??this.sessions.model,n=t?.config?.kv_cache_dtype??"float32",r="float16"===n?new Uint16Array:[],s=(e[this.main_input_name]??e.attention_mask)?.dims?.[0]??1,i=z_(this.config,{batch_size:s});for(const t in i)e[t]=new Xp(n,r,i[t])}}async encode_image({pixel_values:e}){const t=(await Bg(this.sessions.vision_encoder,{pixel_values:e})).image_features;return this.config.num_image_tokens||(console.warn(`The number of image tokens was not set in the model configuration. Setting it to the number of features detected by the vision encoder (${t.dims[1]}).`),this.config.num_image_tokens=t.dims[1]),t}async encode_text({input_ids:e}){return(await Bg(this.sessions.embed_tokens,{input_ids:e})).inputs_embeds}}class Xg{}class Qg extends Kg{}class Yg extends Kg{}class Zg extends Kg{}class Jg extends Kg{}class ew extends Kg{}class tw extends Kg{}class nw extends Kg{}class rw extends Kg{}class sw extends Kg{}class iw extends Kg{}class aw extends Kg{}class ow extends Kg{}class lw extends Kg{}class uw extends Kg{}class dw extends Kg{forward_params=["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"]}class cw extends Kg{}class pw extends Kg{}class hw extends Kg{}class fw extends Kg{}class mw extends Kg{}class _w extends Kg{}class gw extends Kg{}class ww extends Kg{}class yw extends Kg{}class bw extends Kg{}class xw extends Kg{requires_attention_mask=!1;main_input_name="input_features";forward_params=["input_features","attention_mask","decoder_input_ids","decoder_attention_mask","past_key_values"]}class vw extends xw{_prepare_generation_config(e,t){return super._prepare_generation_config(e,t,gg)}_retrieve_init_tokens(e){const t=[e.decoder_start_token_id];let n=e.language;const r=e.task;if(e.is_multilingual){n||(console.warn("No language specified - defaulting to English (en)."),n="en");const s=function i(e){e=e.toLowerCase();let t=bf.get(e);if(void 0===t){if(!yf.has(e)){const t=2===e.length?yf.keys():yf.values();throw new Error(`Language "${e}" is not supported. Must be one of: ${JSON.stringify(t)}`)}t=e}return t}(n),a=`<|${s}|>`;t.push(e.lang_to_id[a]),t.push(e.task_to_id[r??"transcribe"])}else if(n||r)throw new Error("Cannot specify `task` or `language` for an English-only model. If the model is intended to be multilingual, pass `is_multilingual=true` to generate, or update the generation config.");return!e.return_timestamps&&e.no_timestamps_token_id&&t.at(-1)!==e.no_timestamps_token_id?t.push(e.no_timestamps_token_id):e.return_timestamps&&t.at(-1)===e.no_timestamps_token_id&&(console.warn("<|notimestamps|> prompt token is removed from generation_config since `return_timestamps` is set to `true`."),t.pop()),t.filter((e=>null!=e))}async generate({inputs:e=null,generation_config:t=null,logits_processor:n=null,stopping_criteria:r=null,...s}){t=this._prepare_generation_config(t,s);const i=s.decoder_input_ids??this._retrieve_init_tokens(t);if(t.return_timestamps&&(n??=new F_,n.push(new W_(t,i))),t.begin_suppress_tokens&&(n??=new F_,n.push(new V_(t.begin_suppress_tokens,i.length))),t.return_token_timestamps){if(!t.alignment_heads)throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");"translate"===t.task&&console.warn("Token-level timestamps may not be reliable for task \'translate\'."),t.output_attentions=!0,t.return_dict_in_generate=!0}const a=await super.generate({inputs:e,generation_config:t,logits_processor:n,decoder_input_ids:i,...s});return t.return_token_timestamps&&(a.token_timestamps=this._extract_token_timestamps(a,t.alignment_heads,t.num_frames)),a}_extract_token_timestamps(e,t,n=null,r=.02){if(!e.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");null==n&&console.warn("`num_frames` has not been set, meaning the entire audio will be analyzed. This may lead to inaccurate token-level timestamps for short audios (< 30 seconds).");let s=this.config.median_filter_width;void 0===s&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),s=7);const i=e.cross_attentions,a=Array.from({length:this.config.decoder_layers},((e,t)=>sh(i.map((e=>e[t])),2))),o=ih(t.map((([e,t])=>{if(e>=a.length)throw new Error(`Layer index ${e} is out of bounds for cross attentions (length ${a.length}).`);return n?a[e].slice(null,t,null,[0,n]):a[e].slice(null,t)}))).transpose(1,0,2,3),[l,u]=ah(o,-2,0,!0),d=o.clone();for(let e=0;e<d.dims[0];++e){const t=d[e];for(let n=0;n<t.dims[0];++n){const r=t[n],i=l[e][n][0].data,a=u[e][n][0].data;for(let e=0;e<r.dims[0];++e){let t=r[e].data;for(let e=0;e<t.length;++e)t[e]=(t[e]-a[e])/i[e];t.set(xe(t,s))}}}const c=[oh(d,1)],p=e.sequences.dims,h=new Xp("float32",new Float32Array(p[0]*p[1]),p);for(let e=0;e<p[0];++e){const t=c[e].neg().squeeze_(0),[n,s]=$e(t.tolist()),i=Q([1],Array.from({length:n.length-1},((e,t)=>n[t+1]-n[t]))).map((e=>!!e)),a=[];for(let e=0;e<i.length;++e)i[e]&&a.push(s[e]*r);h[e].data.set(a,1)}return h}}class $w extends Kg{requires_attention_mask=!1;main_input_name="input_values";forward_params=["input_values","decoder_input_ids","past_key_values"]}class kw extends Kg{main_input_name="pixel_values";forward_params=["pixel_values","decoder_input_ids","encoder_hidden_states","past_key_values"]}class Ew extends Kg{forward_params=["input_ids","attention_mask","pixel_values","position_ids","past_key_values"]}class Sw extends Ew{_merge_input_ids_with_image_features({inputs_embeds:e,image_features:t,input_ids:n,attention_mask:r}){const s=this.config.image_token_index,i=n.tolist().map((e=>e.findIndex((e=>e==s)))),a=i.every((e=>-1===e)),o=i.every((e=>-1!==e));if(!a&&!o)throw new Error("Every input should contain either 0 or 1 image token.");if(a)return{inputs_embeds:e,attention_mask:r};const l=[],u=[];for(let n=0;n<i.length;++n){const s=i[n],a=e[n],o=t[n],d=r[n];l.push(sh([a.slice([0,s]),o,a.slice([s+1,a.dims[0]])],0)),u.push(sh([d.slice([0,s]),ch([o.dims[0]]),d.slice([s+1,d.dims[0]])],0))}return{inputs_embeds:ih(l,0),attention_mask:ih(u,0)}}}class zw extends Kg{forward_params=["input_ids","inputs_embeds","attention_mask","pixel_values","encoder_outputs","decoder_input_ids","decoder_inputs_embeds","decoder_attention_mask","past_key_values"];main_input_name="inputs_embeds"}class Cw extends Kg{forward_params=["input_ids","attention_mask","pixel_values","position_ids","past_key_values"]}class Tw extends Kg{forward_params=["input_ids","attention_mask","pixel_values","pixel_attention_mask","position_ids","past_key_values"]}class Aw extends Tw{async encode_image({pixel_values:e,pixel_attention_mask:t}){return(await Bg(this.sessions.vision_encoder,{pixel_values:e,pixel_attention_mask:t})).image_features}_merge_input_ids_with_image_features(e){const t=e.image_features.dims.at(-1),n=e.image_features.view(-1,t);return Ug({image_token_id:this.config.image_token_id,...e,image_features:n})}}class Iw extends Kg{forward_params=["input_ids","inputs_embeds","attention_mask","position_ids","pixel_values","image_sizes","past_key_values"]}class Mw extends Iw{async forward({input_ids:e=null,attention_mask:t=null,pixel_values:n=null,image_sizes:r=null,position_ids:s=null,inputs_embeds:i=null,past_key_values:a=null,generation_config:o=null,logits_processor:l=null,...u}){if(!i){let t;if(n&&1!==e.dims[1]){if(!r)throw new Error("`image_sizes` must be provided when `pixel_values` is provided.");({image_features:t}=await Bg(this.sessions.vision_encoder,{pixel_values:n,image_sizes:r}))}else{const e=this.config.normalized_config.hidden_size;t=new Xp("float32",[],[0,e])}({inputs_embeds:i}=await Bg(this.sessions.prepare_inputs_embeds,{input_ids:e,image_features:t}))}return await Fg(this,{inputs_embeds:i,past_key_values:a,attention_mask:t,position_ids:s,generation_config:o,logits_processor:l},!1)}}class Ow extends Kg{}class Bw extends Kg{}class Nw extends Kg{}class Pw extends Kg{}class Rw extends Kg{}class Dw extends Kg{}class Lw extends Kg{}class Fw extends Kg{}class Uw extends Kg{}class qw extends Kg{}class Vw extends Kg{}class Ww extends Kg{}class jw extends Kg{}class Gw extends Kg{}class Hw extends Kg{}class Kw extends Kg{}class Xw extends Kg{}class Qw extends Kg{}class Yw extends Kg{}class Zw extends Kg{}class Jw extends Kg{}class ey extends Kg{}class ty extends Kg{}class ny extends Kg{forward_params=["input_ids","attention_mask","position_ids","past_key_values","pixel_values","image_grid_thw"]}class ry extends Kg{}class sy extends Kg{}class iy extends Kg{}class ay extends Kg{}class oy extends Kg{}class ly extends Kg{}class uy extends Kg{}class dy extends Kg{}class cy extends Kg{}class py extends Kg{}class hy extends Kg{}class fy extends Kg{}class my extends Kg{}class _y extends Kg{}class gy extends Kg{}class wy extends Kg{}class yy extends Kg{}class by extends Kg{}class xy extends Kg{}class vy extends Kg{}class $y extends vy{async _call(e){return new Ey(await super._call(e))}}class ky extends Xg{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class Ey extends Xg{constructor({logits:e,pred_boxes:t,pred_masks:n}){super(),this.logits=e,this.pred_boxes=t,this.pred_masks=n}}class Sy extends Kg{}class zy extends Xg{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class Cy extends Kg{}class Ty extends ky{}class Ay extends Kg{}class Iy extends Kg{}class My extends Kg{}class Oy extends Kg{}class By extends Kg{}class Ny extends Kg{}class Py extends Kg{}class Ry extends Kg{}class Dy extends Kg{}class Ly extends Kg{}class Fy extends Kg{}class Uy extends Kg{}class qy extends Kg{}class Vy extends Kg{}class Wy extends Kg{}class jy extends Kg{}class Gy extends Xg{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class Hy extends Kg{}class Ky extends Xg{constructor({iou_scores:e,pred_masks:t}){super(),this.iou_scores=e,this.pred_masks=t}}class Xy extends Kg{}class Qy extends Kg{}class Yy extends Kg{}class Zy extends Kg{}class Jy extends Kg{}class eb extends Kg{}class tb extends Kg{}class nb extends Kg{}class rb extends Kg{}class sb extends Kg{}class ib extends Kg{}class ab extends Kg{}class ob extends Kg{}class lb extends Kg{}class ub extends Kg{}class db extends Kg{}class cb extends db{async _call(e){return new BS(await super._call(e))}}class pb extends Kg{}class hb extends Kg{}class fb extends Kg{}class mb extends Kg{forward_params=["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"];_apply_and_filter_by_delay_pattern_mask(e){const[t,n]=e.dims,r=this.config.decoder.num_codebooks,s=n-r;let i=0;for(let t=0;t<e.size;++t){if(e.data[t]===this.config.decoder.pad_token_id)continue;const a=t%n-Math.floor(t/n)%r;a>0&&a<=s&&(e.data[i++]=e.data[t])}const a=Math.floor(t/r),o=i/(a*r);return new Xp(e.type,e.data.slice(0,i),[a,r,o])}prepare_inputs_for_generation(e,t,n){let r=structuredClone(e);for(let e=0;e<r.length;++e)for(let t=0;t<r[e].length;++t)e%this.config.decoder.num_codebooks>=t&&(r[e][t]=BigInt(this.config.decoder.pad_token_id));null!==n.guidance_scale&&n.guidance_scale>1&&(r=r.concat(r));return super.prepare_inputs_for_generation(r,t,n)}async generate(e){const t=await super.generate(e),n=this._apply_and_filter_by_delay_pattern_mask(t).unsqueeze_(0),{audio_values:r}=await Bg(this.sessions.encodec_decode,{audio_codes:n});return r}}class _b extends Kg{}class gb extends Kg{}class wb extends Kg{}class yb extends Kg{}class bb extends Kg{}class xb extends Kg{}class vb extends Xg{constructor({char_logits:e,bpe_logits:t,wp_logits:n}){super(),this.char_logits=e,this.bpe_logits=t,this.wp_logits=n}get logits(){return[this.char_logits,this.bpe_logits,this.wp_logits]}}class $b extends Kg{}class kb extends Kg{}class Eb extends Kg{}class Sb{static MODEL_CLASS_MAPPINGS=null;static BASE_IF_FAIL=!1;static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:i="main",model_file_name:a=null,subfolder:o="onnx",device:l=null,dtype:u=null,use_external_data_format:d=null,session_options:c={}}={}){const p={progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:i,model_file_name:a,subfolder:o,device:l,dtype:u,use_external_data_format:d,session_options:c};if(p.config=await T_.from_pretrained(e,p),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);for(const t of this.MODEL_CLASS_MAPPINGS){const n=t.get(p.config.model_type);if(n)return await n[1].from_pretrained(e,p)}if(this.BASE_IF_FAIL)return console.warn(`Unknown model class "${p.config.model_type}", attempting to construct from base class.`),await Kg.from_pretrained(e,p);throw Error(`Unsupported model type: ${p.config.model_type}`)}}const zb=new Map([["bert",["BertModel",class Cb extends Qg{}]],["nomic_bert",["NomicBertModel",class Tb extends Yg{}]],["roformer",["RoFormerModel",class Ab extends Zg{}]],["electra",["ElectraModel",class Ib extends ew{}]],["esm",["EsmModel",class Mb extends iw{}]],["convbert",["ConvBertModel",class Ob extends Jg{}]],["camembert",["CamembertModel",class Bb extends tw{}]],["deberta",["DebertaModel",class Nb extends nw{}]],["deberta-v2",["DebertaV2Model",class Pb extends rw{}]],["mpnet",["MPNetModel",class Rb extends ow{}]],["albert",["AlbertModel",class Db extends uw{}]],["distilbert",["DistilBertModel",class Lb extends sw{}]],["roberta",["RobertaModel",class Fb extends gw{}]],["xlm",["XLMModel",class Ub extends ww{}]],["xlm-roberta",["XLMRobertaModel",class qb extends yw{}]],["clap",["ClapModel",class Vb extends ub{}]],["clip",["CLIPModel",class Wb extends Ow{}]],["clipseg",["CLIPSegModel",class jb extends Rw{}]],["chinese_clip",["ChineseCLIPModel",class Gb extends Nw{}]],["siglip",["SiglipModel",class Hb extends Bw{}]],["jina_clip",["JinaCLIPModel",class Kb extends Pw{async forward(e){const t=!e.input_ids,n=!e.pixel_values;if(t&&n)throw new Error("Either `input_ids` or `pixel_values` should be provided.");if(t&&(e.input_ids=ch([e.pixel_values.dims[0],1])),n){const{image_size:t}=this.config.vision_config;e.pixel_values=uh([0,3,t,t],0)}const{text_embeddings:r,image_embeddings:s,l2norm_text_embeddings:i,l2norm_image_embeddings:a}=await super.forward(e),o={};return t||(o.text_embeddings=r,o.l2norm_text_embeddings=i),n||(o.image_embeddings=s,o.l2norm_image_embeddings=a),o}}]],["mobilebert",["MobileBertModel",class Xb extends aw{}]],["squeezebert",["SqueezeBertModel",class Qb extends lw{}]],["wav2vec2",["Wav2Vec2Model",class Yb extends Yy{}]],["wav2vec2-bert",["Wav2Vec2BertModel",class Zb extends nb{}]],["unispeech",["UniSpeechModel",class Jb extends eb{}]],["unispeech-sat",["UniSpeechSatModel",class ex extends tb{}]],["hubert",["HubertModel",class tx extends Yy{}]],["wavlm",["WavLMModel",class nx extends rb{}]],["audio-spectrogram-transformer",["ASTModel",class rx extends bw{}]],["vits",["VitsModel",cb]],["pyannote",["PyAnnoteModel",class sx extends Zy{}]],["wespeaker-resnet",["WeSpeakerResNetModel",class ix extends Jy{}]],["detr",["DetrModel",class ax extends vy{}]],["rt_detr",["RTDetrModel",class ox extends Sy{}]],["table-transformer",["TableTransformerModel",class lx extends Cy{}]],["vit",["ViTModel",class ux extends ly{}]],["ijepa",["IJepaModel",class dx extends uy{}]],["pvt",["PvtModel",class cx extends cy{}]],["vit_msn",["ViTMSNModel",class px extends hy{}]],["vit_mae",["ViTMAEModel",class hx extends py{}]],["groupvit",["GroupViTModel",class fx extends fy{}]],["fastvit",["FastViTModel",class mx extends my{}]],["mobilevit",["MobileViTModel",class _x extends gy{}]],["mobilevitv2",["MobileViTV2Model",class gx extends wy{}]],["owlvit",["OwlViTModel",class wx extends yy{}]],["owlv2",["Owlv2Model",class yx extends by{}]],["beit",["BeitModel",class bx extends xy{}]],["deit",["DeiTModel",class xx extends Ay{}]],["hiera",["HieraModel",class vx extends Iy{}]],["convnext",["ConvNextModel",class $x extends qy{}]],["convnextv2",["ConvNextV2Model",class kx extends Vy{}]],["dinov2",["Dinov2Model",class Ex extends Wy{}]],["resnet",["ResNetModel",class Sx extends My{}]],["swin",["SwinModel",class zx extends Oy{}]],["swin2sr",["Swin2SRModel",class Cx extends By{}]],["donut-swin",["DonutSwinModel",class Tx extends Uy{}]],["yolos",["YolosModel",class Ax extends jy{}]],["dpt",["DPTModel",class Ix extends Ny{}]],["glpn",["GLPNModel",class Mx extends Fy{}]],["hifigan",["SpeechT5HifiGan",class Ox extends Kg{main_input_name="spectrogram"}]],["efficientnet",["EfficientNetModel",class Bx extends fb{}]],["decision_transformer",["DecisionTransformerModel",class Nx extends bb{}]],["patchtst",["PatchTSTForPrediction",class Px extends kb{}]],["patchtsmixer",["PatchTSMixerForPrediction",class Rx extends Eb{}]],["mobilenet_v1",["MobileNetV1Model",class Dx extends _b{}]],["mobilenet_v2",["MobileNetV2Model",class Lx extends gb{}]],["mobilenet_v3",["MobileNetV3Model",class Fx extends wb{}]],["mobilenet_v4",["MobileNetV4Model",class Ux extends yb{}]],["maskformer",["MaskFormerModel",class qx extends Ly{}]],["mgp-str",["MgpstrForSceneTextRecognition",class Vx extends $b{async _call(e){return new vb(await super._call(e))}}]]]),Wx=new Map([["t5",["T5Model",class jx extends dw{}]],["longt5",["LongT5Model",class Gx extends cw{}]],["mt5",["MT5Model",class Hx extends pw{}]],["bart",["BartModel",class Kx extends hw{}]],["mbart",["MBartModel",class Xx extends fw{}]],["marian",["MarianModel",class Qx extends Xy{}]],["whisper",["WhisperModel",class Yx extends xw{}]],["m2m_100",["M2M100Model",class Zx extends Qy{}]],["blenderbot",["BlenderbotModel",class Jx extends mw{}]],["blenderbot-small",["BlenderbotSmallModel",class ev extends _w{}]]]),tv=new Map([["bloom",["BloomModel",class nv extends iy{}]],["jais",["JAISModel",class rv extends Lw{}]],["gpt2",["GPT2Model",class sv extends Dw{}]],["gptj",["GPTJModel",class iv extends qw{}]],["gpt_bigcode",["GPTBigCodeModel",class av extends Vw{}]],["gpt_neo",["GPTNeoModel",class ov extends Fw{}]],["gpt_neox",["GPTNeoXModel",class lv extends Uw{}]],["codegen",["CodeGenModel",class uv extends Ww{}]],["llama",["LlamaModel",class dv extends jw{}]],["exaone",["ExaoneModel",class cv extends Gw{}]],["olmo",["OlmoModel",class pv extends Kw{}]],["olmo2",["Olmo2Model",class hv extends Xw{}]],["mobilellm",["MobileLLMModel",class fv extends Hw{}]],["granite",["GraniteModel",class mv extends Qw{}]],["cohere",["CohereModel",class _v extends Yw{}]],["gemma",["GemmaModel",class gv extends Zw{}]],["gemma2",["Gemma2Model",class wv extends Jw{}]],["openelm",["OpenELMModel",class yv extends ey{}]],["qwen2",["Qwen2Model",class bv extends ty{}]],["phi",["PhiModel",class xv extends ry{}]],["phi3",["Phi3Model",class vv extends sy{}]],["mpt",["MptModel",class $v extends ay{}]],["opt",["OPTModel",class kv extends oy{}]],["mistral",["MistralModel",class Ev extends ab{}]],["starcoder2",["Starcoder2Model",class Sv extends ob{}]],["falcon",["FalconModel",class zv extends lb{}]],["stablelm",["StableLmModel",class Cv extends hb{}]]]),Tv=new Map([["speecht5",["SpeechT5ForSpeechToText",class Av extends sb{}]],["whisper",["WhisperForConditionalGeneration",vw]],["moonshine",["MoonshineForConditionalGeneration",class Iv extends $w{}]]]),Mv=new Map([["speecht5",["SpeechT5ForTextToSpeech",class Ov extends sb{async generate_speech(e,t,{threshold:n=.5,minlenratio:r=0,maxlenratio:s=20,vocoder:i=null}={}){const a={input_ids:e},{encoder_outputs:o,encoder_attention_mask:l}=await Lg(this,a),u=o.dims[1]/this.config.reduction_factor,d=Math.floor(u*s),c=Math.floor(u*r),p=this.config.num_mel_bins;let h=[],f=null,m=null,_=0;for(;;){++_;const e=Rg(!!m);let r;r=m?m.output_sequence_out:new Xp("float32",new Float32Array(p),[1,1,p]);let s={use_cache_branch:e,output_sequence:r,encoder_attention_mask:l,speaker_embeddings:t,encoder_hidden_states:o};this.addPastKeyValues(s,f),m=await Bg(this.sessions.decoder_model_merged,s),f=this.getPastKeyValues(m,f);const{prob:i,spectrum:a}=m;if(h.push(a),_>=c&&(Array.from(i.data).filter((e=>e>=n)).length>0||_>=d))break}const g=sh(h),{waveform:w}=await Bg(i.sessions.model,{spectrogram:g});return{spectrogram:g,waveform:w}}}]]]),Bv=new Map([["vits",["VitsModel",cb]],["musicgen",["MusicgenForConditionalGeneration",mb]]]),Nv=new Map([["bert",["BertForSequenceClassification",class Pv extends Qg{async _call(e){return new zS(await super._call(e))}}]],["roformer",["RoFormerForSequenceClassification",class Rv extends Zg{async _call(e){return new zS(await super._call(e))}}]],["electra",["ElectraForSequenceClassification",class Dv extends ew{async _call(e){return new zS(await super._call(e))}}]],["esm",["EsmForSequenceClassification",class Lv extends iw{async _call(e){return new zS(await super._call(e))}}]],["convbert",["ConvBertForSequenceClassification",class Fv extends Jg{async _call(e){return new zS(await super._call(e))}}]],["camembert",["CamembertForSequenceClassification",class Uv extends tw{async _call(e){return new zS(await super._call(e))}}]],["deberta",["DebertaForSequenceClassification",class qv extends nw{async _call(e){return new zS(await super._call(e))}}]],["deberta-v2",["DebertaV2ForSequenceClassification",class Vv extends rw{async _call(e){return new zS(await super._call(e))}}]],["mpnet",["MPNetForSequenceClassification",class Wv extends ow{async _call(e){return new zS(await super._call(e))}}]],["albert",["AlbertForSequenceClassification",class jv extends uw{async _call(e){return new zS(await super._call(e))}}]],["distilbert",["DistilBertForSequenceClassification",class Gv extends sw{async _call(e){return new zS(await super._call(e))}}]],["roberta",["RobertaForSequenceClassification",class Hv extends gw{async _call(e){return new zS(await super._call(e))}}]],["xlm",["XLMForSequenceClassification",class Kv extends ww{async _call(e){return new zS(await super._call(e))}}]],["xlm-roberta",["XLMRobertaForSequenceClassification",class Xv extends yw{async _call(e){return new zS(await super._call(e))}}]],["bart",["BartForSequenceClassification",class Qv extends hw{async _call(e){return new zS(await super._call(e))}}]],["mbart",["MBartForSequenceClassification",class Yv extends fw{async _call(e){return new zS(await super._call(e))}}]],["mobilebert",["MobileBertForSequenceClassification",class Zv extends aw{async _call(e){return new zS(await super._call(e))}}]],["squeezebert",["SqueezeBertForSequenceClassification",class Jv extends lw{async _call(e){return new zS(await super._call(e))}}]]]),e$=new Map([["bert",["BertForTokenClassification",class t$ extends Qg{async _call(e){return new TS(await super._call(e))}}]],["roformer",["RoFormerForTokenClassification",class n$ extends Zg{async _call(e){return new TS(await super._call(e))}}]],["electra",["ElectraForTokenClassification",class r$ extends ew{async _call(e){return new TS(await super._call(e))}}]],["esm",["EsmForTokenClassification",class s$ extends iw{async _call(e){return new TS(await super._call(e))}}]],["convbert",["ConvBertForTokenClassification",class i$ extends Jg{async _call(e){return new TS(await super._call(e))}}]],["camembert",["CamembertForTokenClassification",class a$ extends tw{async _call(e){return new TS(await super._call(e))}}]],["deberta",["DebertaForTokenClassification",class o$ extends nw{async _call(e){return new TS(await super._call(e))}}]],["deberta-v2",["DebertaV2ForTokenClassification",class l$ extends rw{async _call(e){return new TS(await super._call(e))}}]],["mpnet",["MPNetForTokenClassification",class u$ extends ow{async _call(e){return new TS(await super._call(e))}}]],["distilbert",["DistilBertForTokenClassification",class d$ extends sw{async _call(e){return new TS(await super._call(e))}}]],["roberta",["RobertaForTokenClassification",class c$ extends gw{async _call(e){return new TS(await super._call(e))}}]],["xlm",["XLMForTokenClassification",class p$ extends ww{async _call(e){return new TS(await super._call(e))}}]],["xlm-roberta",["XLMRobertaForTokenClassification",class h$ extends yw{async _call(e){return new TS(await super._call(e))}}]]]),f$=new Map([["t5",["T5ForConditionalGeneration",class m$ extends dw{}]],["longt5",["LongT5ForConditionalGeneration",class _$ extends cw{}]],["mt5",["MT5ForConditionalGeneration",class g$ extends pw{}]],["bart",["BartForConditionalGeneration",class w$ extends hw{}]],["mbart",["MBartForConditionalGeneration",class y$ extends fw{}]],["marian",["MarianMTModel",class b$ extends Xy{}]],["m2m_100",["M2M100ForConditionalGeneration",class x$ extends Qy{}]],["blenderbot",["BlenderbotForConditionalGeneration",class v$ extends mw{}]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",class $$ extends _w{}]]]),k$=new Map([["bloom",["BloomForCausalLM",class E$ extends iy{}]],["gpt2",["GPT2LMHeadModel",class S$ extends Dw{}]],["jais",["JAISLMHeadModel",class z$ extends Lw{}]],["gptj",["GPTJForCausalLM",class C$ extends qw{}]],["gpt_bigcode",["GPTBigCodeForCausalLM",class T$ extends Vw{}]],["gpt_neo",["GPTNeoForCausalLM",class A$ extends Fw{}]],["gpt_neox",["GPTNeoXForCausalLM",class I$ extends Uw{}]],["codegen",["CodeGenForCausalLM",class M$ extends Ww{}]],["llama",["LlamaForCausalLM",class O$ extends jw{}]],["exaone",["ExaoneForCausalLM",class B$ extends Gw{}]],["olmo",["OlmoForCausalLM",class N$ extends Kw{}]],["olmo2",["Olmo2ForCausalLM",class P$ extends Xw{}]],["mobilellm",["MobileLLMForCausalLM",class R$ extends Hw{}]],["granite",["GraniteForCausalLM",class D$ extends Qw{}]],["cohere",["CohereForCausalLM",class L$ extends Yw{}]],["gemma",["GemmaForCausalLM",class F$ extends Zw{}]],["gemma2",["Gemma2ForCausalLM",class U$ extends Jw{}]],["openelm",["OpenELMForCausalLM",class q$ extends ey{}]],["qwen2",["Qwen2ForCausalLM",class V$ extends ty{}]],["phi",["PhiForCausalLM",class W$ extends ry{}]],["phi3",["Phi3ForCausalLM",class j$ extends sy{}]],["mpt",["MptForCausalLM",class G$ extends ay{}]],["opt",["OPTForCausalLM",class H$ extends oy{}]],["mbart",["MBartForCausalLM",class K$ extends fw{}]],["mistral",["MistralForCausalLM",class X$ extends ab{}]],["starcoder2",["Starcoder2ForCausalLM",class Q$ extends ob{}]],["falcon",["FalconForCausalLM",class Y$ extends lb{}]],["trocr",["TrOCRForCausalLM",class Z$ extends ib{}]],["stablelm",["StableLmForCausalLM",class J$ extends hb{}]],["phi3_v",["Phi3VForCausalLM",Mw]]]),ek=new Map([["multi_modality",["MultiModalityCausalLM",class tk extends xb{forward_params=["input_ids","pixel_values","images_seq_mask","images_emb_mask","attention_mask","position_ids","past_key_values"];constructor(...e){super(...e),this._generation_mode="text"}async forward(e){const t=this._generation_mode??"text";let n;if("text"!==t&&e.past_key_values){const t=this.sessions.gen_img_embeds,r=J({image_ids:e.input_ids},t.inputNames);n=await Bg(t,r)}else{const t=this.sessions.prepare_inputs_embeds,r=J(e,t.inputNames);n=await Bg(t,r)}const r={...e,...n},s=await Fg(this,r),i=this.sessions["text"===t?"lm_head":"gen_head"];if(!i)throw new Error(`Unable to find "${i}" generation head`);const a=await Bg(i,J(s,i.inputNames));return{...n,...s,...a}}async generate(e){return this._generation_mode="text",super.generate(e)}async generate_images(e){this._generation_mode="image";const t=(e.inputs??e[this.main_input_name]).dims[1],n=(await super.generate(e)).slice(null,[t,null]),r=this.sessions.image_decode,{decoded_image:s}=await Bg(r,{generated_tokens:n}),i=s.add_(1).mul_(127.5).clamp_(0,255).to("uint8"),a=[];for(const e of i){const t=lg.fromTensor(e);a.push(t)}return a}}]]]),nk=new Map([["bert",["BertForMaskedLM",class rk extends Qg{async _call(e){return new AS(await super._call(e))}}]],["roformer",["RoFormerForMaskedLM",class sk extends Zg{async _call(e){return new AS(await super._call(e))}}]],["electra",["ElectraForMaskedLM",class ik extends ew{async _call(e){return new AS(await super._call(e))}}]],["esm",["EsmForMaskedLM",class ak extends iw{async _call(e){return new AS(await super._call(e))}}]],["convbert",["ConvBertForMaskedLM",class ok extends Jg{async _call(e){return new AS(await super._call(e))}}]],["camembert",["CamembertForMaskedLM",class lk extends tw{async _call(e){return new AS(await super._call(e))}}]],["deberta",["DebertaForMaskedLM",class uk extends nw{async _call(e){return new AS(await super._call(e))}}]],["deberta-v2",["DebertaV2ForMaskedLM",class dk extends rw{async _call(e){return new AS(await super._call(e))}}]],["mpnet",["MPNetForMaskedLM",class ck extends ow{async _call(e){return new AS(await super._call(e))}}]],["albert",["AlbertForMaskedLM",class pk extends uw{async _call(e){return new AS(await super._call(e))}}]],["distilbert",["DistilBertForMaskedLM",class hk extends sw{async _call(e){return new AS(await super._call(e))}}]],["roberta",["RobertaForMaskedLM",class fk extends gw{async _call(e){return new AS(await super._call(e))}}]],["xlm",["XLMWithLMHeadModel",class mk extends ww{async _call(e){return new AS(await super._call(e))}}]],["xlm-roberta",["XLMRobertaForMaskedLM",class _k extends yw{async _call(e){return new AS(await super._call(e))}}]],["mobilebert",["MobileBertForMaskedLM",class gk extends aw{async _call(e){return new AS(await super._call(e))}}]],["squeezebert",["SqueezeBertForMaskedLM",class wk extends lw{async _call(e){return new AS(await super._call(e))}}]]]),yk=new Map([["bert",["BertForQuestionAnswering",class bk extends Qg{async _call(e){return new IS(await super._call(e))}}]],["roformer",["RoFormerForQuestionAnswering",class xk extends Zg{async _call(e){return new IS(await super._call(e))}}]],["electra",["ElectraForQuestionAnswering",class vk extends ew{async _call(e){return new IS(await super._call(e))}}]],["convbert",["ConvBertForQuestionAnswering",class $k extends Jg{async _call(e){return new IS(await super._call(e))}}]],["camembert",["CamembertForQuestionAnswering",class kk extends tw{async _call(e){return new IS(await super._call(e))}}]],["deberta",["DebertaForQuestionAnswering",class Ek extends nw{async _call(e){return new IS(await super._call(e))}}]],["deberta-v2",["DebertaV2ForQuestionAnswering",class Sk extends rw{async _call(e){return new IS(await super._call(e))}}]],["mpnet",["MPNetForQuestionAnswering",class zk extends ow{async _call(e){return new IS(await super._call(e))}}]],["albert",["AlbertForQuestionAnswering",class Ck extends uw{async _call(e){return new IS(await super._call(e))}}]],["distilbert",["DistilBertForQuestionAnswering",class Tk extends sw{async _call(e){return new IS(await super._call(e))}}]],["roberta",["RobertaForQuestionAnswering",class Ak extends gw{async _call(e){return new IS(await super._call(e))}}]],["xlm",["XLMForQuestionAnswering",class Ik extends ww{async _call(e){return new IS(await super._call(e))}}]],["xlm-roberta",["XLMRobertaForQuestionAnswering",class Mk extends yw{async _call(e){return new IS(await super._call(e))}}]],["mobilebert",["MobileBertForQuestionAnswering",class Ok extends aw{async _call(e){return new IS(await super._call(e))}}]],["squeezebert",["SqueezeBertForQuestionAnswering",class Bk extends lw{async _call(e){return new IS(await super._call(e))}}]]]),Nk=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",kw]],["idefics3",["Idefics3ForConditionalGeneration",Aw]]]),Pk=new Map([["llava",["LlavaForConditionalGeneration",Sw]],["llava_onevision",["LlavaOnevisionForConditionalGeneration",class Rk extends Sw{}]],["moondream1",["Moondream1ForConditionalGeneration",class Dk extends Sw{}]],["florence2",["Florence2ForConditionalGeneration",class Lk extends zw{_merge_input_ids_with_image_features({inputs_embeds:e,image_features:t,input_ids:n,attention_mask:r}){return{inputs_embeds:sh([t,e],1),attention_mask:sh([ch(t.dims.slice(0,2)),r],1)}}async _prepare_inputs_embeds({input_ids:e,pixel_values:t,inputs_embeds:n,attention_mask:r}){if(!e&&!t)throw new Error("Either `input_ids` or `pixel_values` should be provided.");let s,i;return e&&(s=await this.encode_text({input_ids:e})),t&&(i=await this.encode_image({pixel_values:t})),s&&i?({inputs_embeds:n,attention_mask:r}=this._merge_input_ids_with_image_features({inputs_embeds:s,image_features:i,input_ids:e,attention_mask:r})):n=s||i,{inputs_embeds:n,attention_mask:r}}async forward({input_ids:e,pixel_values:t,attention_mask:n,decoder_input_ids:r,decoder_attention_mask:s,encoder_outputs:i,past_key_values:a,inputs_embeds:o,decoder_inputs_embeds:l}){if(o||({inputs_embeds:o,attention_mask:n}=await this._prepare_inputs_embeds({input_ids:e,pixel_values:t,inputs_embeds:o,attention_mask:n})),!i){let{last_hidden_state:e}=await Lg(this,{inputs_embeds:o,attention_mask:n});i=e}if(!l){if(!r)throw new Error("Either `decoder_input_ids` or `decoder_inputs_embeds` should be provided.");l=await this.encode_text({input_ids:r})}const u={inputs_embeds:l,attention_mask:s,encoder_attention_mask:n,encoder_hidden_states:i,past_key_values:a};return await Fg(this,u,!0)}}]],["qwen2-vl",["Qwen2VLForConditionalGeneration",class Fk extends ny{get_rope_index(e,t,n,r){const{vision_config:s,image_token_id:i,video_token_id:a,vision_start_token_id:o}=this.config,l=s.spatial_merge_size??2,u=[];if(t||n){let s=e.tolist();r||(r=ph(e));const d=r.tolist(),c=Array.from({length:3},(t=>Array.from({length:e.dims[0]},(t=>Array.from({length:e.dims[1]},(e=>1)))))),p=t?t.tolist():[],h=n?n.tolist():[];let f=0,m=0;for(let e=0;e<s.length;++e){const t=s[e].filter(((t,n)=>1==d[e][n])),n=t.reduce(((e,t,n)=>(t==o&&e.push(n),e)),[]).map((e=>t[e+1])),r=n.filter((e=>e==i)).length,_=n.filter((e=>e==a)).length;let g=[],w=0,y=r,b=_;for(let e=0;e<n.length;++e){const e=t.findIndex(((e,t)=>t>w&&e==i)),n=t.findIndex(((e,t)=>t>w&&e==a)),r=y>0&&-1!==e?e:t.length+1,s=b>0&&-1!==n?n:t.length+1;let o,u,d,c;r<s?([u,d,c]=p[f],++f,--y,o=r):([u,d,c]=h[m],++m,--b,o=s);const[_,x,v]=[Number(u),Math.floor(Number(d)/l),Math.floor(Number(c)/l)],$=o-w,k=g.length>0?_e(g.at(-1))[0]+1:0;g.push(Array.from({length:3*$},((e,t)=>k+t%$)));const E=$+k,S=_*x*v,z=Array.from({length:S},((e,t)=>E+Math.floor(t/(x*v)))),C=Array.from({length:S},((e,t)=>E+Math.floor(t/v)%x)),T=Array.from({length:S},((e,t)=>E+t%v));g.push([z,C,T].flat()),w=o+S}if(w<t.length){const e=g.length>0?_e(g.at(-1))[0]+1:0,n=t.length-w;g.push(Array.from({length:3*n},((t,r)=>e+r%n)))}const x=g.reduce(((e,t)=>e+t.length),0),v=new Array(x);let $=0;for(let e=0;e<3;++e)for(let t=0;t<g.length;++t){const n=g[t],r=n.length/3;for(let t=e*r;t<(e+1)*r;++t)v[$++]=n[t]}let k=0;const E=d[e];for(let t=0;t<E.length;++t)if(1==E[t]){for(let n=0;n<3;++n)c[n][e][t]=v[n*x/3+k];++k}const S=_e(v)[0];u.push(S+1-s[e].length)}return[new Xp("int64",c.flat(Infinity),[3,e.dims[0],e.dims[1]]),new Xp("int64",u,[u.length,1])]}if(r){const{data:e,dims:t}=Vg(r),n=BigInt64Array.from({length:3*e.length},((t,n)=>e[n%e.length])),s=Array.from({length:t[0]},((n,r)=>_e(e.subarray(t[1]*r,t[1]*(r+1)))[0]+1+t[1]));return[new Xp("int64",n,[3,...t]),new Xp("int64",s,[s.length,1])]}{const[t,n]=e.dims,r=BigInt64Array.from({length:3*t*n},((e,r)=>BigInt(Math.floor(r%n/t))));return[new Xp("int64",r,[3,...e.dims]),hh([t,1])]}}async encode_image({pixel_values:e,image_grid_thw:t}){return(await Bg(this.sessions.vision_encoder,{pixel_values:e,grid_thw:t})).image_features}_merge_input_ids_with_image_features(e){return Ug({image_token_id:this.config.image_token_id,...e})}prepare_inputs_for_generation(e,t,n){if(t.attention_mask&&!t.position_ids)if(t.past_key_values){t.pixel_values=null;const e=BigInt(Object.values(t.past_key_values)[0].dims.at(-2)),n=t.rope_deltas.map((t=>e+t));t.position_ids=ih([n,n,n],0)}else[t.position_ids,t.rope_deltas]=this.get_rope_index(t.input_ids,t.image_grid_thw,t.video_grid_thw,t.attention_mask);return t}}]],["idefics3",["Idefics3ForConditionalGeneration",Aw]],["paligemma",["PaliGemmaForConditionalGeneration",class Uk extends Cw{_merge_input_ids_with_image_features(e){const t=e.image_features.dims.at(-1),n=e.image_features.view(-1,t);return Ug({image_token_id:this.config.image_token_index,...e,image_features:n})}}]]]),qk=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",kw]]]),Vk=new Map([["vit",["ViTForImageClassification",class Wk extends ly{async _call(e){return new zS(await super._call(e))}}]],["ijepa",["IJepaForImageClassification",class jk extends uy{async _call(e){return new zS(await super._call(e))}}]],["pvt",["PvtForImageClassification",class Gk extends cy{async _call(e){return new zS(await super._call(e))}}]],["vit_msn",["ViTMSNForImageClassification",class Hk extends hy{async _call(e){return new zS(await super._call(e))}}]],["fastvit",["FastViTForImageClassification",class Kk extends my{async _call(e){return new zS(await super._call(e))}}]],["mobilevit",["MobileViTForImageClassification",class Xk extends gy{async _call(e){return new zS(await super._call(e))}}]],["mobilevitv2",["MobileViTV2ForImageClassification",class Qk extends wy{async _call(e){return new zS(await super._call(e))}}]],["beit",["BeitForImageClassification",class Yk extends xy{async _call(e){return new zS(await super._call(e))}}]],["deit",["DeiTForImageClassification",class Zk extends Ay{async _call(e){return new zS(await super._call(e))}}]],["hiera",["HieraForImageClassification",class Jk extends Iy{async _call(e){return new zS(await super._call(e))}}]],["convnext",["ConvNextForImageClassification",class eE extends qy{async _call(e){return new zS(await super._call(e))}}]],["convnextv2",["ConvNextV2ForImageClassification",class tE extends Vy{async _call(e){return new zS(await super._call(e))}}]],["dinov2",["Dinov2ForImageClassification",class nE extends Wy{async _call(e){return new zS(await super._call(e))}}]],["resnet",["ResNetForImageClassification",class rE extends My{async _call(e){return new zS(await super._call(e))}}]],["swin",["SwinForImageClassification",class sE extends Oy{async _call(e){return new zS(await super._call(e))}}]],["segformer",["SegformerForImageClassification",class iE extends pb{}]],["efficientnet",["EfficientNetForImageClassification",class aE extends fb{async _call(e){return new zS(await super._call(e))}}]],["mobilenet_v1",["MobileNetV1ForImageClassification",class oE extends _b{async _call(e){return new zS(await super._call(e))}}]],["mobilenet_v2",["MobileNetV2ForImageClassification",class lE extends gb{async _call(e){return new zS(await super._call(e))}}]],["mobilenet_v3",["MobileNetV3ForImageClassification",class uE extends wb{async _call(e){return new zS(await super._call(e))}}]],["mobilenet_v4",["MobileNetV4ForImageClassification",class dE extends yb{async _call(e){return new zS(await super._call(e))}}]]]),cE=new Map([["detr",["DetrForObjectDetection",class pE extends vy{async _call(e){return new ky(await super._call(e))}}]],["rt_detr",["RTDetrForObjectDetection",class hE extends Sy{async _call(e){return new zy(await super._call(e))}}]],["table-transformer",["TableTransformerForObjectDetection",class fE extends Cy{async _call(e){return new Ty(await super._call(e))}}]],["yolos",["YolosForObjectDetection",class mE extends jy{async _call(e){return new Gy(await super._call(e))}}]]]),_E=new Map([["owlvit",["OwlViTForObjectDetection",class gE extends yy{}]],["owlv2",["Owlv2ForObjectDetection",class wE extends by{}]]]),yE=new Map([["detr",["DetrForSegmentation",$y]],["clipseg",["CLIPSegForImageSegmentation",class bE extends Rw{}]]]),xE=new Map([["segformer",["SegformerForSemanticSegmentation",class vE extends pb{}]],["sapiens",["SapiensForSemanticSegmentation",class $E extends Ry{}]]]),kE=new Map([["detr",["DetrForSegmentation",$y]],["maskformer",["MaskFormerForInstanceSegmentation",class EE extends Ly{}]]]),SE=new Map([["sam",["SamModel",class zE extends Hy{async get_image_embeddings({pixel_values:e}){return await Lg(this,{pixel_values:e})}async forward(e){if(e.image_embeddings&&e.image_positional_embeddings||(e={...e,...await this.get_image_embeddings(e)}),!e.input_labels&&e.input_points){const t=e.input_points.dims.slice(0,-1),n=t.reduce(((e,t)=>e*t),1);e.input_labels=new Xp("int64",new BigInt64Array(n).fill(1n),t)}const t={image_embeddings:e.image_embeddings,image_positional_embeddings:e.image_positional_embeddings};return e.input_points&&(t.input_points=e.input_points),e.input_labels&&(t.input_labels=e.input_labels),e.input_boxes&&(t.input_boxes=e.input_boxes),await Bg(this.sessions.prompt_encoder_mask_decoder,t)}async _call(e){return new Ky(await super._call(e))}}]]]),CE=new Map([["wav2vec2",["Wav2Vec2ForCTC",class TE extends Yy{async _call(e){return new MS(await super._call(e))}}]],["wav2vec2-bert",["Wav2Vec2BertForCTC",class AE extends nb{async _call(e){return new MS(await super._call(e))}}]],["unispeech",["UniSpeechForCTC",class IE extends eb{async _call(e){return new MS(await super._call(e))}}]],["unispeech-sat",["UniSpeechSatForCTC",class ME extends tb{async _call(e){return new MS(await super._call(e))}}]],["wavlm",["WavLMForCTC",class OE extends rb{async _call(e){return new MS(await super._call(e))}}]],["hubert",["HubertForCTC",class BE extends Yy{async _call(e){return new MS(await super._call(e))}}]]]),NE=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",class PE extends Yy{async _call(e){return new zS(await super._call(e))}}]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",class RE extends nb{async _call(e){return new zS(await super._call(e))}}]],["unispeech",["UniSpeechForSequenceClassification",class DE extends eb{async _call(e){return new zS(await super._call(e))}}]],["unispeech-sat",["UniSpeechSatForSequenceClassification",class LE extends tb{async _call(e){return new zS(await super._call(e))}}]],["wavlm",["WavLMForSequenceClassification",class FE extends rb{async _call(e){return new zS(await super._call(e))}}]],["hubert",["HubertForSequenceClassification",class UE extends Yy{async _call(e){return new zS(await super._call(e))}}]],["audio-spectrogram-transformer",["ASTForAudioClassification",class qE extends bw{}]]]),VE=new Map([["wavlm",["WavLMForXVector",class WE extends rb{async _call(e){return new CS(await super._call(e))}}]]]),jE=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",class GE extends tb{async _call(e){return new TS(await super._call(e))}}]],["wavlm",["WavLMForAudioFrameClassification",class HE extends rb{async _call(e){return new TS(await super._call(e))}}]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",class KE extends Yy{async _call(e){return new TS(await super._call(e))}}]],["pyannote",["PyAnnoteForAudioFrameClassification",class XE extends Zy{async _call(e){return new TS(await super._call(e))}}]]]),QE=new Map([["vitmatte",["VitMatteForImageMatting",class YE extends _y{async _call(e){return new OS(await super._call(e))}}]]]),ZE=new Map([["patchtst",["PatchTSTForPrediction",class JE extends kb{}]],["patchtsmixer",["PatchTSMixerForPrediction",class eS extends Eb{}]]]),tS=new Map([["swin2sr",["Swin2SRForImageSuperResolution",class nS extends By{}]]]),rS=new Map([["dpt",["DPTForDepthEstimation",class sS extends Ny{}]],["depth_anything",["DepthAnythingForDepthEstimation",class iS extends Py{}]],["glpn",["GLPNForDepthEstimation",class aS extends Fy{}]],["sapiens",["SapiensForDepthEstimation",class oS extends Ry{}]],["depth_pro",["DepthProForDepthEstimation",class lS extends Dy{}]]]),uS=new Map([["sapiens",["SapiensForNormalEstimation",class dS extends Ry{}]]]),cS=new Map([["vitpose",["VitPoseForPoseEstimation",class pS extends dy{}]]]),hS=new Map([["clip",["CLIPVisionModelWithProjection",class fS extends Ow{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"vision_model",...t})}}]],["siglip",["SiglipVisionModel",class mS extends Ow{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"vision_model",...t})}}]],["jina_clip",["JinaCLIPVisionModel",class _S extends Pw{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"vision_model",...t})}}]]]),gS=[[zb,wg],[Wx,yg],[tv,vg],[Nv,wg],[e$,wg],[f$,bg],[Tv,bg],[k$,vg],[ek,Sg],[nk,wg],[yk,wg],[Nk,xg],[Pk,kg],[Vk,wg],[yE,wg],[kE,wg],[xE,wg],[QE,wg],[ZE,wg],[tS,wg],[rS,wg],[uS,wg],[cS,wg],[cE,wg],[_E,wg],[SE,$g],[CE,wg],[NE,wg],[Mv,bg],[Bv,wg],[VE,wg],[jE,wg],[hS,wg]];for(const[e,t]of gS)for(const[n,r]of e.values())Cg.set(n,t),Ag.set(r,n),Tg.set(n,r);const wS=[["MusicgenForConditionalGeneration",mb,Eg],["Phi3VForCausalLM",Mw,zg],["CLIPTextModelWithProjection",class yS extends Ow{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"text_model",...t})}},wg],["SiglipTextModel",class bS extends Bw{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"text_model",...t})}},wg],["JinaCLIPTextModel",class xS extends Pw{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"text_model",...t})}},wg],["ClapTextModelWithProjection",class vS extends ub{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"text_model",...t})}},wg],["ClapAudioModelWithProjection",class $S extends ub{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"audio_model",...t})}},wg]];for(const[e,t,n]of wS)Cg.set(e,n),Ag.set(t,e),Tg.set(e,t);class kS extends Sb{static MODEL_CLASS_MAPPINGS=gS.map((e=>e[0]));static BASE_IF_FAIL=!0}class ES extends Sb{static MODEL_CLASS_MAPPINGS=[Nv]}class SS extends Sb{static MODEL_CLASS_MAPPINGS=[f$]}class zS extends Xg{constructor({logits:e}){super(),this.logits=e}}class CS extends Xg{constructor({logits:e,embeddings:t}){super(),this.logits=e,this.embeddings=t}}class TS extends Xg{constructor({logits:e}){super(),this.logits=e}}class AS extends Xg{constructor({logits:e}){super(),this.logits=e}}class IS extends Xg{constructor({start_logits:e,end_logits:t}){super(),this.start_logits=e,this.end_logits=t}}class MS extends Xg{constructor({logits:e}){super(),this.logits=e}}class OS extends Xg{constructor({alphas:e}){super(),this.alphas=e}}class BS extends Xg{constructor({waveform:e,spectrogram:t}){super(),this.waveform=e,this.spectrogram=t}}class NS extends j{static classes=["image_processor_class","tokenizer_class","feature_extractor_class"];static uses_processor_config=!1;constructor(e,t){super(),this.config=e,this.components=t}get image_processor(){return this.components.image_processor}get tokenizer(){return this.components.tokenizer}get feature_extractor(){return this.components.feature_extractor}apply_chat_template(e,t={}){if(!this.tokenizer)throw new Error("Unable to apply chat template without a tokenizer.");return this.tokenizer.apply_chat_template(e,{tokenize:!1,...t})}batch_decode(...e){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.batch_decode(...e)}async _call(e,...t){for(const n of[this.image_processor,this.feature_extractor,this.tokenizer])if(n)return n(e,...t);throw new Error("No image processor, feature extractor, or tokenizer found.")}static async from_pretrained(e,t){const[n,r]=await Promise.all([this.uses_processor_config?ce(e,"processor_config.json",!0,t):{},Promise.all(this.classes.filter((e=>e in this)).map((async n=>{const r=await this[n].from_pretrained(e,t);return[n.replace(/_class$/,""),r]}))).then(Object.fromEntries)]);return new this(n,r)}}function PS(e,t,n=0,r=null){const s=e/t;let i=function a(e){const t=Math.round(e);return Math.abs(e)%1==.5?t%2==0?t:t-1:t}(s)*t;return null!==r&&i>r&&(i=Math.floor(s)*t),i<n&&(i=Math.ceil(s)*t),i}function RS([e,t],n){return[Math.max(Math.floor(e/n),1)*n,Math.max(Math.floor(t/n),1)*n]}function DS([e,t,n,r]){return[e-n/2,t-r/2,e+n/2,t+r/2]}function LS(e,t=.5,n=null,r=!1){const s=e.logits,i=e.pred_boxes,[a,o,l]=s.dims;if(null!==n&&n.length!==a)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let u=[];for(let e=0;e<a;++e){let a=null!==n?n[e]:null,d={boxes:[],classes:[],scores:[]},c=s[e],p=i[e];for(let e=0;e<o;++e){let n,s=c[e],i=[];if(r){n=s.sigmoid().data;for(let e=0;e<n.length;++e)n[e]>t&&i.push(e)}else{let e=_e(s.data)[1];if(e===l-1)continue;if(n=he(s.data),n[e]<t)continue;i.push(e)}for(const t of i){let r=p[e].data;r=DS(r),null!==a&&(r=r.map(((e,t)=>e*a[(t+1)%2]))),d.boxes.push(r),d.classes.push(t),d.scores.push(n[t])}}u.push(d)}return u}function FS(e,t,n,r){const s=[],i=[],a=[];for(let o=0;o<e.dims[0];++o){const l=e[o],u=t[o],d=_e(l.data)[1];if(d===r)continue;const c=he(l.data)[d];c>n&&(s.push(u),i.push(c),a.push(d))}return[s,i,a]}function US(e,t,n,r=.5,s=.8){const i=[];let a=0,o=0;const l=t[n].data;for(let t=0;t<e.length;++t)e[t]===n&&(i.push(t),++a),l[t]>=r&&++o;let u=a>0&&o>0;if(u){u=a/o>s}return[u,i]}function qS(e,t,n,r,s,i=null,a=null){const[o,l]=a??e[0].dims,u=new Xp("int32",new Int32Array(o*l),[o,l]),d=[];if(null!==a)for(let t=0;t<e.length;++t)e[t]=Qp(e[t],a,"bilinear",!1);const c=new Int32Array(e[0].data.length),p=new Float32Array(e[0].data.length);for(let n=0;n<e.length;++n){let r=t[n];const s=e[n].data;for(let e=0;e<s.length;++e)s[e]*=r,s[e]>p[e]&&(c[e]=n,p[e]=s[e])}let h=0;const f=u.data;for(let i=0;i<n.length;++i){const a=n[i],[o,l]=US(c,e,i,r,s);if(o){++h;for(const e of l)f[e]=h;d.push({id:h,label_id:a,score:t[i]})}}return[u,d]}function VS(e,t=.5,n=.5,r=.8,s=null,i=null){null===s&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),s=new Set);const a=e.class_queries_logits??e.logits,o=(e.masks_queries_logits??e.pred_masks).sigmoid();let[l,u,d]=a.dims;if(d-=1,null!==i&&i.length!==l)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let c=[];for(let e=0;e<l;++e){let l=null!==i?i[e]:null,u=a[e],p=o[e],[h,f,m]=FS(u,p,t,d);if(0===m.length){let[e,t]=l??p.dims.slice(-2),n=new Xp("int32",new Int32Array(e*t).fill(-1),[e,t]);c.push({segmentation:n,segments_info:[]});continue}let[_,g]=qS(h,f,m,n,r,s,l);c.push({segmentation:_,segments_info:g})}return c}function WS(e,t=.5,n=null){throw new Error("`post_process_instance_segmentation` is not yet implemented.")}class jS extends j{constructor(e){super(),this.image_mean=e.image_mean??e.mean,this.image_std=e.image_std??e.std,this.resample=e.resample??2,this.do_rescale=e.do_rescale??!0,this.rescale_factor=e.rescale_factor??1/255,this.do_normalize=e.do_normalize,this.do_thumbnail=e.do_thumbnail,this.size=e.size??e.image_size,this.do_resize=e.do_resize??void 0!==this.size,this.size_divisibility=e.size_divisibility??e.size_divisor,this.do_center_crop=e.do_center_crop,this.crop_size=e.crop_size,this.do_convert_rgb=e.do_convert_rgb??!0,this.do_crop_margin=e.do_crop_margin,this.pad_size=e.pad_size,this.do_pad=e.do_pad,this.do_pad&&!this.pad_size&&this.size&&void 0!==this.size.width&&void 0!==this.size.height&&(this.pad_size=this.size),this.do_flip_channel_order=e.do_flip_channel_order??!1,this.config=e}async thumbnail(e,t,n=2){const r=e.height,s=e.width,i=t.height,a=t.width;let o=Math.min(r,i),l=Math.min(s,a);return o===r&&l===s?e:(r>s?l=Math.floor(s*o/r):s>r&&(o=Math.floor(r*l/s)),await e.resize(l,o,{resample:n}))}async crop_margin(e,t=200){const n=e.clone().grayscale(),r=me(n.data)[0],s=_e(n.data)[0]-r;if(0===s)return e;const i=t/255;let a=n.width,o=n.height,l=0,u=0;const d=n.data;for(let e=0;e<n.height;++e){const t=e*n.width;for(let c=0;c<n.width;++c)(d[t+c]-r)/s<i&&(a=Math.min(a,c),o=Math.min(o,e),l=Math.max(l,c),u=Math.max(u,e))}return e=await e.crop([a,o,l,u])}pad_image(e,t,n,{mode:r="constant",center:s=!1,constant_values:i=0}={}){const[a,o,l]=t;let u,d;if("number"==typeof n?(u=n,d=n):"square"===n?u=d=Math.max(a,o):(u=n.width,d=n.height),u!==o||d!==a){const n=new Float32Array(u*d*l);if(Array.isArray(i))for(let e=0;e<n.length;++e)n[e]=i[e%l];else 0!==i&&n.fill(i);const[c,p]=s?[Math.floor((u-o)/2),Math.floor((d-a)/2)]:[0,0];for(let t=0;t<a;++t){const r=(t+p)*u,s=t*o;for(let t=0;t<o;++t){const i=(r+t+c)*l,a=(s+t)*l;for(let t=0;t<l;++t)n[i+t]=e[a+t]}}if("symmetric"===r){if(s)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const t=a-1,r=o-1;for(let s=0;s<d;++s){const i=s*u,d=Z(s,t)*o;for(let t=0;t<u;++t){if(s<a&&t<o)continue;const u=(i+t)*l,c=(d+Z(t,r))*l;for(let t=0;t<l;++t)n[u+t]=e[c+t]}}}e=n,t=[d,u,l]}return[e,t]}rescale(e){for(let t=0;t<e.length;++t)e[t]=this.rescale_factor*e[t]}get_resize_output_image_size(e,t){const[n,r]=e.size;let s,i;if(this.do_thumbnail){const{height:e,width:n}=t;s=Math.min(e,n)}else Number.isInteger(t)?(s=t,i=this.config.max_size??s):void 0!==t&&(s=t.shortest_edge,i=t.longest_edge);if(void 0!==s||void 0!==i){const e=void 0===s?1:Math.max(s/n,s/r),t=n*e,a=r*e,o=void 0===i?1:Math.min(i/t,i/a);let l=Math.floor(Number((t*o).toFixed(2))),u=Math.floor(Number((a*o).toFixed(2)));return void 0!==this.size_divisibility&&([l,u]=RS([l,u],this.size_divisibility)),[l,u]}if(void 0!==t&&void 0!==t.width&&void 0!==t.height){let e=t.width,s=t.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let t=s/r,i=e/n;Math.abs(1-i)<Math.abs(1-t)?t=i:i=t,s=PS(t*r,this.config.ensure_multiple_of),e=PS(i*n,this.config.ensure_multiple_of)}return[e,s]}if(void 0!==this.size_divisibility)return RS([n,r],this.size_divisibility);if(void 0!==t.min_pixels&&void 0!==t.max_pixels){const{min_pixels:e,max_pixels:s}=t;return function i(e,t,n=28,r=3136,s=1003520){if(e<n||t<n)throw new Error(`height:${e} or width:${t} must be larger than factor:${n}`);if(Math.max(e,t)/Math.min(e,t)>200)throw new Error("absolute aspect ratio must be smaller than 200, got "+Math.max(e,t)/Math.min(e,t));let i=Math.round(e/n)*n,a=Math.round(t/n)*n;if(i*a>s){const r=Math.sqrt(e*t/s);i=Math.floor(e/r/n)*n,a=Math.floor(t/r/n)*n}else if(i*a<r){const s=Math.sqrt(r/(e*t));i=Math.ceil(e*s/n)*n,a=Math.ceil(t*s/n)*n}return[i,a]}(r,n,this.config.patch_size*this.config.merge_size,e,s)}throw new Error(`Could not resize image due to unsupported \\`this.size\\` option in config: ${JSON.stringify(t)}`)}async resize(e){const[t,n]=this.get_resize_output_image_size(e,this.size);return await e.resize(t,n,{resample:this.resample})}async preprocess(e,{do_normalize:t=null,do_pad:n=null,do_convert_rgb:r=null,do_convert_grayscale:s=null,do_flip_channel_order:i=null}={}){this.do_crop_margin&&(e=await this.crop_margin(e));const[a,o]=e.size;if(r??this.do_convert_rgb?e=e.rgb():s&&(e=e.grayscale()),this.do_resize&&(e=await this.resize(e)),this.do_thumbnail&&(e=await this.thumbnail(e,this.size,this.resample)),this.do_center_crop){let t,n;Number.isInteger(this.crop_size)?(t=this.crop_size,n=this.crop_size):(t=this.crop_size.width,n=this.crop_size.height),e=await e.center_crop(t,n)}const l=[e.height,e.width];let u=Float32Array.from(e.data),d=[e.height,e.width,e.channels];if(this.do_rescale&&this.rescale(u),t??this.do_normalize){let t=this.image_mean;Array.isArray(this.image_mean)||(t=new Array(e.channels).fill(t));let n=this.image_std;if(Array.isArray(this.image_std)||(n=new Array(e.channels).fill(t)),t.length!==e.channels||n.length!==e.channels)throw new Error(`When set to arrays, the length of \\`image_mean\\` (${t.length}) and \\`image_std\\` (${n.length}) must match the number of channels in the image (${e.channels}).`);for(let r=0;r<u.length;r+=e.channels)for(let s=0;s<e.channels;++s)u[r+s]=(u[r+s]-t[s])/n[s]}if(n??this.do_pad)if(this.pad_size){const t=this.pad_image(u,[e.height,e.width,e.channels],this.pad_size);[u,d]=t}else if(this.size_divisibility){const[e,t]=RS([d[1],d[0]],this.size_divisibility);[u,d]=this.pad_image(u,d,{width:e,height:t})}if(i??this.do_flip_channel_order){if(3!==d[2])throw new Error("Flipping channel order is only supported for RGB images.");for(let e=0;e<u.length;e+=3){const t=u[e];u[e]=u[e+2],u[e+2]=t}}return{original_size:[o,a],reshaped_input_size:l,pixel_values:new Xp("float32",u,d).permute(2,0,1)}}async _call(e,...t){Array.isArray(e)||(e=[e]);const n=await Promise.all(e.map((e=>this.preprocess(e))));return{pixel_values:ih(n.map((e=>e.pixel_values)),0),original_sizes:n.map((e=>e.original_size)),reshaped_input_sizes:n.map((e=>e.reshaped_input_size))}}static async from_pretrained(e,t){return new this(await ce(e,R_,!0,t))}}class GS extends jS{}class HS extends jS{}class KS extends jS{}class XS extends jS{}class QS extends XS{}class YS extends jS{constructor(e){super(e),this.crop_pct=this.config.crop_pct??.875}async resize(e){const t=this.size?.shortest_edge;if(void 0===t)throw new Error("Size dictionary must contain \'shortest_edge\' key.");if(t<384){const n=Math.floor(t/this.crop_pct),[r,s]=this.get_resize_output_image_size(e,{shortest_edge:n});e=await e.resize(r,s,{resample:this.resample}),e=await e.center_crop(t,t)}else e=await e.resize(t,t,{resample:this.resample});return e}}class ZS extends YS{}class JS extends jS{}class ez extends JS{}class tz extends jS{async _call(e){const t=await super._call(e),n=uh([t.pixel_values.dims[0],64,64],1n);return{...t,pixel_mask:n}}post_process_object_detection(...e){return LS(...e)}post_process_panoptic_segmentation(...e){return VS(...e)}post_process_instance_segmentation(...e){return WS(...e)}}class nz extends tz{}class rz extends jS{pad_image(e,t,n,r={}){const[s,i,a]=t;let o=this.image_mean;Array.isArray(this.image_mean)||(o=new Array(a).fill(o));let l=this.image_std;Array.isArray(l)||(l=new Array(a).fill(o));const u=o.map(((e,t)=>-e/l[t]));return super.pad_image(e,t,n,{center:!0,constant_values:u,...r})}}class sz extends rz{}class iz extends jS{}class az extends iz{}class oz extends jS{constructor(e){super(e),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map((e=>e*e)))}}class lz extends jS{}class uz extends jS{constructor(e){super(e),this.do_image_splitting=e.do_image_splitting??!0,this.max_image_size=e.max_image_size}get_resize_for_vision_encoder(e,t){let[n,r]=e.dims.slice(-2);const s=r/n;return r>=n?(r=Math.ceil(r/t)*t,n=Math.floor(r/s),n=Math.ceil(n/t)*t):(n=Math.ceil(n/t)*t,r=Math.floor(n*s),r=Math.ceil(r/t)*t),{height:n,width:r}}async _call(e,{do_image_splitting:t=null,return_row_col_info:n=!1}={}){let r;if(Array.isArray(e)){if(0===e.length||!e[0])throw new Error("No images provided.");r=Array.isArray(e[0])?e:[e]}else r=[[e]];let s=[],i=[],a=[];const o=[],l=[];for(const e of r){let n=await Promise.all(e.map((e=>this.preprocess(e))));o.push(...n.map((e=>e.original_size))),l.push(...n.map((e=>e.reshaped_input_size))),n.forEach((e=>e.pixel_values.unsqueeze_(0)));const{longest_edge:r}=this.max_image_size;let u;if(t??this.do_image_splitting){let e=new Array(n.length),t=new Array(n.length);u=await Promise.all(n.map((async(n,s)=>{const i=this.get_resize_for_vision_encoder(n.pixel_values,r),a=await Yp(n.pixel_values,{size:[i.height,i.width]}),{frames:o,num_splits_h:l,num_splits_w:u}=await this.split_image(a,this.max_image_size);return e[s]=l,t[s]=u,sh(o,0)}))),i.push(e),a.push(t)}else{const e=[r,r];u=await Promise.all(n.map((t=>Yp(t.pixel_values,{size:e})))),i.push(new Array(n.length).fill(0)),a.push(new Array(n.length).fill(0))}s.push(sh(u,0))}const u=s.length,[d,c,p,h]=s[0].dims;let f,m;if(1===u)f=s[0].unsqueeze_(0),m=uh([u,d,p,h],!0);else{const e=Math.max(...s.map((e=>e.dims.at(0))));m=uh([u,e,p,h],!0);const t=m.data,n=e*p*h;for(let r=0;r<u;++r){const i=s[r].dims[0];if(i<e){s[r]=sh([s[r],uh([e-i,c,p,h],0)],0);const a=r*n+i*p*h,o=(r+1)*n;t.fill(!1,a,o)}}f=ih(s,0)}return{pixel_values:f,pixel_attention_mask:m,original_sizes:o,reshaped_input_sizes:l,...n?{rows:i,cols:a}:{}}}async split_image(e,{longest_edge:t}){const n=t,r=t,s=[],[i,a]=e.dims.slice(-2);let o=0,l=0;if(i>n||a>r){o=Math.ceil(i/n),l=Math.ceil(a/r);const t=Math.ceil(i/o),u=Math.ceil(a/l);for(let n=0;n<o;++n)for(let r=0;r<l;++r){let d,c,p,h;n===o-1?(c=i-t,h=i):(c=n*t,h=(n+1)*t),r===l-1?(d=a-u,p=a):(d=r*u,p=(r+1)*u);const f=[c,d],m=[h,p],_=await eh(e,f,m,[2,3]);s.push(_)}const d=n,c=r;i===d&&a===c||(e=await Yp(e,{size:[d,c]}))}return s.push(e),{frames:s,num_splits_h:o,num_splits_w:l}}}class dz extends jS{constructor(e){super({do_pad:!0,pad_size:{width:e.image_size,height:e.image_size},...e}),this.constant_values=this.config.background_color.map((e=>e*this.rescale_factor))}pad_image(e,t,n,r){return super.pad_image(e,t,n,{constant_values:this.constant_values,center:!0,...r})}}class cz extends jS{constructor(e){const{resize_mode:t,fill_color:n,interpolation:r,size:s,...i}=e;super({...i,size:"squash"===t?{width:s,height:s}:"shortest"===t?{shortest_edge:s}:{longest_edge:s},resample:"bicubic"===r?3:2,do_center_crop:!0,crop_size:s,do_normalize:!0})}}class pz extends jS{}class hz extends jS{post_process_panoptic_segmentation(...e){return VS(...e)}post_process_instance_segmentation(...e){return WS(...e)}}class fz extends hz{}class mz extends hz{}class _z extends jS{}class gz extends _z{}class wz extends jS{}class yz extends wz{}class bz extends jS{}class xz extends bz{}class vz extends jS{}class $z extends vz{}class kz extends jS{}class Ez extends kz{}class Sz extends rz{}class zz extends jS{post_process_object_detection(...e){return LS(...e)}}class Cz extends zz{}class Tz extends zz{}const Az=336,Iz=[2,3],{ceil:Mz,floor:Oz,sqrt:Bz}=Math;class Nz extends jS{constructor(e){super({...e,do_normalize:!0,do_pad:!0,pad_size:"custom",do_convert_rgb:!0,do_resize:!0}),this._num_crops=e.num_crops}calc_num_image_tokens_from_image_size(e,t){const{num_img_tokens:n}=this.config;return Oz((Oz(t/Az)*Oz(e/Az)+1)*n+1+(Oz(t/Az)+1)*Bz(n))}get_resize_output_image_size(e,t){const n=this._num_crops,[r,s]=e.size;let i=r/s,a=1;for(;a*Math.ceil(a/i)<=n;)a+=1;a-=1;const o=Math.floor(336*a);return[o,Math.floor(o/i)]}pad_image(e,t,n,r={}){const[s,i]=t,a=Az*Mz(s/Az),o=Az*Mz(i/Az),l=[1,1,1].map(((e,t)=>(e-this.image_mean[t])/this.image_std[t]));return super.pad_image(e,t,{width:o,height:a},{center:!0,constant_values:l,...r})}async _call(e,{num_crops:t=null}={}){if(this._num_crops=t??=this.config.num_crops,t<4||Bz(t)%1!=0)throw new Error("num_crops must be a square number >= 4");Array.isArray(e)||(e=[e]);const n=e.length,r=await Promise.all(e.map((e=>this.preprocess(e)))),s=r.map((e=>e.original_size)),i=r.map((e=>e.reshaped_input_size)),a=[];for(const{pixel_values:e}of r){e.unsqueeze_(0);const[n,r]=e.dims.slice(-2),s=await Yp(e,{size:[Az,Az],mode:"bicubic"});if(t>0){const i=[],o=Bz(t),l=Oz(r/o),u=Oz(n/o);for(let t=0;t<o;++t)for(let s=0;s<o;++s){let a,d,c,p;t===o-1?(d=n-u,p=n):(d=t*u,p=(t+1)*u),s===o-1?(a=r-l,c=r):(a=s*l,c=(s+1)*l);const h=[d,a],f=[p,c],m=await eh(e,h,f,Iz);i.push(m)}const d=await Yp(sh(i,0),{size:[Az,Az],mode:"bicubic"});a.push(sh([s,d],0))}else a.push(s)}const o=ih(a,0),l=i.map((e=>e.map((e=>Az*Mz(e/Az)))));return{pixel_values:o,original_sizes:s,reshaped_input_sizes:i,image_sizes:new Xp("int64",l.flat(),[n,2]),num_img_tokens:l.map((([e,t])=>this.calc_num_image_tokens_from_image_size(t,e)))}}}class Pz extends jS{}class Rz extends jS{async _call(e,...t){const{pixel_values:n,original_sizes:r,reshaped_input_sizes:s}=await super._call(e,...t);let i=n;const{temporal_patch_size:a,merge_size:o,patch_size:l}=this.config;1===i.dims[0]&&(i=sh(Array.from({length:a},(()=>i)),0));const u=i.dims[0]/a,d=i.dims[1],c=Math.floor(i.dims[2]/l),p=Math.floor(i.dims[3]/l);return{pixel_values:i.view(u,a,d,Math.floor(c/o),o,l,Math.floor(p/o),o,l).permute(0,3,6,4,7,2,1,5,8).view(u*c*p,d*a*l*l),image_grid_thw:new Xp("int64",[u,c,p],[1,3]),original_sizes:r,reshaped_input_sizes:s}}}class Dz extends jS{post_process_object_detection(...e){return LS(...e)}}class Lz extends jS{reshape_input_points(e,t,n,r=!1){let s=X(e=structuredClone(e));if(3===s.length)r||(s=[1,...s]),e=[e];else if(4!==s.length)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let r=0;r<e.length;++r){let s=t[r],i=n[r],a=[i[0]/s[0],i[1]/s[1]];for(let t=0;t<e[r].length;++t)for(let n=0;n<e[r][t].length;++n)for(let s=0;s<e[r][t][n].length;++s)e[r][t][n][s]*=a[s%2]}return new Xp("float32",Float32Array.from(e.flat(Infinity)),s)}add_input_labels(e,t){let n=X(e);if(2===n.length)n=[1,...n],e=[e];else if(3!==n.length)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(n.some(((e,n)=>e!==t.dims[n])))throw Error(`The first ${n.length} dimensions of \'input_points\' and \'input_labels\' must be the same.`);return new Xp("int64",e.flat(Infinity).map(BigInt),n)}async _call(e,{input_points:t=null,input_labels:n=null,input_boxes:r=null}={}){const s=await super._call(e);if(t&&(s.input_points=this.reshape_input_points(t,s.original_sizes,s.reshaped_input_sizes)),n){if(!s.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");s.input_labels=this.add_input_labels(n,s.input_points)}return r&&(s.input_boxes=this.reshape_input_points(r,s.original_sizes,s.reshaped_input_sizes,!0)),s}async post_process_masks(e,t,n,{mask_threshold:r=0,binarize:s=!0,pad_size:i=null}={}){const a=[],o=[(i=i??this.pad_size).height,i.width];for(let i=0;i<t.length;++i){const l=t[i],u=n[i];let d=await Yp(e[i],{mode:"bilinear",size:o});if(d=d.slice(null,null,[0,u[0]],[0,u[1]]),d=await Yp(d,{mode:"bilinear",size:l}),s){const e=d.data,t=new Uint8Array(e.length);for(let n=0;n<e.length;++n)e[n]>r&&(t[n]=1);d=new Xp("bool",t,d.dims)}a.push(d)}return a}generate_crop_boxes(e,t,{crop_n_layers:n=0,overlap_ratio:r=512/1500,points_per_crop:s=32,crop_n_points_downscale_factor:i=1}={}){}}class Fz extends jS{post_process_semantic_segmentation(...e){return function t(e,n=null){const r=e.logits,s=r.dims[0];if(null!==n&&n.length!==s)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const i=[];for(let e=0;e<s;++e){const t=null!==n?n[e]:null;let s=r[e];null!==t&&(s=Qp(s,t,"bilinear",!1));const[a,o]=t??s.dims.slice(-2),l=new Xp("int32",new Int32Array(a*o),[a,o]),u=s[0].data,d=l.data;for(let e=1;e<s.dims[0];++e){const t=s[e].data;for(let n=0;n<t.length;++n)t[n]>u[n]&&(u[n]=t[n],d[n]=e)}const c=new Array(s.dims[0]);for(let e=0;e<d.length;++e){const t=d[e];c[t]=t}const p=c.filter((e=>void 0!==e));i.push({segmentation:l,labels:p})}return i}(...e)}}class Uz extends Fz{}class qz extends jS{}class Vz extends jS{pad_image(e,t,n,r={}){const[s,i,a]=t;return super.pad_image(e,t,{width:i+(n-i%n)%n,height:s+(n-s%n)%n},{mode:"symmetric",center:!1,constant_values:-1,...r})}}class Wz extends jS{}class jz extends Wz{}class Gz extends jS{async _call(e,t){Array.isArray(e)||(e=[e]),Array.isArray(t)||(t=[t]);const n=await Promise.all(e.map((e=>this.preprocess(e)))),r=await Promise.all(t.map((e=>this.preprocess(e,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0}))));return{pixel_values:ih(n.map(((e,t)=>sh([e.pixel_values,r[t].pixel_values],0))),0),original_sizes:n.map((e=>e.original_size)),reshaped_input_sizes:n.map((e=>e.reshaped_input_size))}}}class Hz extends jS{post_process_pose_estimation(e,t,{threshold:n=null}={}){const r=e.tolist(),[s,i,a,o]=e.dims,l=[];for(let e=0;e<s;++e){const s=r[e],i=t[e],u=[];for(let e=0;e<i.length;++e){const t=i[e],r=[],l=[],d=[],c=t.at(-2)/o,p=t.at(-1)/a;for(let e=0;e<s.length;++e){let[t,i]=[0,0],a=0,o=-Infinity;const u=s[e];for(let e=0;e<u.length;++e){const n=u[e];for(let r=0;r<n.length;++r){const s=n[r];a+=s,o=Math.max(o,s),t+=(r+.5)*s,i+=e*s}}if(null!=n&&o<n)continue;const h=[c*t/a,p*i/a];r.push(h),d.push(e),l.push(o)}u.push({bbox:t,scores:l,labels:d,keypoints:r})}l.push(u)}return l}}class Kz extends jS{post_process_object_detection(...e){return LS(...e)}}class Xz extends Kz{}class Qz{static async from_pretrained(e,n={}){const r=await ce(e,R_,!0,n),s=r.image_processor_type??r.feature_extractor_type;let i=t[s];return i||(void 0!==s&&console.warn(`Image processor type \'${s}\' not found, assuming base ImageProcessor. Please report this at ${N_}.`),i=jS),new i(r)}}class Yz extends NS{static tokenizer_class=E_;static image_processor_class=Qz;constructor(e,t){super(e,t);const{tasks_answer_post_processing_type:n,task_prompts_without_inputs:r,task_prompts_with_input:s}=this.image_processor.config;this.tasks_answer_post_processing_type=new Map(Object.entries(n??{})),this.task_prompts_without_inputs=new Map(Object.entries(r??{})),this.task_prompts_with_input=new Map(Object.entries(s??{})),this.regexes={quad_boxes:/(.+?)<loc_(\\d+)><loc_(\\d+)><loc_(\\d+)><loc_(\\d+)><loc_(\\d+)><loc_(\\d+)><loc_(\\d+)><loc_(\\d+)>/gm,bboxes:/([^<]+)?<loc_(\\d+)><loc_(\\d+)><loc_(\\d+)><loc_(\\d+)>/gm},this.size_per_bin=1e3}construct_prompts(e){"string"==typeof e&&(e=[e]);const t=[];for(const n of e)if(this.task_prompts_without_inputs.has(n))t.push(this.task_prompts_without_inputs.get(n));else{for(const[e,r]of this.task_prompts_with_input)if(n.includes(e)){t.push(r.replaceAll("{input}",n).replaceAll(e,""));break}t.length!==e.length&&t.push(n)}return t}post_process_generation(e,t,n){const r=this.tasks_answer_post_processing_type.get(t)??"pure_text";let s;switch(e=e.replaceAll("<s>","").replaceAll("</s>",""),r){case"pure_text":s=e;break;case"description_with_bboxes":case"bboxes":case"phrase_grounding":case"ocr":const i="ocr"===r?"quad_boxes":"bboxes",a=e.matchAll(this.regexes[i]),o=[],l=[];for(const[e,t,...r]of a)o.push(t?t.trim():o.at(-1)??""),l.push(r.map(((e,t)=>(Number(e)+.5)/this.size_per_bin*n[t%2])));s={labels:o,[i]:l};break;default:throw new Error(`Task "${t}" (of type "${r}") not yet implemented.`)}return{[t]:s}}async _call(e,t=null,n={}){if(!e&&!t)throw new Error("Either text or images must be provided");return{...await this.image_processor(e,n),...t?this.tokenizer(t,n):{}}}}const Zz={char:["char_decode",1],bpe:["bpe_decode",2],wp:["wp_decode",102]};class Jz extends NS{static tokenizer_class=E_;static image_processor_class=Qz;get char_tokenizer(){return this.components.char_tokenizer}get bpe_tokenizer(){return this.components.bpe_tokenizer}get wp_tokenizer(){return this.components.wp_tokenizer}_decode_helper(e,t){if(!Zz.hasOwnProperty(t))throw new Error(`Format ${t} is not supported.`);const[n,r]=Zz[t],s=this[n].bind(this),[i,a]=e.dims,o=[],l=[],u=e.tolist();for(let e=0;e<i;++e){const t=u[e],n=[],s=[];for(let e=1;e<a;++e){const[i,a]=_e(he(t[e]));if(s.push(i),a==r)break;n.push(a)}const i=s.length>0?s.reduce(((e,t)=>e*t),1):0;l.push(n),o.push(i)}return[s(l),o]}char_decode(e){return this.char_tokenizer.batch_decode(e).map((e=>e.replaceAll(" ","")))}bpe_decode(e){return this.bpe_tokenizer.batch_decode(e)}wp_decode(e){return this.wp_tokenizer.batch_decode(e).map((e=>e.replaceAll(" ","")))}batch_decode([e,t,n]){const[r,s]=this._decode_helper(e,"char"),[i,a]=this._decode_helper(t,"bpe"),[o,l]=this._decode_helper(n,"wp"),u=[],d=[];for(let e=0;e<r.length;++e){const[t,n]=_e([s[e],a[e],l[e]]);u.push([r[e],i[e],o[e]][n]),d.push(t)}return{generated_text:u,scores:d,char_preds:r,bpe_preds:i,wp_preds:o}}static async from_pretrained(...e){const t=await super.from_pretrained(...e),n=await E_.from_pretrained("Xenova/gpt2"),r=await E_.from_pretrained("Xenova/bert-base-uncased");return t.components={image_processor:t.image_processor,char_tokenizer:t.tokenizer,bpe_tokenizer:n,wp_tokenizer:r},t}async _call(e,t=null){const n=await this.image_processor(e);return t&&(n.labels=this.tokenizer(t).input_ids),n}}class eC extends j{constructor(e){super(),this.config=e}static async from_pretrained(e,t){return new this(await ce(e,P_,!0,t))}}function tC(e,t){if(!(e instanceof Float32Array||e instanceof Float64Array))throw new Error(`${t} expects input to be a Float32Array or a Float64Array, but got ${e?.constructor?.name??typeof e} instead. If using the feature extractor directly, remember to use \\`read_audio(url, sampling_rate)\\` to obtain the raw audio data of the file/url.`)}function nC(e,t){if(e<1)return new Float64Array;if(1===e)return new Float64Array([1]);const n=1-t,r=2*Math.PI/(e-1),s=new Float64Array(e);for(let i=0;i<e;++i)s[i]=t-n*Math.cos(i*r);return s}function rC(e){return nC(e,.5)}const sC={htk:e=>2595*Math.log10(1+e/700),kaldi:e=>1127*Math.log(1+e/700),slaney:(e,t=1e3,n=15,r=27/Math.log(6.4))=>e>=t?n+Math.log(e/t)*r:3*e/200};function iC(e,t="htk"){const n=sC[t];if(!n)throw new Error(\'mel_scale should be one of "htk", "slaney" or "kaldi".\');return"number"==typeof e?n(e):e.map((e=>n(e)))}const aC={htk:e=>700*(10**(e/2595)-1),kaldi:e=>700*(Math.exp(e/1127)-1),slaney:(e,t=1e3,n=15,r=Math.log(6.4)/27)=>e>=n?t*Math.exp(r*(e-n)):200*e/3};function oC(e,t,n){const r=(t-e)/(n-1);return Float64Array.from({length:n},((t,n)=>e+r*n))}function lC(e,t,n,r,s,i=null,a="htk",o=!1){if(null!==i&&"slaney"!==i)throw new Error(\'norm must be one of null or "slaney"\');const l=oC(iC(n,a),iC(r,a),t+2);let u,d=function c(e,t="htk"){const n=aC[t];if(!n)throw new Error(\'mel_scale should be one of "htk", "slaney" or "kaldi".\');return"number"==typeof e?n(e):e.map((e=>n(e)))}(l,a);if(o){const t=s/(2*e);u=iC(Float64Array.from({length:e},((e,n)=>n*t)),a),d=l}else u=oC(0,Math.floor(s/2),e);const p=function h(e,t){const n=Float64Array.from({length:t.length-1},((e,n)=>t[n+1]-t[n])),r=Array.from({length:e.length},(()=>new Array(t.length)));for(let n=0;n<e.length;++n){const s=r[n];for(let r=0;r<t.length;++r)s[r]=t[r]-e[n]}const s=t.length-2,i=Array.from({length:s},(()=>new Array(e.length)));for(let t=0;t<e.length;++t){const e=r[t];for(let r=0;r<s;++r){const s=-e[r]/n[r],a=e[r+2]/n[r+1];i[r][t]=Math.max(0,Math.min(s,a))}}return i}(u,d);if(null!==i&&"slaney"===i)for(let n=0;n<t;++n){const t=p[n],r=2/(d[n+2]-d[n]);for(let n=0;n<e;++n)t[n]*=r}return p}function uC(e,t,n,r,s){if(n<=0)throw new Error("reference must be greater than zero");if(r<=0)throw new Error("min_value must be greater than zero");n=Math.max(r,n);const i=Math.log10(n);for(let n=0;n<e.length;++n)e[n]=t*Math.log10(Math.max(r,e[n])-i);if(null!==s){if(s<=0)throw new Error("db_range must be greater than zero");const t=_e(e)[0]-s;for(let n=0;n<e.length;++n)e[n]=Math.max(e[n],t)}return e}async function dC(e,t,n,r,{fft_length:s=null,power:i=1,center:a=!0,pad_mode:o="reflect",onesided:l=!0,preemphasis:u=null,mel_filters:d=null,mel_floor:c=1e-10,log_mel:p=null,reference:h=1,min_value:f=1e-10,db_range:m=null,remove_dc_offset:_=null,min_num_frames:g=null,max_num_frames:w=null,do_pad:y=!0,transpose:b=!1}={}){const x=t.length;if(null===s&&(s=n),n>s)throw Error(`frame_length (${n}) may not be larger than fft_length (${s})`);if(x!==n)throw new Error(`Length of the window (${x}) must equal frame_length (${n})`);if(r<=0)throw new Error("hop_length must be greater than zero");if(null===i&&null!==d)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(a){if("reflect"!==o)throw new Error(`pad_mode="${o}" not implemented yet.`);const t=Math.floor((s-1)/2)+1;e=function n(e,t,r){const s=new e.constructor(e.length+t+r),i=e.length-1;for(let n=0;n<e.length;++n)s[t+n]=e[n];for(let n=1;n<=t;++n)s[t-n]=e[Z(n,i)];for(let n=1;n<=r;++n)s[i+t+n]=e[Z(i-n,i)];return s}(e,t,t)}let v=Math.floor(1+Math.floor((e.length-n)/r));null!==g&&v<g&&(v=g);const $=l?Math.floor(s/2)+1:s;let k=v,E=v;null!==w&&(w>v?y&&(E=w):E=k=w);const S=new be(s),z=new Float64Array(s),C=new Float64Array(S.outputBufferSize),T=new Float32Array($*E);for(let s=0;s<k;++s){const i=s*r,a=Math.min(e.length-i,n);a!==n&&z.fill(0,0,n);for(let t=0;t<a;++t)z[t]=e[i+t];if(_){let e=0;for(let t=0;t<a;++t)e+=z[t];const t=e/a;for(let e=0;e<a;++e)z[e]-=t}if(null!==u){for(let e=a-1;e>=1;--e)z[e]-=u*z[e-1];z[0]*=1-u}for(let e=0;e<t.length;++e)z[e]*=t[e];S.realTransform(C,z);for(let e=0;e<$;++e){const t=e<<1;T[e*E+s]=C[t]**2+C[t+1]**2}}if(null!==i&&2!==i){const e=2/i;for(let t=0;t<T.length;++t)T[t]**=e}const A=d.length;let I=await async function M(e,t){const n=await Hp.matmul;return await n({a:e,b:t})}(new Xp("float32",d.flat(),[A,$]),new Xp("float32",T,[$,E]));b&&(I=I.transpose(1,0));const O=I.data;for(let e=0;e<O.length;++e)O[e]=Math.max(c,O[e]);if(null!==i&&null!==p){const e=Math.min(O.length,k*A);switch(p){case"log":for(let t=0;t<e;++t)O[t]=Math.log(O[t]);break;case"log10":for(let t=0;t<e;++t)O[t]=Math.log10(O[t]);break;case"dB":if(1===i)!function t(e,n=1,r=1e-5,s=null){return uC(e,20,n,r,s)}(O,h,f,m);else{if(2!==i)throw new Error(`Cannot use log_mel option \'${p}\' with power ${i}`);!function e(t,n=1,r=1e-10,s=null){return uC(t,10,n,r,s)}(O,h,f,m)}break;default:throw new Error(`log_mel must be one of null, \'log\', \'log10\' or \'dB\'. Got \'${p}\'`)}}return I}function cC(e,t,{periodic:n=!0,frame_length:r=null,center:s=!0}={}){const i=n?e+1:e;let a;switch(t){case"boxcar":a=new Float64Array(i).fill(1);break;case"hann":case"hann_window":a=rC(i);break;case"hamming":a=function e(t){return nC(t,.54)}(i);break;case"povey":a=rC(i).map((e=>Math.pow(e,.85)));break;default:throw new Error(`Unknown window type ${t}.`)}if(n&&(a=a.subarray(0,e)),null===r)return a;if(e>r)throw new Error(`Length of the window (${e}) may not be larger than frame_length (${r})`);return a}class pC extends eC{constructor(e){super(e);const t=this.config.sampling_rate,n=lC(256,this.config.num_mel_bins,20,Math.floor(t/2),t,null,"kaldi",!0);for(let e=0;e<n.length;++e)n[e].push(0);this.mel_filters=n,this.window=cC(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}async _extract_fbank_features(e,t){return dC(e,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1.192092955078125e-7,remove_dc_offset:!0,max_num_frames:t,transpose:!0})}async _call(e){tC(e,"ASTFeatureExtractor");const t=await this._extract_fbank_features(e,this.config.max_length);if(this.config.do_normalize){const e=2*this.std,n=t.data;for(let t=0;t<n.length;++t)n[t]=(n[t]-this.mean)/e}return{input_values:t.unsqueeze_(0)}}}class hC extends eC{constructor(e){super(e),this.mel_filters=lC(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=lC(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=cC(this.config.fft_window_size,"hann")}async _get_input_mel(e,t,n,r){let s,i=!1;const a=e.length-t;if(a>0){if("rand_trunc"!==n)throw new Error(`Truncation strategy "${n}" not implemented`);{i=!0;const n=Math.floor(Math.random()*(a+1));e=e.subarray(n,n+t),s=await this._extract_fbank_features(e,this.mel_filters_slaney,this.config.nb_max_samples)}}else{if(a<0){let n=new Float64Array(t);if(n.set(e),"repeat"===r)for(let r=e.length;r<t;r+=e.length)n.set(e.subarray(0,Math.min(e.length,t-r)),r);else if("repeatpad"===r)for(let t=e.length;t<-a;t+=e.length)n.set(e,t);e=n}if("fusion"===n)throw new Error(`Truncation strategy "${n}" not implemented`);s=await this._extract_fbank_features(e,this.mel_filters_slaney,this.config.nb_max_samples)}return s.unsqueeze_(0)}async _extract_fbank_features(e,t,n=null){return dC(e,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:t,log_mel:"dB",max_num_frames:n,do_pad:!1,transpose:!0})}async _call(e,{max_length:t=null}={}){tC(e,"ClapFeatureExtractor");return{input_features:(await this._get_input_mel(e,t??this.config.nb_max_samples,this.config.truncation,this.config.padding)).unsqueeze_(0)}}}class fC extends eC{async _call(e){tC(e,"MoonshineFeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));const t=[1,e.length];return{input_values:new Xp("float32",e,t)}}}class mC extends eC{async _call(e){tC(e,"PyAnnoteFeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));const t=[1,1,e.length];return{input_values:new Xp("float32",e,t)}}samples_to_frames(e){return(e-this.config.offset)/this.config.step}post_process_speaker_diarization(e,t){const n=t/this.samples_to_frames(t)/this.config.sampling_rate,r=[];for(const t of e.tolist()){const e=[];let s=-1;for(let n=0;n<t.length;++n){const r=he(t[n]),[i,a]=_e(r),[o,l]=[n,n+1];a!==s?(s=a,e.push({id:a,start:o,end:l,score:i})):(e.at(-1).end=l,e.at(-1).score+=i)}r.push(e.map((({id:e,start:t,end:r,score:s})=>({id:e,start:t*n,end:r*n,confidence:s/(r-t)}))))}return r}}class _C extends eC{constructor(e){super(e);const t=this.config.sampling_rate,n=lC(256,this.config.num_mel_bins,20,Math.floor(t/2),t,null,"kaldi",!0);for(let e=0;e<n.length;++e)n[e].push(0);this.mel_filters=n,this.window=cC(400,"povey",{periodic:!1})}async _extract_fbank_features(e,t){return dC(e=e.map((e=>32768*e)),this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1.192092955078125e-7,remove_dc_offset:!0,max_num_frames:t,transpose:!0})}async _call(e,{padding:t=!0,pad_to_multiple_of:n=2,do_normalize_per_mel_bins:r=!0,return_attention_mask:s=!0}={}){tC(e,"SeamlessM4TFeatureExtractor");let i,a=await this._extract_fbank_features(e,this.config.max_length);if(r){const[e,t]=a.dims,n=a.data;for(let r=0;r<t;++r){let s=0;for(let i=0;i<e;++i)s+=n[i*t+r];const i=s/e;let a=0;for(let s=0;s<e;++s)a+=(n[s*t+r]-i)**2;a/=e-1;const o=Math.sqrt(a+1e-7);for(let s=0;s<e;++s){const e=s*t+r;n[e]=(n[e]-i)/o}}}if(t){const[e,t]=a.dims,r=a.data,o=e%n;if(o>0){const n=new Float32Array(t*(e+o));n.set(r),n.fill(this.config.padding_value,r.length);const l=e+o;a=new Xp(a.type,n,[l,t]),s&&(i=new Xp("int64",new BigInt64Array(l),[1,l]),i.data.fill(1n,0,e))}}const[o,l]=a.dims,u=this.config.stride;if(0!==o%u)throw new Error(`The number of frames (${o}) must be a multiple of the stride (${u}).`);const d=a.view(1,Math.floor(o/u),l*u),c={input_features:d};if(s){const e=d.dims[1],t=new BigInt64Array(e);if(i){const e=i.data;for(let n=1,r=0;n<o;n+=u,++r)t[r]=e[n]}else t.fill(1n);c.attention_mask=new Xp("int64",t,[1,e])}return c}}class gC extends eC{}class wC extends eC{_zero_mean_unit_var_norm(e){const t=e.reduce(((e,t)=>e+t),0)/e.length,n=e.reduce(((e,n)=>e+(n-t)**2),0)/e.length;return e.map((e=>(e-t)/Math.sqrt(n+1e-7)))}async _call(e){tC(e,"Wav2Vec2FeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));let t=e;this.config.do_normalize&&(t=this._zero_mean_unit_var_norm(t));const n=[1,t.length];return{input_values:new Xp("float32",t,n),attention_mask:new Xp("int64",new BigInt64Array(t.length).fill(1n),n)}}}class yC extends eC{constructor(e){super(e);const t=this.config.sampling_rate,n=lC(256,this.config.num_mel_bins,20,Math.floor(t/2),t,null,"kaldi",!0);for(let e=0;e<n.length;++e)n[e].push(0);this.mel_filters=n,this.window=cC(400,"hamming",{periodic:!1}),this.min_num_frames=this.config.min_num_frames}async _extract_fbank_features(e){return dC(e=e.map((e=>32768*e)),this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1.192092955078125e-7,remove_dc_offset:!0,transpose:!0,min_num_frames:this.min_num_frames})}async _call(e){tC(e,"WeSpeakerFeatureExtractor");const t=(await this._extract_fbank_features(e)).unsqueeze_(0);if(null===this.config.fbank_centering_span){const e=t.mean(1).data,n=t.data,[r,s,i]=t.dims;for(let t=0;t<r;++t){const r=t*s*i,a=t*i;for(let t=0;t<s;++t){const s=r+t*i;for(let t=0;t<i;++t)n[s+t]-=e[a+t]}}}return{input_features:t}}}class bC extends eC{constructor(e){super(e),this.config.mel_filters??=lC(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney"),this.window=cC(this.config.n_fft,"hann")}async _extract_fbank_features(e){const t=await dC(e,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:this.config.nb_max_frames}),n=t.data,r=_e(n)[0];for(let e=0;e<n.length;++e)n[e]=(Math.max(n[e],r-8)+4)/4;return t}async _call(e){let t;tC(e,"WhisperFeatureExtractor"),e.length>this.config.n_samples?(console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),t=e.slice(0,this.config.n_samples)):(t=new Float32Array(this.config.n_samples),t.set(e));return{input_features:(await this._extract_fbank_features(t)).unsqueeze_(0)}}}class xC{static async from_pretrained(e,t={}){const r=await ce(e,P_,!0,t),s=r.feature_extractor_type,i=n[s];if(!i)throw new Error(`Unknown feature_extractor_type: \'${s}\'. Please report this at ${N_}.`);return new i(r)}}class vC extends NS{static tokenizer_class=E_;static feature_extractor_class=xC;async _call(e){return await this.feature_extractor(e)}}function $C(e,t,n,r,s,i){return 0===e&&0===t?function a(e,t,n,r){return`${t}${r}`+n.repeat(e)+`${t}`}(n,r,s,i):function o(e,t,n,r,s,i){let a="";for(let i=0;i<t;++i){for(let t=0;t<n;++t)a+=r+`<row_${i+1}_col_${t+1}>`+s.repeat(e);a+="\\n"}return a+=`\\n${r}${i}`+s.repeat(e)+`${r}`,a}(n,e,t,r,s,i)}class kC extends NS{static image_processor_class=Qz;static tokenizer_class=E_;static uses_processor_config=!0;fake_image_token="<fake_token_around_image>";image_token="<image>";global_img_token="<global-img>";async _call(e,t=null,n={}){let r;n.return_row_col_info??=!0,t&&(r=await this.image_processor(t,n)),Array.isArray(e)||(e=[e]);const s=r.rows??[new Array(e.length).fill(0)],i=r.cols??[new Array(e.length).fill(0)],a=this.config.image_seq_len,o=[],l=[];for(let t=0;t<e.length;++t){const n=e[t],r=s[t],u=i[t];o.push(te(n,this.image_token));const d=r.map(((e,t)=>$C(e,u[t],a,this.fake_image_token,this.image_token,this.global_img_token))),c=n.split(this.image_token);if(0===c.length)throw new Error("The image token should be present in the text.");let p=c[0];for(let e=0;e<d.length;++e)p+=d[e]+c[e+1];l.push(p)}return{...this.tokenizer(l),...r}}}class EC extends NS{static image_processor_class=Qz;static tokenizer_class=E_;static uses_processor_config=!0;constructor(e,t){super(e,t),this.image_tag=this.config.image_tag,this.image_start_tag=this.config.image_start_tag,this.image_end_tag=this.config.image_end_tag,this.num_image_tokens=this.config.num_image_tokens}async _call(e,{images:t=null,chat_template:n="default"}={}){t?Array.isArray(t)||(t=[t]):t=await Promise.all(e.filter((e=>e.images)).flatMap((e=>e.images)).map((e=>lg.read(e))));const r=this.tokenizer,s=e=>r.encode(e,{add_special_tokens:!1}),i=r.apply_chat_template(e,{tokenize:!1,add_generation_prompt:!0,chat_template:n}).split(this.image_tag),a=i.length-1;if(t.length!==a)throw new Error(`Number of images provided (${t.length}) does not match number of "${this.image_tag}" image tags (${a})`);const[o,l,u]=r.model.convert_tokens_to_ids([this.image_tag,this.image_start_tag,this.image_end_tag]);let d=s(i[0]),c=new Array(d.length).fill(!1);for(let e=1;e<i.length;++e){const t=new Array(this.num_image_tokens).fill(o),n=s(i[e]);d=Q(d,[l],t,[u],n);c=Q(c,[!1],new Array(this.num_image_tokens).fill(!0),[!1],new Array(n.length).fill(!1))}const p=[1,d.length],h={input_ids:new Xp("int64",d,p),attention_mask:new Xp("int64",new Array(d.length).fill(1),p),images_seq_mask:new Xp("bool",c,p),images_emb_mask:new Xp("bool",new Array(a*this.num_image_tokens).fill(!0),[1,a,this.num_image_tokens])};if(t&&t.length>0){const e=await this.image_processor(t);return e.pixel_values.unsqueeze_(0),{...h,...e}}return h}}class SC extends NS{static tokenizer_class=E_;static image_processor_class=Qz;async _call(e=null,t=null,n={}){if(!e&&!t)throw new Error("Either text or images must be provided");return{...e?this.tokenizer(e,n):{},...t?await this.image_processor(t,n):{}}}}class zC extends NS{static tokenizer_class=E_;static image_processor_class=Qz}const CC="<|image|>",TC=/<\\|image_\\d+\\|>/g;class AC extends NS{static image_processor_class=Qz;static tokenizer_class=E_;async _call(e,t=null,{padding:n=!0,truncation:r=!0,num_crops:s=null}={}){let i,a;if(Array.isArray(e)||(e=[e]),t){a=await this.image_processor(t,{num_crops:s});const{num_img_tokens:o}=a,l=e.map(((e,t)=>e.split(TC).join(CC.repeat(o[t]))));i=this.tokenizer(l,{padding:n,truncation:r});const u=this.tokenizer.model.convert_tokens_to_ids([CC])[0];i.input_ids.map_((e=>e==u?-e:e))}else i=this.tokenizer(e);return{...i,...a}}}const IC="<image>";class MC extends NS{static tokenizer_class=E_;static image_processor_class=Qz;static uses_processor_config=!1;async _call(e,t=null,n={}){t||(console.warn("You are using PaliGemma without a text prefix. It will perform as a picture-captioning model."),t=""),Array.isArray(e)||(e=[e]),Array.isArray(t)||(t=[t]);const r=this.tokenizer.bos_token,s=this.image_processor.config.image_seq_length;let i;t.some((e=>e.includes(IC)))?i=t.map((e=>{const t=e.replaceAll(IC,IC.repeat(s)),n=t.lastIndexOf(IC),i=-1===n?0:n+7;return t.slice(0,i)+r+t.slice(i)+"\\n"})):(console.warn("You are passing both `text` and `images` to `PaliGemmaProcessor`. The processor expects special image tokens in the text, as many tokens as there are images per each text. It is recommended to add `<image>` tokens in the very beginning of your text. For this call, we will infer how many images each text has and add special tokens."),i=t.map((t=>function n(e,t,r,s,i){return`${s.repeat(r*i)}${t}${e}\\n`}(t,r,s,IC,e.length))));const a=this.tokenizer(i,n);return{...await this.image_processor(e,n),...a}}}class OC extends NS{static feature_extractor_class=mC;async _call(e){return await this.feature_extractor(e)}post_process_speaker_diarization(...e){return this.feature_extractor.post_process_speaker_diarization(...e)}get sampling_rate(){return this.feature_extractor.config.sampling_rate}}class BC extends NS{static image_processor_class=Qz;static tokenizer_class=E_;async _call(e,t=null,...n){let r,s;if(Array.isArray(e)||(e=[e]),t&&(r=await this.image_processor(t),s=r.image_grid_thw),s){let t=this.image_processor.config.merge_size**2,n=0;const r=s.tolist();e=e.map((e=>{for(;e.includes("<|image_pad|>");){const s=Number(r[n++].reduce(((e,t)=>e*t),1n));e=e.replace("<|image_pad|>","<|placeholder|>".repeat(Math.floor(s/t)))}return e.replaceAll("<|placeholder|>","<|image_pad|>")}))}return{...this.tokenizer(e),...r}}}class NC extends NS{static image_processor_class=Qz;async _call(...e){return await this.image_processor(...e)}post_process_masks(...e){return this.image_processor.post_process_masks(...e)}reshape_input_points(...e){return this.image_processor.reshape_input_points(...e)}}class PC extends NS{static tokenizer_class=E_;static feature_extractor_class=xC;async _call(e){return await this.feature_extractor(e)}}class RC extends NS{static feature_extractor_class=xC;async _call(e){return await this.feature_extractor(e)}}class DC extends NS{static tokenizer_class=E_;static feature_extractor_class=xC;async _call(e){return await this.feature_extractor(e)}}class LC{static async from_pretrained(e,s={}){const i=await ce(e,R_,!0,s),{image_processor_type:a,feature_extractor_type:o,processor_class:l}=i;if(l&&r[l])return r[l].from_pretrained(e,s);if(!a&&!o)throw new Error("No `image_processor_type` or `feature_extractor_type` found in the config.");const u={};if(a){const e=t[a];if(!e)throw new Error(`Unknown image_processor_type: \'${a}\'.`);u.image_processor=new e(i)}if(o){const e=t[o];if(e)u.image_processor=new e(i);else{const e=n[o];if(!e)throw new Error(`Unknown feature_extractor_type: \'${o}\'.`);u.feature_extractor=new e(i)}}return new NS({},u)}}async function FC(e){return Array.isArray(e)||(e=[e]),await Promise.all(e.map((e=>lg.read(e))))}async function UC(e,t){return Array.isArray(e)||(e=[e]),await Promise.all(e.map((e=>"string"==typeof e||e instanceof URL?async function n(e,t){if("undefined"==typeof AudioContext)throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const n=await(await oe(e)).arrayBuffer(),r=new AudioContext({sampleRate:t});"undefined"==typeof t&&console.warn(`No sampling rate provided, using default of ${r.sampleRate}Hz.`);const s=await r.decodeAudioData(n);let i;if(2===s.numberOfChannels){const e=Math.sqrt(2),t=s.getChannelData(0),n=s.getChannelData(1);i=new Float32Array(t.length);for(let r=0;r<s.length;++r)i[r]=e*(t[r]+n[r])/2}else i=s.getChannelData(0);return i}(e,t):e instanceof Float64Array?new Float32Array(e):e)))}function qC(e,t){t&&(e=e.map((e=>0|e)));const[n,r,s,i]=e;return{xmin:n,ymin:r,xmax:s,ymax:i}}class VC extends j{constructor({task:e,model:t,tokenizer:n=null,processor:r=null}){super(),this.task=e,this.model=t,this.tokenizer=n,this.processor=r}async dispose(){await this.model.dispose()}}class WC extends VC{_key="generated_text";constructor(e){super(e)}async _call(e,t={}){Array.isArray(e)||(e=[e]),this.model.config.prefix&&(e=e.map((e=>this.model.config.prefix+e)));const n=this.model.config.task_specific_params;n&&n[this.task]&&n[this.task].prefix&&(e=e.map((e=>n[this.task].prefix+e)));const r=this.tokenizer,s={padding:!0,truncation:!0};let i;i=this instanceof jC&&"_build_translation_inputs"in r?r._build_translation_inputs(e,s,t):r(e,s);const a=await this.model.generate({...i,...t});return r.batch_decode(a,{skip_special_tokens:!0}).map((e=>({[this._key]:e})))}}class jC extends WC{_key="translation_text";constructor(e){super(e)}}function GC(e){return Array.isArray(e)&&e.every((e=>"role"in e&&"content"in e))}Object.freeze({"text-classification":{tokenizer:E_,pipeline:class HC extends VC{constructor(e){super(e)}async _call(e,{top_k:t=1}={}){const n=this.tokenizer(e,{padding:!0,truncation:!0}),r=await this.model(n),s="multi_label_classification"===this.model.config.problem_type?e=>e.sigmoid():e=>new Xp("float32",he(e.data),e.dims),i=this.model.config.id2label,a=[];for(const e of r.logits){const n=s(e),r=await Zp(n,t),o=r[0].tolist(),l=r[1].tolist().map(((e,t)=>({label:i?i[e]:`LABEL_${e}`,score:o[t]})));1===t?a.push(...l):a.push(l)}return Array.isArray(e)||1===t?a:a[0]}},model:ES,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:E_,pipeline:class KC extends VC{constructor(e){super(e)}async _call(e,{ignore_labels:t=["O"]}={}){const n=Array.isArray(e),r=this.tokenizer(n?e:[e],{padding:!0,truncation:!0}),s=(await this.model(r)).logits,i=this.model.config.id2label,a=[];for(let e=0;e<s.dims[0];++e){const n=r.input_ids[e],o=s[e],l=[];for(let e=0;e<o.dims[0];++e){const r=o[e],s=_e(r.data)[1],a=i?i[s]:`LABEL_${s}`;if(t.includes(a))continue;const u=this.tokenizer.decode([n[e].item()],{skip_special_tokens:!0});if(""===u)continue;const d=he(r.data);l.push({entity:a,score:d[s],index:e,word:u})}a.push(l)}return n?a:a[0]}},model:class XC extends Sb{static MODEL_CLASS_MAPPINGS=[e$]},default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:E_,pipeline:class QC extends VC{constructor(e){super(e)}async _call(e,t,{top_k:n=1}={}){const r=this.tokenizer(e,{text_pair:t,padding:!0,truncation:!0}),{start_logits:s,end_logits:i}=await this.model(r),a=r.input_ids.tolist(),o=r.attention_mask.tolist(),l=this.tokenizer.all_special_ids,u=[];for(let e=0;e<s.dims[0];++e){const t=a[e],r=t.findIndex((e=>e==this.tokenizer.sep_token_id)),d=(o[e].map(((e,n)=>1==e&&(0===n||n>r&&-1===l.findIndex((e=>e==t[n]))))),s[e].tolist()),c=i[e].tolist();for(let n=1;n<d.length;++n)(0==o[e]||n<=r||-1!==l.findIndex((e=>e==t[n])))&&(d[n]=-Infinity,c[n]=-Infinity);const p=he(d).map(((e,t)=>[e,t])),h=he(c).map(((e,t)=>[e,t]));p[0][0]=0,h[0][0]=0;const f=Y(p,h).filter((e=>e[0][1]<=e[1][1])).map((e=>[e[0][1],e[1][1],e[0][0]*e[1][0]])).sort(((e,t)=>t[2]-e[2]));for(let e=0;e<Math.min(f.length,n);++e){const[n,r,s]=f[e],i=t.slice(n,r+1),a=this.tokenizer.decode(i,{skip_special_tokens:!0});u.push({answer:a,score:s})}}return 1===n?u[0]:u}},model:class YC extends Sb{static MODEL_CLASS_MAPPINGS=[yk]},default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:E_,pipeline:class ZC extends VC{constructor(e){super(e)}async _call(e,{top_k:t=5}={}){const n=this.tokenizer(e,{padding:!0,truncation:!0}),{logits:r}=await this.model(n),s=[],i=n.input_ids.tolist();for(let e=0;e<i.length;++e){const n=i[e],a=n.findIndex((e=>e==this.tokenizer.mask_token_id));if(-1===a)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const o=r[e][a],l=await Zp(new Xp("float32",he(o.data),o.dims),t),u=l[0].tolist(),d=l[1].tolist();s.push(d.map(((e,t)=>{const r=n.slice();return r[a]=e,{score:u[t],token:Number(e),token_str:this.tokenizer.model.vocab[e],sequence:this.tokenizer.decode(r,{skip_special_tokens:!0})}})))}return Array.isArray(e)?s:s[0]}},model:class JC extends Sb{static MODEL_CLASS_MAPPINGS=[nk]},default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:E_,pipeline:class eT extends WC{_key="summary_text";constructor(e){super(e)}},model:SS,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:E_,pipeline:jC,model:SS,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:E_,pipeline:WC,model:SS,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:E_,pipeline:class tT extends VC{constructor(e){super(e)}async _call(e,t={}){let n,r=!1,s=!1;if("string"==typeof e)n=e=[e];else if(Array.isArray(e)&&e.every((e=>"string"==typeof e)))r=!0,n=e;else{if(GC(e))e=[e];else{if(!Array.isArray(e)||!e.every(GC))throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");r=!0}s=!0,n=e.map((e=>this.tokenizer.apply_chat_template(e,{tokenize:!1,add_generation_prompt:!0})))}const i=t.add_special_tokens??!1,a=!s&&(t.return_full_text??!0);this.tokenizer.padding_side="left";const o=this.tokenizer(n,{add_special_tokens:i,padding:!0,truncation:!0}),l=await this.model.generate({...o,...t}),u=this.tokenizer.batch_decode(l,{skip_special_tokens:!0});let d;!a&&o.input_ids.dims.at(-1)>0&&(d=this.tokenizer.batch_decode(o.input_ids,{skip_special_tokens:!0}).map((e=>e.length)));const c=Array.from({length:e.length},(e=>[]));for(let t=0;t<u.length;++t){const n=Math.floor(t/l.dims[0]*e.length);d&&(u[t]=u[t].slice(d[n])),c[n].push({generated_text:s?[...e[n],{role:"assistant",content:u[t]}]:u[t]})}return r||1!==c.length?c:c[0]}},model:class nT extends Sb{static MODEL_CLASS_MAPPINGS=[k$]},default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:E_,pipeline:class rT extends VC{constructor(e){super(e),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map((([e,t])=>[e.toLowerCase(),t]))),this.entailment_id=this.label2id.entailment,void 0===this.entailment_id&&(console.warn("Could not find \'entailment\' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,void 0===this.contradiction_id&&(console.warn("Could not find \'contradiction\' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(e,t,{hypothesis_template:n="This example is {}.",multi_label:r=!1}={}){const s=Array.isArray(e);s||(e=[e]),Array.isArray(t)||(t=[t]);const i=t.map((e=>n.replace("{}",e))),a=r||1===t.length,o=[];for(const n of e){const e=[];for(const t of i){const r=this.tokenizer(n,{text_pair:t,padding:!0,truncation:!0}),s=await this.model(r);a?e.push([s.logits.data[this.contradiction_id],s.logits.data[this.entailment_id]]):e.push(s.logits.data[this.entailment_id])}const r=(a?e.map((e=>he(e)[1])):he(e)).map(((e,t)=>[e,t])).sort(((e,t)=>t[0]-e[0]));o.push({sequence:n,labels:r.map((e=>t[e[1]])),scores:r.map((e=>e[0]))})}return s?o:o[0]}},model:ES,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:class sT extends VC{constructor(e){super(e)}async _call(e,{top_k:t=5}={}){const n=this.processor.feature_extractor.config.sampling_rate,r=await UC(e,n),s=this.model.config.id2label,i=[];for(const e of r){const n=await this.processor(e),r=(await this.model(n)).logits[0],a=await Zp(new Xp("float32",he(r.data),r.dims),t),o=a[0].tolist(),l=a[1].tolist().map(((e,t)=>({label:s?s[e]:`LABEL_${e}`,score:o[t]})));i.push(l)}return Array.isArray(e)?i:i[0]}},model:class iT extends Sb{static MODEL_CLASS_MAPPINGS=[NE]},processor:LC,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:E_,pipeline:class aT extends VC{constructor(e){super(e)}async _call(e,t,{hypothesis_template:n="This is a sound of {}."}={}){const r=!Array.isArray(e);r&&(e=[e]);const s=t.map((e=>n.replace("{}",e))),i=this.tokenizer(s,{padding:!0,truncation:!0}),a=this.processor.feature_extractor.config.sampling_rate,o=await UC(e,a),l=[];for(const e of o){const n=await this.processor(e),r=he((await this.model({...i,...n})).logits_per_audio.data);l.push([...r].map(((e,n)=>({score:e,label:t[n]}))))}return r?l[0]:l}},model:kS,processor:LC,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:E_,pipeline:class oT extends VC{constructor(e){super(e)}async _call(e,t={}){switch(this.model.config.model_type){case"whisper":return this._call_whisper(e,t);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":return this._call_wav2vec2(e,t);case"moonshine":return this._call_moonshine(e,t);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type \'${this.model.config.model_type}\'.`)}}async _call_wav2vec2(e,t){t.language&&console.warn(\'`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".\'),t.task&&console.warn(\'`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".\');const n=!Array.isArray(e);n&&(e=[e]);const r=this.processor.feature_extractor.config.sampling_rate,s=await UC(e,r),i=[];for(const e of s){const t=await this.processor(e),n=(await this.model(t)).logits[0],r=[];for(const e of n)r.push(_e(e.data)[1]);const s=this.tokenizer.decode(r);i.push({text:s})}return n?i[0]:i}async _call_whisper(e,t){const n=t.return_timestamps??!1,r=t.chunk_length_s??0,s=t.force_full_sequences??!1;let i=t.stride_length_s??null;const a={...t};"word"===n&&(a.return_token_timestamps=!0,a.return_timestamps=!1);const o=!Array.isArray(e);o&&(e=[e]);const l=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,u=this.processor.feature_extractor.config.hop_length,d=this.processor.feature_extractor.config.sampling_rate,c=await UC(e,d),p=[];for(const e of c){let t=[];if(r>0){if(null===i)i=r/6;else if(r<=i)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const n=d*r,s=d*i,a=n-2*s;let o=0;for(;;){const r=o+n,i=e.subarray(o,r),l=await this.processor(i),u=0===o,d=r>=e.length;if(t.push({stride:[i.length,u?0:s,d?0:s],input_features:l.input_features,is_last:d}),d)break;o+=a}}else t=[{stride:[e.length,0,0],input_features:(await this.processor(e)).input_features,is_last:!0}];for(const e of t){a.num_frames=Math.floor(e.stride[0]/u);const t=await this.model.generate({inputs:e.input_features,...a});"word"===n?(e.tokens=t.sequences.tolist()[0],e.token_timestamps=t.token_timestamps.tolist()[0].map((e=>ve(e,2)))):e.tokens=t[0].tolist(),e.stride=e.stride.map((e=>e/d))}const[o,c]=this.tokenizer._decode_asr(t,{time_precision:l,return_timestamps:n,force_full_sequences:s});p.push({text:o,...c})}return o?p[0]:p}async _call_moonshine(e,t){const n=!Array.isArray(e);n&&(e=[e]);const r=this.processor.feature_extractor.config.sampling_rate,s=await UC(e,r),i=[];for(const e of s){const n=await this.processor(e),s=6*Math.floor(e.length/r),a=await this.model.generate({max_new_tokens:s,...t,...n}),o=this.processor.batch_decode(a,{skip_special_tokens:!0})[0];i.push({text:o})}return n?i[0]:i}},model:[class lT extends Sb{static MODEL_CLASS_MAPPINGS=[Tv]},class uT extends Sb{static MODEL_CLASS_MAPPINGS=[CE]}],processor:LC,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:E_,pipeline:class dT extends VC{DEFAULT_VOCODER_ID="Xenova/speecht5_hifigan";constructor(e){super(e),this.vocoder=e.vocoder??null}async _call(e,{speaker_embeddings:t=null}={}){return this.processor?this._call_text_to_spectrogram(e,{speaker_embeddings:t}):this._call_text_to_waveform(e)}async _call_text_to_waveform(e){const t=this.tokenizer(e,{padding:!0,truncation:!0}),{waveform:n}=await this.model(t),r=this.model.config.sampling_rate;return{audio:n.data,sampling_rate:r}}async _call_text_to_spectrogram(e,{speaker_embeddings:t}){if(this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await kS.from_pretrained(this.DEFAULT_VOCODER_ID,{dtype:"fp32"})),("string"==typeof t||t instanceof URL)&&(t=new Float32Array(await(await fetch(t)).arrayBuffer())),t instanceof Float32Array)t=new Xp("float32",t,[1,t.length]);else if(!(t instanceof Xp))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");const{input_ids:n}=this.tokenizer(e,{padding:!0,truncation:!0}),{waveform:r}=await this.model.generate_speech(n,t,{vocoder:this.vocoder}),s=this.processor.feature_extractor.config.sampling_rate;return{audio:r.data,sampling_rate:s}}},model:[class cT extends Sb{static MODEL_CLASS_MAPPINGS=[Bv]},class pT extends Sb{static MODEL_CLASS_MAPPINGS=[Mv]}],processor:[LC,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:E_,pipeline:class hT extends VC{constructor(e){super(e)}async _call(e,t={}){const n=Array.isArray(e),r=await FC(e),{pixel_values:s}=await this.processor(r),i=[];for(const e of s){e.dims=[1,...e.dims];const n=await this.model.generate({inputs:e,...t}),r=this.tokenizer.batch_decode(n,{skip_special_tokens:!0}).map((e=>({generated_text:e.trim()})));i.push(r)}return n?i:i[0]}},model:class fT extends Sb{static MODEL_CLASS_MAPPINGS=[Nk]},processor:LC,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:class mT extends VC{constructor(e){super(e)}async _call(e,{top_k:t=5}={}){const n=await FC(e),{pixel_values:r}=await this.processor(n),s=await this.model({pixel_values:r}),i=this.model.config.id2label,a=[];for(const e of s.logits){const n=await Zp(new Xp("float32",he(e.data),e.dims),t),r=n[0].tolist(),s=n[1].tolist().map(((e,t)=>({label:i?i[e]:`LABEL_${e}`,score:r[t]})));a.push(s)}return Array.isArray(e)?a:a[0]}},model:class _T extends Sb{static MODEL_CLASS_MAPPINGS=[Vk]},processor:LC,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:class gT extends VC{constructor(e){super(e),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(e,{threshold:t=.5,mask_threshold:n=.5,overlap_mask_area_threshold:r=.8,label_ids_to_fuse:s=null,target_sizes:i=null,subtask:a=null}={}){if(Array.isArray(e)&&1!==e.length)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const o=await FC(e),l=o.map((e=>[e.height,e.width])),{pixel_values:u,pixel_mask:d}=await this.processor(o),c=await this.model({pixel_values:u,pixel_mask:d});let p=null;if(null!==a)p=this.subtasks_mapping[a];else for(let[e,t]of Object.entries(this.subtasks_mapping))if(t in this.processor.image_processor){p=this.processor.image_processor[t].bind(this.processor.image_processor),a=e;break}const h=this.model.config.id2label,f=[];if("panoptic"===a||"instance"===a){const e=p(c,t,n,r,s,i??l)[0],a=e.segmentation;for(const t of e.segments_info){const e=new Uint8ClampedArray(a.data.length);for(let n=0;n<a.data.length;++n)a.data[n]===t.id&&(e[n]=255);const n=new lg(e,a.dims[1],a.dims[0],1);f.push({score:t.score,label:h[t.label_id],mask:n})}}else{if("semantic"!==a)throw Error(`Subtask ${a} not supported.`);{const{segmentation:e,labels:t}=p(c,i??l)[0];for(const n of t){const t=new Uint8ClampedArray(e.data.length);for(let r=0;r<e.data.length;++r)e.data[r]===n&&(t[r]=255);const r=new lg(t,e.dims[1],e.dims[0],1);f.push({score:null,label:h[n],mask:r})}}}return f}},model:[class wT extends Sb{static MODEL_CLASS_MAPPINGS=[yE]},class yT extends Sb{static MODEL_CLASS_MAPPINGS=[xE]},class bT extends Sb{static MODEL_CLASS_MAPPINGS=[kE]}],processor:LC,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"zero-shot-image-classification":{tokenizer:E_,pipeline:class xT extends VC{constructor(e){super(e)}async _call(e,t,{hypothesis_template:n="This is a photo of {}"}={}){const r=Array.isArray(e),s=await FC(e),i=t.map((e=>n.replace("{}",e))),a=this.tokenizer(i,{padding:"siglip"!==this.model.config.model_type||"max_length",truncation:!0}),{pixel_values:o}=await this.processor(s),l=await this.model({...a,pixel_values:o}),u="siglip"===this.model.config.model_type?e=>e.sigmoid().data:e=>he(e.data),d=[];for(const e of l.logits_per_image){const n=[...u(e)].map(((e,n)=>({score:e,label:t[n]})));n.sort(((e,t)=>t.score-e.score)),d.push(n)}return r?d:d[0]}},model:kS,processor:LC,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:class vT extends VC{constructor(e){super(e)}async _call(e,{threshold:t=.9,percentage:n=!1}={}){const r=Array.isArray(e);if(r&&1!==e.length)throw Error("Object detection pipeline currently only supports a batch size of 1.");const s=await FC(e),i=n?null:s.map((e=>[e.height,e.width])),{pixel_values:a,pixel_mask:o}=await this.processor(s),l=await this.model({pixel_values:a,pixel_mask:o}),u=this.processor.image_processor.post_process_object_detection(l,t,i),d=this.model.config.id2label,c=u.map((e=>e.boxes.map(((t,r)=>({score:e.scores[r],label:d[e.classes[r]],box:qC(t,!n)})))));return r?c:c[0]}},model:class $T extends Sb{static MODEL_CLASS_MAPPINGS=[cE]},processor:LC,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:E_,pipeline:class kT extends VC{constructor(e){super(e)}async _call(e,t,{threshold:n=.1,top_k:r=null,percentage:s=!1}={}){const i=Array.isArray(e),a=await FC(e),o=this.tokenizer(t,{padding:!0,truncation:!0}),l=await this.processor(a),u=[];for(let e=0;e<a.length;++e){const i=a[e],d=s?null:[[i.height,i.width]],c=l.pixel_values[e].unsqueeze_(0),p=await this.model({...o,pixel_values:c}),h=this.processor.image_processor.post_process_object_detection(p,n,d,!0)[0];let f=h.boxes.map(((e,n)=>({score:h.scores[n],label:t[h.classes[n]],box:qC(e,!s)}))).sort(((e,t)=>t.score-e.score));null!==r&&(f=f.slice(0,r)),u.push(f)}return i?u:u[0]}},model:class ET extends Sb{static MODEL_CLASS_MAPPINGS=[_E]},processor:LC,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:E_,pipeline:class ST extends VC{constructor(e){super(e)}async _call(e,t,n={}){const r=(await FC(e))[0],{pixel_values:s}=await this.processor(r),i=`<s_docvqa><s_question>${t}</s_question><s_answer>`,a=this.tokenizer(i,{add_special_tokens:!1,padding:!0,truncation:!0}).input_ids,o=await this.model.generate({inputs:s,max_length:this.model.config.decoder.max_position_embeddings,decoder_input_ids:a,...n}),l=this.tokenizer.batch_decode(o)[0].match(/<s_answer>(.*?)<\\/s_answer>/);let u=null;return l&&l.length>=2&&(u=l[1].trim()),[{answer:u}]}},model:class zT extends Sb{static MODEL_CLASS_MAPPINGS=[qk]},processor:LC,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:class CT extends VC{constructor(e){super(e)}async _call(e){const t=await FC(e),n=await this.processor(t),r=await this.model(n),s=[];for(const e of r.reconstruction){const t=e.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");s.push(lg.fromTensor(t))}return s.length>1?s:s[0]}},model:class TT extends Sb{static MODEL_CLASS_MAPPINGS=[tS]},processor:LC,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:class AT extends VC{constructor(e){super(e)}async _call(e){const t=await FC(e),n=await this.processor(t),{predicted_depth:r}=await this.model(n),s=[];for(let e=0;e<t.length;++e){const n=Qp(r[e],t[e].size.reverse(),"bilinear",!1),i=n.mul_(255/_e(n.data)[0]).to("uint8");s.push({predicted_depth:r[e],depth:lg.fromTensor(i)})}return s.length>1?s:s[0]}},model:class IT extends Sb{static MODEL_CLASS_MAPPINGS=[rS]},processor:LC,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:E_,pipeline:class MT extends VC{constructor(e){super(e)}async _call(e,{pooling:t="none",normalize:n=!1,quantize:r=!1,precision:s="binary"}={}){const i=this.tokenizer(e,{padding:!0,truncation:!0}),a=await this.model(i);let o=a.last_hidden_state??a.logits??a.token_embeddings;if("none"===t);else if("mean"===t)o=function l(e,t){const n=e.data,r=t.data,s=[e.dims[0],e.dims[2]],i=new n.constructor(s[0]*s[1]),[a,o,l]=e.dims;let u=0;for(let e=0;e<a;++e){const t=e*l*o;for(let s=0;s<l;++s){let a=0,d=0;const c=e*o,p=t+s;for(let e=0;e<o;++e){const t=Number(r[c+e]);d+=t,a+=n[p+e*l]*t}const h=a/d;i[u++]=h}}return new Xp(e.type,i,s)}(o,i.attention_mask);else{if("cls"!==t)throw Error(`Pooling method \'${t}\' not supported.`);o=o.slice(null,0)}return n&&(o=o.normalize(2,-1)),r&&(o=function u(e,t){if(2!==e.dims.length)throw new Error("The tensor must have 2 dimensions");if(e.dims.at(-1)%8!=0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(t))throw new Error("The precision must be either \'binary\' or \'ubinary\'");const n="binary"===t,r=n?"int8":"uint8",s=n?Int8Array:Uint8Array,i=e.data,a=new s(i.length/8);for(let e=0;e<i.length;++e){const t=i[e]>0?1:0,r=Math.floor(e/8),s=e%8;a[r]|=t<<7-s,n&&0===s&&(a[r]-=128)}return new Xp(r,a,[e.dims[0],e.dims[1]/8])}(o,s)),o}},model:kS,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:LC,pipeline:class OT extends VC{constructor(e){super(e)}async _call(e,{pool:t=null}={}){const n=await FC(e),{pixel_values:r}=await this.processor(n),s=await this.model({pixel_values:r});let i;if(t){if(!("pooler_output"in s))throw Error("No pooled output was returned. Make sure the model has a \'pooler\' layer when using the \'pool\' option.");i=s.pooler_output}else i=s.last_hidden_state??s.logits??s.image_embeds;return i}},model:[class BT extends Sb{static MODEL_CLASS_MAPPINGS=[hS]},kS],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});class NT{put(e){throw Error("Not implemented")}end(){throw Error("Not implemented")}}const PT=D.IS_PROCESS_AVAILABLE?e=>process.stdout.write(e):e=>console.log(e);class RT extends NT{constructor(e,{skip_prompt:t=!1,callback_function:n=null,token_callback_function:r=null,decode_kwargs:s={},...i}={}){super(),this.tokenizer=e,this.skip_prompt=t,this.callback_function=n??PT,this.token_callback_function=r,this.decode_kwargs={...s,...i},this.token_cache=[],this.print_len=0,this.next_tokens_are_prompt=!0}put(e){if(e.length>1)throw Error("TextStreamer only supports batch size of 1");if(this.skip_prompt&&this.next_tokens_are_prompt)return void(this.next_tokens_are_prompt=!1);const t=e[0];this.token_callback_function?.(t),this.token_cache=Q(this.token_cache,t);const n=this.tokenizer.decode(this.token_cache,this.decode_kwargs);let r;n.endsWith("\\n")?(r=n.slice(this.print_len),this.token_cache=[],this.print_len=0):n.length>0&&zf(n.charCodeAt(n.length-1))?(r=n.slice(this.print_len),this.print_len+=r.length):(r=n.slice(this.print_len,n.lastIndexOf(" ")+1),this.print_len+=r.length),this.on_finalized_text(r,!1)}end(){let e;if(this.token_cache.length>0){e=this.tokenizer.decode(this.token_cache,this.decode_kwargs).slice(this.print_len),this.token_cache=[],this.print_len=0}else e="";this.next_tokens_are_prompt=!0,this.on_finalized_text(e,!0)}on_finalized_text(e,t){e.length>0&&this.callback_function?.(e),t&&this.callback_function===PT&&D.IS_PROCESS_AVAILABLE&&this.callback_function?.("\\n")}}["upload","listen","summarize","telehealth"].map((e=>`finished-${e}-transcriptions`));const DT=(e,t=void 0)=>e instanceof Function?e(t):e,LT=(e,t,n=(()=>{}))=>(...r)=>DT(e)?t(...r):n(...r);var FT,UT;const qT=(...e)=>e.reduce(((e,t)=>(e[t]=t,e)),{}),VT=qT("milliseconds","seconds","minutes","hours","days","weeks"),WT=qT("ms","s","m","h","d","w"),jT=36e5,GT=864e5,HT={milliseconds:1,seconds:1e3,minutes:6e4,hours:jT,days:GT,weeks:7*GT},KT={ms:"milliseconds",s:"seconds",m:"minutes",h:"hours",d:"days",w:"weeks"};Number.prototype.in=function(e){return this/("number"==typeof e?e:HT[e])},Object.defineProperties(Number.prototype,Object.values(VT).reduce(((e,t)=>(e[t]={get(){return this*HT[t]}},e)),{})),Object.defineProperties(Number.prototype,Object.values(WT).reduce(((e,t)=>(e[t]={get(){return ZT(this*HT[KT[t]])}},e)),{}));const XT="undefined"==typeof performance?()=>currentTime:performance.now.bind(performance),QT="undefined"==typeof performance?XT:()=>performance.timeOrigin+YT(),YT=new(UT=class e extends Function{constructor(){super("return performance.now();"),this[FT]=XT}},FT=Symbol.toPrimitive,UT),ZT=e=>{let t=!1;const n=new Promise((n=>setTimeout((()=>!t&&n()),e)));return Object.assign(n,{cancel:()=>{t=!0}})},JT=((new Date).getDay(),"undefined"!=typeof navigator&&navigator.userAgent.includes("Firefox"));let eA=48e3;if("undefined"!=typeof AudioContext){const e=new AudioContext;eA=e.sampleRate,e.close()}const tA=JT?eA:16e3,nA=(!!globalThis.navigator&&/Mobi|Android/i.test(navigator.userAgent),"undefined"==typeof location?"":location.search),rA="undefined"!=typeof process,sA=(!rA&&"undefined"!=typeof location&&location.pathname.includes("/dashboard"),"undefined"!=typeof AudioWorkletProcessor),iA="undefined"!=typeof DedicatedWorkerGlobalScope||sA,aA=!rA&&(iA||sA||"undefined"!=typeof navigator),oA="undefined"!=typeof location&&("localhost"===location.hostname||location.href.startsWith("blob:http://localhost")),{fromEntries:lA,keys:uA}=(aA&&"undefined"!=typeof location&&(location.host.includes("nuiq.com")||location.href.startsWith("blob:https://nuiq.com")||oA&&location.port),"undefined"!=typeof location&&(location.host.includes("stage.nuiq.com")||location.href.startsWith("blob:https://stage.nuiq.com")),oA||/debug(\\=true)?($|&)/.test(nA),"undefined"!=typeof navigator&&/Safari/i.test(navigator.userAgent)&&navigator.userAgent.includes("Chrome"),nA.includes("useDevServer=true"),Math.PI,Object);const{parse:dA,stringify:cA}=JSON;var pA;let hA=!1;try{hA=!1}catch(UT){}const fA=globalThis.setTimeout||(e=>{});class mA{}pA=mA,mA.passed=0,mA.failed=0,mA.testPromises=[],mA.expect=LT(hA,((e,t,n="")=>{const r=new Promise((r=>fA((async()=>{const s=await DT(e),i=DT(t),a=s===i,o=null!=n?n:e instanceof Function?e.name:"";a?pA.passed+=1:(console.error(` failed InlineTest::${o} (expected ${i}, got ${s})`),pA.failed+=1),r()}))));return pA.testPromises.push(r),r})),fA(LT(hA,(async()=>{await Promise.all(pA.testPromises);const{passed:e,failed:t}=pA,n=e+t;console.log(` InlineTest: passed ${e} / ${n} (${kA(e/n)})`),t&&console.log(` InlineTest: failed ${t} / ${n} (${kA(t/n)})`)})),5..seconds);const _A=new Map,gA=e=>{const t=JSON.stringify(e);return _A.has(t)?_A.get(t):(_A.set(t,e),e)};mA.expect(gA({a:1,b:2,c:3}),gA({a:1,b:2,c:3}));const{floor:wA,max:yA,round:bA}=Math,{isArray:xA}=Array,{entries:vA}=Object,{ListFormat:$A}=Intl,kA=e=>zA(e)?`${EA(100*+e)}%`:"0%",EA=e=>e.toFixed(/\\./.test(`${e}`)?2:0),SA=new Set(["boolean","symbol"]),zA=e=>!SA.has(typeof e)&&""!==e&&+e==+e;new $A("en",{style:"long",type:"conjunction"});Map;Map;WeakMap;Map;Map;const{floor:CA,max:TA,min:AA,pow:IA,random:MA,sqrt:OA}=Math;new Intl.Collator("en");function BA(e,t){return n=>null==t?n[e]:t instanceof Function?t(n[e]):n[e]===t}BA("length");const NA=(e,t=(e=>e))=>{let n=0;for(let r=0;r<e.length;r+=1)n+=t(e[r]);return n},PA=(e,t=(e=>e))=>NA(e,t)/e.length,RA=(e,t=(e=>e))=>TA.apply(null,e.map((e=>t(e)))),DA=(e,t=(e=>e))=>AA.apply(null,e.map((e=>t(e)))),LA=(e,t=(e=>e))=>{e=e.map((e=>t(e)));const n=PA(e),r=[];let s=e.length;for(;s-- >0;)r.push(IA(e[s]-n,2));return PA(r)},FA={sum:NA,mean:PA,median:(e,t=(e=>e))=>{const n=[].sort.call(e.map(t),((e,t)=>e-t)),r=n.length,s=CA(.5*r);return r%2?n[s]:.5*(n[s-1]+n[s])},mode:(e,t=(e=>e))=>{var n;const r=new Map;for(const s of e){const e=t(s);r.set(e,(null!==(n=r.get(e))&&void 0!==n?n:0)+1)}const s=Math.max.apply(null,[...r.values()]);return[...r.keys()].find((e=>r.get(e)===s))},min:DA,max:RA,range:(e,t=(e=>e))=>(e=e.map((e=>t(e))),RA(e)-DA(e)),deviation:(e,t=(e=>e))=>OA(LA(e,t)),variance:LA};Object.keys(FA);let{from:UA}=Array;const{log10:qA}=Math,VA=(e,t,n=.5)=>e*(1-n)+t*n,WA=/(?:(?:\\s[.,?!:;\'"])|(?:[.,?!:;\'"]\\s)|[\\s.,?!:;])+/g,jA="Okay, so good evening, everyone. I want to say welcome to the Substance Abuse Support Group. I\'m Courtney and I will be the facilitator or the group leader of this group and I just want to say welcome first and I want to just kind of briefly go over some some rules, you know, I don\'t necessarily, you guys don\'t have to be on mute if you don\'t want to be, but I don\'t want anyone talking over anyone else or cutting them off.",GA=["Okay","so","good","evening","everyone","I","want","to","say","welcome","to","the","Substance","Abuse","Support","Group","I\'m","Courtney","and","I","will","be","the","facilitator","or","the","group","leader","of","this","group","and","I","just","want","to","say","welcome","first","and","I","want","to","just","kind","of","briefly","go","over","some","some","rules","you","know","I","don\'t","necessarily","you","guys","don\'t","have","to","be","on","mute","if","you","don\'t","want","to","be","but","I","don\'t","want","anyone","talking","over","anyone","else","or","cutting","them","off",""];mA.expect((()=>jA.split(WA).join("::")),(()=>GA.join("::")));const HA=/^.+\\@.+\\..+$/g;mA.expect(HA.test("test@email.com"),!0),mA.expect(HA.test("123 test address st., denver co 80201"),!1);const KA=/\\d+ .+\\,?.+[A-Z]{2}\\,? ?\\d{5}\\-?\\d{0,4}/;mA.expect(KA.test("72 Applegate Drive Taunton, MA 02780"),!0),mA.expect(KA.test("723 Applegate Dr, Taunton, MA 02780"),!0),mA.expect(KA.test("7 Applegate Ln., Taunton MA 02780"),!0),mA.expect(KA.test("72 Applegate Way, Taunton MA 02780-4052"),!0),mA.expect(KA.test("Applegate Way, Taunton MA 02780-4052"),!1),mA.expect(KA.test("42 Applegate Way, Taunton MA"),!1),mA.expect(KA.test("42 Applegate Way, Taunton 02780"),!1);mA.expect(/\\d{3}\\-\\d{2}\\-\\d{4}/.test("111-11-1111"),!0);const XA=/^(?:\\$\\s*\\d+(\\.\\d{2})?\\s*|\\s*\\d+(\\.\\d{2})?\\s*\\$)$/;mA.expect(XA.test("$24.40"),!0),mA.expect(XA.test("$ 24.40"),!0),mA.expect(XA.test("$\\n24.40"),!0),mA.expect(XA.test("24.40 $"),!0),mA.expect(XA.test("24$"),!0),mA.expect(XA.test("24"),!1),mA.expect(XA.test("$ 24.3432"),!1);const QA=(e="")=>e.trim().split(WA).filter(Boolean),YA=e=>e.replaceAll(WA,""),ZA=e=>(e.words?e.words.map(BA("word")):QA(e.text)).map(YA),JA=e=>{var t,n;const r=ZA(e);let{words:s}=e;if(null==s){const t=NA(r,(e=>e.length));let n=0;const{start:i=0,end:a=0}=e;s=r.map((e=>{const r=VA(i,a,n/t),s=VA(i,a,(n+e.length)/t);return n+=e.length,{word:e,start:r,end:s}}))}const i=null!==(t=e.wordsSet)&&void 0!==t?t:new Set(r);return{...e,wordCount:null!==(n=e.wordCount)&&void 0!==n?n:i.size,words:s,wordsSet:i}};V.backends.onnx&&V.backends.onnx.wasm&&(V.backends.onnx.wasm.numThreads=1),V.allowLocalModels=!1;let eI=150;class tI{static async getInstance({device:e="webgpu",model:t="tiny"}={}){var n,r,s;return this.model_id=`onnx-community/${t.includes("distil")?"":"whisper-"}${t}.en`,this.tokenizer&&this.processor&&this.model||(console.log(`loading model ${this.model_id}`),null!==(n=this.tokenizer)&&void 0!==n||(this.tokenizer=E_.from_pretrained(this.model_id,{progress_callback:aI})),null!==(r=this.processor)&&void 0!==r||(this.processor=LC.from_pretrained(this.model_id,{progress_callback:aI})),null!==(s=this.model)&&void 0!==s||(this.model=vw.from_pretrained(this.model_id,{dtype:{encoder_model:t.includes("turbo")?"fp16":"fp32",decoder_model_merged:"q4"},device:e,progress_callback:aI})),console.log(`loaded model ${this.model_id}`)),Promise.all([this.tokenizer,this.processor,this.model])}}tI.model_id=null,tI.tokenizer=null,tI.processor=null,tI.model=null;const nI=/[a-zA-Z0-9]/,rI=({text:e=""})=>nI.test(e)&&(null==e?void 0:e.length),sI=e=>{var t;return e.text=(null!==(t=e.text)&&void 0!==t?t:"").replace(/[<>]{2}/g,""),e},iI=((e,{mode:t="chain"}={})=>{let n,r=!1;const s=async(...i)=>r?"chain"===t?n.then((()=>s(...i))):n:(r=!0,n=new Promise((async(t,n)=>{try{t(await e(...i))}catch(e){console.error(e),n(e)}finally{r=!1}})),n);return s})((async function e(t){var n;self.postMessage({status:"start"});const[r,s,i]=await tI.getInstance();let a,o=0,l=!1;const u=new RT(r,{skip_prompt:!0,skip_special_tokens:!0,callback_function:e=>{let t;null!=a||(a=performance.now()),o++>0&&(t=o/(performance.now()-a)*1e3),o>=eI&&(l=!0,console.warn(`num tokens above max of ${eI}. increasing max to ${eI+16}`),eI+=16),self.postMessage({status:"update",output:e,tps:t,numTokens:o})}}),d=await s(t),c=await i.generate({...d,max_new_tokens:eI,streamer:u,return_timestamps:!0,force_full_sequences:!1,chunk_length_s:30,stride_length_s:3}),p=r.batch_decode(c,{skip_special_tokens:!0,return_timestamps:!0,force_full_sequences:!1}),h=p[0].replaceAll(/\\<\\|\\d+\\.\\d+\\|\\>/g,""),f=p[0].replaceAll("|><|",":|:").replaceAll("<|","::").replaceAll("|>","::").split(":|:");f[0]=null===(n=f[0])||void 0===n?void 0:n.replace(/^\\:\\:/,"");const m=f.map((e=>{const[n,r,s=t.length/16e3]=e.split("::");return{start:+n,text:r,end:+s,processor:mI}})).filter(rI).map(sI).map(JA);return{text:h,segments:m,exceededMaxTokens:l,processor:mI}}));let aI=()=>{},oI=0,lI=0,uI=0,dI=0,cI=0,pI=0,hI=new Set,fI={};const mI=crypto.randomUUID().split("-")[0];new class _I{async metrics(){return{id:mI,requests:lI,retries:0,failures:uI,successes:pI,hallucinations:0,processed:dI,processedIndices:[...hI],elapsed:cI,xRealTime:dI/cI,misc:fI}}async init({device:e="webgpu",model:t="tiny"}){await async function n({device:e="webgpu",model:t="tiny"}){self.postMessage({status:"loading",data:"Loading model..."});const[,,n]=await tI.getInstance({device:e,model:t});self.postMessage({status:"loading",data:"Compiling shaders and warming up model..."}),await n.generate({input_features:uh([1,80,3e3],0),max_new_tokens:1}),self.postMessage({status:"ready"})}({device:e,model:t}),postMessage({status:"ready"})}progress(e){aI=e}async process({index:e,audio:t}){const n=QT();oI+=1;const r=t.length/tA;let s;hI.add(e),dI+=r,lI+=1;try{s=await iI(t),pI+=1}catch(e){uI+=1,s={text:"",segments:[],exceededMaxTokens:!1,processor:mI}}return oI-=1,cI+=.001*(QT()-n),v(Object.assign(s,{audio:t}),[t.buffer])}constructor(){p(this),postMessage({status:"listening"})}}})()})();',"Worker",void 0,void 0)}function l(){return a()('(()=>{var e,t,n={98:(e,t,n)=>{"use strict";e.exports=n.p+"9784243b0cabe768d594.wasm"},193:()=>{},160:()=>{},448:()=>{},655:()=>{},626:()=>{},674:()=>{},666:()=>{}},r={};function s(e){var t=r[e];if(void 0!==t)return t.exports;var i=r[e]={exports:{}};return n[e](i,i.exports,s),i.exports}s.m=n,t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,s.t=function(n,r){if(1&r&&(n=this(n)),8&r)return n;if("object"==typeof n&&n){if(4&r&&n.__esModule)return n;if(16&r&&"function"==typeof n.then)return n}var i=Object.create(null);s.r(i);var a={};e=e||[null,t({}),t([]),t(t)];for(var o=2&r&&n;"object"==typeof o&&!~e.indexOf(o);o=t(o))Object.getOwnPropertyNames(o).forEach((e=>a[e]=()=>n[e]));return a.default=()=>n,s.d(i,a),i},s.d=(e,t)=>{for(var n in t)s.o(t,n)&&!s.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},s.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),s.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),s.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{var e;s.g.importScripts&&(e=s.g.location+"");var t=s.g.document;if(!e&&t&&(t.currentScript&&(e=t.currentScript.src),!e)){var n=t.getElementsByTagName("script");if(n.length)for(var r=n.length-1;r>-1&&(!e||!/^http(s?):/.test(e));)e=n[r--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\\?.*$/,"").replace(/\\/[^\\/]+$/,"/"),s.p=e})(),s.b=self.location+"",(()=>{"use strict";var e={};s.r(e),s.d(e,{InferenceSession:()=>Be,TRACE:()=>Te,TRACE_FUNC_BEGIN:()=>Ie,TRACE_FUNC_END:()=>Me,Tensor:()=>Ce,default:()=>ip,env:()=>pe,registerBackend:()=>ae});var t={};s.r(t),s.d(t,{BeitFeatureExtractor:()=>ES,BitImageProcessor:()=>SS,CLIPFeatureExtractor:()=>TS,CLIPImageProcessor:()=>CS,ChineseCLIPFeatureExtractor:()=>zS,ConvNextFeatureExtractor:()=>IS,ConvNextImageProcessor:()=>AS,DPTFeatureExtractor:()=>LS,DPTImageProcessor:()=>DS,DeiTFeatureExtractor:()=>OS,DeiTImageProcessor:()=>MS,DetrFeatureExtractor:()=>NS,DetrImageProcessor:()=>BS,DonutFeatureExtractor:()=>RS,DonutImageProcessor:()=>PS,EfficientNetImageProcessor:()=>FS,GLPNFeatureExtractor:()=>US,Idefics3ImageProcessor:()=>qS,JinaCLIPImageProcessor:()=>WS,LlavaOnevisionImageProcessor:()=>jS,Mask2FormerImageProcessor:()=>KS,MaskFormerFeatureExtractor:()=>HS,MaskFormerImageProcessor:()=>GS,MobileNetV1FeatureExtractor:()=>QS,MobileNetV1ImageProcessor:()=>XS,MobileNetV2FeatureExtractor:()=>ZS,MobileNetV2ImageProcessor:()=>YS,MobileNetV3FeatureExtractor:()=>ez,MobileNetV3ImageProcessor:()=>JS,MobileNetV4FeatureExtractor:()=>nz,MobileNetV4ImageProcessor:()=>tz,MobileViTFeatureExtractor:()=>sz,MobileViTImageProcessor:()=>rz,NougatImageProcessor:()=>iz,OwlViTFeatureExtractor:()=>oz,OwlViTImageProcessor:()=>az,Owlv2ImageProcessor:()=>lz,Phi3VImageProcessor:()=>fz,PvtImageProcessor:()=>mz,Qwen2VLImageProcessor:()=>_z,RTDetrImageProcessor:()=>gz,SamImageProcessor:()=>wz,SegformerFeatureExtractor:()=>bz,SegformerImageProcessor:()=>yz,SiglipImageProcessor:()=>xz,Swin2SRImageProcessor:()=>vz,VLMImageProcessor:()=>VS,ViTFeatureExtractor:()=>kz,ViTImageProcessor:()=>$z,VitMatteImageProcessor:()=>Ez,VitPoseImageProcessor:()=>Sz,YolosFeatureExtractor:()=>Cz,YolosImageProcessor:()=>zz});var n={};s.r(n),s.d(n,{ASTFeatureExtractor:()=>jz,ClapFeatureExtractor:()=>Gz,ImageFeatureExtractor:()=>kS,MoonshineFeatureExtractor:()=>Hz,PyAnnoteFeatureExtractor:()=>Kz,SeamlessM4TFeatureExtractor:()=>Xz,SpeechT5FeatureExtractor:()=>Qz,Wav2Vec2FeatureExtractor:()=>Yz,WeSpeakerFeatureExtractor:()=>Zz,WhisperFeatureExtractor:()=>Jz});var r={};s.r(r),s.d(r,{Florence2Processor:()=>Az,Idefics3Processor:()=>rC,JinaCLIPProcessor:()=>iC,MgpstrProcessor:()=>Mz,MoonshineProcessor:()=>tC,OwlViTProcessor:()=>aC,PaliGemmaProcessor:()=>cC,Phi3VProcessor:()=>uC,PyAnnoteProcessor:()=>pC,Qwen2VLProcessor:()=>hC,SamProcessor:()=>fC,SpeechT5Processor:()=>mC,VLChatProcessor:()=>sC,Wav2Vec2ProcessorWithLM:()=>_C,WhisperProcessor:()=>gC});var i=s(626),a=s(674),o=s(666);const l="undefined"!=typeof window&&"undefined"!=typeof window.document,u="undefined"!=typeof self&&"DedicatedWorkerGlobalScope"===self.constructor?.name,d="undefined"!=typeof self&&"caches"in self,c="undefined"!=typeof navigator&&"gpu"in navigator,p="undefined"!=typeof navigator&&"ml"in navigator,h="undefined"!=typeof process,f=h&&"node"===process?.release?.name,m=!$(i),_=!$(a),g=Object.freeze({IS_BROWSER_ENV:l,IS_WEBWORKER_ENV:u,IS_WEB_CACHE_AVAILABLE:d,IS_WEBGPU_AVAILABLE:c,IS_WEBNN_AVAILABLE:p,IS_PROCESS_AVAILABLE:h,IS_NODE_ENV:f,IS_FS_AVAILABLE:m,IS_PATH_AVAILABLE:_}),w=m&&_;let y="./";if(w){const e=Object({}).url;e?y=a.dirname(a.dirname(o.fileURLToPath(e))):"undefined"!=typeof __dirname&&(y=a.dirname(__dirname))}const b=w?a.join(y,"/.cache/"):null,x="/models/",v={version:"3.2.0",backends:{onnx:{}},allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!(l||u),localModelPath:w?a.join(y,x):x,useFS:m,useBrowserCache:d,useFSCache:m,cacheDir:b,useCustomCache:!1,customCache:null};function $(e){return 0===Object.keys(e).length}const k=class{constructor(){let e=function(...t){return e._call(...t)};return Object.setPrototypeOf(e,new.target.prototype)}_call(...e){throw Error("Must implement _call method in subclass")}};function E(e,t){e&&e(t)}function S(e){return e.replace(/[.*+?^${}()|[\\]\\\\]/g,"\\\\$&")}function z(e){return null==e||-1===e}function C(e){const t=[];let n=e;for(;Array.isArray(n);)t.push(n.length),n=n[0];return t}function T(...e){return Array.prototype.concat.apply([],e)}function A(...e){return e.reduce(((e,t)=>e.flatMap((e=>t.map((t=>[e,t]))))))}function I(e,t){return Math.abs((e+t)%(2*t)-t)}function M(e,t){return Object.assign({},...t.map((t=>{if(void 0!==e[t])return{[t]:e[t]}})))}function O(e){let t=0;for(const n of e)++t;return t}function B(e,t){let n=0;for(const r of e)r===t&&++n;return n}var N=s(160),P=s(448);const R={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};class D{constructor(e){if(this.filePath=e,this.headers=new Headers,this.exists=N.existsSync(e),this.exists){this.status=200,this.statusText="OK";let t=N.statSync(e);this.headers.set("content-length",t.size.toString()),this.updateContentType();let n=this;this.body=new ReadableStream({start(e){n.arrayBuffer().then((t=>{e.enqueue(new Uint8Array(t)),e.close()}))}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const e=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",R[e]??"application/octet-stream")}clone(){let e=new D(this.filePath);return e.exists=this.exists,e.status=this.status,e.statusText=this.statusText,e.headers=new Headers(this.headers),e}async arrayBuffer(){return(await N.promises.readFile(this.filePath)).buffer}async blob(){const e=await N.promises.readFile(this.filePath);return new Blob([e],{type:this.headers.get("content-type")})}async text(){return await N.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function L(e,t=null,n=null){let r;try{r=new URL(e)}catch(e){return!1}return!(t&&!t.includes(r.protocol))&&!(n&&!n.includes(r.hostname))}async function F(e){if(v.useFS&&!L(e,["http:","https:","blob:"]))return new D(e);if("undefined"!=typeof process&&"node"===process?.release?.name){const t=!!process.env?.TESTING_REMOTELY,n=v.version,r=new Headers;r.set("User-Agent",`transformers.js/${n}; is_ci/${t};`);if(L(e,["http:","https:"],["huggingface.co","hf.co"])){const e=process.env?.HF_TOKEN??process.env?.HF_ACCESS_TOKEN;e&&r.set("Authorization",`Bearer ${e}`)}return fetch(e,{headers:r})}return fetch(e)}const U={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};class q{constructor(e){this.path=e}async match(e){let t=P.join(this.path,e),n=new D(t);return n.exists?n:void 0}async put(e,t){const n=Buffer.from(await t.arrayBuffer());let r=P.join(this.path,e);try{await N.promises.mkdir(P.dirname(r),{recursive:!0}),await N.promises.writeFile(r,n)}catch(e){console.warn("An error occurred while writing the file to cache:",e)}}}async function V(e,t,n=!0,r={}){if(!v.allowLocalModels){if(r.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!v.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}let s;if(E(r.progress_callback,{status:"initiate",name:e,file:t}),!s&&v.useBrowserCache){if("undefined"==typeof caches)throw Error("Browser cache is not available in this environment.");try{s=await caches.open("transformers-cache")}catch(e){console.warn("An error occurred while opening the browser cache:",e)}}if(!s&&v.useFSCache&&(s=new q(r.cache_dir??v.cacheDir)),!s&&v.useCustomCache){if(!v.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");if(!v.customCache.match||!v.customCache.put)throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");s=v.customCache}const i=r.revision??"main";let a,o,l=j(e,t),u=j(v.localModelPath,l),d=j(v.remoteHost,v.remotePathTemplate.replaceAll("{model}",e).replaceAll("{revision}",encodeURIComponent(i)),t),c="main"===i?l:j(e,i,t),p=s instanceof q?c:d,h=!1;s&&(o=await async function f(e,...t){for(let n of t)try{let t=await e.match(n);if(t)return t}catch(e){continue}}(s,u,p));const m=void 0!==o;if(void 0===o){if(v.allowLocalModels){if(L(l,["http:","https:"])){if(r.local_files_only)throw new Error(`\\`local_files_only=true\\`, but attempted to load a remote file from: ${l}.`);if(!v.allowRemoteModels)throw new Error(`\\`env.allowRemoteModels=false\\`, but attempted to load a remote file from: ${l}.`)}else try{o=await F(u),a=u}catch(e){console.warn(`Unable to load from local path "${u}": "${e}"`)}}if(void 0===o||404===o.status){if(r.local_files_only||!v.allowRemoteModels){if(n)throw Error(`\\`local_files_only=true\\` or \\`env.allowRemoteModels=false\\` and file was not found locally at "${u}".`);return null}if(o=await F(d),200!==o.status)return function e(t,n,r){if(!r)return null;const s=U[t]??`Error (${t}) occurred while trying to load file`;throw Error(`${s}: "${n}".`)}(o.status,d,n);a=p}h=s&&"undefined"!=typeof Response&&o instanceof Response&&200===o.status}let _;return E(r.progress_callback,{status:"download",name:e,file:t}),r.progress_callback?m&&"undefined"!=typeof navigator&&/firefox/i.test(navigator.userAgent)?(_=new Uint8Array(await o.arrayBuffer()),E(r.progress_callback,{status:"progress",name:e,file:t,progress:100,loaded:_.length,total:_.length})):_=await async function g(e,t){const n=e.headers.get("Content-Length");null===n&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let r=parseInt(n??"0"),s=new Uint8Array(r),i=0;const a=e.body.getReader();async function o(){const{done:e,value:n}=await a.read();if(e)return;let l=i+n.length;if(l>r){r=l;let e=new Uint8Array(r);e.set(s),s=e}s.set(n,i),i=l;return t({progress:i/r*100,loaded:i,total:r}),o()}return await o(),s}(o,(n=>{E(r.progress_callback,{status:"progress",name:e,file:t,...n})})):_=new Uint8Array(await o.arrayBuffer()),h&&a&&void 0===await s.match(a)&&await s.put(a,new Response(_,{headers:o.headers})).catch((e=>{console.warn(`Unable to add response to browser cache: ${e}.`)})),E(r.progress_callback,{status:"done",name:e,file:t}),_}async function W(e,t,n=!0,r={}){let s=await V(e,t,n,r);if(null===s)return{};let i=new TextDecoder("utf-8").decode(s);return JSON.parse(i)}function j(...e){return(e=e.map(((t,n)=>(n&&(t=t.replace(new RegExp("^/"),"")),n!==e.length-1&&(t=t.replace(new RegExp("/$"),"")),t)))).join("/")}function G(e){const t=X(e)[0],n=e.map((e=>Math.exp(e-t))),r=n.reduce(((e,t)=>e+t),0);return n.map((e=>e/r))}function H(e){const t=X(e)[0];let n=0;for(let r=0;r<e.length;++r)n+=Math.exp(e[r]-t);const r=Math.log(n);return e.map((e=>e-t-r))}function K(e){if(0===e.length)throw Error("Array must not be empty");let t=e[0],n=0;for(let r=1;r<e.length;++r)e[r]<t&&(t=e[r],n=r);return[t,n]}function X(e){if(0===e.length)throw Error("Array must not be empty");let t=e[0],n=0;for(let r=1;r<e.length;++r)e[r]>t&&(t=e[r],n=r);return[Number(t),n]}function Q(e){return e>0&&!(e&e-1)}class Y{constructor(e){if(this.size=0|e,this.size<=1||!Q(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=e<<1,this.table=new Float64Array(2*this.size);for(let e=0;e<this.table.length;e+=2){const t=Math.PI*e/this.size;this.table[e]=Math.cos(t),this.table[e+1]=-Math.sin(t)}let t=0;for(let e=1;this.size>e;e<<=1)++t;this._width=t%2==0?t-1:t,this._bitrev=new Int32Array(1<<this._width);for(let e=0;e<this._bitrev.length;++e){this._bitrev[e]=0;for(let t=0;t<this._width;t+=2){const n=this._width-t-2;this._bitrev[e]|=(e>>>t&3)<<n}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(e,t){const n=t||new Array(e.length>>>1);for(let t=0;t<e.length;t+=2)n[t>>>1]=e[t];return n}toComplexArray(e,t){const n=t||this.createComplexArray();for(let t=0;t<n.length;t+=2)n[t]=e[t>>>1],n[t+1]=0;return n}transform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._transform4(e,t,1)}realTransform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._realTransform4(e,t,1)}inverseTransform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._transform4(e,t,-1);for(let t=0;t<e.length;++t)e[t]/=this.size}_transform4(e,t,n){const r=this._csize;let s,i,a=1<<this._width,o=r/a<<1;const l=this._bitrev;if(4===o)for(s=0,i=0;s<r;s+=o,++i){const n=l[i];this._singleTransform2(t,e,s,n,a)}else for(s=0,i=0;s<r;s+=o,++i){const r=l[i];this._singleTransform4(t,e,s,r,a,n)}const u=this.table;for(a>>=2;a>=2;a>>=2){o=r/a<<1;const t=o>>>2;for(s=0;s<r;s+=o){const r=s+t-1;for(let i=s,o=0;i<r;i+=2,o+=a){const r=i,s=r+t,a=s+t,l=a+t,d=e[r],c=e[r+1],p=e[s],h=e[s+1],f=e[a],m=e[a+1],_=e[l],g=e[l+1],w=u[o],y=n*u[o+1],b=p*w-h*y,x=p*y+h*w,v=u[2*o],$=n*u[2*o+1],k=f*v-m*$,E=f*$+m*v,S=u[3*o],z=n*u[3*o+1],C=_*S-g*z,T=_*z+g*S,A=d+k,I=c+E,M=d-k,O=c-E,B=b+C,N=x+T,P=n*(b-C),R=n*(x-T);e[r]=A+B,e[r+1]=I+N,e[s]=M+R,e[s+1]=O-P,e[a]=A-B,e[a+1]=I-N,e[l]=M-R,e[l+1]=O+P}}}}_singleTransform2(e,t,n,r,s){const i=e[r],a=e[r+1],o=e[r+s],l=e[r+s+1];t[n]=i+o,t[n+1]=a+l,t[n+2]=i-o,t[n+3]=a-l}_singleTransform4(e,t,n,r,s,i){const a=2*s,o=3*s,l=e[r],u=e[r+1],d=e[r+s],c=e[r+s+1],p=e[r+a],h=e[r+a+1],f=e[r+o],m=e[r+o+1],_=l+p,g=u+h,w=l-p,y=u-h,b=d+f,x=c+m,v=i*(d-f),$=i*(c-m);t[n]=_+b,t[n+1]=g+x,t[n+2]=w+$,t[n+3]=y-v,t[n+4]=_-b,t[n+5]=g-x,t[n+6]=w-$,t[n+7]=y+v}_realTransform4(e,t,n){const r=this._csize;let s,i,a=1<<this._width,o=r/a<<1;const l=this._bitrev;if(4===o)for(s=0,i=0;s<r;s+=o,++i){const n=l[i];this._singleRealTransform2(t,e,s,n>>>1,a>>>1)}else for(s=0,i=0;s<r;s+=o,++i){const r=l[i];this._singleRealTransform4(t,e,s,r>>>1,a>>>1,n)}const u=this.table;for(a>>=2;a>=2;a>>=2){o=r/a<<1;const t=o>>>1,i=t>>>1,l=i>>>1;for(s=0;s<r;s+=o)for(let r=0,o=0;r<=l;r+=2,o+=a){const a=s+r,d=a+i,c=d+i,p=c+i,h=e[a],f=e[a+1],m=e[d],_=e[d+1],g=e[c],w=e[c+1],y=e[p],b=e[p+1],x=h,v=f,$=u[o],k=n*u[o+1],E=m*$-_*k,S=m*k+_*$,z=u[2*o],C=n*u[2*o+1],T=g*z-w*C,A=g*C+w*z,I=u[3*o],M=n*u[3*o+1],O=y*I-b*M,B=y*M+b*I,N=x+T,P=v+A,R=x-T,D=v-A,L=E+O,F=S+B,U=n*(E-O),q=n*(S-B);if(e[a]=N+L,e[a+1]=P+F,e[d]=R+q,e[d+1]=D-U,0===r){e[c]=N-L,e[c+1]=P-F;continue}if(r===l)continue;const V=s+i-r,W=s+t-r;e[V]=R-n*q,e[V+1]=-D-n*U,e[W]=N-n*L,e[W+1]=n*F-P}}const d=r>>>1;for(let t=2;t<d;t+=2)e[r-t]=e[t],e[r-t+1]=-e[t+1]}_singleRealTransform2(e,t,n,r,s){const i=e[r],a=e[r+s];t[n]=i+a,t[n+1]=0,t[n+2]=i-a,t[n+3]=0}_singleRealTransform4(e,t,n,r,s,i){const a=2*s,o=3*s,l=e[r],u=e[r+s],d=e[r+a],c=e[r+o],p=l+d,h=l-d,f=u+c,m=i*(u-c);t[n]=p+f,t[n+1]=0,t[n+2]=h,t[n+3]=-m,t[n+4]=p-f,t[n+5]=0,t[n+6]=h,t[n+7]=m}}class Z{constructor(e){const t=2*(e-1),n=2*(2*e-1),r=2**Math.ceil(Math.log2(n));this.bufferSize=r,this._a=t;const s=new Float64Array(n),i=new Float64Array(r);this._chirpBuffer=new Float64Array(r),this._buffer1=new Float64Array(r),this._buffer2=new Float64Array(r),this._outBuffer1=new Float64Array(r),this._outBuffer2=new Float64Array(r);const a=-2*Math.PI/e,o=Math.cos(a),l=Math.sin(a);for(let t=0;t<n>>1;++t){const n=(t+1-e)**2/2,r=Math.sqrt(o**2+l**2)**n,a=n*Math.atan2(l,o),u=2*t;s[u]=r*Math.cos(a),s[u+1]=r*Math.sin(a),i[u]=s[u],i[u+1]=-s[u+1]}this._slicedChirpBuffer=s.subarray(t,n),this._f=new Y(r>>1),this._f.transform(this._chirpBuffer,i)}_transform(e,t,n){const r=this._buffer1,s=this._buffer2,i=this._outBuffer1,a=this._outBuffer2,o=this._chirpBuffer,l=this._slicedChirpBuffer,u=this._a;if(n)for(let e=0;e<l.length;e+=2){const n=e+1,s=t[e>>1];r[e]=s*l[e],r[n]=s*l[n]}else for(let e=0;e<l.length;e+=2){const n=e+1;r[e]=t[e]*l[e]-t[n]*l[n],r[n]=t[e]*l[n]+t[n]*l[e]}this._f.transform(i,r);for(let e=0;e<o.length;e+=2){const t=e+1;s[e]=i[e]*o[e]-i[t]*o[t],s[t]=i[e]*o[t]+i[t]*o[e]}this._f.inverseTransform(a,s);for(let t=0;t<a.length;t+=2){const n=a[t+u],r=a[t+u+1],s=l[t],i=l[t+1];e[t]=n*s-r*i,e[t+1]=n*i+r*s}}transform(e,t){this._transform(e,t,!1)}realTransform(e,t){this._transform(e,t,!0)}}class J{constructor(e){this.fft_length=e,this.isPowerOfTwo=Q(e),this.isPowerOfTwo?(this.fft=new Y(e),this.outputBufferSize=2*e):(this.fft=new Z(e),this.outputBufferSize=this.fft.bufferSize)}realTransform(e,t){this.fft.realTransform(e,t)}transform(e,t){this.fft.transform(e,t)}}function ee(e,t){if(t%2==0||t<=0)throw new Error("Window size must be a positive odd number");const n=new e.constructor(e.length),r=new e.constructor(t),s=Math.floor(t/2);for(let t=0;t<e.length;++t){let i=0;for(let n=-s;n<=s;++n){let s=t+n;s<0?s=Math.abs(s):s>=e.length&&(s=2*(e.length-1)-s),r[i++]=e[s]}r.sort(),n[t]=r[s]}return n}function te(e,t){const n=Math.pow(10,t);return Math.round(e*n)/n}function ne(e){const t=e.length,n=e[0].length,r=[t+1,n+1],s=Array.from({length:r[0]},(()=>Array(r[1]).fill(Infinity)));s[0][0]=0;const i=Array.from({length:r[0]},(()=>Array(r[1]).fill(-1)));for(let t=1;t<r[1];++t)for(let n=1;n<r[0];++n){const r=s[n-1][t-1],a=s[n-1][t],o=s[n][t-1];let l,u;r<a&&r<o?(l=r,u=0):a<r&&a<o?(l=a,u=1):(l=o,u=2),s[n][t]=e[n-1][t-1]+l,i[n][t]=u}for(let e=0;e<r[1];++e)i[0][e]=2;for(let e=0;e<r[0];++e)i[e][0]=1;let a=t,o=n,l=[],u=[];for(;a>0||o>0;)switch(l.push(a-1),u.push(o-1),i[a][o]){case 0:--a,--o;break;case 1:--a;break;case 2:--o;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${a}, ${o}]. Please file a bug report.`)}return l.reverse(),u.reverse(),[l,u]}var re,se,ie,ae,oe,le,ue,de,ce,pe,he,fe,me,_e,ge,we,ye,be,xe,ve,$e,ke,Ee,Se,ze,Ce,Te,Ae,Ie,Me,Oe,Be,Ne=s(193),Pe=s.t(Ne,2),Re=Object.defineProperty,De=Object.getOwnPropertyDescriptor,Le=Object.getOwnPropertyNames,Fe=Object.prototype.hasOwnProperty,Ue=(re=function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error(\'Dynamic require of "\'+e+\'" is not supported\')},typeof require<"u"?require:typeof Proxy<"u"?new Proxy(re,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):re),qe=(e,t)=>()=>(e&&(t=e(e=0)),t),Ve=(e,t)=>{for(var n in t)Re(e,n,{get:t[n],enumerable:!0})},We=e=>((e,t,n,r)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let s of Le(t))!Fe.call(e,s)&&s!==n&&Re(e,s,{get:()=>t[s],enumerable:!(r=De(t,s))||r.enumerable});return e})(Re({},"__esModule",{value:!0}),e),je=qe((()=>{se=new Map,ie=[],ae=(e,t,n)=>{if(!t||"function"!=typeof t.init||"function"!=typeof t.createInferenceSessionHandler)throw new TypeError("not a valid backend");{let r=se.get(e);if(void 0===r)se.set(e,{backend:t,priority:n});else{if(r.priority>n)return;if(r.priority===n&&r.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){let t=ie.indexOf(e);-1!==t&&ie.splice(t,1);for(let t=0;t<ie.length;t++)if(se.get(ie[t]).priority<=n)return void ie.splice(t,0,e);ie.push(e)}}},oe=async e=>{let t=se.get(e);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let n=!!t.initPromise;try{return n||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(e){return n||(t.error=`${e}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},le=async e=>{let t,n=e.executionProviders||[],r=n.map((e=>"string"==typeof e?e:e.name)),s=0===r.length?ie:r,i=[],a=new Set;for(let e of s){let n=await oe(e);"string"==typeof n?i.push({name:e,err:n}):(t||(t=n),t===n&&a.add(e))}if(!t)throw new Error(`no available backend found. ERR: ${i.map((e=>`[${e.name}] ${e.err}`)).join(", ")}`);for(let{name:e,err:t}of i)r.includes(e)&&console.warn(`removing requested execution provider "${e}" from session options because it is not available: ${t}`);let o=n.filter((e=>a.has("string"==typeof e?e:e.name)));return[t,new Proxy(e,{get:(e,t)=>"executionProviders"===t?o:Reflect.get(e,t)})]}})),Ge=qe((()=>{je()})),He=qe((()=>{ue="1.21.0-dev.20241205-6ed77cc374"})),Ke=qe((()=>{He(),de="warning",ce={wasm:{},webgl:{},webgpu:{},versions:{common:ue},set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);de=e}},get logLevel(){return de}},Object.defineProperty(ce,"logLevel",{enumerable:!0})})),Xe=qe((()=>{Ke(),pe=ce})),Qe=qe((()=>{he=(e,t)=>{let n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];let r=n.getContext("2d");if(null!=r){let s,i;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(s=e.dims[2],i=e.dims[3]):(s=e.dims[3],i=e.dims[2]);let a,o,l=void 0!==t?.format?t.format:"RGB",u=t?.norm;void 0===u||void 0===u.mean?a=[255,255,255,255]:"number"==typeof u.mean?a=[u.mean,u.mean,u.mean,u.mean]:(a=[u.mean[0],u.mean[1],u.mean[2],0],void 0!==u.mean[3]&&(a[3]=u.mean[3])),void 0===u||void 0===u.bias?o=[0,0,0,0]:"number"==typeof u.bias?o=[u.bias,u.bias,u.bias,u.bias]:(o=[u.bias[0],u.bias[1],u.bias[2],0],void 0!==u.bias[3]&&(o[3]=u.bias[3]));let d=i*s,c=0,p=d,h=2*d,f=-1;"RGBA"===l?(c=0,p=d,h=2*d,f=3*d):"RGB"===l?(c=0,p=d,h=2*d):"RBG"===l&&(c=0,h=d,p=2*d);for(let t=0;t<i;t++)for(let n=0;n<s;n++){let s=(e.data[c++]-o[0])*a[0],i=(e.data[p++]-o[1])*a[1],l=(e.data[h++]-o[2])*a[2],u=-1===f?255:(e.data[f++]-o[3])*a[3];r.fillStyle="rgba("+s+","+i+","+l+","+u+")",r.fillRect(n,t,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}throw new Error("Can not access image data")},fe=(e,t)=>{let n,r=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");if(null==r)throw new Error("Can not access image data");{let s,i,a;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(s=e.dims[2],i=e.dims[1],a=e.dims[3]):(s=e.dims[3],i=e.dims[2],a=e.dims[1]);let o,l,u=void 0!==t&&void 0!==t.format?t.format:"RGB",d=t?.norm;void 0===d||void 0===d.mean?o=[255,255,255,255]:"number"==typeof d.mean?o=[d.mean,d.mean,d.mean,d.mean]:(o=[d.mean[0],d.mean[1],d.mean[2],255],void 0!==d.mean[3]&&(o[3]=d.mean[3])),void 0===d||void 0===d.bias?l=[0,0,0,0]:"number"==typeof d.bias?l=[d.bias,d.bias,d.bias,d.bias]:(l=[d.bias[0],d.bias[1],d.bias[2],0],void 0!==d.bias[3]&&(l[3]=d.bias[3]));let c=i*s;if(void 0!==t&&(void 0!==t.format&&4===a&&"RGBA"!==t.format||3===a&&"RGB"!==t.format&&"BGR"!==t.format))throw new Error("Tensor format doesn\'t match input tensor dims");let p=4,h=0,f=1,m=2,_=3,g=0,w=c,y=2*c,b=-1;"RGBA"===u?(g=0,w=c,y=2*c,b=3*c):"RGB"===u?(g=0,w=c,y=2*c):"RBG"===u&&(g=0,y=c,w=2*c),n=r.createImageData(s,i);for(let t=0;t<i*s;h+=p,f+=p,m+=p,_+=p,t++)n.data[h]=(e.data[g++]-l[0])*o[0],n.data[f]=(e.data[w++]-l[1])*o[1],n.data[m]=(e.data[y++]-l[2])*o[2],n.data[_]=-1===b?255:(e.data[b++]-l[3])*o[3]}return n}})),Ye=qe((()=>{et(),me=(e,t)=>{if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");let n,r,{height:s,width:i}=t,a=t.norm??{mean:255,bias:0};n="number"==typeof a.mean?[a.mean,a.mean,a.mean,a.mean]:[a.mean[0],a.mean[1],a.mean[2],a.mean[3]??255],r="number"==typeof a.bias?[a.bias,a.bias,a.bias,a.bias]:[a.bias[0],a.bias[1],a.bias[2],a.bias[3]??0];let o=void 0!==t.format?t.format:"RGBA",l=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",u=s*i,d="RGBA"===l?new Float32Array(4*u):new Float32Array(3*u),c=4,p=0,h=1,f=2,m=3,_=0,g=u,w=2*u,y=-1;"RGB"===o&&(c=3,p=0,h=1,f=2,m=-1),"RGBA"===l?y=3*u:"RBG"===l?(_=0,w=u,g=2*u):"BGR"===l&&(w=0,g=u,_=2*u);for(let t=0;t<u;t++,p+=c,f+=c,h+=c,m+=c)d[_++]=(e[p]+r[0])/n[0],d[g++]=(e[h]+r[1])/n[1],d[w++]=(e[f]+r[2])/n[2],-1!==y&&-1!==m&&(d[y++]=(e[m]+r[3])/n[3]);return new ze("float32",d,"RGBA"===l?[1,4,s,i]:[1,3,s,i])},_e=async(e,t)=>{let n,r=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,s=typeof ImageData<"u"&&e instanceof ImageData,i=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,a="string"==typeof e,o=t??{},l=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},u=e=>typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas?e.getContext("2d"):null;if(r){let r=l();r.width=e.width,r.height=e.height;let s=u(r);if(null==s)throw new Error("Can not access image data");{let r=e.height,i=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(r=t.resizedHeight,i=t.resizedWidth),void 0!==t){if(o=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");o.tensorFormat="RGBA",o.height=r,o.width=i}else o.tensorFormat="RGBA",o.height=r,o.width=i;s.drawImage(e,0,0),n=s.getImageData(0,0,i,r).data}}else{if(!s){if(i){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");let r=l();r.width=e.width,r.height=e.height;let s=u(r);if(null!=s){let t=e.height,r=e.width;return s.drawImage(e,0,0,r,t),n=s.getImageData(0,0,r,t).data,o.height=t,o.width=r,me(n,o)}throw new Error("Can not access image data")}if(a)return new Promise(((t,n)=>{let r=l(),s=u(r);if(!e||!s)return n();let i=new Image;i.crossOrigin="Anonymous",i.src=e,i.onload=()=>{r.width=i.width,r.height=i.height,s.drawImage(i,0,0,r.width,r.height);let e=s.getImageData(0,0,r.width,r.height);o.height=r.height,o.width=r.width,t(me(e.data,o))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{let r,s;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(r=t.resizedHeight,s=t.resizedWidth):(r=e.height,s=e.width),void 0!==t&&(o=t),o.format="RGBA",o.height=r,o.width=s,void 0!==t){let t=l();t.width=s,t.height=r;let i=u(t);if(null==i)throw new Error("Can not access image data");i.putImageData(e,0,0),n=i.getImageData(0,0,s,r).data}else n=e.data}}if(void 0!==n)return me(n,o);throw new Error("Input data provided is not supported - aborted tensor creation")},ge=(e,t)=>{let{width:n,height:r,download:s,dispose:i}=t;return new ze({location:"texture",type:"float32",texture:e,dims:[1,r,n,4],download:s,dispose:i})},we=(e,t)=>{let{dataType:n,dims:r,download:s,dispose:i}=t;return new ze({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:r,download:s,dispose:i})},ye=(e,t)=>{let{dataType:n,dims:r,download:s,dispose:i}=t;return new ze({location:"ml-tensor",type:n??"float32",mlTensor:e,dims:r,download:s,dispose:i})},be=(e,t,n)=>new ze({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]})})),Ze=qe((()=>{xe=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),ve=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),$e=!1,ke=()=>{if(!$e){$e=!0;let e=typeof BigInt64Array<"u"&&BigInt64Array.from,t=typeof BigUint64Array<"u"&&BigUint64Array.from,n=typeof Float16Array<"u"&&Float16Array.from;e&&(xe.set("int64",BigInt64Array),ve.set(BigInt64Array,"int64")),t&&(xe.set("uint64",BigUint64Array),ve.set(BigUint64Array,"uint64")),n?(xe.set("float16",Float16Array),ve.set(Float16Array,"float16")):xe.set("float16",Uint16Array)}}})),Je=qe((()=>{et(),Ee=e=>{let t=1;for(let n=0;n<e.length;n++){let r=e[n];if("number"!=typeof r||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t},Se=(e,t)=>{switch(e.location){case"cpu":return new ze(e.type,e.data,t);case"cpu-pinned":return new ze({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new ze({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new ze({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new ze({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}})),et=qe((()=>{Qe(),Ye(),Ze(),Je(),ze=class{constructor(e,t,n){let r,s;if(ke(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,r=e.type,s=e.dims,e.location){case"cpu-pinned":{let t=xe.get(r);if(!t)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw new TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"uint8"!==r&&"bool"!==r&&"uint4"!==r&&"int4"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;case"ml-tensor":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"uint64"!==r&&"int8"!==r&&"uint8"!==r&&"bool"!==r&&"uint4"!==r&&"int4"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break;default:throw new Error(`Tensor constructor: unsupported location \'${this.dataLocation}\'`)}else{let i,a;if("string"==typeof e)if(r=e,a=n,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor\'s data must be a string array.");i=t}else{let n=xe.get(e);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e&&n===Uint16Array||"uint4"===e||"int4"===e)throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${n.name} as data.`);i="uint64"===e||"int64"===e?n.from(t,BigInt):n.from(t)}else if(t instanceof n)i=t;else{if(!(t instanceof Uint8ClampedArray))throw new TypeError(`A ${r} tensor\'s data must be type of ${n}`);if("uint8"!==e)throw new TypeError("A Uint8ClampedArray tensor\'s data must be type of uint8");i=Uint8Array.from(t)}}else if(a=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");let t=typeof e[0];if("string"===t)r="string",i=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);r="bool",i=Uint8Array.from(e)}}else if(e instanceof Uint8ClampedArray)r="uint8",i=Uint8Array.from(e);else{let t=ve.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=t,i=e}if(void 0===a)a=[i.length];else if(!Array.isArray(a))throw new TypeError("A tensor\'s dims must be a number array");s=a,this.cpuData=i,this.dataLocation="cpu"}let i=Ee(s);if(this.cpuData&&i!==this.cpuData.length&&("uint4"!==r&&"int4"!==r||Math.ceil(i/2)!==this.cpuData.length))throw new Error(`Tensor\'s size(${i}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=s,this.size=i}static async fromImage(e,t){return _e(e,t)}static fromTexture(e,t){return ge(e,t)}static fromGpuBuffer(e,t){return we(e,t)}static fromMLTensor(e,t){return ye(e,t)}static fromPinnedBuffer(e,t,n){return be(e,t,n)}toDataURL(e){return he(this,e)}toImageData(e){return fe(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return Se(this,e)}}})),tt=qe((()=>{et(),Ce=ze})),nt=qe((()=>{Ke(),Te=(e,t)=>{(typeof ce.trace>"u"?!ce.wasm.trace:!ce.trace)||console.timeStamp(`${e}::ORT::${t}`)},Ae=(e,t)=>{let n=(new Error).stack?.split(/\\r\\n|\\r|\\n/g)||[],r=!1;for(let s=0;s<n.length;s++){if(r&&!n[s].includes("TRACE_FUNC")){let r=`FUNC_${e}::${n[s].trim().split(" ")[1]}`;return t&&(r+=`::${t}`),void Te("CPU",r)}n[s].includes("TRACE_FUNC")&&(r=!0)}},Ie=e=>{(typeof ce.trace>"u"?!ce.wasm.trace:!ce.trace)||Ae("BEGIN",e)},Me=e=>{(typeof ce.trace>"u"?!ce.wasm.trace:!ce.trace)||Ae("END",e)}})),rt=qe((()=>{je(),tt(),nt(),Oe=class e{constructor(e){this.handler=e}async run(e,t,n){Ie();let r={},s={};if("object"!=typeof e||null===e||e instanceof Ce||Array.isArray(e))throw new TypeError("\'feeds\' must be an object that use input names as keys and OnnxValue as corresponding values.");let i=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof Ce)throw new TypeError("\'fetches\' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("\'fetches\' cannot be an empty array.");i=!1;for(let e of t){if("string"!=typeof e)throw new TypeError("\'fetches\' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`\'fetches\' contains invalid output name: ${e}.`);r[e]=null}if("object"==typeof n&&null!==n)s=n;else if(typeof n<"u")throw new TypeError("\'options\' must be an object.")}else{let e=!1,a=Object.getOwnPropertyNames(t);for(let n of this.outputNames)if(-1!==a.indexOf(n)){let s=t[n];(null===s||s instanceof Ce)&&(e=!0,i=!1,r[n]=s)}if(e){if("object"==typeof n&&null!==n)s=n;else if(typeof n<"u")throw new TypeError("\'options\' must be an object.")}else s=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be \'fetches\' or \'options\'.");for(let t of this.inputNames)if(typeof e[t]>"u")throw new Error(`input \'${t}\' is missing in \'feeds\'.`);if(i)for(let e of this.outputNames)r[e]=null;let a=await this.handler.run(e,r,s),o={};for(let e in a)if(Object.hasOwnProperty.call(a,e)){let t=a[e];o[e]=t instanceof Ce?t:new Ce(t.type,t.data,t.dims)}return Me(),o}async release(){return this.handler.dispose()}static async create(t,n,r,s){Ie();let i,a={};if("string"==typeof t){if(i=t,"object"==typeof n&&null!==n)a=n;else if(typeof n<"u")throw new TypeError("\'options\' must be an object.")}else if(t instanceof Uint8Array){if(i=t,"object"==typeof n&&null!==n)a=n;else if(typeof n<"u")throw new TypeError("\'options\' must be an object.")}else{if(!(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be \'path\' or \'buffer\'.");{let e=t,o=0,l=t.byteLength;if("object"==typeof n&&null!==n)a=n;else if("number"==typeof n){if(o=n,!Number.isSafeInteger(o))throw new RangeError("\'byteOffset\' must be an integer.");if(o<0||o>=e.byteLength)throw new RangeError(`\'byteOffset\' is out of range [0, ${e.byteLength}).`);if(l=t.byteLength-o,"number"==typeof r){if(l=r,!Number.isSafeInteger(l))throw new RangeError("\'byteLength\' must be an integer.");if(l<=0||o+l>e.byteLength)throw new RangeError(`\'byteLength\' is out of range (0, ${e.byteLength-o}].`);if("object"==typeof s&&null!==s)a=s;else if(typeof s<"u")throw new TypeError("\'options\' must be an object.")}else if(typeof r<"u")throw new TypeError("\'byteLength\' must be a number.")}else if(typeof n<"u")throw new TypeError("\'options\' must be an object.");i=new Uint8Array(e,o,l)}}let[o,l]=await le(a),u=await o.createInferenceSessionHandler(i,l);return Me(),new e(u)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}})),st=qe((()=>{rt(),Be=Oe})),it=qe((()=>{})),at=qe((()=>{})),ot=qe((()=>{})),lt=qe((()=>{})),ut={};Ve(ut,{InferenceSession:()=>Be,TRACE:()=>Te,TRACE_FUNC_BEGIN:()=>Ie,TRACE_FUNC_END:()=>Me,Tensor:()=>Ce,env:()=>pe,registerBackend:()=>ae});var dt=qe((()=>{Ge(),Xe(),st(),tt(),it(),at(),nt(),ot(),lt()})),ct=qe((()=>{})),pt={};Ve(pt,{default:()=>mt});var ht,ft,mt,_t=qe((()=>{Yc(),Yu(),Qu(),ht="ort-wasm-proxy-worker",(ft=globalThis.self?.name===ht)&&(self.onmessage=e=>{let{type:t,in:n}=e.data;try{switch(t){case"init-wasm":Nt(n.wasm).then((()=>{wc(n).then((()=>{postMessage({type:t})}),(e=>{postMessage({type:t,err:e})}))}),(e=>{postMessage({type:t,err:e})}));break;case"init-ep":{let{epName:e,env:r}=n;yc(r,e).then((()=>{postMessage({type:t})}),(e=>{postMessage({type:t,err:e})}));break}case"copy-from":{let{buffer:e}=n,r=vc(e);postMessage({type:t,out:r});break}case"create":{let{model:e,options:r}=n;$c(e,r).then((e=>{postMessage({type:t,out:e})}),(e=>{postMessage({type:t,err:e})}));break}case"release":kc(n),postMessage({type:t});break;case"run":{let{sessionId:e,inputIndices:r,inputs:s,outputIndices:i,options:a}=n;Sc(e,r,s,i,new Array(i.length).fill(null),a).then((e=>{e.some((e=>"cpu"!==e[3]))?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:e},Cc([...s,...e]))}),(e=>{postMessage({type:t,err:e})}));break}case"end-profiling":zc(n),postMessage({type:t})}}catch(e){postMessage({type:t,err:e})}}),mt=ft?null:e=>new Worker(e??xt,{type:"module",name:ht})})),gt={};Ve(gt,{default:()=>bt});var wt,yt,bt,xt,vt,$t,kt,Et,St,zt,Ct,Tt,At,It,Mt,Ot,Bt,Nt,Pt,Rt,Dt,Lt,Ft,Ut,qt,Vt,Wt,jt,Gt,Ht,Kt,Xt,Qt,Yt,Zt,Jt,en,tn,nn,rn,sn,an,on,ln,un,dn,cn,pn,hn,fn,mn,_n,gn,wn,yn,bn,xn,vn,$n,kn,En,Sn,zn,Cn,Tn,An,In,Mn,On,Bn,Nn,Pn,Rn,Dn,Ln,Fn,Un,qn,Vn,Wn,jn,Gn,Hn,Kn,Xn,Qn,Yn,Zn,Jn,er,tr,nr,rr,sr,ir,ar,or,lr,ur,dr,cr,pr,hr,fr,mr,_r,gr,wr,yr,br,xr,vr,$r,kr,Er,Sr,zr,Cr,Tr,Ar,Ir,Mr,Or,Br,Nr,Pr,Rr,Dr,Lr,Fr,Ur,qr,Vr,Wr,jr,Gr,Hr,Kr,Xr,Qr,Yr,Zr,Jr,es,ts,ns,rs,ss,is,as,os,ls,us,ds,cs,ps,hs,fs,ms,_s,gs,ws,ys,bs,xs,vs,$s,ks,Es,Ss,zs,Cs,Ts,As,Is,Ms,Os,Bs,Ns,Ps,Rs,Ds,Ls,Fs,Us,qs,Vs,Ws,js,Gs,Hs,Ks,Xs,Qs,Ys,Zs,Js,ei,ti,ni,ri,si,ii,ai,oi,li,ui,di,ci,pi,hi,fi,mi,_i,gi,wi,yi,bi,xi,vi,$i,ki,Ei,Si,zi,Ci,Ti,Ai,Ii,Mi,Oi,Bi,Ni,Pi,Ri,Di,Li,Fi,Ui,qi,Vi,Wi,ji,Gi,Hi,Ki,Xi,Qi,Yi,Zi,Ji,ea,ta,na,ra,sa,ia,aa,oa,la,ua,da,ca,pa,ha,fa,ma,_a,ga,wa,ya,ba,xa,va,$a,ka,Ea,Sa,za,Ca,Ta,Aa,Ia,Ma,Oa,Ba,Na,Pa,Ra,Da,La,Fa,Ua,qa,Va,Wa,ja,Ga,Ha,Ka,Xa,Qa,Ya,Za,Ja,eo,to,no,ro,so,io,ao,oo,lo,uo,co,po,ho,fo,mo,_o,go,wo,yo,bo,xo,vo,$o,ko,Eo,So,zo,Co,To,Ao,Io,Mo,Oo,Bo,No,Po,Ro,Do,Lo,Fo,Uo,qo,Vo,Wo,jo,Go,Ho,Ko,Xo,Qo,Yo,Zo,Jo,el,tl,nl,rl,sl,il,al,ol,ll,ul,dl,cl,pl,hl,fl,ml,_l,gl,wl,yl,bl,xl,vl,$l,kl,El,Sl,zl,Cl,Tl,Al,Il,Ml,Ol,Bl,Nl,Pl,Rl,Dl,Ll,Fl,Ul,ql,Vl,Wl,jl,Gl,Hl,Kl,Xl,Ql,Yl,Zl,Jl,eu,tu,nu,ru,su,iu,au,ou,lu,uu,du,cu,pu,hu,fu,mu,_u,gu,wu,yu,bu,xu,vu,$u,ku,Eu,Su,zu,Cu,Tu,Au,Iu,Mu,Ou,Bu,Nu,Pu,Ru,Du,Lu,Fu,Uu,qu,Vu,Wu,ju,Gu,Hu,Ku,Xu=qe((()=>{wt="file:///Users/sam-schaack/gamp/nuiq-asr/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs",yt=async function(e={}){function t(){return I.buffer!=B.buffer&&j(),B}function n(){return I.buffer!=B.buffer&&j(),N}function r(){return I.buffer!=B.buffer&&j(),P}function i(){return I.buffer!=B.buffer&&j(),R}function a(){return I.buffer!=B.buffer&&j(),D}function o(){return I.buffer!=B.buffer&&j(),L}function l(){return I.buffer!=B.buffer&&j(),F}function u(){return I.buffer!=B.buffer&&j(),V}var d,c,p=Object.assign({},e),h=new Promise(((e,t)=>{d=e,c=t})),f="object"==typeof window,m="function"==typeof importScripts,_=m&&"em-pthread"==self.name;p.mountExternalData=(e,t)=>{e.startsWith("./")&&(e=e.substring(2)),(p.Fb||(p.Fb=new Map)).set(e,t)},p.unmountExternalData=()=>{delete p.Fb};var g=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor;let w=()=>{let e=(e,t,n)=>(...r)=>{let s=Kt,i=t?.();r=e(...r);let a=t?.();return i!==a&&(e=a,n(i),t=n=null),Kt!=s?new Promise(((e,t)=>{en={resolve:e,reject:t}})):r},t=e=>async(...t)=>{try{if(p.Gb)throw Error("Session already started");let n=p.Gb={hc:t[0],errors:[]},r=await e(...t);if(p.Gb!==n)throw Error("Session mismatch");p.Hb?.flush();let s=n.errors;if(0<s.length){let e=await Promise.all(s);if(e=e.filter((e=>e)),0<e.length)throw Error(e.join("\\n"))}return r}finally{p.Gb=null}};p._OrtCreateSession=e(p._OrtCreateSession,(()=>p._OrtCreateSession),(e=>p._OrtCreateSession=e)),p._OrtRun=t(e(p._OrtRun,(()=>p._OrtRun),(e=>p._OrtRun=e))),p._OrtRunWithBinding=t(e(p._OrtRunWithBinding,(()=>p._OrtRunWithBinding),(e=>p._OrtRunWithBinding=e))),p._OrtBindInput=e(p._OrtBindInput,(()=>p._OrtBindInput),(e=>p._OrtBindInput=e)),w=void 0};p.jsepInit=(e,t)=>{if(w?.(),"webgpu"===e){[p.Hb,p.Vb,p.Zb,p.Ob,p.Yb,p.kb,p.$b,p.cc,p.Wb,p.Xb,p.ac]=t;let e=p.Hb;p.jsepRegisterBuffer=(t,n,r,s)=>e.registerBuffer(t,n,r,s),p.jsepGetBuffer=t=>e.getBuffer(t),p.jsepCreateDownloader=(t,n,r)=>e.createDownloader(t,n,r),p.jsepOnCreateSession=t=>{e.onCreateSession(t)},p.jsepOnReleaseSession=t=>{e.onReleaseSession(t)},p.jsepOnRunStart=t=>e.onRunStart(t),p.dc=(t,n)=>{e.upload(t,n)}}else if("webnn"===e){[p.Hb,p.bc,p.Pb,p.jsepEnsureTensor,p.ec,p.jsepDownloadTensor]=t,p.jsepReleaseTensorId=p.Pb;let e=p.Hb;p.jsepOnRunStart=t=>e.onRunStart(t),p.jsepRegisterMLContext=(t,n)=>{e.registerMLContext(t,n)},p.jsepOnReleaseSession=t=>{e.onReleaseSession(t)},p.jsepCreateMLTensorDownloader=(t,n)=>e.createMLTensorDownloader(t,n),p.jsepRegisterMLTensor=(t,n,r)=>e.registerMLTensor(t,n,r),p.jsepCreateMLContext=t=>e.createMLContext(t),p.jsepRegisterMLConstant=(t,n,r,s,i)=>e.registerMLConstant(t,n,r,s,i,p.Fb)}};var y,b,x=Object.assign({},p),v=(e,t)=>{throw t},$="";(f||m)&&(m?$=self.location.href:typeof document<"u"&&document.currentScript&&($=document.currentScript.src),wt&&($=wt),$=$.startsWith("blob:")?"":$.substr(0,$.replace(/[?#].*/,"").lastIndexOf("/")+1),m&&(b=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),y=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var k,E=console.log.bind(console),S=console.error.bind(console),z=E,C=S;if(Object.assign(p,x),x=null,_){let e=function(t){try{var n=t.data,r=n.cmd;if("load"===r){let t=[];self.onmessage=e=>t.push(e),self.startWorker=()=>{postMessage({cmd:"loaded"});for(let n of t)e(n);self.onmessage=e};for(let e of n.handlers)p[e]&&!p[e].proxy||(p[e]=(...t)=>{postMessage({Nb:"callHandler",pc:e,args:t})},"print"==e&&(z=p[e]),"printErr"==e&&(C=p[e]));I=n.wasmMemory,j(),T(n.wasmModule)}else if("run"===r){kr(n.pthread_ptr,0,0,1,0,0),Nt(n.pthread_ptr),Se(),ve(),A||(yr(),A=!0);try{ze(n.start_routine,n.arg)}catch(e){if("unwind"!=e)throw e}}else"cancel"===r?xr()&&Cr(-1):"setimmediate"!==n.target&&("checkMailbox"===r?A&&Pt():r&&(C(`worker: received unknown command ${r}`),C(n)))}catch(e){throw Er(),e}};var T,A=!1;C=function(...e){e=e.join(" "),console.error(e)},self.alert=function(...e){postMessage({Nb:"alert",text:e.join(" "),rc:xr()})},p.instantiateWasm=(e,t)=>new Promise((e=>{T=n=>{n=new WebAssembly.Instance(n,ie()),t(n),e()}})),self.onunhandledrejection=e=>{throw e.reason||e},self.onmessage=e}p.wasmBinary&&(k=p.wasmBinary);var I,M,O,B,N,P,R,D,L,F,U,q,V,W=!1;function j(){var e=I.buffer;p.HEAP8=B=new Int8Array(e),p.HEAP16=P=new Int16Array(e),p.HEAPU8=N=new Uint8Array(e),p.HEAPU16=R=new Uint16Array(e),p.HEAP32=D=new Int32Array(e),p.HEAPU32=L=new Uint32Array(e),p.HEAPF32=F=new Float32Array(e),p.HEAPF64=V=new Float64Array(e),p.HEAP64=U=new BigInt64Array(e),p.HEAPU64=q=new BigUint64Array(e)}if(!_){if(!((I=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0})).buffer instanceof g))throw C("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),Error("bad memory");j()}var G=[],H=[],K=[],X=0,Q=null,Y=null;function Z(){if(0==--X&&(null!==Q&&(clearInterval(Q),Q=null),Y)){var e=Y;Y=null,e()}}function J(e){throw C(e="Aborted("+e+")"),W=!0,O=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),c(e),e}var ee,te=e=>e.startsWith("data:application/octet-stream;base64,"),ne=e=>e.startsWith("file://");function re(e){if(e==ee&&k)return new Uint8Array(k);if(b)return b(e);throw"both async and sync fetching of the wasm failed"}function se(e,t,n){return function(e){if(!k&&(f||m)){if("function"==typeof fetch&&!ne(e))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw`failed to load wasm binary file at \'${e}\'`;return t.arrayBuffer()})).catch((()=>re(e)));if(y)return new Promise(((t,n)=>{y(e,(e=>t(new Uint8Array(e))),n)}))}return Promise.resolve().then((()=>re(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then(n,(e=>{C(`failed to asynchronously prepare wasm: ${e}`),J(e)}))}function ie(){return{a:{O:le,Aa:oe,b:Te,aa:Ie,B:Ne,qa:Pe,Y:Fe,_:Ue,ra:qe,oa:Ve,ha:We,na:je,L:Ge,Z:He,W:Ke,pa:Xe,X:Qe,va:Je,F:at,Q:lt,P:_t,E:yt,u:bt,q:xt,G:vt,A:At,R:It,ua:Mt,ka:Ot,U:Rt,ba:Lt,H:Ft,ja:Nt,ta:Ut,t:Wt,Ba:jt,x:rn,n:an,l:un,c:ct,o:cn,j:mn,w:_n,p:gn,f:wn,s:yn,m:bn,e:xn,k:vn,i:$n,h:kn,d:En,ea:Sn,fa:An,ga:In,ca:Mn,da:On,T:Bn,g:Rn,D:Dn,I:Ln,M:Fn,y:Un,sa:Vn,V:Wn,v:qn,z:jn,N:Gn,S:Hn,za:Yn,ya:Zn,la:nr,ma:rr,$:_e,C:sr,K:ir,ia:ar,J:lr,a:I,xa:fe,wa:pr,r:hr}}}var ae={874308:(e,t,r,s,i)=>{if(void 0===p||!p.Fb)return 1;if((e=Be(Number(e>>>0))).startsWith("./")&&(e=e.substring(2)),!(e=p.Fb.get(e)))return 2;if(t=Number(t>>>0),r=Number(r>>>0),s=Number(s>>>0),t+r>e.byteLength)return 3;try{let a=e.subarray(t,t+r);switch(i){case 0:n().set(a,s>>>0);break;case 1:p.dc(s,a);break;default:return 4}return 0}catch{return 4}},875023:(e,t,r)=>{p.ec(e,n().subarray(t>>>0,t+r>>>0))},875086:()=>p.bc(),875127:e=>{p.Pb(e)},875163:()=>{p.Wb()},875194:()=>{p.Xb()},875223:()=>{p.ac()},875248:e=>p.Vb(e),875281:e=>p.Zb(e),875313:(e,t,n)=>{p.Ob(Number(e),Number(t),Number(n),!0)},875376:(e,t,n)=>{p.Ob(Number(e),Number(t),Number(n))},875433:()=>typeof wasmOffsetConverter<"u",875490:e=>{p.kb("Abs",e,void 0)},875541:e=>{p.kb("Neg",e,void 0)},875592:e=>{p.kb("Floor",e,void 0)},875645:e=>{p.kb("Ceil",e,void 0)},875697:e=>{p.kb("Reciprocal",e,void 0)},875755:e=>{p.kb("Sqrt",e,void 0)},875807:e=>{p.kb("Exp",e,void 0)},875858:e=>{p.kb("Erf",e,void 0)},875909:e=>{p.kb("Sigmoid",e,void 0)},875964:(e,t,n)=>{p.kb("HardSigmoid",e,{alpha:t,beta:n})},876043:e=>{p.kb("Log",e,void 0)},876094:e=>{p.kb("Sin",e,void 0)},876145:e=>{p.kb("Cos",e,void 0)},876196:e=>{p.kb("Tan",e,void 0)},876247:e=>{p.kb("Asin",e,void 0)},876299:e=>{p.kb("Acos",e,void 0)},876351:e=>{p.kb("Atan",e,void 0)},876403:e=>{p.kb("Sinh",e,void 0)},876455:e=>{p.kb("Cosh",e,void 0)},876507:e=>{p.kb("Asinh",e,void 0)},876560:e=>{p.kb("Acosh",e,void 0)},876613:e=>{p.kb("Atanh",e,void 0)},876666:e=>{p.kb("Tanh",e,void 0)},876718:e=>{p.kb("Not",e,void 0)},876769:(e,t,n)=>{p.kb("Clip",e,{min:t,max:n})},876838:e=>{p.kb("Clip",e,void 0)},876890:(e,t)=>{p.kb("Elu",e,{alpha:t})},876948:e=>{p.kb("Gelu",e,void 0)},877e3:e=>{p.kb("Relu",e,void 0)},877052:(e,t)=>{p.kb("LeakyRelu",e,{alpha:t})},877116:(e,t)=>{p.kb("ThresholdedRelu",e,{alpha:t})},877186:(e,t)=>{p.kb("Cast",e,{to:t})},877244:e=>{p.kb("Add",e,void 0)},877295:e=>{p.kb("Sub",e,void 0)},877346:e=>{p.kb("Mul",e,void 0)},877397:e=>{p.kb("Div",e,void 0)},877448:e=>{p.kb("Pow",e,void 0)},877499:e=>{p.kb("Equal",e,void 0)},877552:e=>{p.kb("Greater",e,void 0)},877607:e=>{p.kb("GreaterOrEqual",e,void 0)},877669:e=>{p.kb("Less",e,void 0)},877721:e=>{p.kb("LessOrEqual",e,void 0)},877780:(e,t,n,r,s)=>{p.kb("ReduceMean",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},877955:(e,t,n,r,s)=>{p.kb("ReduceMax",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},878129:(e,t,n,r,s)=>{p.kb("ReduceMin",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},878303:(e,t,n,r,s)=>{p.kb("ReduceProd",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},878478:(e,t,n,r,s)=>{p.kb("ReduceSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},878652:(e,t,n,r,s)=>{p.kb("ReduceL1",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},878825:(e,t,n,r,s)=>{p.kb("ReduceL2",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},878998:(e,t,n,r,s)=>{p.kb("ReduceLogSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},879175:(e,t,n,r,s)=>{p.kb("ReduceSumSquare",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},879355:(e,t,n,r,s)=>{p.kb("ReduceLogSumExp",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},879535:e=>{p.kb("Where",e,void 0)},879588:(e,t,n)=>{p.kb("Transpose",e,{perm:t?Array.from(a().subarray(Number(t)>>>0,Number(n)>>>0)):[]})},879712:(e,t,n,r)=>{p.kb("DepthToSpace",e,{blocksize:t,mode:Be(n),format:r?"NHWC":"NCHW"})},879845:(e,t,n,r)=>{p.kb("DepthToSpace",e,{blocksize:t,mode:Be(n),format:r?"NHWC":"NCHW"})},879978:(e,n,r,s,i,o,l,u,d,c,h,f,m,_,g)=>{p.kb("ConvTranspose",e,{format:d?"NHWC":"NCHW",autoPad:n,dilations:[r],group:s,kernelShape:[i],pads:[o,l],strides:[u],wIsConst:()=>!!t()[c>>>0],outputPadding:h?Array.from(a().subarray(Number(h)>>>0,Number(f)>>>0)):[],outputShape:m?Array.from(a().subarray(Number(m)>>>0,Number(_)>>>0)):[],activation:Be(g)})},880411:(e,n,r,s,i,o,l,u,d,c,h,f,m,_)=>{p.kb("ConvTranspose",e,{format:u?"NHWC":"NCHW",autoPad:n,dilations:Array.from(a().subarray(Number(r)>>>0,2+(Number(r)>>>0)>>>0)),group:s,kernelShape:Array.from(a().subarray(Number(i)>>>0,2+(Number(i)>>>0)>>>0)),pads:Array.from(a().subarray(Number(o)>>>0,4+(Number(o)>>>0)>>>0)),strides:Array.from(a().subarray(Number(l)>>>0,2+(Number(l)>>>0)>>>0)),wIsConst:()=>!!t()[d>>>0],outputPadding:c?Array.from(a().subarray(Number(c)>>>0,Number(h)>>>0)):[],outputShape:f?Array.from(a().subarray(Number(f)>>>0,Number(m)>>>0)):[],activation:Be(_)})},881072:(e,n,r,s,i,o,l,u,d,c,h,f,m,_,g)=>{p.kb("ConvTranspose",e,{format:d?"NHWC":"NCHW",autoPad:n,dilations:[r],group:s,kernelShape:[i],pads:[o,l],strides:[u],wIsConst:()=>!!t()[c>>>0],outputPadding:h?Array.from(a().subarray(Number(h)>>>0,Number(f)>>>0)):[],outputShape:m?Array.from(a().subarray(Number(m)>>>0,Number(_)>>>0)):[],activation:Be(g)})},881505:(e,n,r,s,i,o,l,u,d,c,h,f,m,_)=>{p.kb("ConvTranspose",e,{format:u?"NHWC":"NCHW",autoPad:n,dilations:Array.from(a().subarray(Number(r)>>>0,2+(Number(r)>>>0)>>>0)),group:s,kernelShape:Array.from(a().subarray(Number(i)>>>0,2+(Number(i)>>>0)>>>0)),pads:Array.from(a().subarray(Number(o)>>>0,4+(Number(o)>>>0)>>>0)),strides:Array.from(a().subarray(Number(l)>>>0,2+(Number(l)>>>0)>>>0)),wIsConst:()=>!!t()[d>>>0],outputPadding:c?Array.from(a().subarray(Number(c)>>>0,Number(h)>>>0)):[],outputShape:f?Array.from(a().subarray(Number(f)>>>0,Number(m)>>>0)):[],activation:Be(_)})},882166:(e,t)=>{p.kb("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},882257:(e,t,n,r,s,i,o,l,u,d,c,h,f,m)=>{p.kb("AveragePool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:s,dilations:i?Array.from(a().subarray(Number(i)>>>0,Number(o)>>>0)):[],kernel_shape:l?Array.from(a().subarray(Number(l)>>>0,Number(u)>>>0)):[],pads:d?Array.from(a().subarray(Number(d)>>>0,Number(c)>>>0)):[],strides:h?Array.from(a().subarray(Number(h)>>>0,Number(f)>>>0)):[]})},882736:(e,t)=>{p.kb("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},882827:(e,t,n,r,s,i,o,l,u,d,c,h,f,m)=>{p.kb("AveragePool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:s,dilations:i?Array.from(a().subarray(Number(i)>>>0,Number(o)>>>0)):[],kernel_shape:l?Array.from(a().subarray(Number(l)>>>0,Number(u)>>>0)):[],pads:d?Array.from(a().subarray(Number(d)>>>0,Number(c)>>>0)):[],strides:h?Array.from(a().subarray(Number(h)>>>0,Number(f)>>>0)):[]})},883306:(e,t)=>{p.kb("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},883393:(e,t,n,r,s,i,o,l,u,d,c,h,f,m)=>{p.kb("MaxPool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:s,dilations:i?Array.from(a().subarray(Number(i)>>>0,Number(o)>>>0)):[],kernel_shape:l?Array.from(a().subarray(Number(l)>>>0,Number(u)>>>0)):[],pads:d?Array.from(a().subarray(Number(d)>>>0,Number(c)>>>0)):[],strides:h?Array.from(a().subarray(Number(h)>>>0,Number(f)>>>0)):[]})},883868:(e,t)=>{p.kb("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},883955:(e,t,n,r,s,i,o,l,u,d,c,h,f,m)=>{p.kb("MaxPool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:s,dilations:i?Array.from(a().subarray(Number(i)>>>0,Number(o)>>>0)):[],kernel_shape:l?Array.from(a().subarray(Number(l)>>>0,Number(u)>>>0)):[],pads:d?Array.from(a().subarray(Number(d)>>>0,Number(c)>>>0)):[],strides:h?Array.from(a().subarray(Number(h)>>>0,Number(f)>>>0)):[]})},884430:(e,t,n,r,s)=>{p.kb("Gemm",e,{alpha:t,beta:n,transA:r,transB:s})},884534:e=>{p.kb("MatMul",e,void 0)},884588:(e,t,n,r)=>{p.kb("ArgMax",e,{keepDims:!!t,selectLastIndex:!!n,axis:r})},884696:(e,t,n,r)=>{p.kb("ArgMin",e,{keepDims:!!t,selectLastIndex:!!n,axis:r})},884804:(e,t)=>{p.kb("Softmax",e,{axis:t})},884867:(e,t)=>{p.kb("Concat",e,{axis:t})},884927:(e,t,n,r,s)=>{p.kb("Split",e,{axis:t,numOutputs:n,splitSizes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},885083:e=>{p.kb("Expand",e,void 0)},885137:(e,t)=>{p.kb("Gather",e,{axis:Number(t)})},885208:(e,t)=>{p.kb("GatherElements",e,{axis:Number(t)})},885287:(e,t)=>{p.kb("GatherND",e,{batch_dims:Number(t)})},885366:(e,t,n,r,s,i,o,l,u,d,c)=>{p.kb("Resize",e,{antialias:t,axes:n?Array.from(a().subarray(Number(n)>>>0,Number(r)>>>0)):[],coordinateTransformMode:Be(s),cubicCoeffA:i,excludeOutside:o,extrapolationValue:l,keepAspectRatioPolicy:Be(u),mode:Be(d),nearestMode:Be(c)})},885728:(e,t,n,r,s,i,o)=>{p.kb("Slice",e,{starts:t?Array.from(a().subarray(Number(t)>>>0,Number(n)>>>0)):[],ends:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[],axes:i?Array.from(a().subarray(Number(i)>>>0,Number(o)>>>0)):[]})},885992:e=>{p.kb("Tile",e,void 0)},886044:(e,t,n)=>{p.kb("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},886158:(e,t,n)=>{p.kb("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},886272:e=>{p.kb("Range",e,void 0)},886325:(e,t)=>{p.kb("Einsum",e,{equation:Be(t)})},886406:(e,t,n,r,s)=>{p.kb("Pad",e,{mode:t,value:n,pads:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},886549:(e,t,n,r,s,i)=>{p.kb("BatchNormalization",e,{epsilon:t,momentum:n,spatial:!!s,trainingMode:!!r,format:i?"NHWC":"NCHW"})},886718:(e,t,n,r,s,i)=>{p.kb("BatchNormalization",e,{epsilon:t,momentum:n,spatial:!!s,trainingMode:!!r,format:i?"NHWC":"NCHW"})},886887:(e,t,n)=>{p.kb("CumSum",e,{exclusive:Number(t),reverse:Number(n)})},886984:(e,t,n)=>{p.kb("DequantizeLinear",e,{axis:t,blockSize:n})},887074:(e,t,n,r,s)=>{p.kb("GridSample",e,{align_corners:t,mode:Be(n),padding_mode:Be(r),format:s?"NHWC":"NCHW"})},887244:(e,t,n,r,s)=>{p.kb("GridSample",e,{align_corners:t,mode:Be(n),padding_mode:Be(r),format:s?"NHWC":"NCHW"})},887414:(e,t)=>{p.kb("ScatterND",e,{reduction:Be(t)})},887499:(e,t,n,r,s,i,o,l,u)=>{p.kb("Attention",e,{numHeads:t,isUnidirectional:n,maskFilterValue:r,scale:s,doRotary:i,qkvHiddenSizes:o?Array.from(a().subarray(Number(l)>>>0,Number(l)+o>>>0)):[],pastPresentShareBuffer:!!u})},887771:e=>{p.kb("BiasAdd",e,void 0)},887826:e=>{p.kb("BiasSplitGelu",e,void 0)},887887:e=>{p.kb("FastGelu",e,void 0)},887943:(e,n,r,s,i,o,u,d,c,h,f,m,_,g,w,y)=>{p.kb("Conv",e,{format:m?"NHWC":"NCHW",auto_pad:n,dilations:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[],group:i,kernel_shape:o?Array.from(a().subarray(Number(o)>>>0,Number(u)>>>0)):[],pads:d?Array.from(a().subarray(Number(d)>>>0,Number(c)>>>0)):[],strides:h?Array.from(a().subarray(Number(h)>>>0,Number(f)>>>0)):[],w_is_const:()=>!!t()[Number(_)>>>0],activation:Be(g),activation_params:w?Array.from(l().subarray(Number(w)>>>0,Number(y)>>>0)):[]})},888527:e=>{p.kb("Gelu",e,void 0)},888579:(e,t,n,r,s,i,a,o,l)=>{p.kb("GroupQueryAttention",e,{numHeads:t,kvNumHeads:n,scale:r,softcap:s,doRotary:i,rotaryInterleaved:a,smoothSoftmax:o,localWindowSize:l})},888796:(e,t,n,r)=>{p.kb("LayerNormalization",e,{axis:t,epsilon:n,simplified:!!r})},888907:(e,t,n,r)=>{p.kb("LayerNormalization",e,{axis:t,epsilon:n,simplified:!!r})},889018:(e,t,n,r,s,i)=>{p.kb("MatMulNBits",e,{k:t,n,accuracyLevel:r,bits:s,blockSize:i})},889145:(e,t,n,r,s,i)=>{p.kb("MultiHeadAttention",e,{numHeads:t,isUnidirectional:n,maskFilterValue:r,scale:s,doRotary:i})},889304:(e,t)=>{p.kb("QuickGelu",e,{alpha:t})},889368:(e,t,n,r,s)=>{p.kb("RotaryEmbedding",e,{interleaved:!!t,numHeads:n,rotaryEmbeddingDim:r,scale:s})},889507:(e,t,n)=>{p.kb("SkipLayerNormalization",e,{epsilon:t,simplified:!!n})},889609:(e,t,n)=>{p.kb("SkipLayerNormalization",e,{epsilon:t,simplified:!!n})},889711:(e,t,n,r)=>{p.kb("GatherBlockQuantized",e,{gatherAxis:t,quantizeAxis:n,blockSize:r})},889832:e=>{p.$b(e)},889866:(e,t)=>p.cc(Number(e),Number(t),p.Gb.hc,p.Gb.errors)};function oe(e,t,n){return nn((async()=>{await p.Yb(Number(e),Number(t),Number(n))}))}function le(){return typeof wasmOffsetConverter<"u"}function ue(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}var de=e=>{e.terminate(),e.onmessage=()=>{}},ce=e=>{0==ge.length&&(ke(),$e(ge[0]));var t=ge.pop();if(!t)return 6;we.push(t),be[e.Bb]=t,t.Bb=e.Bb;var n={cmd:"run",start_routine:e.ic,arg:e.Rb,pthread_ptr:e.Bb};return t.postMessage(n,e.nc),0},pe=0,he=(e,t,...n)=>{for(var r=2*n.length,s=Or(),i=Mr(8*r),a=i>>>3,o=0;o<n.length;o++){var l=n[o];"bigint"==typeof l?(U[a+2*o]=1n,U[a+2*o+1]=l):(U[a+2*o]=0n,u()[a+2*o+1>>>0]=l)}return e=Sr(e,0,r,i,t),Ir(s),e};function fe(e){if(_)return he(0,1,e);if(O=e,!(0<pe)){for(var t of we)de(t);for(t of ge)de(t);ge=[],we=[],be=[],W=!0}v(e,new ue(e))}function me(e){if(_)return he(1,0,e);_e(e)}var _e=e=>{if(O=e,_)throw me(e),"unwind";fe(e)},ge=[],we=[],ye=[],be={},xe=e=>{var t=e.Bb;delete be[t],ge.push(e),we.splice(we.indexOf(e),1),e.Bb=0,zr(t)};function ve(){ye.forEach((e=>e()))}var $e=e=>new Promise((t=>{e.onmessage=n=>{var r=(n=n.data).cmd;if(n.targetThread&&n.targetThread!=xr()){var s=be[n.targetThread];s?s.postMessage(n,n.transferList):C(`Internal error! Worker sent a message "${r}" to target pthread ${n.targetThread}, but that thread no longer exists!`)}else"checkMailbox"===r?Pt():"spawnThread"===r?ce(n):"cleanupThread"===r?xe(be[n.thread]):"killThread"===r?(n=n.thread,r=be[n],delete be[n],de(r),zr(n),we.splice(we.indexOf(r),1),r.Bb=0):"cancelThread"===r?be[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,t(e)):"alert"===r?alert(`Thread ${n.threadId}: ${n.text}`):"setimmediate"===n.target?e.postMessage(n):"callHandler"===r?p[n.handler](...n.args):r&&C(`worker sent an unknown command ${r}`)},e.onerror=e=>{throw C(`worker sent an error! ${e.filename}:${e.lineno}: ${e.message}`),e};var n,r=[];for(n of[])p.hasOwnProperty(n)&&r.push(n);e.postMessage({cmd:"load",handlers:r,wasmMemory:I,wasmModule:M})}));function ke(){var e=new Worker(new URL("file:///Users/sam-schaack/gamp/nuiq-asr/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs"),{type:"module",workerData:"em-pthread",name:"em-pthread"});ge.push(e)}var Ee=e=>{for(;0<e.length;)e.shift()(p)},Se=()=>{var e=xr(),t=o()[e+52>>>2>>>0];e=o()[e+56>>>2>>>0],Ar(t,t-e),Ir(t)},ze=(e,t)=>{pe=0,e=Br(e,t),0<pe?O=e:Cr(e)};class Ce{constructor(e){this.Kb=e-24}}function Te(e,t,n){var r=new Ce(e>>>=0);throw t>>>=0,n>>>=0,o()[r.Kb+16>>>2>>>0]=0,o()[r.Kb+4>>>2>>>0]=t,o()[r.Kb+8>>>2>>>0]=n,e}function Ae(e,t,n,r){return _?he(2,1,e,t,n,r):Ie(e,t,n,r)}function Ie(e,t,n,r){if(e>>>=0,t>>>=0,n>>>=0,r>>>=0,void 0===g)return C("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var s=[];return _&&0===s.length?Ae(e,t,n,r):(e={ic:n,Bb:e,Rb:r,nc:s},_?(e.Nb="spawnThread",postMessage(e,s),0):ce(e))}var Me=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Oe=(e,t,n)=>{var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&Me)return Me.decode(e.buffer instanceof g?e.slice(t,n):e.subarray(t,n));for(r="";t<n;){var s=e[t++];if(128&s){var i=63&e[t++];if(192==(224&s))r+=String.fromCharCode((31&s)<<6|i);else{var a=63&e[t++];65536>(s=224==(240&s)?(15&s)<<12|i<<6|a:(7&s)<<18|i<<12|a<<6|63&e[t++])?r+=String.fromCharCode(s):(s-=65536,r+=String.fromCharCode(55296|s>>10,56320|1023&s))}}else r+=String.fromCharCode(s)}return r},Be=(e,t)=>(e>>>=0)?Oe(n(),e,t):"";function Ne(e,t,n){return _?he(3,1,e,t,n):0}function Pe(e,t){if(_)return he(4,1,e,t)}var Re=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t},De=(e,t,n,r)=>{if(!(0<r))return 0;var s=n>>>=0;r=n+r-1;for(var i=0;i<e.length;++i){var a=e.charCodeAt(i);if(55296<=a&&57343>=a&&(a=65536+((1023&a)<<10)|1023&e.charCodeAt(++i)),127>=a){if(n>=r)break;t[n++>>>0]=a}else{if(2047>=a){if(n+1>=r)break;t[n++>>>0]=192|a>>6}else{if(65535>=a){if(n+2>=r)break;t[n++>>>0]=224|a>>12}else{if(n+3>=r)break;t[n++>>>0]=240|a>>18,t[n++>>>0]=128|a>>12&63}t[n++>>>0]=128|a>>6&63}t[n++>>>0]=128|63&a}}return t[n>>>0]=0,n-s},Le=(e,t,r)=>De(e,n(),t,r);function Fe(e,t){if(_)return he(5,1,e,t)}function Ue(e,t,n){if(_)return he(6,1,e,t,n)}function qe(e,t,n){return _?he(7,1,e,t,n):0}function Ve(e,t){if(_)return he(8,1,e,t)}function We(e,t,n){if(_)return he(9,1,e,t,n)}function je(e,t,n,r){if(_)return he(10,1,e,t,n,r)}function Ge(e,t,n,r){if(_)return he(11,1,e,t,n,r)}function He(e,t,n,r){if(_)return he(12,1,e,t,n,r)}function Ke(e){if(_)return he(13,1,e)}function Xe(e,t){if(_)return he(14,1,e,t)}function Qe(e,t,n){if(_)return he(15,1,e,t,n)}var Ye,Ze,Je=()=>{J("")},et=e=>{for(var t="";n()[e>>>0];)t+=Ye[n()[e++>>>0]];return t},tt={},nt={},rt={};function st(e,t,n={}){if(!("argPackAdvance"in t))throw new TypeError("registerType registeredInstance requires argPackAdvance");return function(e,t,n={}){var r=t.name;if(!e)throw new Ze(`type "${r}" must have a positive integer typeid pointer`);if(nt.hasOwnProperty(e)){if(n.Tb)return;throw new Ze(`Cannot register type \'${r}\' twice`)}nt[e]=t,delete rt[e],tt.hasOwnProperty(e)&&(t=tt[e],delete tt[e],t.forEach((e=>e())))}(e,t,n)}var it=(e,s,l)=>{switch(s){case 1:return l?e=>t()[e>>>0]:e=>n()[e>>>0];case 2:return l?e=>r()[e>>>1>>>0]:e=>i()[e>>>1>>>0];case 4:return l?e=>a()[e>>>2>>>0]:e=>o()[e>>>2>>>0];case 8:return l?e=>U[e>>>3]:e=>q[e>>>3];default:throw new TypeError(`invalid integer width (${s}): ${e}`)}};function at(e,t,n){n>>>=0,st(e>>>=0,{name:t=et(t>>>0),fromWireType:e=>e,toWireType:function(e,t){if("bigint"!=typeof t&&"number"!=typeof t)throw t=null===t?"null":"object"==(e=typeof t)||"array"===e||"function"===e?t.toString():""+t,new TypeError(`Cannot convert "${t}" to ${this.name}`);return"number"==typeof t&&(t=BigInt(t)),t},argPackAdvance:ot,readValueFromPointer:it(t,n,-1==t.indexOf("u")),Eb:null})}var ot=8;function lt(e,t,r,s){st(e>>>=0,{name:t=et(t>>>0),fromWireType:function(e){return!!e},toWireType:function(e,t){return t?r:s},argPackAdvance:ot,readValueFromPointer:function(e){return this.fromWireType(n()[e>>>0])},Eb:null})}var ut=[],dt=[];function ct(e){9<(e>>>=0)&&0==--dt[e+1]&&(dt[e]=void 0,ut.push(e))}var pt=e=>{if(!e)throw new Ze("Cannot use deleted val. handle = "+e);return dt[e]},ht=e=>{switch(e){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let t=ut.pop()||dt.length;return dt[t]=e,dt[t+1]=1,t}};function ft(e){return this.fromWireType(o()[e>>>2>>>0])}var mt={name:"emscripten::val",fromWireType:e=>{var t=pt(e);return ct(e),t},toWireType:(e,t)=>ht(t),argPackAdvance:ot,readValueFromPointer:ft,Eb:null};function _t(e){return st(e>>>0,mt)}var gt=(e,t)=>{switch(t){case 4:return function(e){return this.fromWireType(l()[e>>>2>>>0])};case 8:return function(e){return this.fromWireType(u()[e>>>3>>>0])};default:throw new TypeError(`invalid float width (${t}): ${e}`)}};function yt(e,t,n){n>>>=0,st(e>>>=0,{name:t=et(t>>>0),fromWireType:e=>e,toWireType:(e,t)=>t,argPackAdvance:ot,readValueFromPointer:gt(t,n),Eb:null})}function bt(e,t,n,r,s){if(e>>>=0,n>>>=0,t=et(t>>>0),-1===s&&(s=4294967295),s=e=>e,0===r){var i=32-8*n;s=e=>e<<i>>>i}var a=t.includes("unsigned")?function(e,t){return t>>>0}:function(e,t){return t};st(e,{name:t,fromWireType:s,toWireType:a,argPackAdvance:ot,readValueFromPointer:it(t,n,0!==r),Eb:null})}function xt(e,n,r){function s(e){var n=o()[e>>>2>>>0];return e=o()[e+4>>>2>>>0],new i(t().buffer,e,n)}var i=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][n];st(e>>>=0,{name:r=et(r>>>0),fromWireType:s,argPackAdvance:ot,readValueFromPointer:s},{Tb:!0})}function vt(e,t){e>>>=0;var r="std::string"===(t=et(t>>>0));st(e,{name:t,fromWireType:function(e){var t=o()[e>>>2>>>0],s=e+4;if(r)for(var i=s,a=0;a<=t;++a){var l=s+a;if(a==t||0==n()[l>>>0]){if(i=Be(i,l-i),void 0===u)var u=i;else u+=String.fromCharCode(0),u+=i;i=l+1}}else{for(u=Array(t),a=0;a<t;++a)u[a]=String.fromCharCode(n()[s+a>>>0]);u=u.join("")}return vr(e),u},toWireType:function(e,t){t instanceof ArrayBuffer&&(t=new Uint8Array(t));var s="string"==typeof t;if(!(s||t instanceof Uint8Array||t instanceof Uint8ClampedArray||t instanceof Int8Array))throw new Ze("Cannot pass non-string to std::string");var i=r&&s?Re(t):t.length,a=$r(4+i+1),l=a+4;if(o()[a>>>2>>>0]=i,r&&s)Le(t,l,i+1);else if(s)for(s=0;s<i;++s){var u=t.charCodeAt(s);if(255<u)throw vr(l),new Ze("String has UTF-16 code units that do not fit in 8 bits");n()[l+s>>>0]=u}else for(s=0;s<i;++s)n()[l+s>>>0]=t[s];return null!==e&&e.push(vr,a),a},argPackAdvance:ot,readValueFromPointer:ft,Eb(e){vr(e)}})}var $t=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,kt=(e,t)=>{for(var s=e>>1,a=s+t/2;!(s>=a)&&i()[s>>>0];)++s;if(32<(s<<=1)-e&&$t)return $t.decode(n().slice(e,s));for(s="",a=0;!(a>=t/2);++a){var o=r()[e+2*a>>>1>>>0];if(0==o)break;s+=String.fromCharCode(o)}return s},Et=(e,t,n)=>{if(n??=2147483647,2>n)return 0;var s=t;n=(n-=2)<2*e.length?n/2:e.length;for(var i=0;i<n;++i){var a=e.charCodeAt(i);r()[t>>>1>>>0]=a,t+=2}return r()[t>>>1>>>0]=0,t-s},St=e=>2*e.length,zt=(e,t)=>{for(var n=0,r="";!(n>=t/4);){var s=a()[e+4*n>>>2>>>0];if(0==s)break;++n,65536<=s?(s-=65536,r+=String.fromCharCode(55296|s>>10,56320|1023&s)):r+=String.fromCharCode(s)}return r},Ct=(e,t,n)=>{if(t>>>=0,n??=2147483647,4>n)return 0;var r=t;n=r+n-4;for(var s=0;s<e.length;++s){var i=e.charCodeAt(s);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++s)),a()[t>>>2>>>0]=i,(t+=4)+4>n)break}return a()[t>>>2>>>0]=0,t-r},Tt=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);55296<=r&&57343>=r&&++n,t+=4}return t};function At(e,t,n){if(e>>>=0,t>>>=0,n=et(n>>>=0),2===t)var r=kt,s=Et,a=St,l=e=>i()[e>>>1>>>0];else 4===t&&(r=zt,s=Ct,a=Tt,l=e=>o()[e>>>2>>>0]);st(e,{name:n,fromWireType:e=>{for(var n,s=o()[e>>>2>>>0],i=e+4,a=0;a<=s;++a){var u=e+4+a*t;a!=s&&0!=l(u)||(i=r(i,u-i),void 0===n?n=i:(n+=String.fromCharCode(0),n+=i),i=u+t)}return vr(e),n},toWireType:(e,r)=>{if("string"!=typeof r)throw new Ze(`Cannot pass non-string to C++ string type ${n}`);var i=a(r),l=$r(4+i+t);return o()[l>>>2>>>0]=i/t,s(r,l+4,i+t),null!==e&&e.push(vr,l),l},argPackAdvance:ot,readValueFromPointer:ft,Eb(e){vr(e)}})}function It(e,t){st(e>>>=0,{Ub:!0,name:t=et(t>>>0),argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})}var Mt=()=>1;function Ot(e){kr(e>>>0,!m,1,!f,131072,!1),ve()}var Bt=e=>{if(!W)try{if(e(),!(0<pe))try{_?Cr(O):_e(O)}catch(e){e instanceof ue||"unwind"==e||v(1,e)}}catch(e){e instanceof ue||"unwind"==e||v(1,e)}};function Nt(e){e>>>=0,"function"==typeof Atomics.oc&&(Atomics.oc(a(),e>>>2,e).value.then(Pt),e+=128,Atomics.store(a(),e>>>2,1))}var Pt=()=>{var e=xr();e&&(Nt(e),Bt(Tr))};function Rt(e,t){(e>>>=0)==t>>>0?setTimeout(Pt):_?postMessage({targetThread:e,cmd:"checkMailbox"}):(e=be[e])&&e.postMessage({cmd:"checkMailbox"})}var Dt=[];function Lt(e,t,n,r,s){for(t>>>=0,r/=2,Dt.length=r,n=s>>>0>>>3,s=0;s<r;s++)Dt[s]=U[n+2*s]?U[n+2*s+1]:u()[n+2*s+1>>>0];return(t?ae[t]:_r[e])(...Dt)}function Ft(e){e>>>=0,_?postMessage({cmd:"cleanupThread",thread:e}):xe(be[e])}function Ut(e){}var qt=(e,t)=>{var n=nt[e];if(void 0===n)throw e=wr(e),n=et(e),vr(e),new Ze(`${t} has unknown type ${n}`);return n},Vt=(e,t,n)=>{var r=[];return e=e.toWireType(r,n),r.length&&(o()[t>>>2>>>0]=ht(r)),e};function Wt(e,t,n){return t>>>=0,n>>>=0,e=pt(e>>>0),t=qt(t,"emval::as"),Vt(t,n,e)}function jt(e,t){return t>>>=0,e=pt(e>>>0),(t=qt(t,"emval::as")).toWireType(null,e)}var Gt=e=>{try{e()}catch(e){J(e)}},Ht=0,Kt=null,Xt=0,Qt=[],Yt={},Zt={},Jt=0,en=null,tn=[];function nn(e){return function(t){if(!W){if(0===Ht){var n=!1,r=!1;(t=>{e().then(t)})(((e=0)=>{if(!W&&(Xt=e,n=!0,r)){Ht=2,Gt((()=>Rr(Kt))),typeof Browser<"u"&&Browser.Lb.Sb&&Browser.Lb.resume(),e=!1;try{var t=(o=a()[Kt+8>>>2>>>0],o=gr[Zt[o]],--pe,o())}catch(o){t=o,e=!0}var s=!1;if(!Kt){var i=en;i&&(en=null,(e?i.reject:i.resolve)(t),s=!0)}if(e&&!s)throw t}var o})),r=!0,n||(Ht=1,Kt=function(){var e=$r(65548),t=e+12;o()[e>>>2>>>0]=t,o()[e+4>>>2>>>0]=t+65536,t=Qt[0];var n=Yt[t];return void 0===n&&(n=Jt++,Yt[t]=n,Zt[n]=t),t=n,a()[e+8>>>2>>>0]=t,e}(),typeof Browser<"u"&&Browser.Lb.Sb&&Browser.Lb.pause(),Gt((()=>Nr(Kt))))}else 2===Ht?(Ht=0,Gt(Dr),vr(Kt),Kt=null,tn.forEach(Bt)):J(`invalid state: ${Ht}`);return Xt}}()}function rn(e){return e>>>=0,nn((()=>(e=pt(e)).then(ht)))}var sn=[];function an(e,t,n,r){return n>>>=0,r>>>=0,(e=sn[e>>>0])(null,t=pt(t>>>0),n,r)}var on={},ln=e=>{var t=on[e];return void 0===t?et(e):t};function un(e,t,n,r,s){return n>>>=0,r>>>=0,s>>>=0,(e=sn[e>>>0])(t=pt(t>>>0),t[n=ln(n)],r,s)}var dn=()=>"object"==typeof globalThis?globalThis:Function("return this")();function cn(e){return 0==(e>>>=0)?ht(dn()):(e=ln(e),ht(dn()[e]))}var pn=e=>{var t=sn.length;return sn.push(e),t},hn=(e,t)=>{for(var n=Array(e),r=0;r<e;++r)n[r]=qt(o()[t+4*r>>>2>>>0],"parameter "+r);return n},fn=(e,t)=>Object.defineProperty(t,"name",{value:e});function mn(e,t,n){var r=(t=hn(e,t>>>0)).shift();e--;var s="return function (obj, func, destructorsRef, args) {\\n",i=0,a=[];0===n&&a.push("obj");for(var o=["retType"],l=[r],u=0;u<e;++u)a.push("arg"+u),o.push("argType"+u),l.push(t[u]),s+=`  var arg${u} = argType${u}.readValueFromPointer(args${i?"+"+i:""});\\n`,i+=t[u].argPackAdvance;return s+=`  var rv = ${1===n?"new func":"func.call"}(${a.join(", ")});\\n`,r.Ub||(o.push("emval_returnValue"),l.push(Vt),s+="  return emval_returnValue(retType, destructorsRef, rv);\\n"),o.push(s+"};\\n"),e=function(e){var t=Function;if(!(t instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof t} which is not a function`);var n=fn(t.name||"unknownFunctionName",(function(){}));return n.prototype=t.prototype,n=new n,(e=t.apply(n,e))instanceof Object?e:n}(o)(...l),n=`methodCaller<(${t.map((e=>e.name)).join(", ")}) => ${r.name}>`,pn(fn(n,e))}function _n(e){return e=ln(e>>>0),ht(p[e])}function gn(e,t){return t>>>=0,e=pt(e>>>0),t=pt(t),ht(e[t])}function wn(e){9<(e>>>=0)&&(dt[e+1]+=1)}function yn(){return ht([])}function bn(e){e=pt(e>>>0);for(var t=Array(e.length),n=0;n<e.length;n++)t[n]=e[n];return ht(t)}function xn(e){return ht(ln(e>>>0))}function vn(){return ht({})}function $n(e){for(var t=pt(e>>>=0);t.length;){var n=t.pop();t.pop()(n)}ct(e)}function kn(e,t,n){t>>>=0,n>>>=0,e=pt(e>>>0),t=pt(t),n=pt(n),e[t]=n}function En(e,t){return t>>>=0,e=(e=qt(e>>>0,"_emval_take_value")).readValueFromPointer(t),ht(e)}function Sn(e,t){e=-9007199254740992>e||9007199254740992<e?NaN:Number(e),t>>>=0,e=new Date(1e3*e),a()[t>>>2>>>0]=e.getUTCSeconds(),a()[t+4>>>2>>>0]=e.getUTCMinutes(),a()[t+8>>>2>>>0]=e.getUTCHours(),a()[t+12>>>2>>>0]=e.getUTCDate(),a()[t+16>>>2>>>0]=e.getUTCMonth(),a()[t+20>>>2>>>0]=e.getUTCFullYear()-1900,a()[t+24>>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[t+28>>>2>>>0]=e}var zn=e=>e%4==0&&(e%100!=0||e%400==0),Cn=[0,31,60,91,121,152,182,213,244,274,305,335],Tn=[0,31,59,90,120,151,181,212,243,273,304,334];function An(e,t){e=-9007199254740992>e||9007199254740992<e?NaN:Number(e),t>>>=0,e=new Date(1e3*e),a()[t>>>2>>>0]=e.getSeconds(),a()[t+4>>>2>>>0]=e.getMinutes(),a()[t+8>>>2>>>0]=e.getHours(),a()[t+12>>>2>>>0]=e.getDate(),a()[t+16>>>2>>>0]=e.getMonth(),a()[t+20>>>2>>>0]=e.getFullYear()-1900,a()[t+24>>>2>>>0]=e.getDay();var n=(zn(e.getFullYear())?Cn:Tn)[e.getMonth()]+e.getDate()-1|0;a()[t+28>>>2>>>0]=n,a()[t+36>>>2>>>0]=-60*e.getTimezoneOffset(),n=new Date(e.getFullYear(),6,1).getTimezoneOffset();var r=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(n!=r&&e.getTimezoneOffset()==Math.min(r,n)),a()[t+32>>>2>>>0]=e}function In(e){e>>>=0;var t=new Date(a()[e+20>>>2>>>0]+1900,a()[e+16>>>2>>>0],a()[e+12>>>2>>>0],a()[e+8>>>2>>>0],a()[e+4>>>2>>>0],a()[e>>>2>>>0],0),n=a()[e+32>>>2>>>0],r=t.getTimezoneOffset(),s=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=new Date(t.getFullYear(),0,1).getTimezoneOffset(),o=Math.min(i,s);return 0>n?a()[e+32>>>2>>>0]=+(s!=i&&o==r):0<n!=(o==r)&&(s=Math.max(i,s),t.setTime(t.getTime()+6e4*((0<n?o:s)-r))),a()[e+24>>>2>>>0]=t.getDay(),n=(zn(t.getFullYear())?Cn:Tn)[t.getMonth()]+t.getDate()-1|0,a()[e+28>>>2>>>0]=n,a()[e>>>2>>>0]=t.getSeconds(),a()[e+4>>>2>>>0]=t.getMinutes(),a()[e+8>>>2>>>0]=t.getHours(),a()[e+12>>>2>>>0]=t.getDate(),a()[e+16>>>2>>>0]=t.getMonth(),a()[e+20>>>2>>>0]=t.getYear(),e=t.getTime(),BigInt(isNaN(e)?-1:e/1e3)}function Mn(e,t,n,r,s,i,a){return _?he(16,1,e,t,n,r,s,i,a):-52}function On(e,t,n,r,s,i){if(_)return he(17,1,e,t,n,r,s,i)}function Bn(e,t,n,r){e>>>=0,t>>>=0,n>>>=0,r>>>=0;var s=(new Date).getFullYear(),i=new Date(s,0,1),l=new Date(s,6,1);s=i.getTimezoneOffset();var u=l.getTimezoneOffset(),d=Math.max(s,u);o()[e>>>2>>>0]=60*d,a()[t>>>2>>>0]=+(s!=u),i=(e=e=>e.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1])(i),l=e(l),u<s?(Le(i,n,17),Le(l,r,17)):(Le(i,r,17),Le(l,n,17))}var Nn=[],Pn=(e,t)=>{Nn.length=0;for(var r;r=n()[e++>>>0];){var s=105!=r;t+=(s&=112!=r)&&t%8?4:0,Nn.push(112==r?o()[t>>>2>>>0]:106==r?U[t>>>3]:105==r?a()[t>>>2>>>0]:u()[t>>>3>>>0]),t+=s?8:4}return Nn};function Rn(e,t,n){return e>>>=0,t=Pn(t>>>0,n>>>0),ae[e](...t)}function Dn(e,t,n){return e>>>=0,t=Pn(t>>>0,n>>>0),ae[e](...t)}var Ln=()=>{},Fn=()=>Date.now();function Un(e,t){return C(Be(e>>>0,t>>>0))}var qn,Vn=()=>{throw pe+=1,"unwind"};function Wn(){return 4294901760}qn=()=>performance.timeOrigin+performance.now();var jn=()=>navigator.hardwareConcurrency;function Gn(){return J("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function Hn(e){e>>>=0;var t=n().length;if(e<=t||4294901760<e)return!1;for(var r=1;4>=r;r*=2){var s=t*(1+.2/r);s=Math.min(s,e+100663296);var i=Math;s=Math.max(e,s);e:{i=(i.min.call(i,4294901760,s+(65536-s%65536)%65536)-I.buffer.byteLength+65535)/65536;try{I.grow(i),j();var a=1;break e}catch{}a=void 0}if(a)return!0}return!1}var Kn=()=>(J("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),Xn={},Qn=e=>{e.forEach((e=>{var t=Kn();t&&(Xn[t]=e)}))};function Yn(){var e=Error().stack.toString().split("\\n");return"Error"==e[0]&&e.shift(),Qn(e),Xn.Qb=Kn(),Xn.fc=e,Xn.Qb}function Zn(e,t,n){if(e>>>=0,t>>>=0,Xn.Qb==e)var r=Xn.fc;else"Error"==(r=Error().stack.toString().split("\\n"))[0]&&r.shift(),Qn(r);for(var s=3;r[s]&&Kn()!=e;)++s;for(e=0;e<n&&r[e+s];++e)a()[t+4*e>>>2>>>0]=Kn();return e}var Jn,er={},tr=()=>{if(!Jn){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:"./this.program"};for(e in er)void 0===er[e]?delete t[e]:t[e]=er[e];var n=[];for(e in t)n.push(`${e}=${t[e]}`);Jn=n}return Jn};function nr(e,n){if(_)return he(18,1,e,n);e>>>=0,n>>>=0;var r=0;return tr().forEach(((s,i)=>{var a=n+r;for(i=o()[e+4*i>>>2>>>0]=a,a=0;a<s.length;++a)t()[i++>>>0]=s.charCodeAt(a);t()[i>>>0]=0,r+=s.length+1})),0}function rr(e,t){if(_)return he(19,1,e,t);e>>>=0,t>>>=0;var n=tr();o()[e>>>2>>>0]=n.length;var r=0;return n.forEach((e=>r+=e.length+1)),o()[t>>>2>>>0]=r,0}function sr(e){return _?he(20,1,e):52}function ir(e,t,n,r){return _?he(21,1,e,t,n,r):52}function ar(e,t,n,r){return _?he(22,1,e,t,n,r):70}var or=[null,[],[]];function lr(e,t,r,s){if(_)return he(23,1,e,t,r,s);t>>>=0,r>>>=0,s>>>=0;for(var i=0,a=0;a<r;a++){var l=o()[t>>>2>>>0],u=o()[t+4>>>2>>>0];t+=8;for(var d=0;d<u;d++){var c=n()[l+d>>>0],p=or[e];0===c||10===c?((1===e?z:C)(Oe(p,0)),p.length=0):p.push(c)}i+=u}return o()[s>>>2>>>0]=i,0}var ur=[31,29,31,30,31,30,31,31,30,31,30,31],dr=[31,28,31,30,31,30,31,31,30,31,30,31],cr=(e,n)=>{t().set(e,n>>>0)};function pr(e,t,n,r){function s(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function i(e,t){return s(e,t,"0")}function l(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function u(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function d(e){var t=e.Cb;for(e=new Date(new Date(e.Db+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(zn(e.getFullYear())?ur:dr)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=u(new Date(e.getFullYear(),0,4)),n=u(n),0>=l(t,e)?0>=l(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,n>>>=0,r>>>=0;var c=o()[r+40>>>2>>>0];for(var p in r={lc:a()[r>>>2>>>0],kc:a()[r+4>>>2>>>0],Ib:a()[r+8>>>2>>>0],Mb:a()[r+12>>>2>>>0],Jb:a()[r+16>>>2>>>0],Db:a()[r+20>>>2>>>0],vb:a()[r+24>>>2>>>0],Cb:a()[r+28>>>2>>>0],sc:a()[r+32>>>2>>>0],jc:a()[r+36>>>2>>>0],mc:c?Be(c):""},n=Be(n),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(p,"g"),c[p]);var h,f,m="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),_="January February March April May June July August September October November December".split(" ");for(p in c={"%a":e=>m[e.vb].substring(0,3),"%A":e=>m[e.vb],"%b":e=>_[e.Jb].substring(0,3),"%B":e=>_[e.Jb],"%C":e=>i((e.Db+1900)/100|0,2),"%d":e=>i(e.Mb,2),"%e":e=>s(e.Mb,2," "),"%g":e=>d(e).toString().substring(2),"%G":d,"%H":e=>i(e.Ib,2),"%I":e=>(0==(e=e.Ib)?e=12:12<e&&(e-=12),i(e,2)),"%j":e=>{for(var t=0,n=0;n<=e.Jb-1;t+=(zn(e.Db+1900)?ur:dr)[n++]);return i(e.Mb+t,3)},"%m":e=>i(e.Jb+1,2),"%M":e=>i(e.kc,2),"%n":()=>"\\n","%p":e=>0<=e.Ib&&12>e.Ib?"AM":"PM","%S":e=>i(e.lc,2),"%t":()=>"\\t","%u":e=>e.vb||7,"%U":e=>i(Math.floor((e.Cb+7-e.vb)/7),2),"%V":e=>{var t=Math.floor((e.Cb+7-(e.vb+6)%7)/7);if(2>=(e.vb+371-e.Cb-2)%7&&t++,t)53==t&&(4==(n=(e.vb+371-e.Cb)%7)||3==n&&zn(e.Db)||(t=1));else{t=52;var n=(e.vb+7-e.Cb-1)%7;(4==n||5==n&&zn(e.Db%400-1))&&t++}return i(t,2)},"%w":e=>e.vb,"%W":e=>i(Math.floor((e.Cb+7-(e.vb+6)%7)/7),2),"%y":e=>(e.Db+1900).toString().substring(2),"%Y":e=>e.Db+1900,"%z":e=>(0<=(e=e.jc)?"+":"-")+("0000"+((e=Math.abs(e)/60)/60*100+e%60)).slice(-4),"%Z":e=>e.mc,"%%":()=>"%"},n=n.replace(/%%/g,"\\0\\0"),c)n.includes(p)&&(n=n.replace(new RegExp(p,"g"),c[p](r)));return h=n=n.replace(/\\0\\0/g,"%"),f=Array(Re(h)+1),De(h,f,0,f.length),(p=f).length>t?0:(cr(p,e),p.length-1)}function hr(e,t,n,r){return pr(e>>>0,t>>>0,n>>>0,r>>>0)}_||function(){for(var e=p.numThreads-1;e--;)ke();G.unshift((()=>{var e;X++,e=()=>Z(),_?e():Promise.all(ge.map($e)).then(e)}))}();for(var fr=Array(256),mr=0;256>mr;++mr)fr[mr]=String.fromCharCode(mr);Ye=fr,Ze=p.BindingError=class extends Error{constructor(e){super(e),this.name="BindingError"}},p.InternalError=class extends Error{constructor(e){super(e),this.name="InternalError"}},dt.push(0,1,void 0,1,null,1,!0,1,!1,1),p.count_emval_handles=()=>dt.length/2-5-ut.length;var _r=[fe,me,Ae,Ne,Pe,Fe,Ue,qe,Ve,We,je,Ge,He,Ke,Xe,Qe,Mn,On,nr,rr,sr,ir,ar,lr],gr=function(){function e(e,t){return gr=e.exports,gr=function(){var e=gr,t={};for(let[n,r]of Object.entries(e))t[n]="function"==typeof r?(...e)=>{Qt.push(n);try{return r(...e)}finally{W||(Qt.pop(),Kt&&1===Ht&&0===Qt.length&&(Ht=0,pe+=1,Gt(Pr),typeof Fibers<"u"&&Fibers.tc()))}}:r;return t}(),n=gr,r=e=>t=>e(t)>>>0,s=e=>()=>e()>>>0,(n=Object.assign({},n)).Da=r(n.Da),n.gb=s(n.gb),n.ib=r(n.ib),n.emscripten_main_runtime_thread_id=s(n.emscripten_main_runtime_thread_id),n.tb=r(n.tb),n.ub=s(n.ub),gr=n,ye.push(gr.jb),H.unshift(gr.Ca),M=t,Z(),gr;var n,r,s}var t,n,r,i=ie();if(X++,p.instantiateWasm)try{return p.instantiateWasm(i,e)}catch(t){C(`Module.instantiateWasm callback failed with error: ${t}`),c(t)}return ee||=p.locateFile?te("ort-wasm-simd-threaded.jsep.wasm")?"ort-wasm-simd-threaded.jsep.wasm":p.locateFile?p.locateFile("ort-wasm-simd-threaded.jsep.wasm",$):$+"ort-wasm-simd-threaded.jsep.wasm":new URL(s(98),s.b).href,(t=i,n=function(t){e(t.instance,t.module)},r=ee,k||"function"!=typeof WebAssembly.instantiateStreaming||te(r)||ne(r)||"function"!=typeof fetch?se(r,t,n):fetch(r,{credentials:"same-origin"}).then((e=>WebAssembly.instantiateStreaming(e,t).then(n,(function(e){return C(`wasm streaming compile failed: ${e}`),C("falling back to ArrayBuffer instantiation"),se(r,t,n)}))))).catch(c),{}}(),wr=e=>(wr=gr.Da)(e),yr=()=>(yr=gr.Ea)();p._OrtInit=(e,t)=>(p._OrtInit=gr.Fa)(e,t),p._OrtGetLastError=(e,t)=>(p._OrtGetLastError=gr.Ga)(e,t),p._OrtCreateSessionOptions=(e,t,n,r,s,i,a,o,l,u)=>(p._OrtCreateSessionOptions=gr.Ha)(e,t,n,r,s,i,a,o,l,u),p._OrtAppendExecutionProvider=(e,t)=>(p._OrtAppendExecutionProvider=gr.Ia)(e,t),p._OrtAddFreeDimensionOverride=(e,t,n)=>(p._OrtAddFreeDimensionOverride=gr.Ja)(e,t,n),p._OrtAddSessionConfigEntry=(e,t,n)=>(p._OrtAddSessionConfigEntry=gr.Ka)(e,t,n),p._OrtReleaseSessionOptions=e=>(p._OrtReleaseSessionOptions=gr.La)(e),p._OrtCreateSession=(e,t,n)=>(p._OrtCreateSession=gr.Ma)(e,t,n),p._OrtReleaseSession=e=>(p._OrtReleaseSession=gr.Na)(e),p._OrtGetInputOutputCount=(e,t,n)=>(p._OrtGetInputOutputCount=gr.Oa)(e,t,n),p._OrtGetInputName=(e,t)=>(p._OrtGetInputName=gr.Pa)(e,t),p._OrtGetOutputName=(e,t)=>(p._OrtGetOutputName=gr.Qa)(e,t),p._OrtFree=e=>(p._OrtFree=gr.Ra)(e),p._OrtCreateTensor=(e,t,n,r,s,i)=>(p._OrtCreateTensor=gr.Sa)(e,t,n,r,s,i),p._OrtGetTensorData=(e,t,n,r,s)=>(p._OrtGetTensorData=gr.Ta)(e,t,n,r,s),p._OrtReleaseTensor=e=>(p._OrtReleaseTensor=gr.Ua)(e),p._OrtCreateRunOptions=(e,t,n,r)=>(p._OrtCreateRunOptions=gr.Va)(e,t,n,r),p._OrtAddRunConfigEntry=(e,t,n)=>(p._OrtAddRunConfigEntry=gr.Wa)(e,t,n),p._OrtReleaseRunOptions=e=>(p._OrtReleaseRunOptions=gr.Xa)(e),p._OrtCreateBinding=e=>(p._OrtCreateBinding=gr.Ya)(e),p._OrtBindInput=(e,t,n)=>(p._OrtBindInput=gr.Za)(e,t,n),p._OrtBindOutput=(e,t,n,r)=>(p._OrtBindOutput=gr._a)(e,t,n,r),p._OrtClearBoundOutputs=e=>(p._OrtClearBoundOutputs=gr.$a)(e),p._OrtReleaseBinding=e=>(p._OrtReleaseBinding=gr.ab)(e),p._OrtRunWithBinding=(e,t,n,r,s)=>(p._OrtRunWithBinding=gr.bb)(e,t,n,r,s),p._OrtRun=(e,t,n,r,s,i,a,o)=>(p._OrtRun=gr.cb)(e,t,n,r,s,i,a,o),p._OrtEndProfiling=e=>(p._OrtEndProfiling=gr.db)(e),p._JsepOutput=(e,t,n)=>(p._JsepOutput=gr.eb)(e,t,n),p._JsepGetNodeName=e=>(p._JsepGetNodeName=gr.fb)(e);var br,xr=()=>(xr=gr.gb)(),vr=p._free=e=>(vr=p._free=gr.hb)(e),$r=p._malloc=e=>($r=p._malloc=gr.ib)(e),kr=(e,t,n,r,s,i)=>(kr=gr.lb)(e,t,n,r,s,i),Er=()=>(Er=gr.mb)(),Sr=(e,t,n,r,s)=>(Sr=gr.nb)(e,t,n,r,s),zr=e=>(zr=gr.ob)(e),Cr=e=>(Cr=gr.pb)(e),Tr=()=>(Tr=gr.qb)(),Ar=(e,t)=>(Ar=gr.rb)(e,t),Ir=e=>(Ir=gr.sb)(e),Mr=e=>(Mr=gr.tb)(e),Or=()=>(Or=gr.ub)(),Br=p.dynCall_ii=(e,t)=>(Br=p.dynCall_ii=gr.wb)(e,t),Nr=e=>(Nr=gr.xb)(e),Pr=()=>(Pr=gr.yb)(),Rr=e=>(Rr=gr.zb)(e),Dr=()=>(Dr=gr.Ab)();function Lr(){0<X||(_?(d(p),_||Ee(H),startWorker(p)):(Ee(G),0<X||br||(br=!0,p.calledRun=!0,W||(_||Ee(H),d(p),_||Ee(K)))))}return p.___start_em_js=889994,p.___stop_em_js=890240,p.stackSave=()=>Or(),p.stackRestore=e=>Ir(e),p.stackAlloc=e=>Mr(e),p.setValue=function(e,n,s="i8"){switch(s.endsWith("*")&&(s="*"),s){case"i1":case"i8":t()[e>>>0]=n;break;case"i16":r()[e>>>1>>>0]=n;break;case"i32":a()[e>>>2>>>0]=n;break;case"i64":U[e>>>3]=BigInt(n);break;case"float":l()[e>>>2>>>0]=n;break;case"double":u()[e>>>3>>>0]=n;break;case"*":o()[e>>>2>>>0]=n;break;default:J(`invalid type for setValue: ${s}`)}},p.getValue=function(e,n="i8"){switch(n.endsWith("*")&&(n="*"),n){case"i1":case"i8":return t()[e>>>0];case"i16":return r()[e>>>1>>>0];case"i32":return a()[e>>>2>>>0];case"i64":return U[e>>>3];case"float":return l()[e>>>2>>>0];case"double":return u()[e>>>3>>>0];case"*":return o()[e>>>2>>>0];default:J(`invalid type for getValue: ${n}`)}},p.UTF8ToString=Be,p.stringToUTF8=Le,p.lengthBytesUTF8=Re,Y=function e(){br||Lr(),br||(Y=e)},Lr(),p.PTR_SIZE=4,h},bt=yt,"em-pthread"===globalThis.self?.name&&yt()})),Qu=qe((()=>{ct(),xt="file:///Users/sam-schaack/gamp/nuiq-asr/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs",vt=typeof location>"u"?void 0:location.origin,$t=(e,t)=>{try{let n=t??xt;return(n?new URL(e,n):new URL(e)).origin===vt}catch{return!1}},kt=async e=>{let t=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(t)},Et=(_t(),We(pt)).default,St=async()=>{if(!xt)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if($t(xt))return[void 0,Et()];let e=await kt(xt);return[e,Et(e)]},zt=(Xu(),We(gt)).default,Ct=async(e,t,n)=>[void 0,zt]})),Yu=qe((()=>{Qu(),At=!1,It=!1,Mt=!1,Ot=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Bt=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Nt=async e=>{if(At)return Promise.resolve();if(It)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(Mt)throw new Error("previous call to \'initializeWebAssembly()\' failed.");It=!0;let t=e.initTimeout,n=e.numThreads;if(!Bt())throw new Error("WebAssembly SIMD is not supported in the current environment.");let r=Ot();n>1&&!r&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=n=1);let s=e.wasmPaths,i="string"==typeof s?s:void 0,a=s?.mjs,o=a?.href??a,l=s?.wasm,u=l?.href??l,d=e.wasmBinary,[c,p]=await Ct(o,i,n>1),h=!1,f=[];if(t>0&&f.push(new Promise((e=>{setTimeout((()=>{h=!0,e()}),t)}))),f.push(new Promise(((e,t)=>{let r={numThreads:n};d?r.wasmBinary=d:(u||i)&&(r.locateFile=(e,t)=>u??(i??t)+e),p(r).then((t=>{It=!1,At=!0,Tt=t,e(),c&&URL.revokeObjectURL(c)}),(e=>{It=!1,Mt=!0,t(e)}))}))),await Promise.race(f),h)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Pt=()=>{if(At&&Tt)return Tt;throw new Error("WebAssembly is not initialized yet.")}})),Zu=qe((()=>{Yu(),Rt=(e,t)=>{let n=Pt(),r=n.lengthBytesUTF8(e)+1,s=n._malloc(r);return n.stringToUTF8(e,s,r),t.push(s),s},Dt=(e,t,n,r)=>{if("object"==typeof e&&null!==e){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach((([e,s])=>{let i=t?t+e:e;if("object"==typeof s)Dt(s,i+".",n,r);else if("string"==typeof s||"number"==typeof s)r(i,s.toString());else{if("boolean"!=typeof s)throw new Error("Can\'t handle extra config type: "+typeof s);r(i,s?"1":"0")}}))},Lt=e=>{let t=Pt(),n=t.stackSave();try{let n=t.PTR_SIZE,r=t.stackAlloc(2*n);t._OrtGetLastError(r,r+n);let s=Number(t.getValue(r,4===n?"i32":"i64")),i=t.getValue(r+n,"*"),a=i?t.UTF8ToString(i):"";throw new Error(`${e} ERROR_CODE: ${s}, ERROR_MESSAGE: ${a}`)}finally{t.stackRestore(n)}}})),Ju=qe((()=>{Yu(),Zu(),Ft=e=>{let t=Pt(),n=0,r=[],s=e||{};try{if(void 0===e?.logSeverityLevel)s.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===e?.logVerbosityLevel)s.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===e?.terminate&&(s.terminate=!1);let i=0;return void 0!==e?.tag&&(i=Rt(e.tag,r)),n=t._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,i),0===n&&Lt("Can\'t create run options."),void 0!==e?.extra&&Dt(e.extra,"",new WeakSet,((e,s)=>{let i=Rt(e,r),a=Rt(s,r);0!==t._OrtAddRunConfigEntry(n,i,a)&&Lt(`Can\'t set a run config entry: ${e} - ${s}.`)})),[n,r]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),r.forEach((e=>t._free(e))),e}}})),ed=qe((()=>{Yu(),Zu(),Ut=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},qt=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Vt=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)},Wt=(e,t,n)=>{for(let r of t){let t="string"==typeof r?r:r.name;switch(t){case"webnn":if(t="WEBNN","string"!=typeof r){let t=r?.deviceType;if(t){let r=Rt("deviceType",n),s=Rt(t,n);0!==Pt()._OrtAddSessionConfigEntry(e,r,s)&&Lt(`Can\'t set a session config entry: \'deviceType\' - ${t}.`)}}break;case"webgpu":if(t="JS","string"!=typeof r){let t=r;if(t?.preferredLayout){if("NCHW"!==t.preferredLayout&&"NHWC"!==t.preferredLayout)throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${t.preferredLayout}`);let r=Rt("preferredLayout",n),s=Rt(t.preferredLayout,n);0!==Pt()._OrtAddSessionConfigEntry(e,r,s)&&Lt(`Can\'t set a session config entry: \'preferredLayout\' - ${t.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${t}`)}let s=Rt(t,n);0!==Pt()._OrtAppendExecutionProvider(e,s)&&Lt(`Can\'t append execution provider: ${t}.`)}},jt=e=>{let t=Pt(),n=0,r=[],s=e||{};Vt(s);try{let e=Ut(s.graphOptimizationLevel??"all"),i=qt(s.executionMode??"sequential"),a="string"==typeof s.logId?Rt(s.logId,r):0,o=s.logSeverityLevel??2;if(!Number.isInteger(o)||o<0||o>4)throw new Error(`log serverity level is not valid: ${o}`);let l=s.logVerbosityLevel??0;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log verbosity level is not valid: ${l}`);let u="string"==typeof s.optimizedModelFilePath?Rt(s.optimizedModelFilePath,r):0;if(n=t._OrtCreateSessionOptions(e,!!s.enableCpuMemArena,!!s.enableMemPattern,i,!!s.enableProfiling,0,a,o,l,u),0===n&&Lt("Can\'t create session options."),s.executionProviders&&Wt(n,s.executionProviders,r),void 0!==s.enableGraphCapture){if("boolean"!=typeof s.enableGraphCapture)throw new Error(`enableGraphCapture must be a boolean value: ${s.enableGraphCapture}`);let e=Rt("enableGraphCapture",r),i=Rt(s.enableGraphCapture.toString(),r);0!==t._OrtAddSessionConfigEntry(n,e,i)&&Lt(`Can\'t set a session config entry: \'enableGraphCapture\' - ${s.enableGraphCapture}.`)}if(s.freeDimensionOverrides)for(let[e,i]of Object.entries(s.freeDimensionOverrides)){if("string"!=typeof e)throw new Error(`free dimension override name must be a string: ${e}`);if("number"!=typeof i||!Number.isInteger(i)||i<0)throw new Error(`free dimension override value must be a non-negative integer: ${i}`);let s=Rt(e,r);0!==t._OrtAddFreeDimensionOverride(n,s,i)&&Lt(`Can\'t set a free dimension override: ${e} - ${i}.`)}return void 0!==s.extra&&Dt(s.extra,"",new WeakSet,((e,s)=>{let i=Rt(e,r),a=Rt(s,r);0!==t._OrtAddSessionConfigEntry(n,i,a)&&Lt(`Can\'t set a session config entry: ${e} - ${s}.`)})),[n,r]}catch(e){throw 0!==n&&0!==t._OrtReleaseSessionOptions(n)&&Lt("Can\'t release session options."),r.forEach((e=>t._free(e))),e}}})),td=qe((()=>{Gt=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},Ht=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},Kt=(e,t)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],r="number"==typeof t?t:t.reduce(((e,t)=>e*t),1);return n>0?Math.ceil(r*n):void 0},Xt=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Qt=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Yt=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,Zt=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint64"===e||"int8"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,Jt=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}})),nd=qe((()=>{ct(),en=async e=>{if("string"==typeof e){{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let n=t.headers.get("Content-Length"),r=n?parseInt(n,10):0;if(r<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let n,s=t.body.getReader();try{n=new ArrayBuffer(r)}catch(e){if(!(e instanceof RangeError))throw e;{let e=Math.ceil(r/65536);n=new WebAssembly.Memory({initial:e,maximum:e}).buffer}}let i=0;for(;;){let{done:e,value:t}=await s.read();if(e)break;let r=t.byteLength;new Uint8Array(n,i,r).set(t),i+=r}return new Uint8Array(n,0,r)}}}return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}})),rd=qe((()=>{td(),tn=["V","I","W","E","F"],nn=(e,t)=>{console.log(`[${tn[e]},${(new Date).toISOString()}]${t}`)},an=(e,t)=>{rn=e,sn=t},on=(e,t)=>{let n=Qt(e);n>=Qt(rn)&&nn(n,"function"==typeof t?t():t)},ln=(...e)=>{sn&&on(...e)}})),sd=qe((()=>{td(),un=(e,t)=>new(Xt(t))(e)})),id=qe((()=>{})),ad=qe((()=>{rd(),id(),dn=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),cn=[],pn=e=>16*Math.ceil(Number(e)/16),hn=e=>{for(let t=0;t<cn.length;t++){let n=cn[t];if(e<=n)return n}return 16*Math.ceil(e/16)},fn=1,mn=()=>fn++,_n=async(e,t,n,r)=>{let s=pn(n),i=e.device.createBuffer({size:s,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let a=e.getCommandEncoder();e.endComputePass(),a.copyBufferToBuffer(t,0,i,0,s),e.flush(),await i.mapAsync(GPUMapMode.READ);let o=i.getMappedRange();if(r){let e=r();return e.set(new Uint8Array(o,0,n)),e}return new Uint8Array(o.slice(0,n))}finally{i.destroy()}},gn=class{constructor(e){this.backend=e,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[e]of dn)cn.push(e),this.freeBuffers.set(e,[]),this.freeUniformBuffers.set(e,[]);this.sessionCount=0}upload(e,t){let n=t.buffer,r=t.byteOffset,s=t.byteLength,i=pn(s),a=this.storageCache.get(e);if(!a)throw new Error("gpu data for uploading does not exist");if(Number(a.originalSize)!==s)throw new Error(`inconsistent data size. gpu data size=${a.originalSize}, data size=${s}`);let o=this.backend.device.createBuffer({mappedAtCreation:!0,size:i,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),l=o.getMappedRange();new Uint8Array(l).set(new Uint8Array(n,r,s)),o.unmap();let u=this.backend.device.createCommandEncoder();u.copyBufferToBuffer(o,0,a.gpuData.buffer,0,i),this.backend.device.queue.submit([u.finish()]),o.destroy(),ln("verbose",(()=>`[WebGPU] GpuDataManager.upload(id=${e})`))}memcpy(e,t){let n=this.storageCache.get(e);if(!n)throw new Error("source gpu data for memcpy does not exist");let r=this.storageCache.get(t);if(!r)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==r.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=pn(n.originalSize),i=this.backend.getCommandEncoder();this.backend.endComputePass(),i.copyBufferToBuffer(n.gpuData.buffer,0,r.gpuData.buffer,0,s)}registerExternalBuffer(e,t,n){let r;if(n){if(r=n[0],e===n[1])return ln("verbose",(()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${r}, buffer is the same, skip.`)),r;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error("Registering a different external buffer under graph capture mode is not supported yet.\\n             Please use the previous external buffer!")}else r=mn();return this.storageCache.set(r,{gpuData:{id:r,type:0,buffer:e},originalSize:t}),ln("verbose",(()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${r}, registered.`)),r}unregisterExternalBuffer(e){void 0!==e&&(this.storageCache.delete(e),ln("verbose",(()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`)))}create(e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n,r=hn(e),s=(t&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,i=(t&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||i){let e=(s?this.freeBuffers:this.freeUniformBuffers).get(r);n=e&&e.length>0?e.pop():this.backend.device.createBuffer({size:r,usage:t})}else n=this.backend.device.createBuffer({size:r,usage:t});let a={id:mn(),type:0,buffer:n};return this.storageCache.set(a.id,{gpuData:a,originalSize:Number(e)}),ln("verbose",(()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${a.id}`)),a}get(e){return this.storageCache.get(e)?.gpuData}release(e){let t="bigint"==typeof e?Number(e):e,n=this.storageCache.get(t);if(!n){if(0===this.storageCache.size)return 0;throw new Error("releasing data does not exist")}return ln("verbose",(()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${n.gpuData.id}`)),this.storageCache.delete(t),this.buffersPending.push(n.gpuData.buffer),n.originalSize}async download(e,t){let n=this.storageCache.get(Number(e));if(!n)throw new Error("data does not exist");await _n(this.backend,n.gpuData.buffer,n.originalSize,t)}refreshPendingBuffers(){if(0!==this.buffersPending.length)if("default"===this.backend.sessionStatus){for(let e of this.buffersPending){let t=dn.get(e.size);if((e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let n=this.freeBuffers.get(e.size)||[];void 0===t||n.length>=t?e.destroy():n.push(e)}else if((e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let n=this.freeUniformBuffers.get(e.size)||[];void 0===t||n.length>=t?e.destroy():n.push(e)}else e.destroy()}this.buffersPending=[]}else{let e=this.capturedPendingBuffers.get(this.backend.currentSessionId);e||(e=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,e));for(let t of this.buffersPending)e.push(t);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.freeUniformBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.storageCache.forEach((e=>{e.gpuData.buffer.destroy()})),this.capturedPendingBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(e){let t=this.capturedPendingBuffers.get(e);t&&(t.forEach((e=>{e.destroy()})),this.capturedPendingBuffers.delete(e)),this.sessionCount-=1,0===this.sessionCount&&(ln("warning",(()=>"[WebGPU] Clearing webgpu buffer cache")),this.storageCache.forEach((e=>{e.gpuData.buffer.destroy()})),this.storageCache=new Map)}},wn=(...e)=>new gn(...e)})),od=qe((()=>{yn=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map((e=>`${this[e]}`)).join(";")),this.key}},bn=e=>new yn(e)})),ld=qe((()=>{xn=class{static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}},vn=class{static calcShape(e,t,n=!1){let r=e.length,s=t.length;if(0===r)return t;if(0===s)return e;let i=Math.max(e.length,t.length),a=new Array(i);if(n){if(r<2||s<2)return;let n=xn.calcMatMulShape([e[r-2],e[r-1]],[t[s-2],t[s-1]]);if(void 0===n)return;[a[i-2],a[i-1]]=n}for(let o=n?3:1;o<=i;o++){let n=r-o<0?1:e[r-o],l=s-o<0?1:t[s-o];if(n!==l&&n>1&&l>1)return;let u=Math.max(n,l);if(n&&l)a[i-o]=Math.max(n,l);else{if(u>1)return;a[i-o]=0}}return a}static isValidBroadcast(e,t){let n=e.length,r=t.length;if(n>r)return!1;for(let s=1;s<=n;s++)if(1!==e[n-s]&&e[n-s]!==t[r-s])return!1;return!0}},$n=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static convertShape(e,t=4){let n=e.length;if(0===n)return[];let r=new Array(n),s=n-1;for(;s>=0;){if(e[s]%t==0){r[s]=e[s]/t;break}if(t%e[s]!=0)throw new Error("cannot convert shape");r[s]=1,t/=e[s],s--}for(s--;s>=0;s--)r[s]=e[s];return r}static sizeFromDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,n,t.length)}static sizeToDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,n)}static getSizeFromDimensionRange(e,t,n){let r=1;for(let s=t;s<n;s++){if(e[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");r*=Number(e[s])}return r}static computeStrides(e){let t=e.length;if(0===t)return[];if(1===t)return[1];let n=new Array(t);n[t-1]=1,n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map((n=>this.normalizeAxis(n,t??e.length)))}static sortBasedOnPerm(e,t){return t?t.map((t=>e[t])):e.slice().reverse()}static padShape(e,t){let n=e.length;return e.map(((e,r)=>e+t[r]+t[r+n]))}static areEqual(e,t){return e.length===t.length&&e.every(((e,n)=>e===t[n]))}},kn=class e{static adjustPoolAttributes(e,t,n,r,s,i){if(!e&&n.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let e=0;e<t.length-2;e++)e>=n.length?n.push(t[e+2]):n[e]=t[e+2];for(let e=0;e<n.length;e++)if(e<r.length){if(r[e]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let e=0;e<n.length;e++)if(e<s.length){if(s[e]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let e=0;e<2*n.length;e++)if(e<i.length){if(i[e]<0)throw new Error("pad should be greater than or equal to 1")}else i.push(0);for(let e=0;e<n.length;e++){if(n[e]<=0)throw new Error("kernel shapes need to be greater than 0");if(i[e]>=n[e]||i[e+n.length]>=n[e])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,n,r,s,i,a,o){if(o){if(i.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(s.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let l=0;l<t.length-2;l++)e.adjustPadAndReturnShape(t[l+(a?1:2)],n[l],r[l],s[l],i,l,l+t.length-2,o)}}static computePoolOutputShape(t,n,r,s,i,a,o){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let l=[n[0],n[1]];return e.computeShapeHelper(t,n,l,r,s,i,a,o),l}static computeConvOutputShape(t,n,r,s,i,a,o){if(t.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let l=[t[0],n[0]];return e.computeShapeHelper(!1,t,l,r,s,i,a,o),l}static computeShapeHelper(t,n,r,s,i,a,o,l){if(t)for(let e=0;e<n.length-2;e++)r.push(1);else for(let t=0;t<n.length-2;t++)r.push(e.adjustPadAndReturnShape(n[t+2],s[t],i[t],a[t],o,t,t+n.length-2,l))}static adjustPadAndReturnShape(e,t,n,r,s,i,a,o){let l=n*(r-1)+1;if(!o||"NOTSET"===o)return Math.floor((e+s[i]+s[a]-l)/t+1);switch(o){case"VALID":return s[i]=0,s[a]=0,Math.floor((e-l)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let n=((e+t-1)/t-1)*t+r-e;return s[i]=Math.floor("SAME_LOWER"===o?(n+1)/2:n/2),s[a]=n-s[i],Math.floor((e+n-r)/t+1)}default:throw new Error("Unsupported AutoPad type")}}},En=class{static getShapeOfGemmResult(e,t,n,r,s){if(2!==e.length||2!==n.length)throw new Error("shape need to be of size 2");let i,a,o;t?(i=e[1],a=e[0]):(i=e[0],a=e[1]);let l=-1;if(r?(o=n[0],l=1):(o=n[1],l=0),n[l]!==a)throw new Error("dimension mismatch");if(i<=0||o<=0||a<=0)throw new Error("invalid shape specified");if(s&&!vn.isValidBroadcast(s,[i,o]))throw new Error("gemm: invalid bias shape for broadcast");return[i,o,a]}},Sn=-34028234663852886e22,zn=34028234663852886e22})),ud=qe((()=>{td(),ld(),Cn=64,Tn=(e,t)=>{if(3===t)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(e)){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(4!==t)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${e}`)}},An=(e,t=1)=>{let n=Tn(e,t);return"string"==typeof n?n:n[0]},In=(e,t=1)=>{let n=Tn(e,t);return"string"==typeof n?n:n[1]},Mn=(...e)=>{let t=[];return e.forEach((e=>{0!==e.length&&t.push({type:12,data:e},{type:12,data:$n.computeStrides(e)})})),t},On=e=>e%4==0?4:e%2==0?2:1,Bn=(e="f32",t,n="0")=>t&&1!==t?`vec${t}<${e}>(${n})`:`${e}(${n})`,Nn=(e,t,n)=>"f32"===e?n:1===t?`f32(${n})`:`vec${t}<f32>(${n})`,Pn=(e,t)=>4===t?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:2===t?`(${e}.x + ${e}.y)`:3===t?`(${e}.x + ${e}.y + ${e}.z)`:e,Rn=(e,t,n,r)=>e.startsWith("uniforms.")&&n>4?"string"==typeof t?"f16"===r?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:"f16"===r?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:n>1?`${e}[${t}]`:e,Dn=(e,t,n,r,s)=>{let i="number"==typeof n,a=i?n:n.length,o=[...new Array(a).keys()],l=a<2?"u32":a<=4?`vec${a}<u32>`:`array<u32, ${a}>`,u=Tn(t,s),d="string"==typeof u?u:u[1],c="string"==typeof u?u:u[0],p={indices:l,value:d,storage:c,tensor:t},h=e=>"string"==typeof e?e:`${e}u`,f={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},m=i?"uniforms.":"",_=`${m}${e}_shape`,g=`${m}${e}_strides`,w="";for(let e=0;e<a-1;e++)w+=`\\n    let dim${e} = current / ${Rn(g,e,a)};\\n    let rest${e} = current % ${Rn(g,e,a)};\\n    indices[${e}] = dim${e};\\n    current = rest${e};\\n    `;w+=`indices[${a-1}] = current;`;let y=a<2?"":`\\n  fn o2i_${e}(offset: u32) -> ${p.indices} {\\n    var indices: ${p.indices};\\n    var current = offset;\\n    ${w}\\n    return indices;\\n  }`,b=[];if(a>=2)for(let e=a-1;e>=0;e--)b.push(`${Rn(g,e,a)} * (indices[${e}])`);let x=a<2?"":`\\n  fn i2o_${e}(indices: ${p.indices}) -> u32 {\\n    return ${b.join("+")};\\n  }`,v=(...e)=>0===a?"0u":`${p.indices}(${e.map(h).join(",")})`,$=(e,t)=>a<2?`${e}`:`${Rn(e,t,a)}`,k={},E=(t,n)=>(()=>{if(p.storage===p.value)return`${e}[${t}]=${n};`;if("vec2<u32>"===p.storage&&"i32"===p.value)return`${e}[${t}]=vec2<u32>(u32(${n}), select(0u, 0xFFFFFFFFu, ${n} < 0));`;if("vec2<u32>"===p.storage&&"u32"===p.value)return`${e}[${t}]=vec2<u32>(u32(${n}), 0u);`;if("u32"===p.storage&&"vec4<bool>"===p.value)return`${e}[${t}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${n}));`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),S=t=>(()=>{if(p.storage===p.value)return`${e}[${t}]`;if("vec2<u32>"===p.storage&&"i32"===p.value)return`i32(${e}[${t}].x)`;if("vec2<u32>"===p.storage&&"u32"===p.value)return`u32(${e}[${t}].x)`;if("u32"===p.storage&&"vec4<bool>"===p.value)return`vec4<bool>(bool(${e}[${t}] & 0xFFu), bool(${e}[${t}] & 0xFF00u), bool(${e}[${t}] & 0xFF0000u), bool(${e}[${t}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),z=a<2?"":`\\n  fn get_${e}ByIndices(indices: ${p.indices}) -> ${d} {\\n    return ${S(`i2o_${e}(indices)`)};\\n  }`,C=a<2?"":(()=>{let t=o.map((e=>`d${e}: u32`)).join(", "),n=o.map((e=>`d${e}`)).join(", ");return`\\n  fn get_${e}(${t}) -> ${d} {\\n    return get_${e}ByIndices(${v(n)});\\n  }`})(),T=a<2?"":`\\n  fn set_${e}ByIndices(indices: ${p.indices}, value: ${d}) {\\n    ${E(`i2o_${e}(indices)`,"value")}\\n  }`,A=a<2?"":(()=>{let t=o.map((e=>`d${e}: u32`)).join(", "),n=o.map((e=>`d${e}`)).join(", ");return`\\n  fn set_${e}(${t}, value: ${d}) {\\n    set_${e}ByIndices(${v(n)}, value);\\n  }`})();return{impl:()=>{let e=[],t=!1;return f.offsetToIndices&&(e.push(y),t=!0),f.indicesToOffset&&(e.push(x),t=!0),f.broadcastedIndicesToOffset&&(Object.values(k).forEach((t=>e.push(t))),t=!0),f.set&&(e.push(A),t=!0),f.setByIndices&&(e.push(T),t=!0),f.get&&(e.push(C),t=!0),f.getByIndices&&(e.push(z),t=!0),!i&&t&&e.unshift(`const ${_} = ${p.indices}(${n.join(",")});`,`const ${g} = ${p.indices}(${$n.computeStrides(n).join(",")});`),e.join("\\n")},type:p,offsetToIndices:t=>(f.offsetToIndices=!0,a<2?t:`o2i_${e}(${t})`),indicesToOffset:t=>(f.indicesToOffset=!0,a<2?t:`i2o_${e}(${t})`),broadcastedIndicesToOffset:(t,n)=>{f.broadcastedIndicesToOffset=!0;let r=`${n.name}broadcastedIndicesTo${e}Offset`;if(r in k)return`${r}(${t})`;let s=[];for(let e=a-1;e>=0;e--){let t=n.indicesGet("outputIndices",e+n.rank-a);s.push(`${$(g,e)} * (${t} % ${$(_,e)})`)}return k[r]=`fn ${r}(outputIndices: ${n.type.indices}) -> u32 {\\n             return ${s.length>0?s.join("+"):"0u"};\\n           }`,`${r}(${t})`},indices:v,indicesGet:$,indicesSet:(e,t,n)=>a<2?`${e}=${n};`:`${Rn(e,t,a)}=${n};`,set:(...t)=>{if(t.length!==a+1)throw new Error(`indices length must be ${a}`);let n=t[a];if("string"!=typeof n)throw new Error("value must be string");let r=t.slice(0,a).map(h).join(",");return 0===a?E("0u",n):1===a?E(r[0],n):(f.set=!0,f.setByIndices=!0,f.indicesToOffset=!0,`set_${e}(${r}, ${n})`)},setByOffset:E,setByIndices:(t,n)=>a<2?E(t,n):(f.setByIndices=!0,f.indicesToOffset=!0,`set_${e}ByIndices(${t}, ${n});`),get:(...t)=>{if(t.length!==a)throw new Error(`indices length must be ${a}`);let n=t.map(h).join(",");return 0===a?S("0u"):1===a?S(n[0]):(f.get=!0,f.getByIndices=!0,f.indicesToOffset=!0,`get_${e}(${n})`)},getByOffset:S,getByIndices:t=>a<2?S(t):(f.getByIndices=!0,f.indicesToOffset=!0,`get_${e}ByIndices(${t})`),usage:r,name:e,strides:g,shape:_,rank:a}},Ln=(e,t,n,r=1)=>Dn(e,t,n,"input",r),Fn=(e,t,n,r=1)=>Dn(e,t,n,"output",r),Un=(e,t,n)=>Dn(e,t,n,"atomicOutput",1),qn=(e,t,n,r=1)=>Dn(e,t,n,"internal",r),Vn=class{constructor(e,t){this.normalizedDispatchGroup=e,this.limits=t,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${"number"==typeof e?`${e}u`:e}) { return; }`}mainStart(e=Cn){let t="number"==typeof e?e:e[0],n="number"==typeof e?1:e[1],r="number"==typeof e?1:e[2];if(t>this.limits.maxComputeWorkgroupSizeX||n>this.limits.maxComputeWorkgroupSizeY||r>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${t}, ${n}, ${r}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(t*n*r>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${t}, ${n}, ${r}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let s=1===this.normalizedDispatchGroup[1]&&1===this.normalizedDispatchGroup[2];return`@compute @workgroup_size(${t}, ${n}, ${r})\\n  fn main(${s?"@builtin(global_invocation_id) global_id : vec3<u32>,\\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\\n    @builtin(local_invocation_index) local_idx : u32,\\n    @builtin(local_invocation_id) local_id : vec3<u32>":"@builtin(global_invocation_id) global_id : vec3<u32>,\\n                                             @builtin(local_invocation_id) local_id : vec3<u32>,\\n    @builtin(local_invocation_index) local_idx : u32,\\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\\n    @builtin(num_workgroups) num_workgroups : vec3<u32>"}) {\\n    ${s?"let global_idx = global_id.x;\\n         let workgroup_index = workgroup_id.x;":`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\\n             workgroup_id.y * num_workgroups[0] + workgroup_id.x;\\n         let global_idx = workgroup_index * ${t*n*r}u + local_idx;`}\\n  `}appendVariableUniforms(e){0!==e.rank&&(e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:"u32",length:e.rank}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:"u32",length:e.rank}))}declareVariable(e,t){if("internal"===e.usage)throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(e),this.appendVariableUniforms(e);let n="input"===e.usage?"read":"read_write",r="atomicOutput"===e.usage?"atomic<i32>":e.type.storage;return`@group(0) @binding(${t}) var<storage, ${n}> ${e.name}: array<${r}>;`}declareVariables(...e){return e.map((e=>this.declareVariable(e,this.variableIndex++))).join("\\n")}registerInternalVariable(e){if("internal"!==e.usage)throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(e),this.appendVariableUniforms(e)}registerInternalVariables(...e){return e.forEach((e=>this.registerInternalVariable(e))),this}registerUniform(e,t,n=1){return this.uniforms.push({name:e,type:t,length:n}),this}registerUniforms(e){return this.uniforms=this.uniforms.concat(e),this}uniformDeclaration(){if(0===this.uniforms.length)return"";let e=[];for(let{name:t,type:n,length:r}of this.uniforms)if(r&&r>4)"f16"===n?e.push(`@align(16) ${t}:array<mat2x4<${n}>, ${Math.ceil(r/8)}>`):e.push(`${t}:array<vec4<${n}>, ${Math.ceil(r/4)}>`);else{let s=null==r||1===r?n:`vec${r}<${n}>`;e.push(`${t}:${s}`)}return`\\n      struct Uniforms { ${e.join(", ")} };\\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map((e=>e.impl())).join("\\n")+this.internalVariables.map((e=>e.impl())).join("\\n")}get variablesInfo(){if(0===this.uniforms.length)return;let e=e=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(e)];return this.uniforms.map((t=>[e(t.type),t.length??1]))}},Wn=(e,t)=>new Vn(e,t)})),dd=qe((()=>{td(),ld(),od(),ud(),jn=e=>{if(!e||1!==e.length)throw new Error("Transpose requires 1 input.")},Gn=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,Hn=(e,t)=>$n.sortBasedOnPerm(e,Gn(e.length,t)),Kn=(e,t,n,r)=>{let s=`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {\\n    var a: ${n.type.indices};`;for(let n=0;n<t;++n)s+=`a[${e[n]}]=i[${n}];`;return s+"return a;}"},Xn=(e,t)=>{let n=[],r=[];for(let s=0;s<e.length;++s)1!==e[s]&&n.push(e[s]),1!==e[t[s]]&&r.push(t[s]);return{newShape:n,newPerm:r}},Qn=(e,t)=>{let n=0;for(let r=0;r<e.length;++r)if(1!==t[e[r]]){if(e[r]<n)return!1;n=e[r]}return!0},Yn=(e,t)=>{let n,r=e.dataType,s=e.dims.length,i=Gn(s,t),a=Hn(e.dims,i),o=e.dims,l=a;if(s<2||Qn(i,e.dims))return n=e=>{let t=Ln("input",r,o,4),n=Fn("output",r,l,4);return`\\n  ${e.registerUniform("output_size","u32").declareVariables(t,n)}\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n    output[global_idx] = input[global_idx];\\n  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let t=$n.size(a);return{outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(t/64/4)},programUniforms:[{type:12,data:Math.ceil(t/4)}]}},getShaderSource:n};let{newShape:u,newPerm:d}=Xn(e.dims,i),c=$n.areEqual(d,[2,3,1]),p=$n.areEqual(d,[3,1,2]);if(2===u.length||c||p){o=c?[u[0],u[1]*u[2]]:p?[u[0]*u[1],u[2]]:u,l=[o[1],o[0]];let t=16;return n=e=>{let n=Ln("a",r,o.length),s=Fn("output",r,l.length);return`\\n  ${e.registerUniform("output_size","u32").declareVariables(n,s)}\\n  var<workgroup> tile : array<array<${s.type.value}, ${t+1}>, ${t}>;\\n  ${e.mainStart([t,t,1])}\\n    let stride = (uniforms.output_shape[1] - 1) / ${t} + 1;\\n    let workgroup_id_x = workgroup_index % stride;\\n    let workgroup_id_y = workgroup_index / stride;\\n    let input_col = workgroup_id_y * ${t}u + local_id.x;\\n    let input_row = workgroup_id_x * ${t}u + local_id.y;\\n    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {\\n      tile[local_id.y][local_id.x] = ${n.getByIndices(`${n.type.indices}(input_row, input_col)`)};\\n    }\\n    workgroupBarrier();\\n\\n    let output_col = workgroup_id_x * ${t}u + local_id.x;\\n    let output_row = workgroup_id_y * ${t}u + local_id.y;\\n    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {\\n      ${s.setByIndices(`${s.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}\\n    }\\n  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let n=$n.size(a);return{outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(l[1]/t),y:Math.ceil(l[0]/t)},programUniforms:[{type:12,data:n},...Mn(o,l)]}},getShaderSource:n}}return n=e=>{let t=Ln("a",r,o.length),n=Fn("output",r,l.length);return`\\n  ${e.registerUniform("output_size","u32").declareVariables(t,n)}\\n\\n  ${Kn(i,s,t,n)}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n\\n    let indices = ${n.offsetToIndices("global_idx")};\\n    let aIndices = perm(indices);\\n\\n    ${n.setByOffset("global_idx",t.getByIndices("aIndices"))}\\n  }`},{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:["rank"]},getRunData:()=>{let t=$n.size(a);return{outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(t/64)},programUniforms:[{type:12,data:t},...Mn(o,l)]}},getShaderSource:n}},Zn=(e,t)=>{jn(e.inputs),e.compute(Yn(e.inputs[0],t.perm))},Jn=e=>bn({perm:e.perm})})),cd=qe((()=>{td(),ld(),ud(),pd(),dd(),er={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},tr={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},nr={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},rr={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},sr=(e,t)=>{let n=[];for(let r=t-e;r<t;++r)n.push(r);return n},ir=(e,t)=>{let n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);return[n,t.map((t=>e[t]))]},ar=(e,t)=>{let n=e.length+t.length,r=[],s=0;for(let i=0;i<n;i++)-1===t.indexOf(i)?r.push(e[s++]):r.push(1);return r},or=(e,t)=>{for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0},lr=(e,t)=>{let n=[];if(!or(e,t)){for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);e.forEach((e=>n.push(e)))}return n},ur=(e,t,n,r,s,i,a)=>{let o=n[0].dims,l=$n.size(i),u=$n.size(a),d=Ln("_A",n[0].dataType,o),c=Fn("output",s,i),p=64;1===l&&(p=256);let h=`\\n          var<workgroup> aBestValues : array<f32, ${p}>;\\n       `;return{name:e,shaderCache:{hint:`${t};${p}`,inputDependencies:["type"]},getShaderSource:e=>`\\n        ${e.registerUniform("reduceSize","u32").declareVariables(d,c)}\\n        ${h}\\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\\n          return ((a - 1u) / b + 1u);\\n         }\\n         ${e.mainStart(p)}\\n\\n          let outputIndex = global_idx / ${p};\\n          let offset = outputIndex * uniforms.reduceSize;\\n\\n          var bestValue = f32(${nr[r]});\\n          let Length = uniforms.reduceSize;\\n          for (var k = local_idx; k < Length; k = k + ${p}) {\\n           let candidate = f32(${d.getByOffset("offset + k")});\\n           bestValue = ${er[r]};\\n          }\\n          aBestValues[local_idx] = bestValue;\\n          workgroupBarrier();\\n\\n         var reduceSize = min(Length, ${p}u);\\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\\n             currentSize = reduceSize / 2u) {\\n           let interval = DIV_CEIL(reduceSize, 2u);\\n           if (local_idx < currentSize) {\\n            let candidate = aBestValues[local_idx + interval];\\n            bestValue = ${tr[r]};\\n            aBestValues[local_idx] = bestValue;\\n           }\\n           reduceSize = interval;\\n           workgroupBarrier();\\n         }\\n\\n         if (local_idx == 0u) {\\n          ${c.setByOffset("outputIndex",""+("mean"===r?`${c.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${c.type.storage}(${rr[r]})`))};\\n         }\\n        }`,getRunData:()=>({outputs:[{dims:i,dataType:s}],dispatchGroup:{x:l},programUniforms:[{type:12,data:u}]})}},dr=(e,t,n,r)=>{let s=1===e.inputs.length?n:kr(e.inputs,n),i=s.axes;0===i.length&&!s.noopWithEmptyAxes&&(i=e.inputs[0].dims.map(((e,t)=>t)));let a=$n.normalizeAxes(i,e.inputs[0].dims.length),o=a,l=e.inputs[0],u=lr(o,e.inputs[0].dims.length);u.length>0&&(l=e.compute(Yn(e.inputs[0],u),{inputs:[0],outputs:[-1]})[0],o=sr(o.length,l.dims.length));let[d,c]=ir(l.dims,o),p=d;s.keepDims&&(p=ar(d,a)),e.compute(ur(t,s.cacheKey,[l],r,e.inputs[0].dataType,p,c),{inputs:[l]})},cr=(e,t)=>{dr(e,"ReduceMeanShared",t,"mean")},pr=(e,t)=>{dr(e,"ReduceL1Shared",t,"l1")},hr=(e,t)=>{dr(e,"ReduceL2Shared",t,"l2")},fr=(e,t)=>{dr(e,"ReduceLogSumExpShared",t,"logSumExp")},mr=(e,t)=>{dr(e,"ReduceMaxShared",t,"max")},_r=(e,t)=>{dr(e,"ReduceMinShared",t,"min")},gr=(e,t)=>{dr(e,"ReduceProdShared",t,"prod")},wr=(e,t)=>{dr(e,"ReduceSumShared",t,"sum")},yr=(e,t)=>{dr(e,"ReduceSumSquareShared",t,"sumSquare")},br=(e,t)=>{dr(e,"ReduceLogSumShared",t,"logSum")}})),pd=qe((()=>{td(),ld(),od(),ud(),cd(),xr=e=>{if(!e||0===e.length||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(2===e.length&&1!==e[1].dims.length)throw new Error("Invalid axes input dims.")},vr=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],$r=(e,t,n,r,s,i,a=!1,o=!1)=>{let l=[],u=n[0].dims,d=u.length,c=$n.normalizeAxes(s,d),p=!o&&0===c.length;u.forEach(((e,t)=>{p||c.indexOf(t)>=0?a&&l.push(1):l.push(e)}));let h=l.length,f=$n.size(l);return{name:e,shaderCache:t,getShaderSource:e=>{let t=[],s=Ln("_A",n[0].dataType,d),o=Fn("output",i,h),l=r(s,o,c),f=l[2];for(let e=0,n=0;e<d;e++)p||c.indexOf(e)>=0?(a&&n++,f=`for(var j${e}: u32 = 0; j${e} < ${u[e]}; j${e}++) {\\n                  ${l[2].includes("last_index")?`let last_index = j${e};`:""}\\n                  ${s.indicesSet("input_indices",e,`j${e}`)}\\n                  ${f}\\n                }`):(t.push(`${s.indicesSet("input_indices",e,o.indicesGet("output_indices",n))};`),n++);return`\\n\\n        ${e.registerUniform("output_size","u32").declareVariables(s,o)}\\n\\n        ${e.mainStart()}\\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n          var input_indices: ${s.type.indices};\\n          let output_indices = ${o.offsetToIndices("global_idx")};\\n\\n          ${t.join("\\n")}\\n          ${l[0]}       // init ops for reduce max/min\\n          ${l[1]}\\n          ${f}\\n          ${l[3]}\\n          ${4===l.length?o.setByOffset("global_idx","value"):l.slice(4).join("\\n")}\\n        }`},getRunData:()=>({outputs:[{dims:l,dataType:i}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:[{type:12,data:f},...Mn(u,l)]})}},kr=(e,t)=>{let n=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach((e=>n.push(Number(e)))),bn({axes:n,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},Er=(e,t,n,r)=>{let s=e.inputs,i=1===s.length?n:kr(s,n);e.compute($r(t,{hint:i.cacheKey,inputDependencies:["rank"]},[s[0]],i.noopWithEmptyAxes&&0===i.axes.length?vr:r,i.axes,s[0].dataType,i.keepDims,i.noopWithEmptyAxes),{inputs:[0]})},Sr=(e,t)=>{xr(e.inputs),Er(e,"ReduceLogSum",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByIndices("input_indices")};`,"value = log(value);"]))},zr=(e,t)=>{xr(e.inputs),Er(e,"ReduceL1",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += abs(${e.getByIndices("input_indices")});`,""]))},Cr=(e,t)=>{xr(e.inputs),Er(e,"ReduceL2",t,((e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"]))},Tr=(e,t)=>{xr(e.inputs),Er(e,"ReduceLogSumExp",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += exp(${e.getByIndices("input_indices")});`,"value = log(value);"]))},Ar=(e,t)=>{xr(e.inputs),Er(e,"ReduceMax",t,((e,t,n)=>{let r=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&r.push(e.indicesSet("input_indices",t,0));return[`${r.join("\\n")}`,`var value = ${e.getByIndices("input_indices")};`,`value = max(value, ${e.getByIndices("input_indices")});`,""]}))},Ir=(e,t)=>{xr(e.inputs),Er(e,"ReduceMean",t,((t,n,r)=>{let s=1;for(let n=0;n<t.rank;n++)(r.indexOf(n)>=0||0===r.length)&&(s*=e.inputs[0].dims[n]);return["var sum = f32(0);","",`sum += f32(${t.getByIndices("input_indices")});`,`let value = ${n.type.value}(sum / ${s});`]}))},Mr=(e,t)=>{xr(e.inputs),Er(e,"ReduceMin",t,((e,t,n)=>{let r=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&r.push(`input_indices[${t}] = 0;`);return[`${r.join("\\n")}`,`var value = ${e.getByIndices("input_indices")};`,`value = min(value, ${e.getByIndices("input_indices")});`,""]}))},Or=(e,t)=>{xr(e.inputs),Er(e,"ReduceProd",t,((e,t)=>[`var value = ${t.type.storage}(1);`,"",`value *= ${e.getByIndices("input_indices")};`,""]))},Br=(e,t)=>{xr(e.inputs),Er(e,"ReduceSum",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByIndices("input_indices")};`,""]))},Nr=(e,t)=>{xr(e.inputs),Er(e,"ReduceSumSquare",t,((e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByIndices("input_indices")}; value += t * t;`,""]))},Pr=(e,t,n)=>{if(0===t.length)return n;let r=1,s=1;for(let n=0;n<t.length;n++)-1===t.indexOf(n)?r*=e[n]:s*=e[n];return s<32&&r>1024},Rr=(e,t)=>{Pr(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ir(e,t):cr(e,t)},Dr=(e,t)=>{Pr(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?zr(e,t):pr(e,t)},Lr=(e,t)=>{Pr(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Cr(e,t):hr(e,t)},Fr=(e,t)=>{Pr(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Tr(e,t):fr(e,t)},Ur=(e,t)=>{Pr(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ar(e,t):mr(e,t)},qr=(e,t)=>{Pr(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Mr(e,t):_r(e,t)},Vr=(e,t)=>{Pr(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Or(e,t):gr(e,t)},Wr=(e,t)=>{Pr(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Br(e,t):wr(e,t)},jr=(e,t)=>{Pr(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Nr(e,t):yr(e,t)},Gr=(e,t)=>{Pr(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Sr(e,t):br(e,t)}})),hd=qe((()=>{td(),od(),pd(),Hr=e=>{if(!e||0===e.length||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(1!==e[0].dataType)throw new Error("Invalid input type.")},Kr=(e,t)=>{Hr(e.inputs);e.compute($r("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],((e,n,r)=>{let s=[];for(let t=0;t<e.rank;t++)(r.indexOf(t)>=0||0===r.length)&&s.push(`input_indices[${t}] = 0;`);return[`${s.join("\\n")}`,`var value = ${e.getByIndices("input_indices")};\\nvar best_index : i32 = 0;`,`if (${e.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {\\n         value = ${e.getByIndices("input_indices")};\\n         best_index = i32(last_index);\\n       }`,"",n.setByOffset("global_idx","best_index")]}),[t.axis],7,t.keepDims),{inputs:[0]})},Xr=(e,t)=>{Hr(e.inputs);e.compute($r("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],((e,n,r)=>{let s=[];for(let t=0;t<e.rank;t++)(r.indexOf(t)>=0||0===r.length)&&s.push(`input_indices[${t}] = 0;`);return[`${s.join("\\n")}`,`var value = ${e.getByIndices("input_indices")};\\nvar best_index : i32 = 0;`,`if (${e.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {\\n         value = ${e.getByIndices("input_indices")};\\n         best_index = i32(last_index);\\n       }`,"",n.setByOffset("global_idx","best_index")]}),[t.axis],7,t.keepDims),{inputs:[0]})},Qr=e=>bn(e)})),fd=qe((()=>{td(),ld(),id(),ud(),Yr=(e,t)=>{let n=e[0],r=e[1],s=e[2],i=e[3],a=e[4],o=e[5];if(a&&o)throw new Error("Attention cannot have both past and attention_bias");if(3!==n.dims.length)throw new Error(\'Input "input" must have 3 dimensions\');let l=n.dims[0],u=n.dims[1],d=n.dims[2];if(1!==s.dims.length)throw new Error(\'Input "bias" is expected to have 1 dimensions\');if(2!==r.dims.length)throw new Error(\'Input "weights" is expected to have 2 dimensions\');if(r.dims[0]!==d)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(s.dims[0]!==r.dims[1])throw new Error(\'Input "bias" dimension 0 should have same length as dimension 1 of input "weights"\');let c=s.dims[0]/3,p=c,h=p;if(t.qkvHiddenSizes.length>0){if(3!==t.qkvHiddenSizes.length)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let e of t.qkvHiddenSizes)if(e%t.numHeads!=0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");c=t.qkvHiddenSizes[0],p=t.qkvHiddenSizes[1],h=t.qkvHiddenSizes[2]}let f=u;if(c!==p)throw new Error("qkv_hidden_sizes first element should be same as the second");if(s.dims[0]!==c+p+h)throw new Error(\'Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes\');let m=0;if(a){if(p!==h)throw new Error(\'Input "past" expect k_hidden_size == v_hidden_size\');if(5!==a.dims.length)throw new Error(\'Input "past" must have 5 dimensions\');if(2!==a.dims[0])throw new Error(\'Input "past" first dimension must be 2\');if(a.dims[1]!==l)throw new Error(\'Input "past" second dimension must be batch_size\');if(a.dims[2]!==t.numHeads)throw new Error(\'Input "past" third dimension must be num_heads\');if(a.dims[4]!==p/t.numHeads)throw new Error(\'Input "past" fifth dimension must be k_hidden_size / num_heads\');t.pastPresentShareBuffer||(m=a.dims[3])}let _=f+m;if(i)throw new Error("Mask not supported");if(a)throw new Error("past is not supported");if(o){if(4!==o.dims.length)throw new Error(\'Input "attention_bias" must have 4 dimensions\');if(o.dims[0]!==l||o.dims[1]!==t.numHeads||o.dims[2]!==u||o.dims[3]!==_)throw new Error(\'Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)\')}return{batchSize:l,sequenceLength:u,pastSequenceLength:m,kvSequenceLength:f,totalSequenceLength:_,maxSequenceLength:-1,inputHiddenSize:d,hiddenSize:c,vHiddenSize:h,headSize:Math.floor(c/t.numHeads),vHeadSize:Math.floor(h/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:0,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},Zr=(e,t,n)=>t&&e?`\\n      let total_sequence_length_input = u32(${t.getByOffset("0")});\\n      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);\\n      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;\\n      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;\\n      total_sequence_length = u32(${e?.getByOffset("batchIdx")}) + 1;\\n      var past_sequence_length: u32 = 0;\\n      if (is_first_prompt == false) {\\n        past_sequence_length = total_sequence_length - sequence_length;\\n      }\\n       `:`\\n    ${n?"let past_sequence_length = uniforms.past_sequence_length":""};\\n    let present_sequence_length = total_sequence_length;\\n    `,Jr=(e,t,n,r,s,i,a,o)=>{let l=On(a?1:i),u=64,d=i/l;d<u&&(u=32);let c=Math.ceil(i/l/u),p=[{type:12,data:t},{type:12,data:n},{type:12,data:r},{type:12,data:s},{type:12,data:d},{type:12,data:c}],h=An(e.dataType,l),f=In(1,l),m=["type"];a&&m.push("type"),o&&m.push("type");return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${u};${h};${l}`,inputDependencies:m},getShaderSource:t=>{let n=Fn("x",e.dataType,e.dims,l),r=[n],s=a?Ln("seq_lens",a.dataType,a.dims):void 0;s&&r.push(s);let i=o?Ln("total_sequence_length_input",o.dataType,o.dims):void 0;i&&r.push(i);let d=In(e.dataType);return`\\n  var<workgroup> thread_max: array<f32, ${u}>;\\n  var<workgroup> thread_sum: array<f32, ${u}>;\\n  ${t.registerUniforms([{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}]).declareVariables(...r)}\\n  ${t.mainStart([u,1,1])}\\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\\n    let headIdx = workgroup_id.z % uniforms.num_heads;\\n    let sequence_length = uniforms.sequence_length;\\n    var total_sequence_length = uniforms.total_sequence_length;\\n    ${Zr(s,i,!1)}\\n    let local_offset = local_idx * uniforms.elements_per_thread;\\n    let offset = (global_idx / ${u}) * uniforms.total_sequence_length + local_offset;\\n    let seq_causal_length = ${a?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};\\n    var thread_max_vector = ${f}(-3.402823e+38f);\\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\\n      thread_max_vector = max(${f}(x[offset + i]), thread_max_vector);\\n    }\\n    thread_max[local_idx] = ${(()=>{switch(l){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${l}`)}})()};\\n    workgroupBarrier();\\n\\n    var max_value =  f32(-3.402823e+38f);\\n    for (var i = 0u; i < ${u}; i++) {\\n      max_value = max(thread_max[i], max_value);\\n    }\\n\\n    var sum_vector = ${f}(0);\\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\\n      sum_vector += exp(${f}(x[offset + i]) - max_value);\\n    }\\n    thread_sum[local_idx] = ${(()=>{switch(l){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${l}`)}})()};\\n    workgroupBarrier();\\n\\n    var sum: f32 = 0;\\n    for (var i = 0u; i < ${u}; i++) {\\n      sum += thread_sum[i];\\n    }\\n\\n    if (sum == 0) {\\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\\n        x[offset + i] = ${n.type.value}(${d}(1.0) / ${d}(seq_causal_length));\\n      }\\n    } else {\\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\\n        var f32input = ${f}(x[offset + i]);\\n        x[offset + i] = ${n.type.value}(exp(f32input - max_value) / sum);\\n      }\\n    }\\n      ${a?`\\n        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {\\n          x[offset + total_seq_id] = ${n.type.value}(${d}(0));\\n        }`:""};\\n  }`},getRunData:()=>({outputs:[],dispatchGroup:{x:Math.ceil(i/u),y:s,z:t*n},programUniforms:p})}},es=(e,t,n,r,s,i,a,o,l)=>{let u=a+i.kvSequenceLength,d=[i.batchSize,i.numHeads,i.sequenceLength,u],c=e>1&&r,p=i.kvNumHeads?i.kvNumHeads:i.numHeads,h=c?[i.batchSize,p,u,i.headSize]:void 0,f=i.nReps?i.nReps:1,m=0===i.scale?1/Math.sqrt(i.headSize):i.scale,_=On(i.headSize),g=i.headSize/_,w=12,y={x:Math.ceil(u/w),y:Math.ceil(i.sequenceLength/w),z:i.batchSize*i.numHeads},b=[{type:12,data:i.sequenceLength},{type:12,data:g},{type:12,data:u},{type:12,data:i.numHeads},{type:12,data:i.headSize},{type:1,data:m},{type:12,data:a},{type:12,data:i.kvSequenceLength},{type:12,data:f}],x=c&&r&&$n.size(r.dims)>0,v=["type","type"];x&&v.push("type"),s&&v.push("type"),o&&v.push("type"),l&&v.push("type");let $=[{dims:d,dataType:t.dataType,gpuDataType:0}];c&&$.push({dims:h,dataType:t.dataType,gpuDataType:0});return{name:"AttentionProbs",shaderCache:{hint:`${_};${void 0!==s};${void 0!==r};${e}`,inputDependencies:v},getRunData:()=>({outputs:$,dispatchGroup:y,programUniforms:b}),getShaderSource:e=>{let i=Ln("q",t.dataType,t.dims,_),a=[i,Ln("key",n.dataType,n.dims,_)];if(x){let e=Ln("past_key",r.dataType,r.dims,_);a.push(e)}s&&a.push(Ln("attention_bias",s.dataType,s.dims));let u=o?Ln("seq_lens",o.dataType,o.dims):void 0;u&&a.push(u);let p=l?Ln("total_sequence_length_input",l.dataType,l.dims):void 0;p&&a.push(p);let m=Fn("output",t.dataType,d),g=[m];c&&g.push(Fn("present_key",t.dataType,h,_));let y=In(1,_);return`\\n  const TILE_SIZE = 12u;\\n\\n  var<workgroup> tileQ: array<${i.type.storage}, 144>;\\n  var<workgroup> tileK: array<${i.type.storage}, 144>;\\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}]).declareVariables(...a,...g)}\\n  ${e.mainStart([w,w,1])}\\n    // x holds the N and y holds the M\\n    let headIdx = workgroup_id.z % uniforms.num_heads;\\n    let kvHeadIdx = ${1===f?"headIdx":"headIdx / uniforms.n_reps"};\\n    let kv_num_heads = ${1===f?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};\\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\\n    let m = workgroup_id.y * TILE_SIZE;\\n    let n = workgroup_id.x * TILE_SIZE;\\n    let sequence_length = uniforms.M;\\n    var total_sequence_length = uniforms.N;\\n    ${Zr(u,p,!0)}\\n    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;\\n    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\\n    ${x&&c?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};\\n    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;\\n    ${c?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}\\n    var value = ${y}(0);\\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\\n      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {\\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\\n      }\\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\\n        var idx = TILE_SIZE * local_id.y + local_id.x;\\n      ${x&&c?"\\n              if (n + local_id.y < past_sequence_length) {\\n                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\\n              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\\n                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];\\n              }":"\\n          if (n + local_id.y < uniforms.kv_sequence_length) {\\n            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\\n          }"}\\n      ${c?"if (n + local_id.y < present_sequence_length) {\\n        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];\\n      }":""}\\n      }\\n      workgroupBarrier();\\n\\n      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\\n          value += ${y}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);\\n      }\\n\\n      workgroupBarrier();\\n    }\\n\\n    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {\\n      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;\\n      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;\\n      var sum: f32 = ${(()=>{switch(_){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${_}`)}})()};\\n        output[outputIdx] = ${m.type.value} (sum * uniforms.alpha) + ${s?"attention_bias[outputIdx]":"0.0"};\\n    }\\n  }`}}},ts=(e,t,n,r,s,i,a=void 0,o=void 0)=>{let l=i+s.kvSequenceLength,u=s.nReps?s.nReps:1,d=s.vHiddenSize*u,c=e>1&&r,p=s.kvNumHeads?s.kvNumHeads:s.numHeads,h=c?[s.batchSize,p,l,s.headSize]:void 0,f=[s.batchSize,s.sequenceLength,d],m=12,_={x:Math.ceil(s.vHeadSize/m),y:Math.ceil(s.sequenceLength/m),z:s.batchSize*s.numHeads},g=[{type:12,data:s.sequenceLength},{type:12,data:l},{type:12,data:s.vHeadSize},{type:12,data:s.numHeads},{type:12,data:s.headSize},{type:12,data:d},{type:12,data:i},{type:12,data:s.kvSequenceLength},{type:12,data:u}],w=c&&r&&$n.size(r.dims)>0,y=["type","type"];w&&y.push("type"),a&&y.push("type"),o&&y.push("type");let b=[{dims:f,dataType:t.dataType,gpuDataType:0}];c&&b.push({dims:h,dataType:t.dataType,gpuDataType:0});return{name:"AttentionScore",shaderCache:{hint:`${void 0!==r};${e}`,inputDependencies:y},getRunData:()=>({outputs:b,dispatchGroup:_,programUniforms:g}),getShaderSource:e=>{let s=Ln("probs",t.dataType,t.dims),i=[s,Ln("v",n.dataType,n.dims)];w&&i.push(Ln("past_value",r.dataType,r.dims));let l=a?Ln("seq_lens",a.dataType,a.dims):void 0;a&&i.push(l);let d=o?Ln("total_sequence_length_input",o.dataType,o.dims):void 0;o&&i.push(d);let p=[Fn("output",t.dataType,f)];c&&p.push(Fn("present_value",t.dataType,h));return`\\n  const TILE_SIZE = 12u;\\n  var<workgroup> tileQ: array<${s.type.value}, 144>;\\n  var<workgroup> tileV: array<${s.type.value}, 144>;\\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}]).declareVariables(...i,...p)}\\n  ${e.mainStart([m,m,1])}\\n   let headIdx = workgroup_id.z % uniforms.num_heads;\\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\\n   let kvHeadIdx = ${1===u?"headIdx":"headIdx / uniforms.n_reps"};\\n   let kv_num_heads = ${1===u?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};\\n   let m = global_id.y;\\n   let n = global_id.x;\\n   let sequence_length = uniforms.M;\\n   var total_sequence_length = uniforms.K;\\n   ${Zr(l,d,!0)}\\n   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\\n   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch\\n   ${w&&c?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};\\n   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;\\n   ${c?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}\\n   var value = ${s.type.storage}(0);\\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\\n      }\\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\\n        var idx = TILE_SIZE * local_id.y + local_id.x;\\n        ${w&&c?"\\n        if (w + local_id.y < past_sequence_length) {\\n          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];\\n        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\\n          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];\\n        }\\n      ":"\\n            if (w + local_id.y < uniforms.kv_sequence_length) {\\n              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];\\n            }"}\\n        ${c?"\\n            if (w + local_id.y < present_sequence_length) {\\n          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];\\n        }":""}\\n      }\\n     workgroupBarrier();\\n     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {\\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];\\n     }\\n     workgroupBarrier();\\n   }\\n\\n   // we need to transpose output from BNSH_v to BSND_v\\n   if (m < uniforms.M && n < uniforms.N) {\\n     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size\\n       + headIdx * uniforms.N + n;\\n     output[outputIdx] = value;\\n   }\\n  }`}}},ns=(e,t,n,r,s,i,a,o,l,u,d=void 0,c=void 0)=>{let p=Math.min(e.outputCount,1+(a?1:0)+(o?1:0)),h=p>1?u.pastSequenceLength:0,f=h+u.kvSequenceLength,m=l&&$n.size(l.dims)>0?l:void 0,_=[t,n];p>1&&a&&$n.size(a.dims)>0&&_.push(a),m&&_.push(m),d&&_.push(d),c&&_.push(c);let g=e.compute(es(p,t,n,a,m,u,h,d,c),{inputs:_,outputs:p>1?[-1,1]:[-1]})[0];e.compute(Jr(g,u.batchSize,u.numHeads,h,u.sequenceLength,f,d,c),{inputs:d&&c?[g,d,c]:[g],outputs:[]});let w=[g,r];p>1&&o&&$n.size(o.dims)>0&&w.push(o),d&&w.push(d),c&&w.push(c),e.compute(ts(p,g,r,o,u,h,d,c),{inputs:w,outputs:p>1?[0,2]:[0]})},rs=(e,t)=>{let n=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],r=t.sequenceLength,s=t.inputHiddenSize,i=t.headSize,a=12,o={x:Math.ceil(t.headSize/a),y:Math.ceil(t.sequenceLength/a),z:t.batchSize*t.numHeads},l=[e.inputs[0],e.inputs[1],e.inputs[2]],u=[{type:12,data:r},{type:12,data:s},{type:12,data:i},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}];return e.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:o,programUniforms:u}),getShaderSource:e=>{let t=Fn("output_q",l[0].dataType,n),r=Fn("output_k",l[0].dataType,n),s=Fn("output_v",l[0].dataType,n),i=Ln("input",l[0].dataType,l[0].dims),o=Ln("weight",l[1].dataType,l[1].dims),u=Ln("bias",l[2].dataType,l[2].dims),d=i.type.storage;return`\\n  const TILE_SIZE = 12u;\\n  var<workgroup> tileInput: array<${d}, 144>;\\n  var<workgroup> tileWeightQ: array<${d}, 144>;\\n  var<workgroup> tileWeightK: array<${d}, 144>;\\n  var<workgroup> tileWeightV: array<${d}, 144>;\\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}]).declareVariables(i,o,u,t,r,s)}\\n  ${e.mainStart([a,a,1])}\\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\\n    let headNumber = workgroup_id.z % uniforms.num_heads;\\n    let m = global_id.y;\\n    let n = global_id.x;\\n\\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\\n    let biasOffsetQ = headNumber * uniforms.head_size;\\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\\n\\n    var valueQ = ${d}(0);\\n    var valueK = ${d}(0);\\n    var valueV = ${d}(0);\\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\\n      }\\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\\n        let offset = n + (w + local_id.y) * uniforms.ldb;\\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\\n      }\\n      workgroupBarrier();\\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\\n      }\\n\\n      workgroupBarrier();\\n    }\\n\\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\\n    valueQ += bias[headOffset + biasOffsetQ];\\n    valueK += bias[headOffset + biasOffsetK];\\n    valueV += bias[headOffset + biasOffsetV];\\n\\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\\n    if (m < uniforms.M && n < uniforms.N) {\\n      let outputIdx = offset + m * uniforms.N + n;\\n      output_q[outputIdx] = valueQ;\\n      output_k[outputIdx] = valueK;\\n      output_v[outputIdx] = valueV;\\n    }\\n  }`}},{inputs:l,outputs:[-1,-1,-1]})},ss=(e,t)=>{let n=Yr(e.inputs,t),[r,s,i]=rs(e,n);return ns(e,r,s,i,e.inputs[4],void 0,void 0,void 0,e.inputs[5],n)}})),md=qe((()=>{dt(),td(),ld(),od(),ud(),is=(e,t)=>{if(!e||5!==e.length)throw new Error("BatchNormalization requires 5 inputs");let n=(e,t,n)=>{let r=t.length;if(r!==e.length)throw new Error(`${n}: num dimensions != ${r}`);t.forEach(((t,r)=>{if(t!==e[r])throw new Error(`${n}: dim[${r}] do not match`)}))};if(e[0].dims.length>1){let r="NHWC"===t.format?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);n(e[1].dims,r,"Invalid input scale"),n(e[2].dims,r,"Invalid input B"),n(e[3].dims,r,"Invalid input mean"),n(e[4].dims,r,"Invalid input var")}else n(e[1].dims,[1],"Invalid input scale"),n(e[2].dims,[1],"Invalid input B"),n(e[3].dims,[1],"Invalid input mean"),n(e[4].dims,[1],"Invalid input var")},as=(e,t)=>{let{epsilon:n,spatial:r,format:s}=t,i=e[0].dims,a=r?On(i[i.length-1]):1,o="NHWC"===s&&i.length>1?a:1,l=$n.size(i)/a,u=r,d=u?i.length:i,c=Ln("x",e[0].dataType,e[0].dims,a),p=Ln("scale",e[1].dataType,e[1].dims,o),h=Ln("bias",e[2].dataType,e[2].dims,o),f=Ln("inputMean",e[3].dataType,e[3].dims,o),m=Ln("inputVar",e[4].dataType,e[4].dims,o),_=Fn("y",e[0].dataType,d,a);return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${r}_${a}`,inputDependencies:u?["rank","type","type","type","type"]:void 0},getShaderSource:e=>`\\n  const epsilon = ${n};\\n  ${e.registerUniform("outputSize","u32").declareVariables(c,p,h,f,m,_)}\\n  ${e.mainStart()}\\n  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n    var outputIndices = ${_.offsetToIndices(`global_idx * ${a}`)};\\n    ${(()=>{let e="";if(r)e=`let cOffset = ${1===i.length?"0u":"NHWC"===s?`outputIndices[${i.length-1}] / ${a}`:"outputIndices[1]"};`;else if("NCHW"===s)e=`\\n            ${_.indicesSet("outputIndices","0","0")}\\n            let cOffset = ${_.indicesToOffset("outputIndices")};`;else{e=`var cIndices = ${p.type.indices}(0);\\n                       cIndices[0] = outputIndices[${i.length-1}];`;for(let t=1;t<p.rank;t++)e+=`cIndices[${t}] = outputIndices[${t}];`;e+=`let cOffset = ${p.indicesToOffset("cIndices")};`}return e})()}\\n    let scale = ${p.getByOffset("cOffset")};\\n    let bias = ${h.getByOffset("cOffset")};\\n    let inputMean = ${f.getByOffset("cOffset")};\\n    let inputVar = ${m.getByOffset("cOffset")};\\n    let x = ${c.getByOffset("global_idx")};\\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\\n    ${_.setByOffset("global_idx","value")}\\n  }`,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u?[{type:12,data:l},...Mn(i)]:[{type:12,data:l}]})}},os=e=>bn(e),ls=(e,t)=>{let{inputs:n,outputCount:r}=e,s=os({...t,outputCount:r});if(pe.webgpu.validateInputContent&&is(n,s),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(as(n,s))}})),_d=qe((()=>{ld(),ud(),us=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},ds=e=>{let t=e[0].dims,n=e[0].dims[2],r=$n.size(t)/4,s=e[0].dataType,i=Ln("input",s,t,4),a=Ln("bias",s,[n],4),o=Ln("residual",s,t,4),l=Fn("output",s,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(r/64)}}),getShaderSource:e=>`\\n  const channels = ${n}u / 4;\\n  ${e.declareVariables(i,a,o,l)}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(r)}\\n    let value = ${i.getByOffset("global_idx")}\\n      + ${a.getByOffset("global_idx % channels")} + ${o.getByOffset("global_idx")};\\n    ${l.setByOffset("global_idx","value")}\\n  }`}},cs=e=>{us(e.inputs),e.compute(ds(e.inputs))}})),gd=qe((()=>{td(),ld(),od(),ud(),ps=(e,t,n,r,s,i,a)=>{let o=Math.ceil(t/4),l="";l="string"==typeof s?`${s}(a)`:s("a");let u=Ln("inputData",n,[o],4),d=Fn("outputData",r,[o],4),c=[{name:"vec_size",type:"u32"}];return a&&c.push(...a),`\\n      ${e.registerUniforms(c).declareVariables(u,d)}\\n\\n  ${i??""}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\\n\\n    let a = ${u.getByOffset("global_idx")};\\n    ${d.setByOffset("global_idx",l)}\\n  }`},hs=(e,t,n,r,s,i=e.dataType,a,o)=>{let l=[{type:12,data:Math.ceil($n.size(e.dims)/4)}];return a&&l.push(...a),{name:t,shaderCache:{hint:s,inputDependencies:["type"]},getShaderSource:t=>ps(t,$n.size(e.dims),e.dataType,i,n,r,o),getRunData:t=>({outputs:[{dims:e.dims,dataType:i}],dispatchGroup:{x:Math.ceil($n.size(t[0].dims)/64/4)},programUniforms:l})}},fs=e=>{e.compute(hs(e.inputs[0],"Abs","abs"))},ms=e=>{e.compute(hs(e.inputs[0],"Acos","acos"))},_s=e=>{e.compute(hs(e.inputs[0],"Acosh","acosh"))},gs=e=>{e.compute(hs(e.inputs[0],"Asin","asin"))},ws=e=>{e.compute(hs(e.inputs[0],"Asinh","asinh"))},ys=e=>{e.compute(hs(e.inputs[0],"Atan","atan"))},bs=e=>{e.compute(hs(e.inputs[0],"Atanh","atanh"))},xs=e=>bn(e),vs=(e,t)=>{let n;switch(t.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute(hs(e.inputs[0],"Cast",n,void 0,t.cacheKey,t.to))},$s=e=>{let t,n,r=e.length>=2&&0!==e[1].data,s=e.length>=3&&0!==e[2].data;switch(e[0].dataType){case 1:t=r?e[1].getFloat32Array()[0]:-34028234663852886e22,n=s?e[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:t=r?e[1].getUint16Array()[0]:64511,n=s?e[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return bn({min:t,max:n})},ks=(e,t)=>{let n=t||$s(e.inputs),r=In(e.inputs[0].dataType);e.compute(hs(e.inputs[0],"Clip",(e=>`clamp(${e}, vec4<${r}>(uniforms.min), vec4<${r}>(uniforms.max))`),void 0,n.cacheKey,void 0,[{type:e.inputs[0].dataType,data:n.min},{type:e.inputs[0].dataType,data:n.max}],[{name:"min",type:r},{name:"max",type:r}]),{inputs:[0]})},Es=e=>{e.compute(hs(e.inputs[0],"Ceil","ceil"))},Ss=e=>{e.compute(hs(e.inputs[0],"Cos","cos"))},zs=e=>{e.compute(hs(e.inputs[0],"Cosh","cosh"))},Cs=e=>bn(e),Ts=(e,t)=>{let n=In(e.inputs[0].dataType);e.compute(hs(e.inputs[0],"Elu",(e=>`elu_vf32(${e})`),`\\n  const elu_alpha_ = ${n}(${t.alpha});\\n\\n  fn elu_f32(a: ${n}) -> ${n} {\\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\\n  }\\n\\n  fn elu_vf32(v: vec4<${n}>) -> vec4<${n}> {\\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\\n  }`,t.cacheKey))},As=(e="f32")=>`\\nconst r0: ${e} = 0.3275911;\\nconst r1: ${e} = 0.254829592;\\nconst r2: ${e} = -0.284496736;\\nconst r3: ${e} = 1.421413741;\\nconst r4: ${e} = -1.453152027;\\nconst r5: ${e} = 1.061405429;\\n\\nfn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {\\n  let absv = abs(v);\\n  let x = 1.0 / (1.0 + r0 * absv);\\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\\n}`,Is=e=>{let t=In(e.inputs[0].dataType);e.compute(hs(e.inputs[0],"Erf",(e=>`erf_vf32(${e})`),As(t)))},Ms=e=>{e.compute(hs(e.inputs[0],"Exp","exp"))},Os=e=>{e.compute(hs(e.inputs[0],"Floor","floor"))},Bs=e=>{let t=In(e.inputs[0].dataType);e.compute(hs(e.inputs[0],"Gelu",(e=>`0.5 * ${e} * (1.0 + erf_vf32(${e} * 0.7071067811865475))`),As(t)))},Ns=(e,t)=>{let n=In(e.inputs[0].dataType);e.compute(hs(e.inputs[0],"LeakyRelu",(e=>`select(leaky_relu_alpha_ * ${e}, ${e}, ${e} >= vec4<${n}>(0.0))`),`const leaky_relu_alpha_ = ${n}(${t.alpha});`,t.cacheKey))},Ps=e=>{e.compute(hs(e.inputs[0],"Not",(e=>`!${e}`)))},Rs=e=>{e.compute(hs(e.inputs[0],"Neg",(e=>`-${e}`)))},Ds=e=>{e.compute(hs(e.inputs[0],"Reciprocal",(e=>`1.0/${e}`)))},Ls=e=>{let t=In(e.inputs[0].dataType);e.compute(hs(e.inputs[0],"Relu",(e=>`select(vec4<${t}>(0.0), ${e}, ${e} > vec4<${t}>(0.0))`)))},Fs=e=>{e.compute(hs(e.inputs[0],"Sigmoid",(e=>`(1.0 / (1.0 + exp(-${e})))`)))},Us=e=>bn(e),qs=(e,t)=>{let n=In(e.inputs[0].dataType);e.compute(hs(e.inputs[0],"HardSigmoid",(e=>`max(vec4<${n}>(0.0), min(vec4<${n}>(1.0), ${t.alpha} * ${e} + vec4<${n}>(${t.beta})))`),void 0,t.cacheKey))},Vs=e=>{e.compute(hs(e.inputs[0],"Sin","sin"))},Ws=e=>{e.compute(hs(e.inputs[0],"Sinh","sinh"))},js=e=>{e.compute(hs(e.inputs[0],"Sqrt","sqrt"))},Gs=e=>{e.compute(hs(e.inputs[0],"Tan","tan"))},Hs=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,Ks=e=>{e.compute(hs(e.inputs[0],"Tanh",Hs))},Xs=(e="f32")=>`\\nconst fast_gelu_a: ${e} = 0.5;\\nconst fast_gelu_b: ${e} = 0.7978845608028654;\\nconst fast_gelu_c: ${e} = 0.035677408136300125;\\n\\nfn tanh_v(v: vec4<${e}>) -> vec4<${e}> {\\n  return ${Hs("v")};\\n}\\n`,Qs=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,Ys=e=>{let t=In(e.inputs[0].dataType);e.compute(hs(e.inputs[0],"FastGelu",Qs,Xs(t),void 0,e.inputs[0].dataType))},Zs=(e,t)=>{let n=In(e.inputs[0].dataType);return e.compute(hs(e.inputs[0],"ThresholdedRelu",(e=>`select(vec4<${n}>(0.0), ${e}, ${e} > thresholded_relu_alpha_)`),`const thresholded_relu_alpha_ = vec4<${n}>(${t.alpha});`,t.cacheKey)),0},Js=e=>{e.compute(hs(e.inputs[0],"Log","log"))},ei=(e,t)=>`\\nconst alpha = vec4<${e}>(${t});\\nconst one = ${e}(1.0);\\nconst zero = ${e}(0.0);\\n\\nfn quick_gelu_impl(x: vec4<${e}>) -> vec4<${e}> {\\n  let v = x *alpha;\\n  var x1 : vec4<${e}>;\\n  for (var i = 0; i < 4; i = i + 1) {\\n    if (v[i] >= zero) {\\n      x1[i] = one / (one + exp(-v[i]));\\n    } else {\\n      x1[i] = one - one / (one + exp(v[i]));\\n    }\\n  }\\n  return x * x1;\\n}\\n`,ti=e=>`quick_gelu_impl(${e})`,ni=(e,t)=>{let n=In(e.inputs[0].dataType);e.compute(hs(e.inputs[0],"QuickGelu",ti,ei(n,t.alpha),t.cacheKey,e.inputs[0].dataType))}})),wd=qe((()=>{ld(),ud(),gd(),ri=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},si=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let n=Ln("input",e[0].dataType,e[0].dims,4),r=Ln("bias",e[0].dataType,[e[0].dims[2]],4),s=Fn("output",e[0].dataType,t,4),i=$n.size(t)/4,a=An(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:t=>`\\n  const M_SQRT2 = sqrt(2.0);\\n  const halfChannels = ${e[0].dims[2]/4/2}u;\\n\\n  ${t.declareVariables(n,r,s)}\\n\\n  ${As(a)}\\n\\n  ${t.mainStart()}\\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes(i)}\\n    let biasIdx = global_idx % halfChannels;\\n    let batchIndex = global_idx / halfChannels;\\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\\n    let valueLeft = input[inputOffset] + bias[biasIdx];\\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\\n\\n    ${s.setByOffset("global_idx","valueLeft * geluRight")}\\n  }`}},ii=e=>{ri(e.inputs),e.compute(si(e.inputs))}})),yd=qe((()=>{td(),ld(),ud(),ai=(e,t,n,r,s,i,a,o,l,u,d,c)=>{let p,h;"string"==typeof o?p=h=(e,t)=>`${o}((${e}),(${t}))`:"function"==typeof o?p=h=o:(p=o.scalar,h=o.vector);let f,m=Fn("outputData",d,r.length,4),_=Ln("aData",l,t.length,4),g=Ln("bData",u,n.length,4);if(s)if(i){let e=1===$n.size(t),r=1===$n.size(n),s=t.length>0&&t[t.length-1]%4==0,i=n.length>0&&n[n.length-1]%4==0;f=e||r?m.setByOffset("global_idx",h(e?`${_.type.value}(${_.getByOffset("0")}.x)`:_.getByOffset("global_idx"),r?`${g.type.value}(${g.getByOffset("0")}.x)`:g.getByOffset("global_idx"))):`\\n            let outputIndices = ${m.offsetToIndices("global_idx * 4u")};\\n            let offsetA = ${_.broadcastedIndicesToOffset("outputIndices",m)};\\n            let offsetB = ${g.broadcastedIndicesToOffset("outputIndices",m)};\\n            ${m.setByOffset("global_idx",h(a||s?_.getByOffset("offsetA / 4u"):`${_.type.value}(${_.getByOffset("offsetA / 4u")}[offsetA % 4u])`,a||i?g.getByOffset("offsetB / 4u"):`${g.type.value}(${g.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}\\n          `}else f=m.setByOffset("global_idx",h(_.getByOffset("global_idx"),g.getByOffset("global_idx")));else{if(!i)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let e=(e,t,n="")=>{let r=`aData[indexA${t}][componentA${t}]`,s=`bData[indexB${t}][componentB${t}]`;return`\\n            let outputIndices${t} = ${m.offsetToIndices(`global_idx * 4u + ${t}u`)};\\n            let offsetA${t} = ${_.broadcastedIndicesToOffset(`outputIndices${t}`,m)};\\n            let offsetB${t} = ${g.broadcastedIndicesToOffset(`outputIndices${t}`,m)};\\n            let indexA${t} = offsetA${t} / 4u;\\n            let indexB${t} = offsetB${t} / 4u;\\n            let componentA${t} = offsetA${t} % 4u;\\n            let componentB${t} = offsetB${t} % 4u;\\n            ${e}[${t}] = ${n}(${p(r,s)});\\n          `};f=9===d?`\\n            var data = vec4<u32>(0);\\n            ${e("data",0,"u32")}\\n            ${e("data",1,"u32")}\\n            ${e("data",2,"u32")}\\n            ${e("data",3,"u32")}\\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\\n            ${e("outputData[global_idx]",0)}\\n            ${e("outputData[global_idx]",1)}\\n            ${e("outputData[global_idx]",2)}\\n            ${e("outputData[global_idx]",3)}\\n          `}return`\\n        ${e.registerUniform("vec_size","u32").declareVariables(_,g,m)}\\n\\n        ${c??""}\\n\\n        ${e.mainStart()}\\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\\n        ${f}\\n      }`},oi=(e,t,n,r,s,i,a=n.dataType)=>{let o=n.dims.map((e=>Number(e)??1)),l=r.dims.map((e=>Number(e)??1)),u=!$n.areEqual(o,l),d=o,c=$n.size(o),p=!1,h=!1,f=[u];if(u){let e=vn.calcShape(o,l,!1);if(!e)throw new Error("Can\'t perform binary op on the given tensors");d=e.slice(),c=$n.size(d);let t=1===$n.size(o),n=1===$n.size(l),r=o.length>0&&o[o.length-1]%4==0,s=l.length>0&&l[l.length-1]%4==0;f.push(t),f.push(n),f.push(r),f.push(s);let i=1;for(let e=1;e<d.length;e++){let t=o[o.length-e];if(t!==l[l.length-e])break;i*=t}i%4==0?(h=!0,p=!0):(t||n||r||s)&&(p=!0)}else p=!0;return f.push(p),{name:e,shaderCache:{hint:t+f.map((e=>e.toString())).join("_"),inputDependencies:["rank","rank"]},getShaderSource:e=>ai(e,o,l,d,p,u,h,s,n.dataType,r.dataType,a,i),getRunData:()=>({outputs:[{dims:d,dataType:a}],dispatchGroup:{x:Math.ceil(c/64/4)},programUniforms:[{type:12,data:Math.ceil($n.size(d)/4)},...Mn(o,l,d)]})}},li=(e,t,n,r,s,i)=>{e.compute(oi(t,s??"",e.inputs[0],e.inputs[1],n,r,i))},ui=e=>{li(e,"Add",((e,t)=>`${e}+${t}`))},di=e=>{li(e,"Div",((e,t)=>`${e}/${t}`))},ci=e=>{li(e,"Equal",{scalar:(e,t)=>`u32(${e}==${t})`,vector:(e,t)=>`vec4<u32>(${e}==${t})`},void 0,void 0,9)},pi=e=>{li(e,"Mul",((e,t)=>`${e}*${t}`))},hi=e=>{let t=Ln("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;li(e,"Pow",{scalar:(e,t)=>`pow_custom(${e},${t})`,vector:(e,t)=>`pow_vector_custom(${e},${t})`},`\\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\\n      if (b == ${t}(0.0)) {\\n        return ${t}(1.0);\\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\\n        return ${t}(pow(f32(a), f32(b))); // NaN\\n      }\\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${"i32"===t?"round":""}(pow(f32(abs(a)), f32(b))));\\n    }\\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\\n      // TODO: implement vectorized pow\\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\\n    }\\n      `)},fi=e=>{li(e,"Sub",((e,t)=>`${e}-${t}`))},mi=e=>{li(e,"Greater",{scalar:(e,t)=>`u32(${e}>${t})`,vector:(e,t)=>`vec4<u32>(${e}>${t})`},void 0,void 0,9)},_i=e=>{li(e,"Less",{scalar:(e,t)=>`u32(${e}<${t})`,vector:(e,t)=>`vec4<u32>(${e}<${t})`},void 0,void 0,9)},gi=e=>{li(e,"GreaterOrEqual",{scalar:(e,t)=>`u32(${e}>=${t})`,vector:(e,t)=>`vec4<u32>(${e}>=${t})`},void 0,void 0,9)},wi=e=>{li(e,"LessOrEqual",{scalar:(e,t)=>`u32(${e}<=${t})`,vector:(e,t)=>`vec4<u32>(${e}<=${t})`},void 0,void 0,9)}})),bd=qe((()=>{td(),ld(),od(),ud(),yi=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");let n=e[0],r=n.dataType,s=n.dims.length;e.forEach(((e,i)=>{if(0!==i){if(e.dataType!==r)throw new Error("input tensors should be one type");if(e.dims.length!==s)throw new Error("input tensors should have the same shape");e.dims.forEach(((e,r)=>{if(r!==t&&e!==n.dims[r])throw new Error("non concat dimensions must match")}))}}))},bi=(e,t)=>`\\n  fn calculateInputIndex(index: u32) -> u32 {\\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\\n      if (index < sizeInConcatAxis[i]) {\\n        return i;\\n      }\\n    }\\n    return ${e}u;\\n  }`,xi=(e,t)=>{let n=e.length,r=[];for(let s=0;s<n;++s){let i=t.setByOffset("global_idx",e[s].getByIndices("indices"));1===n?r.push(i):0===s?r.push(`if (inputIndex == ${s}u) { ${i} }`):s===n-1?r.push(`else { ${i} }`):r.push(`else if (inputIndex == ${s}) { ${i} }`)}return r.join("\\n")},vi=(e,t,n,r)=>{let s=$n.size(n),i=new Array(e.length),a=new Array(e.length),o=0,l=[],u=[],d=[{type:12,data:s}];for(let n=0;n<e.length;++n)o+=e[n].dims[t],i[n]=o,u.push(e[n].dims.length),a[n]=Ln(`input${n}`,r,u[n]),l.push("rank"),d.push({type:12,data:i[n]});for(let t=0;t<e.length;++t)d.push(...Mn(e[t].dims));d.push(...Mn(n));let c=Fn("output",r,n.length),p=c.indicesGet("indices",t),h=Array.from(Array(i.length).keys()).map((e=>`uniforms.sizeInConcatAxis${e}`)).join(",");return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:n,dataType:r}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:d}),getShaderSource:t=>`\\n\\n  ${(()=>{t.registerUniform("outputSize","u32");for(let n=0;n<e.length;n++)t.registerUniform(`sizeInConcatAxis${n}`,"u32");return t.declareVariables(...a,c)})()}\\n\\n  ${bi(i.length,h)}\\n\\n  ${t.mainStart()}\\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n\\n    var indices = ${c.offsetToIndices("global_idx")};\\n\\n    let inputIndex = calculateInputIndex(${p});\\n    if (inputIndex != 0u) {\\n      let sizeInConcatAxis = array<u32, ${i.length}u>(${h});\\n      ${p} -= sizeInConcatAxis[inputIndex - 1u];\\n    }\\n\\n    ${xi(a,c)}\\n  }`}},$i=(e,t)=>{let n=e.inputs,r=n[0].dims,s=$n.normalizeAxis(t.axis,r.length);yi(n,s);let i=r.slice();i[s]=n.reduce(((e,t)=>e+(t.dims.length>s?t.dims[s]:0)),0);let a=n.filter((e=>$n.size(e.dims)>0));e.compute(vi(a,s,i,n[0].dataType),{inputs:a})},ki=e=>bn({axis:e.axis})})),xd=qe((()=>{td(),ld(),Ei=(e,t,n="f32")=>{switch(e.activation){case"Relu":return`value = max(value, ${t}(0.0));`;case"Sigmoid":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${t}(${n}(uniforms.clip_min)), ${t}(${n}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${t}(0.0), min(${t}(1.0), ${n}(uniforms.alpha) * value + ${n}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${n}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case"Tanh":return"let e2x = exp(-2.0 * abs(value));\\n              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);\\n        ";case"":return"";default:throw new Error(`Unsupported activation ${e.activation}`)}},Si=(e,t)=>{"Clip"===e.activation?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):"HardSigmoid"===e.activation?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):"LeakyRelu"===e.activation&&t.push({type:1,data:e.alpha})},zi=(e,t)=>{"Clip"===e.activation?t.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):"HardSigmoid"===e.activation?t.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):"LeakyRelu"===e.activation&&t.push({name:"alpha",type:"f32"})},Ci=e=>{let t=e?.activation||"";if("HardSigmoid"===t){let[n,r]=e?.activation_params||[.2,.5];return{activation:t,alpha:n,beta:r}}if("Clip"===t){let[n,r]=e?.activation_params||[Sn,zn];return{activation:t,clipMax:r,clipMin:n}}if("LeakyRelu"===t){let[n]=e?.activation_params||[.01];return{activation:t,alpha:n}}return{activation:t}}})),vd=qe((()=>{Ti=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Ai=e=>`\\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\\n      `})),$d=qe((()=>{Ii=e=>`\\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\\n  return dot(coords, vec4<i32>(\\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\\n}\\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\\n  return dot(coords, vec4<i32>(\\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\\n}\\n`})),kd=qe((()=>{td(),ld(),ud(),xd(),Mi=(e,t,n,r,s)=>{let i=r-n;return`\\n      ${Array.from({length:n}).map(((n,a)=>`\\n      if (${Rn(t.shape,a,t.rank)} != 1) {\\n        ${t.indicesSet(e,a,Rn(s,a+i,r))}\\n      } else {\\n        ${t.indicesSet(e,a,0)}\\n      }`)).join("")}\\n`},Oi=(e,t,n,r,s=!1,i)=>{let a=e[0].dims,o=e[1].dims,l=a[a.length-2],u=o[o.length-1],d=a[a.length-1],c=On(u),p=On(d),h=On(l),f=$n.size(n)/c/h,m=e.length>2,_=r?r.slice(0,-2):n.slice(0,-2),g=[$n.size(_),l,u],w=[{type:12,data:f},{type:12,data:l},{type:12,data:u},{type:12,data:d}];Si(t,w),w.push(...Mn(_,a,o)),m&&w.push(...Mn(e[2].dims)),w.push(...Mn(g));return{name:"MatMulNaive",shaderCache:{hint:`${t.activation};${c};${p};${h};${s}`,inputDependencies:m?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:i?i(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:w}),getShaderSource:r=>{let i=qn("batch_dims",e[0].dataType,_.length),l=Ln("a",e[0].dataType,a.length,p),u=Ln("b",e[1].dataType,o.length,c),d=Fn("output",e[0].dataType,g.length,c),f=An(d.type.tensor),w=Ei(t,d.type.value,f),y=[l,u],b="";if(m){let t=s?c:1;y.push(Ln("bias",e[2].dataType,e[2].dims.length,t)),b=""+(s?`value += bias[col / ${t}];`:`value += ${d.type.value}(bias[row + i]);`)}let x=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];zi(t,x);return`\\n  ${r.registerUniforms(x).registerInternalVariables(i).declareVariables(...y,d)}\\n  ${r.mainStart()}\\n    ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n    let col = (global_idx % (uniforms.N / ${c})) * ${c};\\n    var index1 = global_idx / (uniforms.N / ${c});\\n    let stride1 = uniforms.M / ${h};\\n    let row = (index1 % stride1) * ${h};\\n    let batch = index1 / stride1;\\n\\n    ${2===n.length?"":`let batch_indices = ${i.offsetToIndices("batch")};`}\\n\\n    var a_indices: ${l.type.indices};\\n    ${Mi("a_indices",l,l.rank-2,i.rank,"batch_indices")}\\n    ${l.indicesSet("a_indices",l.rank-2,0)}\\n    ${l.indicesSet("a_indices",l.rank-1,0)}\\n    let a_offset = ${l.indicesToOffset("a_indices")};\\n\\n    var b_indices: ${u.type.indices};\\n    ${Mi("b_indices",u,u.rank-2,i.rank,"batch_indices")}\\n    ${u.indicesSet("b_indices",u.rank-2,0)}\\n    ${u.indicesSet("b_indices",u.rank-1,0)}\\n    let b_offset = ${u.indicesToOffset("b_indices")};\\n    var values: array<${d.type.value}, ${h}>;\\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${p}) {\\n      ${(()=>{let e=`var a_data: ${l.type.value};`;for(let t=0;t<p;t++)e+=`\\n              let b_data${t} = b[(b_offset + (k + ${t}) * uniforms.N + col) / ${c}];`;for(let t=0;t<h;t++){e+=`a_data = a[(a_offset + (row + ${t}) * uniforms.K + k) / ${p}];`;for(let n=0;n<p;n++)e+=`\\n            values[${t}] = fma(${u.type.value}(a_data${1===p?"":`[${n}]`}), b_data${n}, values[${t}]);\\n`}return e})()}\\n    }\\n    for (var i = 0u; i < ${h}u; i++) {\\n      var value = values[i];\\n      ${b}\\n      ${w}\\n      let cur_indices = ${d.type.indices}(batch, row + i, col);\\n      let offset = ${d.indicesToOffset("cur_indices")};\\n      ${d.setByOffset(`offset / ${c}`,"value")};\\n    }\\n  }\\n  `}}}})),Ed=qe((()=>{td(),ld(),ud(),xd(),kd(),vd(),Bi=(e,t)=>e?`\\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n          kStart + inputRow,\\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\\n        `:`\\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n          globalRow + innerRow,\\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\\n        `,Ni=(e,t)=>e?`\\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\\n        ${3===t?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\\n        for (var i = 0; i < rowPerThread; i = i + 1) {\\n          acc[i] = BCached0 * ACached0[i] + acc[i];\\n          acc[i] = BCached1 * ACached1[i] + acc[i];\\n          acc[i] = BCached2 * ACached2[i] + acc[i];\\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\\n        }`:`\\n        for (var i = 0; i < rowPerThread; i = i + 1) {\\n          let ACached = mm_Asub[tileRow + i][k];\\n          acc[i] = BCached0 * ACached.x + acc[i];\\n          acc[i] = BCached1 * ACached.y + acc[i];\\n          acc[i] = BCached2 * ACached.z + acc[i];\\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\\n        }`,Pi=(e,t,n="f32",r,s=!1,i=32,a=!1,o=32)=>{let l=t[1]*e[1],u=t[0]*e[0],d=s?l:i,c=s?i:l,p=d/t[0],h=i/t[1];if((!s||4!==p||4!==e[1])&&(s||3!==p&&4!==p)||d%t[0]!=0||i%t[1]!=0||4!==e[0])throw new Error(`If transposeA ${s} is true, innerElementSize ${p} and workPerThread[1] ${e[1]} must be 4.\\n      Otherwise, innerElementSize ${p} must be 3 or 4.\\n  tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}. tileInner ${i} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\\nvar<workgroup> mm_Asub: array<array<vec${p}<${n}>, ${d/p}>, ${c}>;\\nvar<workgroup> mm_Bsub: array<array<vec4<${n}>, ${u/e[0]}>, ${i}>;\\n\\nconst rowPerThread = ${e[1]};\\nconst colPerThread = ${e[0]};\\nconst innerElementSize = ${p};\\nconst tileInner = ${i};\\n\\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\\n        @builtin(global_invocation_id) globalId : vec3<u32>,\\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\\n  let localRow = i32(localId.y);\\n  let tileRow = localRow * rowPerThread;\\n  let tileCol = i32(localId.x);\\n\\n  let globalRow =i32(globalId.y) * rowPerThread;\\n  let globalCol = i32(globalId.x);\\n  let batch = ${a?"0":"i32(globalId.z)"};\\n  ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}\\n  let globalRowStart = i32(workgroupId.y) * ${l};\\n\\n  let num_tiles = ${a?`${Math.ceil(o/i)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\\n  var kStart = ${a?`i32(globalId.z) * ${o}`:"0"};\\n\\n  var acc: array<vec4<${n}>, rowPerThread>;\\n\\n  // Loop over shared dimension.\\n  let tileRowB = localRow * ${h};\\n  for (var t = 0; t < num_tiles; t = t + 1) {\\n      // Load one tile of A into local memory.\\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n          let inputRow = tileRow + innerRow;\\n          let inputCol = tileCol;\\n          ${Bi(s,r)}\\n      }\\n\\n      // Load one tile of B into local memory.\\n      for (var innerRow = 0; innerRow < ${h}; innerRow = innerRow + 1) {\\n          let inputRow = tileRowB + innerRow;\\n          let inputCol = tileCol;\\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${r?", batchIndices":""});\\n      }\\n      kStart = kStart + tileInner;\\n      workgroupBarrier();\\n\\n      // Compute acc values for a single thread.\\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\\n          ${3===p?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\\n\\n          ${Ni(s,p)}\\n      }\\n\\n      workgroupBarrier();\\n  }\\n\\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\\n  }\\n}`},Ri=(e,t)=>e?`\\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n              kStart + inputRow,\\n              globalRowStart + inputCol${t?", batchIndices":""});\\n            `:`\\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n              globalRowStart + inputRow,\\n              kStart + inputCol${t?", batchIndices":""});\\n            `,Di=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Li=(e,t,n="f32",r,s=!1,i=32,a=!1,o=32,l=!1)=>{let u=e[1]*t[1],d=e[0]*t[0],c=s?u:i,p=s?i:u;if(p%t[1]!=0||c%t[0]!=0||i%t[1]!=0)throw new Error(`tileAHight ${p} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}, tileInner ${i} must be divisible by workgroupSize[1]${t[1]}`);let h=p/t[1],f=c/t[0],m=i/t[1],_=l?`\\n    let localRow = i32(localId.y);\\n    let localCol = i32(localId.x);\\n    let globalRowStart = i32(workgroupId.y) * ${u};\\n    let globalColStart = i32(workgroupId.x) * ${d};\\n\\n    // Loop over shared dimension.\\n    for (var t = 0; t < num_tiles; t = t + 1) {\\n      // Load one tile of A into local memory.\\n      for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${t[1]}) {\\n        for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {\\n          ${Ri(s,r)}\\n        }\\n      }\\n      // Load one tile of B into local memory.\\n      for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${t[1]}) {\\n            for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${t[0]}) {\\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\\n            kStart + inputRow,\\n            globalColStart + inputCol${r?", batchIndices":""});\\n        }\\n      }\\n      kStart = kStart + tileInner;\\n      workgroupBarrier();\\n\\n      // Compute acc values for a single thread.\\n      var BCached : array<${n}, colPerThread>;\\n      for (var k = 0; k < tileInner; k = k + 1) {\\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\\n        }\\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n          let ACached = ${s?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\\n                ACached * BCached[innerCol];\\n          }\\n        }\\n      }\\n      workgroupBarrier();\\n    }\\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\\n      }\\n    }\\n    `:`\\nlet tileRow = i32(localId.y) * rowPerThread;\\nlet tileCol = i32(localId.x) * colPerThread;\\n\\nlet globalRow = i32(globalId.y) * rowPerThread;\\nlet globalCol = i32(globalId.x) * colPerThread;\\nlet globalRowStart = i32(workgroupId.y) * ${u};\\n\\nlet tileRowA = i32(localId.y) * ${h};\\nlet tileColA = i32(localId.x) * ${f};\\nlet tileRowB = i32(localId.y) * ${m};\\n// Loop over shared dimension.\\nfor (var t = 0; t < num_tiles; t = t + 1) {\\n  // Load one tile of A into local memory.\\n  for (var innerRow = 0; innerRow < ${h}; innerRow = innerRow + 1) {\\n    for (var innerCol = 0; innerCol < ${f}; innerCol = innerCol + 1) {\\n      let inputRow = tileRowA + innerRow;\\n      let inputCol = tileColA + innerCol;\\n      ${Ri(s,r)}\\n    }\\n  }\\n\\n  // Load one tile of B into local memory.\\n  for (var innerRow = 0; innerRow < ${m}; innerRow = innerRow + 1) {\\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n      let inputRow = tileRowB + innerRow;\\n      let inputCol = tileCol + innerCol;\\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\\n        kStart + inputRow,\\n        globalCol + innerCol${r?", batchIndices":""});\\n    }\\n  }\\n  kStart = kStart + tileInner;\\n  workgroupBarrier();\\n\\n  // Compute acc values for a single thread.\\n  var BCached : array<${n}, colPerThread>;\\n  for (var k = 0; k < tileInner; k = k + 1) {\\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\\n    }\\n\\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      ${Di(s)}\\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\\n      }\\n    }\\n  }\\n\\n  workgroupBarrier();\\n}\\n\\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\\n        acc[innerRow][innerCol]);\\n  }\\n}\\n`;return`\\n  var<workgroup> mm_Asub : array<array<${n}, ${c}>, ${p}>;\\n  var<workgroup> mm_Bsub : array<array<${n}, ${d}>, ${i}>;\\n  const rowPerThread = ${e[1]};\\n  const colPerThread = ${e[0]};\\n  const tileInner = ${i};\\n\\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\\n        @builtin(global_invocation_id) globalId : vec3<u32>,\\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\\n    let batch = ${a?"0":"i32(globalId.z)"};\\n    ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}\\n    let num_tiles = ${a?`${Math.ceil(o/i)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\\n    var kStart = ${a?`i32(globalId.z) * ${o}`:"0"};\\n\\n    var acc : array<array<${n}, colPerThread>, rowPerThread>;\\n    ${_}\\n  }\\n`},Fi=(e,t,n,r,s=!1)=>{let[i,a,o,l]=r,u=An(r[0].type.tensor);return`\\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${i.type.indices}) -> ${Ti(e,u)} {\\n      var value = ${Ti(e,u)}(0.0);\\n      let col = colIn * ${e};\\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\\n      {\\n        var aIndices: ${a.type.indices};\\n        ${Mi("aIndices",a,a.rank-2,i.rank,"batchIndices")}\\n        ${a.indicesSet("aIndices",a.rank-2,"u32(row)")}\\n        ${a.indicesSet("aIndices",a.rank-1,"u32(colIn)")}\\n        value = ${a.getByIndices("aIndices")};\\n      }\\n      return value;\\n    }\\n\\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${i.type.indices}) -> ${Ti(e,u)} {\\n      var value = ${Ti(e,u)}(0.0);\\n      let col = colIn * ${e};\\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\\n      {\\n        var bIndices: ${o.type.indices};\\n        ${Mi("bIndices",o,o.rank-2,i.rank,"batchIndices")}\\n        ${o.indicesSet("bIndices",o.rank-2,"u32(row)")}\\n        ${o.indicesSet("bIndices",o.rank-1,"u32(colIn)")}\\n        value = ${o.getByIndices("bIndices")};\\n      }\\n      return value;\\n    }\\n\\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Ti(e,u)}) {\\n      let col = colIn * ${e};\\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\\n        var value = valueIn;\\n        let coords = vec3<i32>(batch, row, colIn);\\n        ${t?`value = value + ${s?"bias[colIn]":`${Ti(e,u)}(bias[row])`};`:""}\\n        ${n}\\n        ${l.setByIndices("vec3<u32>(coords)","value")}\\n      }\\n    }\\n    `},Ui=(e,t,n,r,s=!1,i)=>{let a=e[0].dims,o=e[1].dims,l=a.slice(0,-2),u=o.slice(0,-2),d=r?r.slice(0,-2):n.slice(0,-2),c=$n.size(d),p=a[a.length-2],h=a[a.length-1],f=o[o.length-1],m=h%4==0&&f%4==0,_=p<=8?[4,1,1]:[4,4,1],g=[8,8,1],w=[Math.ceil(f/g[0]/_[0]),Math.ceil(p/g[1]/_[1]),Math.ceil(c/g[2]/_[2])],y=m?4:1,b=[...l,p,h/y],x=b.length,v=[...u,h,f/y],$=v.length,k=[c,p,f/y],E=[{type:6,data:p},{type:6,data:f},{type:6,data:h}];Si(t,E),E.push(...Mn(d,b,v));let S=["rank","rank"],z=e.length>2;z&&(E.push(...Mn(e[2].dims)),S.push("rank")),E.push(...Mn(k));return{name:"MatMul",shaderCache:{hint:`${_};${t.activation};${m};${s}`,inputDependencies:S},getRunData:()=>({outputs:[{dims:i?i(n):n,dataType:e[0].dataType}],dispatchGroup:{x:w[0],y:w[1],z:w[2]},programUniforms:E}),getShaderSource:n=>{let r=d.length,i=qn("batchDims",e[0].dataType,r,1),a=An(e[0].dataType),o=Ln("a",e[0].dataType,x,y),l=Ln("b",e[1].dataType,$,y),u=Fn("result",e[0].dataType,k.length,y),c=[o,l];if(z){let t=s?y:1;c.push(Ln("bias",e[2].dataType,e[2].dims.length,t))}let p=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];zi(t,p);let h=An(u.type.tensor),f=Ei(t,u.type.value,h),w=Fi(y,z,f,[i,o,l,u],s);return`\\n  ${n.registerUniforms(p).registerInternalVariables(i).declareVariables(...c,u)}\\n  ${w}\\n  ${m?Pi(_,g,a,i):Li(_,g,a,i)}\\n                   `}}}})),Sd=qe((()=>{td(),rd(),ud(),xd(),vd(),$d(),Ed(),qi=(e,t,n,r,s=!1,i,a=4,o=4,l=4,u="f32")=>{let d=e?"\\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\\n    ":"\\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\\n    ",c=e?"\\n    let coords = vec4<i32>(\\n      batch,\\n      row / outWidth,\\n      row % outWidth,\\n      col);\\n    ":"\\n    let coords = vec4<i32>(\\n      batch,\\n      row,\\n      col / outWidth,\\n      col % outWidth);\\n    ",p=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",h=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",f=e?"row":"col",m=e?"col":"row",_=`\\n    let inChannels = i32(uniforms.w_shape[2]);\\n    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\\n    let outRow = ${f} / outWidth;\\n    let outCol = ${f} % outWidth;\\n\\n    let WRow = ${m} / (i32(uniforms.w_shape[1]) * inChannels);\\n    let WCol = ${m} / inChannels % i32(uniforms.w_shape[1]);\\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\\n    let xCh = ${m} % inChannels;\\n    var resData = ${Ti(a,u)}(0.0);\\n    // The bounds checking is always needed since we use it to pad zero for\\n    // the \'same\' padding type.\\n    if (xRow >= 0 && xRow < ${p} && xCol >= 0 && xCol < ${h}) {\\n      ${d}\\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\\n      ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${u}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(a)}\\n    }\\n    return resData;`,g=e?t&&r?`\\n    let col = colIn * ${a};\\n    ${_}`:`\\n    let col = colIn * ${a};\\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\\n      ${_}\\n    }\\n    return ${Ti(a,u)}(0.0);`:r&&n?`\\n    let col = colIn * ${a};\\n    ${_}`:`\\n    let col = colIn * ${a};\\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\\n      ${_}\\n    }\\n    return ${Ti(a,u)}(0.0);`,w=`${(e=>{switch(e){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(o)}`,y=Ti(l,u),b=Ti(e?a:o,u),x=Ti(e?o:a,u),v=Ei(i,y,u);return`\\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${b} {\\n      ${e?g:w}\\n    }\\n\\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${x} {\\n      ${e?w:g}\\n    }\\n\\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${y}) {\\n      let col = colIn * ${l};\\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\\n      {\\n      var value = valueIn;\\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\\n      ${c}\\n      ${Ai(s)}\\n      ${v}\\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\\n      }\\n    }`},Vi=(e,t,n,r,s,i,a,o,l)=>{let u="NHWC"===t.format,d=u?e[0].dims[3]:e[0].dims[1],c=n[0],p=u?n[2]:n[3],h=u?n[1]:n[2],f=u?n[3]:n[1],m=u&&(d%4==0||d%3==0)&&f%4==0,_=u?f:p*h,g=u?p*h:f,w=[8,8,1],y=r<=8?[4,1,1]:[4,4,1],b=[Math.ceil(_/w[0]/y[0]),Math.ceil(g/w[1]/y[1]),Math.ceil(c/w[2]/y[2])];ln("verbose",(()=>`[conv2d_mm_webgpu] dispatch = ${b}`));let x=m?u&&d%4!=0?3:4:1,v=w[1]*y[1],$=w[0]*y[0],k=Math.max(w[0]*x,w[1]),E=r%v==0,S=s%$==0,z=i%k==0,C=m?[x,4,4]:[1,1,1],T=[{type:6,data:r},{type:6,data:s},{type:6,data:i},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];Si(t,T),T.push(...Mn(e[0].dims,e[1].dims));let A=["rank","rank"];a&&(T.push(...Mn(e[2].dims)),A.push("rank")),T.push(...Mn(n));return{name:"Conv2DMatMul",shaderCache:{hint:`${t.cacheKey};${x};${m};${E};${S};${z};${v};${$};${k}`,inputDependencies:A},getRunData:()=>({outputs:[{dims:l?l(n):n,dataType:e[0].dataType}],dispatchGroup:{x:b[0],y:b[1],z:b[2]},programUniforms:T}),getShaderSource:r=>{let s=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];zi(t,s);let i=m?4:1,l=An(e[0].dataType),d=`\\n      fn setOutputAtIndex(flatIndex : i32, value : ${m?`vec4<${l}>`:l}) {\\n        result[flatIndex] = ${m?`vec4<${l}>`:l}(value);\\n      }\\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${m?`vec4<${l}>`:l}) {\\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\\n        setOutputAtIndex(flatIndex ${m?"/ 4":""}, value);\\n      }`,c=[Ln("x",e[0].dataType,e[0].dims.length,3===x?1:x),Ln("w",e[1].dataType,e[1].dims.length,i)],p=Fn("result",e[0].dataType,n.length,i);if(a){let t=Ln("bias",e[2].dataType,e[2].dims.length,i);c.push(t),d+=`\\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${m?`vec4<${l}>`:l} {\\n          return bias[coords.${u?"w":"y"}${m?"/ 4":""}];\\n        }`}return`\\n        ${Ii("uniforms.result_strides")}\\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\\n        ${r.registerUniforms(s).declareVariables(...c,p)}\\n        ${d}\\n        ${qi(u,E,S,z,a,t,C[0],C[1],C[2],l)}\\n        ${m?Pi(y,w,l,void 0,!u,k):Li(y,w,l,void 0,!u,k,!1,void 0,o)}`}}}})),zd=qe((()=>{td(),rd(),ld(),ud(),xd(),vd(),Wi=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t},ji=e=>"number"==typeof e?[e,e,e]:e,Gi=(e,t)=>t<=1?e:e+(e-1)*(t-1),Hi=(e,t,n,r=1)=>{let s=Gi(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)},Ki=(e,t,n,r,s)=>{null==s&&(s=Hi(e,t[0],r[0]));let i=[0,0,0,n];for(let n=0;n<3;n++)e[n]+2*s>=t[n]&&(i[n]=Math.trunc((e[n]-t[n]+2*s)/r[n]+1));return i},Xi=(e,t,n,r,s,i,a,o,l,u)=>{let d,c,p,h;if("VALID"===e&&(e=0),"number"==typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e};let f=Ki([t,n,r,1],[o,l,u],1,[s,i,a],e);c=f[0],p=f[1],h=f[2]}else if(Array.isArray(e)){if(!e.every(((e,t,n)=>e===n[0])))throw Error(`Unsupported padding parameter: ${e}`);d={top:e[0],bottom:e[1],left:e[2],right:e[3],front:e[4],back:e[5]};let f=Ki([t,n,r,1],[o,l,u],1,[s,i,a],e[0]);c=f[0],p=f[1],h=f[2]}else{if("SAME_UPPER"!==e)throw Error(`Unknown padding parameter: ${e}`);{c=Math.ceil(t/s),p=Math.ceil(n/i),h=Math.ceil(r/a);let e=(c-1)*s+o-t,f=(p-1)*i+l-n,m=(h-1)*a+u-r,_=Math.floor(e/2),g=e-_,w=Math.floor(f/2),y=f-w,b=Math.floor(m/2);d={top:w,bottom:y,left:b,right:m-b,front:_,back:g}}}return{padInfo:d,outDepth:c,outHeight:p,outWidth:h}},Qi=(e,t,n,r,s,i=!1,a="channelsLast")=>{let o,l,u,d,c;if("channelsLast"===a)[o,l,u,d,c]=e;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[o,c,l,u,d]=e}let[p,,h,f,m]=t,[_,g,w]=ji(n),[y,b,x]=ji(r),v=Gi(h,y),$=Gi(f,b),k=Gi(m,x),{padInfo:E,outDepth:S,outHeight:z,outWidth:C}=Xi(s,l,u,d,_,g,w,v,$,k),T=i?p*c:p,A=[0,0,0,0,0];return"channelsFirst"===a?A=[o,T,S,z,C]:"channelsLast"===a&&(A=[o,S,z,C,T]),{batchSize:o,dataFormat:a,inDepth:l,inHeight:u,inWidth:d,inChannels:c,outDepth:S,outHeight:z,outWidth:C,outChannels:T,padInfo:E,strideDepth:_,strideHeight:g,strideWidth:w,filterDepth:h,filterHeight:f,filterWidth:m,effectiveFilterDepth:v,effectiveFilterHeight:$,effectiveFilterWidth:k,dilationDepth:y,dilationHeight:b,dilationWidth:x,inShape:e,outShape:A,filterShape:t}},Yi=(e,t,n,r,s,i)=>{let a="channelsLast"===i,o=(a?e[0].dims[3]:e[0].dims[1],{x:n.map(((e,t)=>t))}),l=[Math.ceil(Wi(o.x.map((e=>n[e])))/64),1,1];ln("verbose",(()=>`[conv3d_naive_webgpu] dispatch = ${l}`));let u=[{type:12,data:$n.size(n)},{type:12,data:r},{type:12,data:s},{type:12,data:t.strides},{type:12,data:t.dilations}];Si(t,u),u.push(...Mn(e[0].dims,e[1].dims));let d=["rank","rank"],c=3===e.length;c&&(u.push(...Mn(e[2].dims)),d.push("rank")),u.push(...Mn(n));return{name:"Conv3DNaive",shaderCache:{hint:`${t.cacheKey};${a};1;${c}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:l[0],y:l[1],z:l[2]},programUniforms:u}),getShaderSource:i=>{let o=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:r.length},{name:"pads",type:"u32",length:s.length},{name:"strides",type:"u32",length:t.strides.length},{name:"dilations",type:"u32",length:t.dilations.length}];zi(t,o);let l=An(e[0].dataType),u=Ln("x",e[0].dataType,e[0].dims.length,1),d=Ln("W",e[1].dataType,e[1].dims.length,1),p=[u,d],h=Fn("result",e[0].dataType,n.length,1),f="";if(c){let t=Ln("bias",e[2].dataType,e[2].dims.length,1);p.push(t),f+=`\\n        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${l} {\\n          return bias[${Rn("coords",a?4:1,5)}];\\n        }`}let m=Ti(1,l),_=Ei(t,m,l);return`\\n            ${f}\\n            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\\n              return ${u.getByIndices("aIndices")};\\n            }\\n            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\\n              return ${d.getByIndices("aIndices")};\\n            }\\n          ${i.registerUniforms(o).declareVariables(...p,h)}\\n          ${i.mainStart()}\\n          ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n              let coords = ${h.offsetToIndices("global_idx")};\\n              let batch = ${Rn("coords",0,u.rank)};\\n              let d2 = ${Rn("coords",a?u.rank-1:1,u.rank)};\\n              let xFRCCorner = vec3<u32>(${Rn("coords",a?1:2,u.rank)},\\n              ${Rn("coords",a?2:3,u.rank)},\\n              ${Rn("coords",a?3:4,u.rank)}) * uniforms.strides - uniforms.pads;\\n              let xFCorner = xFRCCorner.x;\\n              let xRCorner = xFRCCorner.y;\\n              let xCCorner = xFRCCorner.z;\\n              let xShapeY = ${Rn("uniforms.x_shape",a?1:2,u.rank)};\\n              let xShapeZ = ${Rn("uniforms.x_shape",a?2:3,u.rank)};\\n              let xShapeW = ${Rn("uniforms.x_shape",a?3:4,u.rank)};\\n              let xShapeU = ${Rn("uniforms.x_shape",a?4:1,u.rank)};\\n              let inputDepthNearestVec4 = (xShapeU / 4) * 4;\\n              let inputDepthVec4Remainder = xShapeU % 4;\\n\\n              var value = 0.0;\\n              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {\\n                let xF = xFCorner + wF * uniforms.dilations[0];\\n                if (xF < 0 || xF >= xShapeY) {\\n                  continue;\\n                }\\n\\n                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {\\n                  let xR = xRCorner + wR * uniforms.dilations[1];\\n                  if (xR < 0 || xR >= xShapeZ) {\\n                    continue;\\n                  }\\n\\n                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {\\n                    let xC = xCCorner + wC * uniforms.dilations[2];\\n                    if (xC < 0 || xC >= xShapeW) {\\n                      continue;\\n                    }\\n\\n                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {\\n                      ${a?"let xValues = vec4<f32>(\\n                               getX(batch, xF, xR, xC, d1),\\n                               getX(batch, xF, xR, xC, d1 + 1),\\n                               getX(batch, xF, xR, xC, d1 + 2),\\n                               getX(batch, xF, xR, xC, d1 + 3));\\n                            ":"let xValues = vec4<f32>(\\n                               getX(batch, d1, xF, xR, xC),\\n                               getX(batch, d1 + 1, xF, xR, xC),\\n                               getX(batch, d1 + 2, xF, xR, xC),\\n                               getX(batch, d1 + 3, xF, xR, xC));\\n                            "}\\n                            let wValues = vec4<f32>(\\n                              getW(d2, d1, wF, wR, wC),\\n                              getW(d2, d1 + 1, wF, wR, wC),\\n                              getW(d2, d1 + 2, wF, wR, wC),\\n                              getW(d2, d1 + 3, wF, wR, wC));\\n                      value += dot(xValues, wValues);\\n                    }\\n                    if (inputDepthVec4Remainder == 1) {\\n                        ${a?"value += getX(batch, xF, xR, xC, inputDepthNearestVec4)\\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);":"value += getX(batch, inputDepthNearestVec4, xF, xR, xC)\\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);"}\\n                    } else if (inputDepthVec4Remainder == 2) {\\n                      ${a?"let xValues = vec2<f32>(\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));\\n                      ":"let xValues = vec2<f32>(\\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));\\n                    "}\\n                    let wValues = vec2<f32>(\\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));\\n                      value += dot(xValues, wValues);\\n                    } else if (inputDepthVec4Remainder == 3) {\\n                      ${a?"let xValues = vec3<f32>(\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));\\n                      ":"let xValues = vec3<f32>(\\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),\\n                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));\\n                    "}\\n                    let wValues = vec3<f32>(\\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),\\n                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));\\n                      value += dot(xValues, wValues);\\n                    }\\n                  }\\n                }\\n              }\\n              ${c?"value = value + getBiasByOutputCoords(coords)":""};\\n              ${_}\\n              result[global_idx] = f32(value);\\n          }`}}}})),Cd=qe((()=>{td(),ld(),ud(),xd(),Zi=(e,t,n,r)=>{let s=e.length>2,i=s?"value += b[output_channel];":"",a=e[0].dims,o=e[1].dims,l="NHWC"===t.format,u=l?n[3]:n[1],d=u/t.group,c=l&&d>=4?On(u):1,p=$n.size(n)/c,h=[{type:12,data:p},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:d}];Si(t,h),h.push(...Mn(a,[o[0],o[1],o[2],o[3]/c]));let f=s?["rank","rank","rank"]:["rank","rank"];h.push(...Mn([n[0],n[1],n[2],n[3]/c]));return{name:"GroupedConv",shaderCache:{hint:`${t.cacheKey}_${c}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:r?r(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:h}),getShaderSource:r=>{let u=Fn("output",e[0].dataType,n.length,c),d=An(u.type.tensor),p=Ei(t,u.type.value,d),h=Ln("x",e[0].dataType,a.length),f=Ln("w",e[1].dataType,o.length,c),m=[h,f];s&&m.push(Ln("b",e[2].dataType,e[2].dims,c));let _=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:t.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];zi(t,_);let g=l?`\\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {\\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\\n\\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {\\n          continue;\\n        }\\n\\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {\\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {\\n            continue;\\n          }\\n\\n          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {\\n            let input_channel = in_channel_offset + wInChannel;\\n            let xVal = ${h.get("batch","xHeight","xWidth","input_channel")};\\n            let wVal = ${f.get("wHeight","wWidth","wInChannel","output_channel")};\\n            value += xVal * wVal;\\n          }\\n        }\\n      }\\n      `:`\\n      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\\n        let input_channel = in_channel_offset + wInChannel;\\n        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\\n          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\\n\\n          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {\\n            continue;\\n          }\\n\\n          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\\n            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\\n            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {\\n              continue;\\n            }\\n\\n            let xVal = ${h.get("batch","input_channel","xHeight","xWidth")};\\n            let wVal = ${f.get("output_channel","wInChannel","wHeight","wWidth")};\\n            value += xVal * wVal;\\n          }\\n        }\\n      }\\n      `;return`\\n  ${r.registerUniforms(_).declareVariables(...m,u)}\\n\\n  ${r.mainStart()}\\n    ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n\\n    let outputIndices = ${u.offsetToIndices("global_idx")};\\n    let batch: u32 = outputIndices[0];\\n    let output_channel: u32 = outputIndices[${l?3:1}];\\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${l?1:2}], outputIndices[${l?2:3}]) * uniforms.strides - uniforms.pads;\\n    let group_id: u32 = output_channel * ${c} / uniforms.output_channels_per_group;\\n    var in_channel_offset = group_id * uniforms.w_shape[${l?2:1}];\\n\\n    var value: ${u.type.value} = ${u.type.value}(0);\\n    ${g}\\n    ${i}\\n    ${p}\\n    ${u.setByOffset("global_idx","value")}\\n  }`}}},Ji=(e,t,n,r)=>{let s=e.length>2,i=On(n[3]),a=On(n[2]),o=$n.size(n)/i/a,l=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/i],u=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/i],d=[n[0],n[1],n[2],n[3]/i],c=[{type:12,data:o},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];Si(t,c),c.push(...Mn(l,u,d));let p=(a-1)*t.strides[1]+u[1];return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${t.cacheKey};${i};${a};${p};${u[0]};${u[1]}`,inputDependencies:s?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:r?r(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:c}),getShaderSource:n=>{let r=Fn("output",e[0].dataType,d.length,i),o=An(r.type.tensor),c=Ei(t,r.type.value,o),h=Ln("x",e[0].dataType,l.length,i),f=Ln("w",e[1].dataType,u.length,i),m=[h,f];s&&m.push(Ln("b",e[2].dataType,e[2].dims,i));let _=s?"value += b[output_channel];":"",g=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return zi(t,g),`\\n  ${n.registerUniforms(g).declareVariables(...m,r)}\\n  ${n.mainStart()}\\n    ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n    let width0 = uniforms.output_shape[3];\\n    let output_channel = global_idx % width0;\\n    var index1 = global_idx / width0;\\n    let width1 = uniforms.output_shape[2] / ${a}u;\\n    let col = (index1 % width1) * ${a}u;\\n    index1 = index1 / width1;\\n    let row = index1 % uniforms.output_shape[1];\\n    let batch = index1 / uniforms.output_shape[1];\\n\\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\\n\\n    var x_vals: array<${h.type.value}, ${p}>;\\n    var values: array<${r.type.value}, ${a}>;\\n    let input_channel = output_channel;\\n    // Use constant instead of uniform can give better performance for w\'s height/width.\\n    for (var w_height: u32 = 0u; w_height < ${u[0]}; w_height++) {\\n      let x_height = x_corner.x + i32(w_height);\\n      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {\\n        for (var i = 0; i < ${p}; i++) {\\n          let x_width = x_corner.y + i;\\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\\n            x_vals[i] = ${h.get("batch","u32(x_height)","u32(x_width)","input_channel")};\\n          } else {\\n            x_vals[i] = ${h.type.value}(0);\\n          }\\n        }\\n        for (var w_width: u32 = 0u; w_width < ${u[1]}; w_width++) {\\n          let w_val = ${f.get("w_height","w_width","0","output_channel")};\\n          for (var i = 0u; i < ${a}u; i++) {\\n            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);\\n          }\\n        }\\n      }\\n    }\\n\\n    for (var i = 0u; i < ${a}u; i++) {\\n      var value = values[i];\\n      ${_}\\n      ${c}\\n      ${r.set("batch","row","col + i","output_channel","value")};\\n    }\\n  }`}}}})),Td=qe((()=>{ld(),Sd(),zd(),Ed(),Cd(),xd(),kd(),dd(),ea=(e,t,n,r,s,i)=>{let a=e[0],o=e.slice(i?1:2,i?3:4),l=o.length,u=t[0],d=t.slice(2).map(((e,t)=>e+(e-1)*(n[t]-1))),c=o.map(((e,t)=>e+r[t]+r[t+l])).map(((e,t)=>Math.floor((e-d[t]+s[t])/s[t])));return c.splice(0,0,a),c.splice(i?3:1,0,u),c},ta=[2,3,1,0],na=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length>5)throw new Error("greater than 5D is not supported");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[1]*t.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===e.length&&(1!==e[2].dims.length||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},ra=(e,t)=>{let n=e.kernelShape.slice();n.length<t[1].dims.length-2&&n.push(...Array(t[1].dims.length-2-n.length).fill(0));for(let e=2;e<t[1].dims.length;++e)0===n[e-2]&&(n[e-2]=t[1].dims[e]);let r=e.pads.slice();kn.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,r,"NHWC"===e.format,e.autoPad);let s=Object.assign({},e);return Object.assign(s,{kernelShape:n,pads:r}),s},sa=e=>{let t=Ci(e),n=e.format;return{autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],format:n,dilations:e.dilations,group:e.group,kernelShape:e.kernel_shape,pads:e.pads,strides:e.strides,wIsConst:e.w_is_const(),...t,cacheKey:`${e.format};${t.activation};`}},ia=(e,t,n,r)=>{let s="NHWC"===n.format,i=ea(t[0].dims,t[1].dims,n.dilations,n.pads,n.strides,s);if(1!==n.group){let a=[t[0]];if(s){let r=e.kernelCustomData.wT??e.compute(Yn(t[1],ta),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=r),a.push(r)}else a.push(t[1]);return 3===t.length&&a.push(t[2]),void(!e.adapterInfo.isArchitecture("ampere")&&s&&t[1].dims[0]===n.group&&1===t[1].dims[1]&&1===n.dilations[0]&&1===n.dilations[1]?e.compute(Ji(a,n,i,r),{inputs:a}):e.compute(Zi(a,n,i,r),{inputs:a}))}let a=3===t.length,o=t[0].dims[s?1:2],l=t[0].dims[s?2:3],u=t[0].dims[s?3:1],d=t[1].dims[2],c=t[1].dims[3],p=i[s?1:2],h=i[s?2:3],f=i[s?3:1],m=s&&d===o&&c===l&&0===n.pads[0]&&0===n.pads[1];if(m||1===d&&1===c&&1===n.dilations[0]&&1===n.dilations[1]&&1===n.strides[0]&&1===n.strides[1]&&0===n.pads[0]&&0===n.pads[1]){let d,c,_,g=i[0],w=[];if(s){let r=e.kernelCustomData.wT??e.compute(Yn(t[1],ta),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=r),m){let e=o*l*u;d=t[0].reshape([1,g,e]),c=r.reshape([1,e,f]),_=[1,g,f]}else d=t[0].reshape([g,o*l,u]),c=r.reshape([1,u,f]),_=[g,p*h,f];w.push(d),w.push(c)}else d=t[0].reshape([g,u,o*l]),c=t[1].reshape([1,f,u]),_=[g,f,p*h],w.push(c),w.push(d);a&&w.push(t[2]);let y=_[2],b=w[0].dims[w[0].dims.length-1];return void(y<8&&b<8?e.compute(Oi(w,n,i,_,s,r),{inputs:w}):e.compute(Ui(w,n,i,_,s,r),{inputs:w}))}let _=e.kernelCustomData.wT??e.compute(Yn(t[1],ta),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=_);let g=[t[0],_];a&&g.push(t[2]);let w=s?p*h:f,y=s?f:p*h,b=d*c*u;e.compute(Vi(g,n,i,w,y,b,a,!0,r),{inputs:g})},aa=(e,t)=>{let n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&r.push(e.inputs[2]);let s=[0,t.pads[0],0,t.pads[1]],i=[1].concat(t.strides),a=[1].concat(t.dilations),o=[1].concat(t.kernelShape),l=ra({...t,pads:s,strides:i,dilations:a,kernelShape:o},r);ia(e,r,l,(e=>n?[e[0],e[2],e[3]]:[e[0],e[1],e[3]]))},oa=(e,t,n)=>{let r="NHWC"===n.format?"channelsLast":"channelsFirst",s=ra(n,t),i="NOTSET"===n.autoPad?n.pads:n.autoPad,a=Qi(t[0].dims,t[1].dims,n.strides,n.dilations,i,!1,r);e.compute(Yi(t,s,a.outShape,[a.filterDepth,a.filterHeight,a.filterWidth],[a.padInfo.front,a.padInfo.top,a.padInfo.left],r))},la=(e,t)=>{if(na(e.inputs,t),3===e.inputs[0].dims.length)aa(e,t);else if(5===e.inputs[0].dims.length)oa(e,e.inputs,t);else{let n=ra(t,e.inputs);ia(e,e.inputs,n)}}})),Ad=qe((()=>{td(),rd(),ld(),ud(),ua=(e,t,n)=>{let r=e.length>2,s=t.outputShape,i="NHWC"===t.format,a=t.group,o=e[1].dims,l=o[2]/a,u=o[3],d=i?On(u):1,c=$n.size(s)/d,p=[Math.ceil(c/64),1,1];ln("verbose",(()=>`[conv2d_backprop_webgpu] dispatch = ${p}`));let h=["rank","rank"],f=[t.strides[0],t.strides[1]],m=[t.kernelShape[i?1:2],t.kernelShape[i?2:3]],_=[t.dilations[0],t.dilations[1]],g=[m[0]+(t.dilations[0]<=1?0:(t.kernelShape[i?1:2]-1)*(t.dilations[0]-1)),m[1]+(t.dilations[1]<=1?0:(t.kernelShape[i?2:3]-1)*(t.dilations[1]-1))],w=[g[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),g[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],y=[{type:12,data:c},{type:12,data:f},{type:12,data:m},{type:12,data:_},{type:12,data:g},{type:6,data:w},{type:12,data:l},{type:12,data:u},...Mn(e[0].dims,e[1].dims)];r&&(y.push(...Mn(e[2].dims)),h.push("rank")),y.push(...Mn(s));return{name:"ConvTranspose2D",shaderCache:{hint:`${t.cacheKey};${d}`,inputDependencies:h},getRunData:()=>({dispatchGroup:{x:p[0],y:p[1],z:p[2]},outputs:[{dims:n?n(s):s,dataType:e[0].dataType}],programUniforms:y}),getShaderSource:t=>{let n=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:f.length},{name:"filter_dims",type:"u32",length:m.length},{name:"dilations",type:"u32",length:m.length},{name:"effective_filter_dims",type:"u32",length:g.length},{name:"pads",type:"i32",length:w.length},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],a=An(e[0].dataType),o=i?1:2,l=i?2:3,u=i?3:1,c=Ln("W",e[1].dataType,e[1].dims.length,d),p=Ln("Dy",e[0].dataType,e[0].dims.length),h=[p,c];r&&h.push(Ln("bias",e[2].dataType,[s[u]].length,d));let _=Fn("result",e[0].dataType,s.length,d),y=`\\n            let outputIndices = ${_.offsetToIndices(`global_idx * ${d}`)};\\n            let batch = ${_.indicesGet("outputIndices",0)};\\n            let d1 = ${_.indicesGet("outputIndices",u)};\\n            let r = ${_.indicesGet("outputIndices",o)};\\n            let c = ${_.indicesGet("outputIndices",l)};\\n            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\\n            let dyRCorner = dyCorner.x;\\n            let dyCCorner = dyCorner.y;\\n            let groupId = d1 / uniforms.output_channels_per_group;\\n            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\\n            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\\n            // ? = to be determined. : = across all values in that axis.\\n            var dotProd = ${_.type.value}(0.0);\\n            for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\\n              if (wR % uniforms.dilations.x != 0) {\\n                continue;\\n              }\\n              let dyR = (${a}(dyRCorner) + ${a}(wR)) / ${a}(uniforms.strides[0]);\\n              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\\n              if (dyR < 0.0 || dyR >= ${a}(uniforms.Dy_shape[${o}]) || fract(dyR) > 0.0 ||\\n                  wRPerm < 0) {\\n                continue;\\n              }\\n              let idyR: u32 = u32(dyR);\\n\\n              for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\\n                if (wC % uniforms.dilations.y != 0) {\\n                  continue;\\n                }\\n                let dyC = (${a}(dyCCorner) + ${a}(wC)) / ${a}(uniforms.strides.y);\\n                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\\n                if (dyC < 0.0 || dyC >= ${a}(uniforms.Dy_shape[${l}]) ||\\n                    fract(dyC) > 0.0 || wCPerm < 0) {\\n                  continue;\\n                }\\n                let idyC: u32 = u32(dyC);\\n                var inputChannel = groupId * uniforms.input_channels_per_group;\\n                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {\\n                  let xValue = ${i?p.get("batch","idyR","idyC","inputChannel"):p.get("batch","inputChannel","idyR","idyC")};\\n                  let w_offset = ${c.indicesToOffset(`${c.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};\\n                  let wValue = ${c.getByOffset(`w_offset / ${d}`)};\\n                  dotProd = dotProd + xValue * wValue;\\n                  inputChannel = inputChannel + 1;\\n                }\\n              }\\n            }\\n            let value = dotProd${r?` + bias[d1 / ${d}]`:""};\\n            ${_.setByOffset("global_idx","value")};\\n          `;return`\\n    ${t.registerUniforms(n).declareVariables(...h,_)}\\n      ${t.mainStart()}\\n      ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};\\n    ${y}}`}}}})),Id=qe((()=>{Ad(),xd(),dd(),da=(e,t,n,r,s,i)=>(e-1)*t+n+(r-1)*s+1-i,ca=(e,t,n,r,s)=>{let i=Math.floor(e/2);"SAME_UPPER"===t?(n[r]=i,n[s]=e-i):"SAME_LOWER"===t&&(n[r]=e-i,n[s]=i)},pa=(e,t,n,r,s,i,a,o,l,u)=>{let d=e.length-2,c=0===u.length;l.length<d&&l.push(...Array(d-l.length).fill(0));let p=e[0],h=t[o?3:1]*s;for(let s=0,p=e.length-d-(o?1:0);s<d;++s,++p){let o=e[p],h=c?o*a[s]:u[s],f=da(o,a[s],i[s],t[p],n[s],h);ca(f,r,i,s,s+d),c&&u.push(a[s]*(o-1)+l[s]+(t[p]-1)*n[s]+1-i[s]-i[s+d])}u.splice(0,0,p),u.splice(o?3:1,0,h)},ha=(e,t)=>{let n=e.kernelShape.slice();if(0===e.kernelShape.length||0===e.kernelShape.reduce(((e,t)=>e*t),1)){n.length=0;for(let e=2;e<t[1].dims.length;++e)n.push(t[1].dims[e])}let r="NHWC"===e.format;n.splice(0,0,t[1].dims[0]),n.splice(r?3:1,0,t[1].dims[1]);let s=e.pads.slice(),i=e.outputShape.slice(),a=e.outputPadding.slice(),o=t[0].dims,l=e.dilations.slice();if(0===l.reduce(((e,t)=>e+t),0)){let e=t[0].dims.length-2;l=new Array(e).fill(1)}let u=e.strides.slice();if(0===u.reduce(((e,t)=>e+t),0)){let e=t[0].dims.length-2;u=new Array(e).fill(1)}pa(o,n,l,e.autoPad,e.group,s,u,r,a,i);let d=Object.assign({},e);return Object.assign(d,{kernelShape:n,pads:s,outputPadding:a,outputShape:i,dilations:l,strides:u}),d},fa=e=>{let t=Ci(e),n=e.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],s=e.dilations,i=e.group,a=e.kernelShape,o=e.pads,l=e.strides,u=e.wIsConst();return{autoPad:r,format:n,dilations:s,group:i,kernelShape:a,outputPadding:e.outputPadding,outputShape:e.outputShape,pads:o,strides:l,wIsConst:u,...t,cacheKey:`${e.format};${t.activation};`}},ma=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(3===e.length&&(1!==e[2].dims.length||e[2].dims[0]!==n))throw new Error("invalid bias");let r=e[0].dims.length-2;if(t.dilations.reduce(((e,t)=>e+t),0)>0&&t.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(t.strides.reduce(((e,t)=>e+t),0)>0&&t.strides.length!==r)throw new Error(`strides should be ${r}D`);if(t.pads.reduce(((e,t)=>e+t),0)>0&&t.pads.length!==2*r)throw new Error(`pads should be ${2*r}D`);if(t.outputPadding.length!==r&&0!==t.outputPadding.length)throw new Error(`output_padding should be ${r}D`);if(t.kernelShape.reduce(((e,t)=>e+t),0)>0&&0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==t.outputShape.length&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},_a=(e,t,n,r)=>{let s=e.kernelCustomData.wT??e.compute(Yn(t[1],[2,3,0,1]),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=s);let i=[t[0],s];3===t.length&&i.push(t[2]),e.compute(ua(i,n,r),{inputs:i})},ga=(e,t)=>{let n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&r.push(e.inputs[2]);let s=t.kernelShape;(0===s.length||0===s[0])&&(s=[e.inputs[1].dims[2]]);let i=t.dilations;(0===i.length||0===i[0])&&(i=[1]);let a=t.strides;(0===a.length||0===a[0])&&(a=[1]);let o=t.pads;0===o.length&&(o=[0,0]),o=[0,o[0],0,o[1]],a=[1].concat(a),i=[1].concat(i),s=[1].concat(s);let l=ha({...t,pads:o,strides:a,dilations:i,kernelShape:s},r);_a(e,r,l,(e=>n?[e[0],e[2],e[3]]:[e[0],e[1],e[3]]))},wa=(e,t)=>{if(ma(e.inputs,t),3===e.inputs[0].dims.length)ga(e,t);else{let n=ha(t,e.inputs);_a(e,e.inputs,n)}}})),Md=qe((()=>{td(),ld(),od(),ud(),ya=(e,t,n,r)=>{let s=$n.size(t),i=t.length,a=Ln("input",e,i),o=Fn("output",e,i),l=6===n.dataType?n.getInt32Array()[0]:Number(n.getBigInt64Array()[0]),u=$n.normalizeAxis(l,i);return{name:"CumSum",shaderCache:{hint:r.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:[{type:12,data:s},{type:12,data:u},...Mn(t,t)]}),getShaderSource:e=>{let t=` i32(${a.indicesGet("inputIndices","uniforms.axis")}) `,n=Rn("uniforms.input_shape","uniforms.axis",i),s=r.reverse?t+(r.exclusive?" + 1":""):"0",l=r.reverse?n:t+(r.exclusive?"":" + 1");return`\\n                ${e.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(a,o)}\\n                ${e.mainStart()}\\n                  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n                  var inputIndices = ${o.offsetToIndices("global_idx")};\\n                  var sum = ${o.type.value}(0);\\n                  let first : i32 = ${s};\\n                  let last : i32 = ${l};\\n                  for (var i : i32 = first; i < last; i++) {\\n                    ${a.indicesSet("inputIndices","uniforms.axis","u32(i)")};\\n                    sum = sum + ${a.getByIndices("inputIndices")};\\n                  }\\n                  ${o.setByOffset("global_idx","sum")};\\n                }`}}},ba=(e,t)=>{let n=e.inputs[0].dims,r=e.inputs[0].dataType,s=e.inputs[1];e.compute(ya(r,n,s,t),{inputs:[0]})},xa=e=>{let t=1===e.exclusive,n=1===e.reverse;return bn({exclusive:t,reverse:n})}})),Od=qe((()=>{td(),ld(),od(),ud(),va=e=>{if(!e||1!==e.length)throw new Error("DepthToSpace requires 1 input.");if(4!==e[0].dims.length)throw new Error("DepthToSpace requires 4D input.")},$a=(e,t,n,r)=>{let s=[];s.push(`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {\\n    var a: ${n.type.indices};`);for(let r=0;r<t;++r)s.push(n.indicesSet("a",e[r],`i[${r}]`));return s.push("return a;}"),s.join("\\n")},ka=(e,t)=>{let n,r,s,i,a,o,l="NHWC"===t.format,u=t.blocksize,d="DCR"===t.mode;l?([n,r,s,i]=e.dims,a=d?[n,r,s,u,u,i/u**2]:[n,r,s,i/u**2,u,u],o=d?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([n,r,s,i]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],a=d?[n,u,u,i/u**2,r,s]:[n,i/u**2,u,u,r,s],o=d?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let c=e.reshape(a),p=c.dims.length,h=e.dataType,f=Ln("a",h,p),m=Fn("output",h,p);return{name:"DepthToSpace",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:["rank"]},getRunData:e=>{let t=l?[n,r*u,s*u,i/u**2]:[n,i/u**2,r*u,s*u],a=$n.size(t),d=c.dims,p=$n.sortBasedOnPerm(d,o);return{outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:[{type:12,data:a},...Mn(d,p)]}},getShaderSource:e=>`\\n  ${e.registerUniform("output_size","u32").declareVariables(f,m)}\\n\\n  ${$a(o,p,f,m)}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n\\n    let indices = ${m.offsetToIndices("global_idx")};\\n    let aIndices = perm(indices);\\n\\n    ${m.setByOffset("global_idx",f.getByIndices("aIndices"))}\\n  }`}},Ea=(e,t)=>{va(e.inputs),e.compute(ka(e.inputs[0],t))},Sa=e=>bn({blocksize:e.blocksize,mode:e.mode,format:e.format})})),Bd=qe((()=>{td(),ld(),od(),ud(),Ta="^"+(Ca="("+(za="[a-zA-Z]|\\\\.\\\\.\\\\.")+")+")+"$",Aa="^"+("("+Ca+",)*"+Ca)+"$",Ia=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,t){let n=this.symbolToIndices.get(e);void 0===n?n=[t]:n.push(t),this.symbolToIndices.set(e,n)}},Ma=class{constructor(e,t){this.equation=t,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,r]=t.includes("->")?t.split("->",2):[t,""];if(!n.match(RegExp(Aa)))throw new Error("Invalid LHS term");if(n.split(",").forEach(((t,n)=>{let r=e[n].dims.slice();if(!t.match(RegExp(Ta)))throw new Error("Invalid LHS term");let s=this.processTerm(t,!0,r,n);this.lhs.push(s)})),""===r)r+=[...this.symbolToInfo.entries()].filter((([e,t])=>1===t.count||"..."===e)).map((([e])=>e)).join("");else if(!r.match(RegExp(Ca)))throw new Error("Invalid RHS");r.match(RegExp(za,"g"))?.forEach((e=>{if("..."===e)this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let t=this.symbolToInfo.get(e);if(void 0===t)throw new Error("Invalid RHS symbol");this.outputDims.push(t.dimValue)}})),this.rhs=this.processTerm(r,!1,this.outputDims)}addSymbol(e,t,n){let r=this.symbolToInfo.get(e);if(void 0!==r){if(r.dimValue!==t&&1!==r.count)throw new Error("Dimension mismatch");r.count++,r.inputIndices.push(n)}else r={count:1,dimValue:t,inputIndices:[n]};this.symbolToInfo.set(e,r)}processTerm(e,t,n,r=-1){let s=n.length,i=!1,a=[],o=0;if(!e.match(RegExp(Ta))&&!t&&""!==e)throw new Error("Invalid LHS term");let l=e.match(RegExp(za,"g")),u=new Ia(r);return l?.forEach(((e,d)=>{if("..."===e){if(i)throw new Error("Only one ellipsis is allowed per input term");i=!0;let e=s-l.length+1;if(e<0)throw new Error("Ellipsis out of bounds");if(a=n.slice(o,o+e),this.hasEllipsis){if(this.ellipsisDims.length!==a.length||this.ellipsisDims.toString()!==a.toString())throw new Error("Ellipsis dimensions mismatch")}else{if(!t)throw new Error("Ellipsis must be specified in the LHS");this.hasEllipsis=!0,this.ellipsisDims=a}for(let e=0;e<a.length;e++){let t=String.fromCharCode("0".charCodeAt(0)+e);u.addSymbol(t,d+e),this.addSymbol(t,n[o++],r)}}else u.addSymbol(e,d+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(e,n[o++],r)})),u}},Oa=e=>e+"_max",Ba=(e,t,n,r)=>{let s=e.map((e=>e.length)).map(((e,n)=>Ln(`input${n}`,t,e))),i=$n.size(r),a=Fn("output",t,r.length),o=[...n.symbolToInfo.keys()].filter((e=>!n.rhs.symbolToIndices.has(e)));return{name:"Einsum",shaderCache:{hint:n.equation,inputDependencies:e.map((()=>"rank"))},getRunData:()=>{let s=o.filter((e=>n.symbolToInfo.has(e))).map((e=>({type:12,data:n.symbolToInfo.get(e)?.dimValue||0})));s.push({type:12,data:i});let a=e.map(((e,t)=>[...Mn(e)])).reduce(((e,t)=>e.concat(t)),s);return a.push(...Mn(r)),{outputs:[{dims:r,dataType:t}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:a}},getShaderSource:e=>{let t=[],r=[],i=[],l=[],u=[],d=n.symbolToInfo.size===n.rhs.symbolToIndices.size;n.symbolToInfo.forEach(((e,o)=>{if(n.rhs.symbolToIndices.has(o)){let r=n.rhs.symbolToIndices.get(o)?.[0];void 0!==r&&n.lhs.forEach(((n,i)=>{if(e.inputIndices.includes(i)){let e=n.symbolToIndices.get(o);if(void 0===e)throw new Error("Invalid symbol error");e.forEach((e=>{t.push(`${s[i].indicesSet(`input${i}Indices`,e,a.indicesGet("outputIndices",r))}`)}))}}))}else n.lhs.forEach(((t,n)=>{if(e.inputIndices.includes(n)){let e=t.symbolToIndices.get(o);if(void 0===e)throw new Error("Invalid symbol error");e.forEach((e=>{r.push(`${s[n].indicesSet(`input${n}Indices`,e,`${o}`)}`)})),u.push(`prod *= ${s[n].getByIndices(`input${n}Indices`)};`)}})),i.push(`for(var ${o}: u32 = 0; ${o} < uniforms.${Oa(o)}; ${o}++) {`),l.push("}")}));let c=d?[...t,`let sum = ${s.map(((e,t)=>e.getByIndices(`input${t}Indices`))).join(" * ")};`]:[...t,"var sum = 0.0;",...i,...r,"var prod = 1.0;",...u,"sum += prod;",...l];return`\\n            ${e.registerUniforms(o.map((e=>({name:`${Oa(e)}`,type:"u32"})))).registerUniform("outputSize","u32").declareVariables(...s,a)}\\n\\n            ${e.mainStart()}\\n            ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n            var outputIndices = ${a.offsetToIndices("global_idx")};\\n            ${s.map(((e,t)=>`var input${t}Indices: ${s[t].type.indices};`)).join("\\n")}\\n            ${c.join("\\n")};\\n            ${a.setByOffset("global_idx","sum")};\\n          }`}}},Na=(e,t)=>{let n=new Ma(e.inputs,t.equation),r=n.outputDims,s=e.inputs.map(((e,t)=>e.dims));e.compute(Ba(s,e.inputs[0].dataType,n,r))},Pa=e=>{let t=e.equation.replace(/\\s+/g,"");return bn({equation:t})}})),Nd=qe((()=>{td(),ld(),ud(),Ra=e=>{if(!e||2!==e.length)throw new Error("Expand requires 2 input.");let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=n.length<t.length?0:n.length-t.length,s=t.length<n.length?0:t.length-n.length;for(;r<n.length&&s<t.length;++r,++s)if(n[r]!==t[s]&&1!==n[r]&&1!==t[s])throw new Error("Expand requires shape to be broadcastable to input")},Da=(e,t)=>{let n=e.length-t.length,r=[];for(let t=0;t<n;++t)r.push(e[t]);for(let s=0;s<t.length;++s)r.push(1===t[s]?e[s+n]:t[s]);return r},La=(e,t)=>e.length>t.length?Da(e,t):Da(t,e),Fa=e=>{let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=La(t,n),s=e[0].dataType,i=9===s||1===$n.size(t),a=9===s||t.length>0&&t[t.length-1]%4==0?4:1,o=i||r.length>0&&r[r.length-1]%4==0?4:1,l=Math.ceil($n.size(r)/o),u=[{type:12,data:l},...Mn(t,r)];return{name:"Expand",shaderCache:{hint:`${r.length};${a}${o}`,inputDependencies:["rank"]},getShaderSource:e=>{let n,i=Ln("input",s,t.length,a),l=Fn("output",s,r.length,o);if(9===s){let e=(e,t,n="")=>`\\n          let outputIndices${t} = ${l.offsetToIndices(`outputOffset + ${t}u`)};\\n          let offset${t} = ${i.broadcastedIndicesToOffset(`outputIndices${t}`,l)};\\n          let index${t} = offset${t} / 4u;\\n          let component${t} = offset${t} % 4u;\\n          ${e}[${t}] = ${n}(${i.getByOffset(`index${t}`)}[component${t}]);\\n        `;n=`\\n        let outputOffset = global_idx * ${o};\\n        var data = vec4<u32>(0);\\n        ${e("data",0,"u32")}\\n        ${e("data",1,"u32")}\\n        ${e("data",2,"u32")}\\n        ${e("data",3,"u32")}\\n        ${l.setByOffset("global_idx","data")}\\n      }`}else n=`\\n        let outputIndices = ${l.offsetToIndices(`global_idx * ${o}`)};\\n        let inputOffset = ${i.broadcastedIndicesToOffset("outputIndices",l)};\\n        let data = ${l.type.value}(${i.getByOffset(`inputOffset / ${a}`)});\\n        ${l.setByOffset("global_idx","data")}\\n      }`;return`\\n    ${e.registerUniform("vec_size","u32").declareVariables(i,l)}\\n    ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\\n    ${n}`},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u})}},Ua=e=>{Ra(e.inputs),e.compute(Fa(e.inputs),{inputs:[0]})}})),Pd=qe((()=>{td(),ld(),ud(),gd(),qa=e=>{let t=e[0].dataType,n=$n.size(e[0].dims),r=$n.size(e[1].dims),s=r%4==0;return{name:"FastGeluWithBias",shaderCache:{hint:`${s}`,inputDependencies:["type","type"]},getShaderSource:e=>{let n=Ln("x",t,[1],4),r=Ln("bias",t,[1],4),i=Fn("y",t,[1],4),a=e=>`\\n      let bias${e}_offset: u32 = (global_idx * 4 + ${e}) % uniforms.bias_size;\\n      let bias${e} = ${r.getByOffset(`bias${e}_offset / 4`)}[bias${e}_offset % 4];`,o=s?`\\n      let bias = ${r.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${a(0)}${a(1)}${a(2)}${a(3)}\\n      let bias = ${n.type.value}(bias0, bias1, bias2, bias3);`;return`${e.registerUniforms([{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}]).declareVariables(n,r,i)}\\n\\n    ${Xs(In(t))}\\n\\n    ${e.mainStart(Cn)}\\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}\\n\\n      let x = ${n.getByOffset("global_idx")};\\n      ${o}\\n      let x_in = x + bias;\\n      ${i.setByOffset("global_idx",Qs("x_in"))}\\n    }`},getRunData:e=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],programUniforms:[{type:12,data:Math.ceil(n/4)},{type:12,data:r}],dispatchGroup:{x:Math.ceil(n/Cn/4)}})}},Va=e=>{e.inputs.length<2||0===$n.size(e.inputs[1].dims)?Ys(e):e.compute(qa(e.inputs))}})),Rd=qe((()=>{td(),ld(),od(),ud(),Wa=e=>{if(!e||2!==e.length)throw new Error("Gather requires 2 inputs.")},ja=(e,t)=>{let n=e[0].dims,r=e[1].dims,s=n.length,i=$n.normalizeAxis(t.axis,s),a=n.slice(0);a.splice(i,1,...r);let o=n[i],l=9===e[0].dataType?4:1,u=Math.ceil($n.size(a)/l),d=[{type:12,data:u},{type:6,data:o},{type:12,data:i},...Mn(e[0].dims,e[1].dims,a)];return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:d}),getShaderSource:t=>{let n,o=Ln("data",e[0].dataType,e[0].dims.length,l),u=Ln("inputIndices",e[1].dataType,e[1].dims.length),d=Fn("output",e[0].dataType,a.length,l),c=e=>{let t=r.length,n=`var indicesIndices${e}  = ${u.type.indices}(0);`;for(let r=0;r<t;r++)n+=`${t>1?`indicesIndices${e}[${r}]`:`indicesIndices${e}`} = ${a.length>1?`outputIndices${e}[uniforms.axis + ${r}]`:`outputIndices${e}`};`;n+=`\\n          var idx${e} = ${u.getByIndices(`indicesIndices${e}`)};\\n          if (idx${e} < 0) {\\n            idx${e} = idx${e} + uniforms.axisDimLimit;\\n          }\\n          var dataIndices${e} : ${o.type.indices};\\n        `;for(let r=0,o=0;r<s;r++)r===i?(n+=`${s>1?`dataIndices${e}[${r}]`:`dataIndices${e}`} = u32(idx${e});`,o+=t):(n+=`${s>1?`dataIndices${e}[${r}]`:`dataIndices${e}`} = ${a.length>1?`outputIndices${e}[${o}]`:`outputIndices${e}`};`,o++);return n};if(9===e[0].dataType){let e=(e,t,n="")=>`\\n          let outputIndices${t} = ${d.offsetToIndices(`outputOffset + ${t}u`)};\\n          ${c(t)};\\n          let offset${t} = ${o.indicesToOffset(`dataIndices${t}`)};\\n          let index${t} = offset${t} / 4u;\\n          let component${t} = offset${t} % 4u;\\n          ${e}[${t}] = ${n}(${o.getByOffset(`index${t}`)}[component${t}]);\\n        `;n=`\\n        let outputOffset = global_idx * ${l};\\n        var value = vec4<u32>(0);\\n        ${e("value",0,"u32")}\\n        ${e("value",1,"u32")}\\n        ${e("value",2,"u32")}\\n        ${e("value",3,"u32")}\\n        ${d.setByOffset("global_idx","value")}\\n      `}else n=`\\n      let outputIndices = ${d.offsetToIndices("global_idx")};\\n      ${c("")};\\n      let value = ${o.getByIndices("dataIndices")};\\n      ${d.setByOffset("global_idx","value")};\\n      `;return`\\n      ${t.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(o,u,d)}\\n      ${t.mainStart()}\\n        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n        ${n}\\n      }`}}},Ga=e=>bn({axis:e.axis}),Ha=(e,t)=>{let n=e.inputs;Wa(n),e.compute(ja(e.inputs,t))}})),Dd=qe((()=>{td(),ld(),ud(),Ka=(e,t,n,r,s,i,a,o,l)=>{let u=[{type:12,data:i},{type:12,data:r},{type:12,data:s},{type:12,data:n},{type:12,data:a},{type:12,data:o},{type:12,data:l}],d=[i];u.push(...Mn(t.dims,d));return e.compute({name:"computeSliceOffsets",shaderCache:{hint:`${s.length}_${n.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:d,dataType:e.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:u}),getShaderSource:e=>{let r=[Ln("indices_data",t.dataType,t.dims.length),Fn("input_slice_offsets_data",12,1,1)],i=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:s.length},{name:"sizes_from_slice_dims_data",type:"u32",length:n.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`\\n  ${e.registerUniforms(i).declareVariables(...r)}\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n    let batch_idx = global_idx / uniforms.num_slices_per_batch;\\n    let base_offset = batch_idx * uniforms.input_batch_stride;\\n\\n    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;\\n    var relative_slice_offset = 0;\\n    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {\\n      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);\\n      let input_dim_idx = uniforms.batch_dims + dim_idx;\\n      if (index < 0) {\\n        ${1===s.length?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}\\n      }\\n      ${1===n.length?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}\\n    }\\n\\n    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);\\n  }`}},{inputs:[t],outputs:[-1]})[0]},Xa=(e,t)=>{let n=e.inputs,r=n[0].dims,s=n[0].dataType,i=n[1].dims,a=i[i.length-1],o=$n.sizeToDimension(i,i.length-1),l=$n.sizeFromDimension(r,t.batchDims+a),u=$n.sizeToDimension(r,t.batchDims),d=$n.sizeFromDimension(r,t.batchDims),c=o/u,p=new Array(a),h=l;for(let e=0;e<a;++e)p[a-1-e]=h,h*=r[t.batchDims+a-1-e];let f=Ka(e,n[1],p,t.batchDims,r,o,c,d,a),m=t.batchDims+a;if(m>r.length)throw new Error("last dimension of indices must not be larger than rank of input tensor");let _=i.slice(0,-1).concat(r.slice(m)),g=$n.size(_),w=[{type:12,data:g},{type:12,data:l},...Mn(n[0].dims,f.dims,_)];e.compute({name:"GatherND",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:_,dataType:s}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:w}),getShaderSource:e=>{let t=Ln("data",n[0].dataType,n[0].dims.length),r=Ln("slice_offsets",12,f.dims.length),s=Fn("output",n[0].dataType,_.length);return`\\n          ${e.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(t,r,s)}\\n            ${e.mainStart()}\\n            ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];\\n          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];\\n        }`}},{inputs:[n[0],f]})},Qa=e=>({batchDims:e.batch_dims,cacheKey:""})})),Ld=qe((()=>{td(),ld(),od(),ud(),Ya=(e,t)=>{if(e.length<3||e.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let n=$n.normalizeAxis(t.quantizeAxis,e[0].dims.length),r=t.blockSize,s=e[0],i=e[2],a=4===e.length?e[3]:void 0;if(i.dims.length!==s.dims.length||!s.dims.map(((e,t)=>t===n?Math.ceil(e/r)===i.dims[t]:e===i.dims[t])).reduce(((e,t)=>e&&t),!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(a){if(a.dataType!==s.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(a.dims.length!==i.dims.length||!a.dims.map(((e,t)=>e===i.dims[t])).reduce(((e,t)=>e&&t),!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},Za=(e,t)=>{let n=e[0].dims,r=e[1].dims,s=n.length,i=$n.normalizeAxis(t.gatherAxis,s),a=$n.normalizeAxis(t.quantizeAxis,s),o=n.slice(0);o.splice(i,1,...r);let l=$n.size(o),u=e[2].dataType,d=22===e[0].dataType,c=[{type:12,data:l},{type:12,data:a},{type:12,data:i},{type:12,data:t.blockSize},...Mn(...e.map(((e,t)=>e.dims)),o)];return{name:"GatherBlockQuantized",shaderCache:{hint:`${t.cacheKey};${e.filter(((e,t)=>1!==t)).map((e=>e.dims.join("_"))).join(";")}`,inputDependencies:Array.from({length:e.length},((e,t)=>"rank"))},getRunData:()=>({outputs:[{dims:o,dataType:u}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:c}),getShaderSource:t=>{let s=Ln("data",e[0].dataType,e[0].dims.length),a=Ln("inputIndices",e[1].dataType,e[1].dims.length),l=Ln("scales",e[2].dataType,e[2].dims.length),c=e.length>3?Ln("zeroPoint",e[3].dataType,e[3].dims.length):void 0,p=Fn("output",u,o.length),h=[s,a,l];c&&h.push(c);return`\\n        ${t.registerUniforms([{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}]).declareVariables(...h,p)}\\n        ${t.mainStart()}\\n        let output_indices = ${p.offsetToIndices("global_idx")};\\n        var indices_indices = ${a.type.indices}(0);\\n        ${r.length>1?`\\n          for (var i: u32 = 0; i < ${r.length}; i++) {\\n            let index = ${p.indicesGet("output_indices","uniforms.gather_axis + i")};\\n            ${a.indicesSet("indices_indices","i","index")};\\n          }`:`indices_indices = ${p.indicesGet("output_indices","uniforms.gather_axis")};`};\\n        var data_indices = ${s.type.indices}(0);\\n        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {\\n          let index = ${p.indicesGet("output_indices","i")};\\n          ${s.indicesSet("data_indices","i","index")};\\n        }\\n        var index_from_indices = ${a.getByIndices("indices_indices")};\\n        if (index_from_indices < 0) {\\n          index_from_indices += ${n[i]};\\n        }\\n        ${s.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};\\n        for (var i = uniforms.gather_axis + 1; i < ${o.length}; i++) {\\n          let index = ${p.indicesGet("output_indices",`i + ${r.length} - 1`)};\\n          ${s.indicesSet("data_indices","i","index")};\\n        }\\n        let data_offset = ${s.indicesToOffset("data_indices")};\\n        let data_index = data_offset % 8;\\n        // Convert 4-bit packed data to 8-bit packed data.\\n        let packed_4bit_quantized_data = ${s.getByOffset("data_offset / 8")};\\n        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;\\n        let quantized_data_vec = ${d?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));\\n        let quantized_data = quantized_data_vec[data_index / 2];\\n        var scale_indices = data_indices;\\n        let quantize_axis_index = ${l.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;\\n        ${l.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};\\n        var scale = ${l.getByIndices("scale_indices")};\\n        ${c?`\\n              let zero_point_indices = scale_indices;\\n              let zero_point_offset = ${c.indicesToOffset("zero_point_indices")};\\n              let zero_point_index = zero_point_offset % 8;\\n              let packed_4bit_zero_points = ${c.getByOffset("zero_point_offset / 8")};\\n              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;\\n              let zero_point_vec = ${d?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));\\n              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};\\n        let dequantized_data = ${In(u)}(quantized_data - zero_point) * scale;\\n        ${p.setByOffset("global_idx","dequantized_data")};\\n    }`}}},Ja=(e,t)=>{let n=e.inputs;Ya(n,t),e.compute(Za(e.inputs,t))},eo=e=>bn({blockSize:e.blockSize,gatherAxis:e.gatherAxis,quantizeAxis:e.quantizeAxis})})),Fd=qe((()=>{td(),ld(),od(),ud(),to=e=>{if(!e||2!==e.length)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error("GatherElements requires that the data input and\\n                     indices input tensors be of same rank.")},no=(e,t)=>{let n=e[0].dims,r=e[0].dataType,s=n.length,i=e[1].dims,a=e[1].dataType,o=$n.normalizeAxis(t.axis,s),l=n[o],u=i.slice(0),d=$n.size(u),c=Ln("input",r,s),p=Ln("indicesInput",a,i.length),h=Fn("output",r,u.length),f=[{type:12,data:d},{type:6,data:l},{type:12,data:o}];return f.push(...Mn(n,i,u)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:f}),getShaderSource:e=>`\\n      ${e.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(c,p,h)}\\n      ${e.mainStart()}\\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n\\n      let outputIndices = ${h.offsetToIndices("global_idx")};\\n\\n      var idx = ${p.getByOffset("global_idx")};\\n      if (idx < 0) {\\n        idx = idx + uniforms.axisDimLimit;\\n      }\\n      var inputIndices = ${c.type.indices}(outputIndices);\\n      ${c.indicesSet("inputIndices","uniforms.axis","u32(idx)")};\\n      let value = ${c.getByIndices("inputIndices")};\\n\\n      ${h.setByOffset("global_idx","value")};\\n  }`}},ro=e=>bn({axis:e.axis}),so=(e,t)=>{let n=e.inputs;to(n),e.compute(no(e.inputs,t))}})),Ud=qe((()=>{td(),ld(),ud(),io=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(3===e.length&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},ao=(e,t)=>{let n=e[0].dims.slice(),r=e[1].dims.slice(),[s,i,a]=En.getShapeOfGemmResult(n,t.transA,r,t.transB,3===e.length?e[2].dims:void 0),o=[s,i];if(!o)throw new Error("Can\'t use gemm on the given tensors");let l=16,u=Math.ceil(i/l),d=Math.ceil(s/l),c=($n.size(o),[{type:12,data:u},{type:12,data:s},{type:12,data:i},{type:12,data:a},{type:1,data:t.alpha},{type:1,data:t.beta}]),p=["type","type"];3===e.length&&(c.push(...Mn(e[2].dims)),p.push("rank")),c.push(...Mn(o));return{name:"GemmShared",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:u*d},programUniforms:c}),getShaderSource:n=>{let r=Ln("a",e[0].dataType,e[0].dims),s=Ln("b",e[1].dataType,e[1].dims),i=null,a=[r,s];3===e.length&&(i=Ln("c",e[2].dataType,e[2].dims.length),a.push(i));let u=Fn("output",e[0].dataType,o.length);a.push(u);let d="",c="";t.transA&&t.transB?(c=`\\n      var col = tile_row_start + local_id.x;\\n      var row = k_start + local_id.y;\\n      if (col < uniforms.M && row < uniforms.K) {\\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\\n      } else {\\n        tile_a[local_id.y][local_id.x] = ${r.type.value}(0);\\n      }\\n\\n      col = k_start + local_id.x;\\n      row = tile_col_start + local_id.y;\\n      if (col < uniforms.K && row < uniforms.N) {\\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\\n      } else {\\n        tile_b[local_id.y][local_id.x] = ${s.type.value}(0);\\n      }\\n      `,d="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):t.transA&&!t.transB?(c=`\\n      var col = tile_row_start + local_id.x;\\n      var row = k_start + local_id.y;\\n      if (col < uniforms.M && row < uniforms.K) {\\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\\n      } else {\\n        tile_a[local_id.y][local_id.x] = ${r.type.value}(0);\\n      }\\n\\n      col = tile_col_start + local_id.x;\\n      row = k_start + local_id.y;\\n      if (col < uniforms.N && row < uniforms.K) {\\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\\n      } else {\\n        tile_b[local_id.y][local_id.x] = ${s.type.value}(0);\\n      }\\n      `,d="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!t.transA&&t.transB?(c=`\\n      var col = k_start + local_id.x;\\n      var row = tile_row_start + local_id.y;\\n      if (col < uniforms.K && row < uniforms.M) {\\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\\n      } else {\\n        tile_a[local_id.y][local_id.x] = ${r.type.value}(0);\\n      }\\n\\n      col = k_start + local_id.x;\\n      row = tile_col_start + local_id.y;\\n      if (col < uniforms.K && row < uniforms.N) {\\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\\n      } else {\\n        tile_b[local_id.y][local_id.x] = ${s.type.value}(0);\\n      }\\n      `,d="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!t.transA&&!t.transB&&(c=`\\n      var col = k_start + local_id.x;\\n      var row = tile_row_start + local_id.y;\\n      if (col < uniforms.K && row < uniforms.M) {\\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\\n      } else {\\n        tile_a[local_id.y][local_id.x] = ${r.type.value}(0);\\n      }\\n\\n      col = tile_col_start + local_id.x;\\n      row = k_start + local_id.y;\\n      if (col < uniforms.N && row < uniforms.K) {\\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\\n      } else {\\n        tile_b[local_id.y][local_id.x] = ${s.type.value}(0);\\n      }\\n      `,d="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let p=1===t.alpha?"":"value *= uniforms.alpha;";return`\\n  ${n.registerUniforms([{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}]).declareVariables(...a)}\\n  var<workgroup> tile_a: array<array<${r.type.storage}, 16>, 16>;\\n  var<workgroup> tile_b: array<array<${s.type.storage}, 16>, 16>;\\n  ${n.mainStart([l,l,1])}\\n    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * 16;\\n    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * 16;\\n    let num_tiles = (uniforms.K - 1) / 16 + 1;\\n    var k_start = 0u;\\n    var value = ${u.type.value}(0);\\n    for (var t: u32 = 0u; t < num_tiles; t++) {\\n      ${c}\\n      k_start = k_start + 16;\\n      workgroupBarrier();\\n\\n      for (var k: u32 = 0u; k < 16; k++) {\\n        ${d}\\n      }\\n      workgroupBarrier();\\n    }\\n\\n    ${p}\\n    let m = tile_row_start + local_id.y;\\n    let n = tile_col_start + local_id.x;\\n    ${null!=i?`let cOffset = ${i.broadcastedIndicesToOffset("vec2(m, n)",u)}; value += ${u.type.value}(uniforms.beta) * ${i.getByOffset("cOffset")};`:""}\\n    if (m < uniforms.M && n < uniforms.N) {\\n      output[m * uniforms.N + n] = value;\\n    }\\n  }`}}},oo=e=>({transA:e.transA,transB:e.transB,alpha:e.alpha,beta:e.beta,cacheKey:`${e.transA};${e.transB};${1===e.alpha}`}),lo=(e,t)=>{io(e.inputs),e.compute(ao(e.inputs,t))}})),qd=qe((()=>{td(),ld(),od(),ud(),[uo,co,po,ho]=[0,1,2,3],fo=e=>{if(4!==e[0].dims.length)throw new Error("only 4-D tensor is supported.");if(e[0].dims.length!==e[1].dims.length)throw new Error("input dimensions must be equal to grid dimensions");if(e[0].dims.length-2!==e[1].dims[e[1].dims.length-1])throw new Error("last dimension of grid must be equal to "+(e[0].dims.length-2));if(e[0].dims[0]!==e[1].dims[0])throw new Error("grid batch size must match input batch size")},mo=e=>`\\n  fn gs_bicubic_interpolate(p: mat4x4<${e}>, x: f32, y: f32) -> ${e} {\\n    var v: vec4<f32>;\\n    var coeffs = gs_get_cubic_coeffs(x);\\n    for (var i = 0; i < 4; i++) {\\n      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];\\n    }\\n    coeffs = gs_get_cubic_coeffs(y);\\n    let pixel = ${e}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);\\n    return pixel;\\n  }\\n`,_o=e=>`\\n  fn gs_denormalize(n: f32, length: i32) -> f32 {\\n    ${0===e.alignCorners?"\\n    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]\\n    return ((n + 1.0) * f32(length) - 1.0) / 2.0;\\n    ":"\\n    // alignCorners: true => [-1, 1] to [0, length - 1]\\n    return (n + 1.0) / 2.0 * (f32(length - 1));\\n    "}\\n  }\\n`,go=e=>`\\n  ${"reflection"===e.paddingMode?"\\n      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {\\n        var dx = 0.0;\\n        var fx = f32(x);\\n        let range = x_max - x_min;\\n        if (fx < x_min) {\\n          dx = x_min - fx;\\n          let n = u32(dx / range);\\n          let r = dx - f32(n) * range;\\n          if (n % 2 == 0) {\\n            fx = x_min + r;\\n          } else {\\n            fx = x_max - r;\\n          }\\n        } else if (fx > x_max) {\\n          dx = fx - x_max;\\n          let n = u32(dx / range);\\n          let r = dx - f32(n) * range;\\n          if (n % 2 == 0) {\\n            fx = x_max - r;\\n          } else {\\n            fx = x_min + r;\\n          }\\n        }\\n        return u32(fx);\\n      }":""}\\n`,wo=(e,t,n)=>`\\n  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${t} {\\n     var pixel = ${t}(0);\\n     var indices = vec4<u32>(0);\\n     indices[${uo}] = batch;\\n     indices[${co}] = channel;`+(()=>{switch(n.paddingMode){case"zeros":return`\\n          if (r >= 0 && r < H && c >=0 && c < W) {\\n            indices[${po}] = u32(r);\\n            indices[${ho}] = u32(c);\\n          }\\n        `;case"border":return`\\n          indices[${po}] = u32(clamp(r, 0, H - 1));\\n          indices[${ho}] = u32(clamp(c, 0, W - 1));\\n        `;case"reflection":return`\\n          indices[${po}] = gs_reflect(r, border[1], border[3]);\\n          indices[${ho}] = gs_reflect(c, border[0], border[2]);\\n        `;default:throw new Error(`padding mode ${n.paddingMode} is not supported`)}})()+`\\n    return ${e.getByIndices("indices")};\\n  }\\n`,yo=(e,t,n)=>(()=>{switch(n.mode){case"nearest":return`\\n          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${uo}], indices[${co}], border);\\n        `;case"bilinear":return`\\n          let x1 = i32(floor(x));\\n          let y1 = i32(floor(y));\\n          let x2 = x1 + 1;\\n          let y2 = y1 + 1;\\n\\n          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${uo}], indices[${co}], border);\\n          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${uo}], indices[${co}], border);\\n          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${uo}], indices[${co}], border);\\n          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${uo}], indices[${co}], border);\\n\\n          let dx2 = ${t}(f32(x2) - x);\\n          let dx1 = ${t}(x - f32(x1));\\n          let dy2 = ${t}(f32(y2) - y);\\n          let dy1 = ${t}(y - f32(y1));\\n          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);\\n        `;case"bicubic":return`\\n          let x0 = i32(floor(x)) - 1;\\n          let y0 = i32(floor(y)) - 1;\\n          var p: mat4x4<${t}>;\\n          for (var h = 0; h < 4; h++) {\\n            for (var w = 0; w < 4; w++) {\\n              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${uo}], indices[${co}], border);\\n            }\\n          }\\n\\n          let dx = x - f32(x0 + 1);\\n          let dy = y - f32(y0 + 1);\\n          let result = gs_bicubic_interpolate(p, dx, dy);\\n        `;default:throw new Error(`mode ${n.mode} is not supported`)}})()+`${e.setByOffset("global_idx","result")}`,bo=(e,t)=>{let n=Ln("x",e[0].dataType,e[0].dims.length),r=[e[1].dims[0],e[1].dims[1],e[1].dims[2]],s=Ln("grid",e[1].dataType,r.length,2),i=[e[0].dims[0],e[0].dims[1],e[1].dims[1],e[1].dims[2]];"NHWC"===t.format&&(i=[e[0].dims[0],e[1].dims[1],e[1].dims[2],e[0].dims[3]],[uo,co,po,ho]=[0,3,1,2]);let a=Fn("output",e[0].dataType,i.length),o=n.type.value,l=[{type:12,data:$n.size(i)},...Mn(e[0].dims,r,i)];return{name:"GridSample",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:["type","type"]},getRunData:e=>{let t=$n.size(i);return{outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(t/64)},programUniforms:l}},getShaderSource:e=>`\\n  ${e.registerUniform("output_size","u32").declareVariables(n,s,a)}\\n  \\n  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {\\n    let cubic_alpha = -0.75f;\\n    let x_abs = abs(x);\\n    var coeffs: vec4<f32>;\\n    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);\\n    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);\\n    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);\\n    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);\\n    return coeffs;\\n  }\\n\\n  ${mo(o)}\\n  ${_o(t)}\\n  ${go(t)}\\n  ${wo(n,o,t)}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n      let H_in = i32(uniforms.x_shape[${po}]);\\n      let W_in = i32(uniforms.x_shape[${ho}]);\\n\\n      ${0===t.alignCorners?"\\n      let x_min = -0.5;\\n      let x_max = f32(W_in) - 0.5;\\n      let y_min = -0.5;\\n      let y_max = f32(H_in) - 0.5;\\n      ":"\\n      let x_min = 0.0;\\n      let x_max = f32(W_in) - 1.0;\\n      let y_min = 0.0;\\n      let y_max = f32(H_in) - 1.0;\\n      "};\\n      let border = vec4<f32>(x_min, y_min, x_max, y_max);\\n\\n      let indices = ${a.offsetToIndices("global_idx")};\\n      var grid_indices = vec3<u32>(indices[${uo}], indices[${po}], indices[${ho}]);\\n      let nxy = ${s.getByIndices("grid_indices")};\\n      var x = gs_denormalize(f32(nxy[0]), W_in);\\n      var y = gs_denormalize(f32(nxy[1]), H_in);\\n\\n      ${yo(a,o,t)}\\n  }`}},xo=(e,t)=>{fo(e.inputs),e.compute(bo(e.inputs,t))},vo=e=>bn({alignCorners:e.align_corners,mode:e.mode,paddingMode:e.padding_mode,format:e.format})})),Vd=qe((()=>{td(),ld(),od(),id(),fd(),ud(),dd(),$o=(e,t)=>e.length>t&&e[t].dims.length>0?e[t]:void 0,ko=(e,t)=>{let n=e[0],r=$o(e,1),s=$o(e,2),i=$o(e,3),a=$o(e,4),o=$o(e,5),l=$o(e,6),u=$o(e,7);if(3!==n.dims.length&&5!==n.dims.length)throw new Error("Input query is expected to have 3 or 5 dimensions");let d,c=n.dims[0],p=n.dims[1],h=3===n.dims.length?n.dims[2]:t.numHeads*n.dims[4],f=p,m=0,_=0,g=Math.floor(h/t.numHeads);if(l&&u&&$n.size(l.dims)&&$n.size(u.dims)){if(4!==l.dims.length)throw new Error(\'Input "past_key" is expected to have 4 dimensions\');if(l.dims[0]!==c||l.dims[1]!==t.numHeads||l.dims[3]!==g)throw new Error(\'Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)\');if(u.dims[0]!==c||u.dims[1]!==t.numHeads||u.dims[3]!==g)throw new Error(\'Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)\');if(l.dims[2]!==u.dims[2])throw new Error(\'Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)\');if(4!==u.dims.length)throw new Error(\'Input "past_value" is expected to have 4 dimensions\');m=l.dims[2],_=l.dims[2]}else if(l&&$n.size(l.dims)||u&&$n.size(u.dims))throw new Error(\'Input "past_key" and "past_value" shall be both present or both absent\');if(r&&$n.size(r.dims)>0){if(3!==n.dims.length)throw new Error(\'Input "query" is expected to have 3 dimensions when key is given\');if(r.dims.length<3||r.dims.length>5)throw new Error(\'Input "key" is expected to have 3, 4, or 5 dimensions\');if(n.dims[0]!==r.dims[0])throw new Error(\'Input "query" and "key" shall have same dim 0 (batch size)\');if(3===r.dims.length){if(r.dims[2]!==n.dims[2])throw new Error(\'Input "query" and "key" shall have same dim 2 (hidden_size)\');d=2,f=r.dims[1]}else if(5===r.dims.length){if(r.dims[2]!==t.numHeads||2!==r.dims[3]||r.dims[4]!==g)throw new Error(\'Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv\');if(s)throw new Error(\'Expect "value" be none when "key" has packed kv format.\');d=5,f=r.dims[1]}else{if(r.dims[1]!==t.numHeads||r.dims[3]!==g)throw new Error(\'Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key\');d=0,f=r.dims[2]}}else{if(5!==n.dims.length)throw new Error(\'Input "query" is expected to have 5 dimensions when key is empty\');if(n.dims[2]!==t.numHeads||3!==n.dims[3])throw new Error(\'Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv\');d=3}if(i&&$n.size(i.dims)>0){if(1!==i.dims.length)throw new Error(\'Input "bias" is expected to have 1 dimension\');if(r&&5===r.dims.length&&2===r.dims[3])throw new Error("bias is not allowed for packed kv.")}let w=m+f,y=0;if(a&&$n.size(a.dims)>0){y=8;let e=a.dims;throw 1===e.length?e[0]===c?y=1:e[0]===3*c+2&&(y=3):2===e.length&&e[0]===c&&e[1]===w&&(y=5),8===y?new Error(\'Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)\'):new Error("Mask not supported")}let b=!1,x=h;if(s&&$n.size(s.dims)>0){if(3!==s.dims.length&&4!==s.dims.length)throw new Error(\'Input "value" is expected to have 3 or 4 dimensions\');if(n.dims[0]!==s.dims[0])throw new Error(\'Input "query" and "value" shall have same dim 0 (batch_size)\');if(3===s.dims.length){if(f!==s.dims[1])throw new Error(\'Input "key" and "value" shall have the same dim 1 (kv_sequence_length)\');x=s.dims[2]}else{if(f!==s.dims[2])throw new Error(\'Input "key" and "value" shall have the same dim 2 (kv_sequence_length)\');x=s.dims[1]*s.dims[3],b=!0}}if(a&&$n.size(a.dims)>0)throw new Error("Key padding mask is not supported");if(o&&$n.size(o.dims)>0){if(4!==o.dims.length)throw new Error(\'Input "attention_bias" is expected to have 4 dimensions\');if(o.dims[0]!==c||o.dims[1]!==t.numHeads||o.dims[2]!==p||o.dims[3]!==w)throw new Error(\'Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)\')}return{batchSize:c,sequenceLength:p,pastSequenceLength:m,kvSequenceLength:f,totalSequenceLength:w,maxSequenceLength:_,inputHiddenSize:0,hiddenSize:h,vHiddenSize:x,headSize:g,vHeadSize:Math.floor(x/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:y,scale:t.scale,broadcastResPosBias:!1,passPastInKv:b,qkvFormat:d}},Eo=e=>bn({...e}),So=bn({perm:[0,2,1,3]}),zo=(e,t,n,r,s,i,a)=>{let o=[r,s,i],l=$n.size(o),u=[{type:12,data:l},{type:12,data:a},{type:12,data:i}];return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:o,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u}),getShaderSource:e=>{let r=Fn("qkv_with_bias",t.dataType,o),s=Ln("qkv",t.dataType,o),i=Ln("bias",n.dataType,o);return`\\n  ${e.registerUniforms([{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}]).declareVariables(s,i,r)}\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\\n\\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\\n  }`}},{inputs:[t,n],outputs:[-1]})[0]},Co=(e,t,n,r,s,i,a,o)=>{let l=i;if(a&&$n.size(a.dims)>0){if(1===r)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return l=zo(e,i,a,t,r,n*s,o),l=l.reshape([t,r,n,s]),1===n||1===r?l:e.compute(Yn(l,So.perm),{inputs:[l],outputs:[-1]})[0]}return 3===i.dims.length&&(l=i.reshape([t,r,n,s])),1===n||1===r?l:e.compute(Yn(l,So.perm),{inputs:[l],outputs:[-1]})[0]},To=(e,t)=>{let n=ko(e.inputs,t),r=e.inputs[0],s=$o(e.inputs,1),i=$o(e.inputs,2),a=$o(e.inputs,3),o=$o(e.inputs,4),l=$o(e.inputs,5),u=$o(e.inputs,6),d=$o(e.inputs,7);if(5===r.dims.length)throw new Error("Packed QKV is not implemented");if(5===s?.dims.length)throw new Error("Packed KV is not implemented");let c=s&&i&&4===s.dims.length&&4===i.dims.length,p=Co(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,r,a,0);if(c)return ns(e,p,s,i,o,void 0,u,d,l,n);if(!s||!i)throw new Error("key and value must be provided");let h=Co(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.headSize,s,a,n.hiddenSize),f=Co(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.vHeadSize,i,a,2*n.hiddenSize);ns(e,p,h,f,o,void 0,u,d,l,n)}})),Wd=qe((()=>{td(),ld(),od(),ud(),Ao=e=>{if(!e||e.length<1)throw new Error("too few inputs")},Io=(e,t)=>{let n=[],r=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach((e=>n.push(Number(e)))),r=n.length),bn({numOutputs:r,axis:t.axis,splitSizes:n})},Mo=e=>`\\nfn calculateOutputIndex(index: u32) -> u32 {\\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\\n    if (index < ${Rn("uniforms.size_in_split_axis","i",e)}) {\\n        return i;\\n    }\\n    }\\n    return ${e}u;\\n}`,Oo=e=>{let t=e.length,n=[];for(let r=0;r<t;++r){let s=e[r].setByIndices("indices","input[global_idx]");1===t?n.push(s):0===r?n.push(`if (output_number == ${r}u) { ${s} }`):r===t-1?n.push(`else { ${s} }`):n.push(`else if (output_number == ${r}) { ${s} }`)}return`\\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\\n        ${n.join("\\n")}\\n      }`},Bo=(e,t)=>{let n=e[0].dims,r=$n.size(n),s=e[0].dataType,i=$n.normalizeAxis(t.axis,n.length),a=new Array(t.numOutputs),o=Ln("input",s,n.length),l=new Array(t.numOutputs),u=[],d=[],c=0,p=[{type:12,data:r}];for(let r=0;r<t.numOutputs;r++){c+=t.splitSizes[r],l[r]=c;let o=n.slice();o[i]=t.splitSizes[r],d.push(o),a[r]=Fn(`output${r}`,s,o.length),u.push({dims:d[r],dataType:e[0].dataType})}p.push({type:12,data:l},...Mn(n,...d));return{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:e=>`\\n  ${e.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",l.length).declareVariables(o,...a)}\\n  ${Mo(l.length)}\\n  ${Oo(a)}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}\\n\\n    var indices = ${o.offsetToIndices("global_idx")};\\n    var index = ${o.indicesGet("indices",i)};\\n    let output_number = calculateOutputIndex(index);\\n    if (output_number != 0) {\\n      index -= ${Rn("uniforms.size_in_split_axis","output_number - 1u",l.length)};\\n      ${o.indicesSet("indices",i,"index")};\\n    }\\n    writeBufferData(output_number, indices, global_idx);\\n  }`,getRunData:()=>({outputs:u,dispatchGroup:{x:Math.ceil(r/64)},programUniforms:p})}},No=(e,t)=>{Ao(e.inputs);let n=1===e.inputs.length?t:Io(e.inputs,t);e.compute(Bo(e.inputs,n),{inputs:[0]})},Po=e=>{let t=e.axis,n=e.splitSizes,r=e.numOutputs<0?n.length:e.numOutputs;if(r!==n.length)throw new Error("numOutputs and splitSizes lengh must be equal");return bn({axis:t,numOutputs:r,splitSizes:n})}})),jd=qe((()=>{od(),fd(),Vd(),Wd(),dd(),Ro=(e,t)=>{if(t.doRotary&&e.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let n=e[0],r=e[1],s=e[2],i=e[3],a=e[4];if(-1!==t.localWindowSize)throw new Error("Local attention is not supported");if(0!==t.softcap)throw new Error("Softcap is not supported");if(0!==t.rotaryInterleaved)throw new Error("Rotary interleaved is not supported");if(t.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(3!==n.dims.length&&5!==n.dims.length)throw new Error("Input query is expected to have 3 or 5 dimensions");let o=n.dims[0],l=n.dims[1],u=3===n.dims.length?n.dims[2]:t.numHeads*n.dims[4],d=l,c=0,p=!r||0===r.dims.length,h=Math.floor(p?u/(t.numHeads+2*t.kvNumHeads):u/t.numHeads);p&&(u=h*t.numHeads);let f=i&&0!==i.dims.length,m=a&&0!==a.dims.length;if(f&&4===i.dims.length&&i.dims[0]===o&&i.dims[1]!==t.kvNumHeads&&i.dims[2]===t.kvNumHeads&&i.dims[3]===h)throw new Error("BSNH pastKey/pastValue is not supported");if(f&&m){if(4!==i.dims.length)throw new Error(\'Input "past_key" is expected to have 4 dimensions\');if(4!==a.dims.length)throw new Error(\'Input "past_value" is expected to have 4 dimensions\');c=i.dims[2]}else if(f||m)throw new Error(\'Input "past_key" and "past_value" shall be both present or both absent\');let _=1;if(r&&r.dims.length>0){if(3!==n.dims.length)throw new Error(\'Input "query" is expected to have 3 dimensions when key is given\');if(r.dims.length<3||r.dims.length>5)throw new Error(\'Input "key" is expected to have 3, 4, or 5 dimensions\');if(n.dims[0]!==r.dims[0])throw new Error(\'Input "query" and "key" shall have same dim 0 (batch size)\');if(3===r.dims.length){if(n.dims[2]%r.dims[2]!=0)throw new Error(\'Dimension 2 of "query" should be a multiple of "key"\');d=r.dims[1]}else if(5===r.dims.length){if(r.dims[2]!==t.numHeads||2!==r.dims[3]||r.dims[4]!==h)throw new Error(\'Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv\');if(s)throw new Error(\'Expect "value" be none when "key" has packed kv format.\');d=r.dims[1]}else{if(r.dims[1]!==t.numHeads||r.dims[3]!==h)throw new Error(\'Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key\');d=r.dims[2]}}else{if(3!==n.dims.length&&5!==n.dims.length)throw new Error(\'Input "query" is expected to have 3 or 5 dimensions when key is empty\');if(5===n.dims.length&&(n.dims[2]!==t.numHeads||3!==n.dims[3]))throw new Error(\'Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv\');_=3}let g=!1,w=t.kvNumHeads?h*t.kvNumHeads:u;if(s&&s.dims.length>0){if(3!==s.dims.length&&4!==s.dims.length)throw new Error(\'Input "value" is expected to have 3 or 4 dimensions\');if(n.dims[0]!==s.dims[0])throw new Error(\'Input "query" and "value" shall have same dim 0 (batch_size)\');if(3===s.dims.length){if(d!==s.dims[1])throw new Error(\'Input "key" and "value" shall have the same dim 1 (kv_sequence_length)\');w=s.dims[2]}else{if(d!==s.dims[2])throw new Error(\'Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)\');w=s.dims[1]*s.dims[3],g=!0}}let y=e.length>4?e[5]:void 0;if(y&&1!==y.dims.length&&y.dims[0]!==o)throw new Error(\'Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size\');return{batchSize:o,sequenceLength:l,pastSequenceLength:c,kvSequenceLength:d,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:u,vHiddenSize:w,headSize:h,vHeadSize:Math.floor(w/t.kvNumHeads),numHeads:t.numHeads,kvNumHeads:t.kvNumHeads,nReps:t.numHeads/t.kvNumHeads,pastPresentShareBuffer:!1,maskType:0,scale:t.scale,broadcastResPosBias:!1,passPastInKv:g,qkvFormat:_}},Do=bn({perm:[0,2,1,3]}),Lo=(e,t,n)=>{let r=t,s=n.kvNumHeads;return 3===t.dims.length&&0!==n.kvSequenceLength&&(r=t.reshape([n.batchSize,n.kvSequenceLength,s,n.headSize]),r=e.compute(Yn(r,Do.perm),{inputs:[r],outputs:[-1]})[0]),r},Fo=(e,t)=>{let n=Ro(e.inputs,t);if(5===e.inputs[0].dims.length)throw new Error("Packed QKV is not implemented");if(5===e.inputs[1]?.dims.length)throw new Error("Packed KV is not implemented");let r=e.inputs[0],s=e.inputs[1]&&e.inputs[1].dims.length>0?e.inputs[1]:void 0,i=e.inputs[2]&&e.inputs[2].dims.length>0?e.inputs[2]:void 0,a=e.inputs[3]&&0!==e.inputs[3].dims.length?e.inputs[3]:void 0,o=e.inputs[4]&&0!==e.inputs[4].dims.length?e.inputs[4]:void 0,l=e.inputs.length>4?e.inputs[5]:void 0,u=e.inputs.length>5?e.inputs[6]:void 0,d=n.kvNumHeads?n.kvNumHeads:n.numHeads,c=bn({axis:2,numOutputs:3,splitSizes:[n.numHeads*n.headSize,d*n.headSize,d*n.headSize]}),[p,h,f]=s||i?[r,s,i]:e.compute(Bo([r],c),{inputs:[r],outputs:[-1,-1,-1]}),m=Co(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,p,void 0,0);ns(e,m,Lo(e,h,n),Lo(e,f,n),void 0,void 0,a,o,void 0,n,l,u)}})),Gd=qe((()=>{td(),ld(),dd(),ud(),Uo=(e,t,n,r,s,i,a,o)=>{let l=On(i),u=1===l?"f32":`vec${l}f`,d=1===l?"vec2f":`mat2x${l}f`,c=s*a,p=64;1===c&&(p=256);let h=[s,a,i/l],f=[s,a,2],m=[];m.push(...Mn(h,f));return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${l};${o};${p}`,inputDependencies:["rank","type","type"]},getRunData:()=>({outputs:[{dims:f,dataType:1}],dispatchGroup:{x:c},programUniforms:m}),getShaderSource:e=>{let s=Ln("x",t.dataType,3,l),i=[s,Ln("scale",n.dataType,n.dims),Ln("bias",r.dataType,r.dims),Fn("output",1,3,2)];return`\\n  var<workgroup> workgroup_shared : array<${d}, ${p}>;\\n  const workgroup_size = ${p}u;\\n  ${e.declareVariables(...i)}\\n  ${e.mainStart(p)}\\n    let batch = workgroup_index / uniforms.x_shape[1];\\n    let channel = workgroup_index % uniforms.x_shape[1];\\n    let hight = uniforms.x_shape[2];\\n    // initialize workgroup memory\\n    var sum = ${u}(0);\\n    var squared_sum = ${u}(0);\\n    for (var h = local_idx; h < hight; h += workgroup_size) {\\n      let value = ${u}(${s.get("batch","channel","h")});\\n      sum += value;\\n      squared_sum += value * value;\\n    }\\n    workgroup_shared[local_idx] = ${d}(sum, squared_sum);\\n    workgroupBarrier();\\n\\n    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {\\n      if (local_idx < currSize) {\\n        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];\\n      }\\n      workgroupBarrier();\\n    }\\n    if (local_idx == 0) {\\n      let sum_final = ${Pn("workgroup_shared[0][0]",l)} / f32(hight * ${l});\\n      let squared_sum_final = ${Pn("workgroup_shared[0][1]",l)} / f32(hight * ${l});\\n\\n      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${o}));\\n      let channel_scale = inv_std_dev * f32(scale[channel]);\\n      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;\\n      output[workgroup_index] = vec2f(channel_scale, channel_shift);\\n    }\\n  }`}},{inputs:[t,n,r],outputs:[-1]})[0]},qo=(e,t,n)=>{let r=t[0].dims,s=r,i=r[0],a=r[1],o=$n.sizeFromDimension(r,2),l=On(o),u=$n.size(s)/l,d=Uo(e,t[0],t[1],t[2],i,o,a,n.epsilon),c=[i,a,o/l],p=[i,a];e.compute({name:"InstanceNormalization",shaderCache:{hint:`${l}`,inputDependencies:["type","none"]},getRunData:()=>({outputs:[{dims:s,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:[{type:12,data:u},...Mn(c,p,c)]}),getShaderSource:e=>{let n=Ln("x",t[0].dataType,c.length,l),r=Ln("scale_shift",1,p.length,2),s=Fn("output",t[0].dataType,c.length,l),i=[n,r,s];return`\\n  ${e.registerUniform("output_size","u32").declareVariables(...i)}\\n  ${e.mainStart()}\\n  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n      let outputIndices = ${s.offsetToIndices("global_idx")};\\n      let batch = outputIndices[0];\\n      let channel = outputIndices[1];\\n      let scale_shift = ${r.getByIndices("vec2<u32>(batch, channel)")};\\n      let value = ${n.getByOffset("global_idx")} * ${s.type.value}(scale_shift.x) + ${s.type.value}(scale_shift.y);\\n      ${s.setByOffset("global_idx","value")};\\n  }`}},{inputs:[t[0],d]})},Vo=(e,t,n)=>{let r=t[0].dims,s=r,i=r[0],a=r[r.length-1],o=$n.sizeFromDimension(r,1)/a,l=On(a),u=$n.size(s)/l,d=[{type:12,data:o},{type:12,data:Math.floor(a/l)}],c=!1,p=[0,r.length-1];for(let e=0;e<r.length-2;e++)c=c||1!==r[e+1],p.push(e+1);c=c&&1!==r[r.length-1];let h=c?e.compute(Yn(e.inputs[0],p),{inputs:[e.inputs[0]],outputs:[-1]})[0]:e.inputs[0].reshape(Array.from({length:r.length},((e,t)=>r[p[t]]))),f=Uo(e,h,t[1],t[2],i,o,a,n.epsilon);e.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${l}`,inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:s,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:d}),getShaderSource:e=>{let n=An(t[0].dataType),r=1===l?"vec2f":`mat${l}x2f`,i=e=>{let t=0===e?"x":"y",r=1===l?"f32":`vec${l}f`;switch(l){case 1:return`${n}(${r}(scale.${t}))`;case 2:return`vec2<${n}>(${r}(scale[0].${t}, scale[1].${t}))`;case 4:return`vec4<${n}>(${r}(scale[0].${t}, scale[1].${t}, scale[2].${t}, scale[3].${t}))`;default:throw new Error(`Not supported compoents ${l}`)}},a=Ln("input",t[0].dataType,t[0].dims,l),o=Fn("output",t[0].dataType,s,l);return`\\n  @group(0) @binding(0) var<storage, read> input : array<${a.type.storage}>;\\n  @group(0) @binding(1) var<storage, read> scale_input : array<${r}>;\\n  @group(0) @binding(2) var<storage, read_write> output : array<${o.type.storage}>;\\n  struct Uniforms {H: u32, C : u32};\\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\\n\\n  ${e.mainStart()}\\n    let current_image_number = global_idx / (uniforms.C * uniforms.H);\\n    let current_channel_number = global_idx % uniforms.C;\\n\\n    let scale_offset = current_image_number * uniforms.C + current_channel_number;\\n    let scale = scale_input[scale_offset];\\n    output[global_idx] = fma(input[global_idx], ${i(0)}, ${i(1)});\\n  }`}},{inputs:[t[0],f]})},Wo=(e,t)=>{"NHWC"===t.format?Vo(e,e.inputs,t):qo(e,e.inputs,t)}})),Hd=qe((()=>{td(),ld(),ud(),jo=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},Go=(e,t,n)=>{let r=t.simplified,s=e[0].dims,i=e[1],a=!r&&e[2],o=s,l=$n.normalizeAxis(t.axis,s.length),u=$n.sizeToDimension(s,l),d=$n.sizeFromDimension(s,l),c=$n.size(i.dims),p=a?$n.size(a.dims):0;if(c!==d||a&&p!==d)throw new Error(`Size of X.shape()[axis:] == ${d}.\\n       Size of scale and bias (if provided) must match this.\\n       Got scale size of ${c} and bias size of ${p}`);let h=[];for(let e=0;e<s.length;++e)e<l?h.push(s[e]):h.push(1);let f=On(d),m=["type","type"],_=[{type:12,data:u},{type:1,data:d},{type:12,data:Math.floor(d/f)},{type:1,data:t.epsilon}];a&&m.push("type");let g=n>1,w=n>2,y=[{dims:o,dataType:e[0].dataType}];return g&&y.push({dims:h,dataType:1}),w&&y.push({dims:h,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${f};${n};${r}`,inputDependencies:m},getRunData:()=>({outputs:y,dispatchGroup:{x:Math.ceil(u/64)},programUniforms:_}),getShaderSource:t=>{let n=An(e[0].dataType),s=[Ln("x",e[0].dataType,e[0].dims,f),Ln("scale",i.dataType,i.dims,f)];a&&s.push(Ln("bias",a.dataType,a.dims,f)),s.push(Fn("output",e[0].dataType,o,f)),g&&s.push(Fn("mean_data_output",1,h)),w&&s.push(Fn("inv_std_output",1,h));return`\\n  ${t.registerUniforms([{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}]).declareVariables(...s)}\\n  ${t.mainStart()}\\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}\\n    let offset = global_idx * uniforms.norm_size_vectorized;\\n    var mean_vector = ${Bn("f32",f)};\\n    var mean_square_vector = ${Bn("f32",f)};\\n\\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\\n      let value = ${Nn(n,f,"x[h + offset]")};\\n      mean_vector += value;\\n      mean_square_vector += value * value;\\n    }\\n    let mean = ${Pn("mean_vector",f)} / uniforms.norm_size;\\n    let inv_std_dev = inverseSqrt(${Pn("mean_square_vector",f)} / uniforms.norm_size ${r?"":"- mean * mean"} + uniforms.epsilon);\\n\\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\\n      let f32input = ${Nn(n,f,"x[j + offset]")};\\n      let f32scale = ${Nn(n,f,"scale[j]")};\\n      output[j + offset] = ${s[0].type.value}((f32input ${r?"":"- mean"}) * inv_std_dev * f32scale\\n        ${a?`+ ${Nn(n,f,"bias[j]")}`:""}\\n      );\\n    }\\n\\n    ${g?"mean_data_output[global_idx] = mean":""};\\n    ${w?"inv_std_output[global_idx] = inv_std_dev":""};\\n  }`}}},Ho=(e,t)=>{jo(e.inputs),e.compute(Go(e.inputs,t,e.outputCount))}})),Kd=qe((()=>{ld(),kd(),Ed(),Ko=e=>{if(!e||2!==e.length)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},Xo=e=>{Ko(e.inputs);let t=vn.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can\'t use matmul on the given tensors");let n=t[t.length-1],r=e.inputs[0].dims[e.inputs[0].dims.length-1];if(n<8&&r<8)e.compute(Oi(e.inputs,{activation:""},t));else{let s=t[t.length-2],i=$n.size(e.inputs[0].dims.slice(0,-2)),a=$n.size(e.inputs[1].dims.slice(0,-2));if(1!==i&&1===s&&1===a){let s=[1,i,n],a=[e.inputs[0].reshape([1,i,r]),e.inputs[1].reshape([1,r,n])];e.compute(Ui(a,{activation:""},t,s),{inputs:a})}else e.compute(Ui(e.inputs,{activation:""},t))}}})),Xd=qe((()=>{td(),ld(),od(),ud(),Qo=(e,t)=>{if(e.length<3||e.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let n=e[0],r=n.dims.length;if(n.dims[r-1]!==t.k)throw new Error("The last dim of input shape does not match the k value");let s=Math.floor((t.k+t.blockSize-1)/t.blockSize),i=t.blockSize/8*t.bits,a=e[1];if(!$n.areEqual(a.dims,[t.n,s,i]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let o=e[2].dims;if($n.size(o)!==t.n*s)throw new Error("scales input size error.");if(4===e.length){let n=e[3].dims,r=t.bits>4?t.n*s:t.n*Math.floor((s+1)/2);if($n.size(n)!==r)throw new Error("zeroPoints input size error.")}},Yo=(e,t)=>{let n=e[0].dims,r=n.length,s=n[r-2],i=t.k,a=t.n,o=n.slice(0,r-2),l=$n.size(o),u=e[1].dims[2]/4,d=e[0].dataType,c=On(t.k),p=On(u),h=On(a),f=o.concat([s,a]),m=s>1&&a/h%2==0?2:1,_=$n.size(f)/h/m,g=64,w=[],y=[l,s,i/c],b=$n.convertShape(e[1].dims).slice();b.splice(-1,1,u/p),w.push(...Mn(y)),w.push(...Mn(b)),w.push(...Mn(e[2].dims)),4===e.length&&w.push(...Mn($n.convertShape(e[3].dims)));let x=[l,s,a/h];w.push(...Mn(x));return{name:"MatMulNBits",shaderCache:{hint:`${t.blockSize};${t.bits};${c};${p};${h};${m};64`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:f,dataType:d}],dispatchGroup:{x:_},programUniforms:w}),getShaderSource:n=>{let r=y.length,s=Ln("a",e[0].dataType,r,c),i=Ln("b",12,b.length,p),a=Ln("scales",e[2].dataType,e[2].dims.length),o=[s,i,a],l=4===e.length?Ln("zero_points",12,e[3].dims.length):void 0;l&&o.push(l);let d=x.length,f=Fn("output",e[0].dataType,d,h),_=An(e[0].dataType),w=(()=>{switch(c){case 1:return`array<${_}, 8>`;case 2:return`mat4x2<${_}>`;case 4:return`mat2x4<${_}>`;default:throw new Error(`${c}-component is not supported.`)}})();return`\\n        var<workgroup> workgroup_shared: array<${f.type.value}, ${m*g}>;\\n        ${n.declareVariables(...o,f)}\\n        ${n.mainStart([g,1,1])}\\n          let output_indices = ${f.offsetToIndices(`(global_idx / 64) * ${m}`)};\\n          let col = output_indices[2];\\n          let row = output_indices[1];\\n          let batch = output_indices[0];\\n          let nBlocksPerCol = uniforms.b_shape[1];\\n\\n          for (var block = local_id.x; block < nBlocksPerCol; block += 64) {\\n            //process one block\\n            var word_offset: u32 = block * ${t.blockSize/c};\\n            ${(()=>{let e=`\\n            var col_index = col * ${h};\\n            ${l?"\\n            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;\\n            var zero_point_byte_count: u32;\\n            var zero_point_word_index: u32;\\n            var zero_point_byte_offset: u32;\\n            let zero_point_nibble_offset: u32 = block & 0x1u;\\n            var zero_point_bits_offset: u32;\\n            var zero_point_word: u32;":`\\n            // The default zero point is 8 for unsigned 4-bit quantization.\\n            let zero_point = ${_}(8);`}\\n            `;for(let t=0;t<h*m;t++)e+=`\\n            let scale${t} = ${a.getByOffset("col_index * nBlocksPerCol + block")};\\n            ${l?`\\n            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);\\n            zero_point_word_index = zero_point_byte_count >> 0x2u;\\n            zero_point_byte_offset = zero_point_byte_count & 0x3u;\\n            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\\n            zero_point_word = ${l.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;\\n            let zero_point${t} = ${_}((zero_point_word) & 0xFu);`:""}\\n            col_index += 1;`;return e})()}\\n            for (var word: u32 = 0; word < ${u}; word += ${p}) {\\n              ${(()=>{let e=`col_index = col * ${h};`;for(let t=0;t<h*m;t++)e+=`\\n            let b${t}_data = ${i.getByIndices(`${i.type.indices}(col_index, block, word)`)};\\n            col_index += 1;`;return e+=`\\n            var b_value: u32;\\n            let b_mask: u32 = 0x0F0F0F0Fu;\\n            var b_value_lower: vec4<u32>;\\n            var b_value_upper: vec4<u32>;\\n            var b_quantized_values: ${w};\\n            var b_dequantized_values: ${w};`,e})()}\\n              for (var i: u32 = 0; i < ${p}; i++) {\\n                ${(()=>{let e=`\\n          // reuse a data\\n            var input_offset = ${s.indicesToOffset(`${s.type.indices}(batch, row, word_offset)`)};\\n            var a_data: ${w};\\n            for (var j: u32 = 0; j < ${8/c}; j++) {\\n              a_data[j] = ${s.getByOffset("input_offset")};\\n              input_offset++;\\n            }\\n          `;for(let t=0;t<h*m;t++)e+=`\\n            b_value = ${1===p?`b${t}_data`:`b${t}_data[i]`};\\n            b_value_lower = unpack4xU8(b_value & b_mask);\\n            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);\\n            b_quantized_values = ${w}(${Array.from({length:4},((e,t)=>`${_}(b_value_lower[${t}]), ${_}(b_value_upper[${t}])`)).join(", ")});\\n            b_dequantized_values = ${1===c?`${w}(${Array.from({length:8},((e,n)=>`(b_quantized_values[${n}] - ${l?`zero_point${t}`:"zero_point"}) * scale${t}`)).join(", ")});`:`(b_quantized_values - ${w}(${Array(8).fill(l?`zero_point${t}`:"zero_point").join(",")})) * scale${t};`};\\n            workgroup_shared[local_id.x * ${m} + ${Math.floor(t/h)}]${h>1?`[${t%h}]`:""} += ${Array.from({length:8/c},((e,t)=>""+(1===c?`a_data[${t}] * b_dequantized_values[${t}]`:`dot(a_data[${t}], b_dequantized_values[${t}])`))).join(" + ")};\\n          `;return e})()}\\n                word_offset += ${8/c};\\n              }\\n            }\\n          }\\n          workgroupBarrier();\\n\\n          if (local_id.x < ${m}) {\\n            var output_value: ${f.type.value} = ${f.type.value}(0);\\n            var workgroup_shared_offset: u32 = local_id.x;\\n            for (var b: u32 = 0u; b < 64u; b++) {\\n              output_value += workgroup_shared[workgroup_shared_offset];\\n              workgroup_shared_offset += ${m};\\n            }\\n            ${f.setByIndices(`${f.type.indices}(batch, row, col + local_id.x)`,"output_value")};\\n          }\\n        }`}}},Zo=(e,t)=>{let n=e[0].dims,r=n.length,s=n[r-2],i=t.k,a=t.n,o=n.slice(0,r-2),l=$n.size(o),u=e[1].dims[2]/4,d=e[0].dataType,c=On(t.k),p=On(u),h=o.concat([s,a]),f=a%8==0?8:a%4==0?4:1,m=128/f,_=m*p*8,g=_/c,w=_/t.blockSize,y=$n.size(h)/f,b=[],x=[l,s,i/c],v=$n.convertShape(e[1].dims).slice();v.splice(-1,1,u/p),b.push(...Mn(x)),b.push(...Mn(v)),b.push(...Mn(e[2].dims)),4===e.length&&b.push(...Mn($n.convertShape(e[3].dims)));let $=[l,s,a];b.push(...Mn($));return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${t.blockSize};${c};${p};${m};${f}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:h,dataType:d}],dispatchGroup:{x:y},programUniforms:b}),getShaderSource:n=>{let r=x.length,s=Ln("a",e[0].dataType,r,c),i=Ln("b",12,v.length,p),a=Ln("scales",e[2].dataType,e[2].dims.length),o=[s,i,a],l=4===e.length?Ln("zero_points",12,e[3].dims.length):void 0;l&&o.push(l);let u=$.length,d=Fn("output",e[0].dataType,u),h=An(e[0].dataType);return`\\n        var<workgroup> sub_a: array<${s.type.value}, ${g}>;\\n        var<workgroup> inter_results: array<array<${d.type.value}, ${m}>, ${f}>;\\n        ${n.declareVariables(...o,d)}\\n        ${n.mainStart([m,f,1])}\\n          let output_indices = ${d.offsetToIndices(`workgroup_index * ${f}`)};\\n          let col = output_indices[2];\\n          let row = output_indices[1];\\n          let batch = output_indices[0];\\n          let n_blocks_per_col = uniforms.b_shape[1];\\n          let num_tiles =  (n_blocks_per_col - 1) / ${w} + 1;\\n\\n          // Loop over shared dimension.\\n          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {\\n            let a_col_start = tile * ${g};\\n            // load one tile A data into shared memory.\\n            for (var a_offset = local_idx; a_offset < ${g}; a_offset += 128)\\n            {\\n              let a_col = a_col_start + a_offset;\\n              if (a_col < uniforms.a_shape[2])\\n              {\\n                sub_a[a_offset] = ${s.getByIndices(`${s.type.indices}(batch, row, a_col)`)};\\n              } else {\\n                sub_a[a_offset] = ${s.type.value}(0);\\n              }\\n            }\\n            workgroupBarrier();\\n\\n            // each thread process one block\\n            let b_row = col + local_id.y;\\n            let block = tile * ${w} + local_id.x;\\n            ${l?`\\n            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;\\n            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);\\n            let zero_point_word_index = zero_point_byte_count >> 0x2u;\\n            let zero_point_byte_offset = zero_point_byte_count & 0x3u;\\n            let zero_point_nibble_offset: u32 = block & 0x1u;\\n            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\\n            let zero_point_word = ${l.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;\\n            let zero_point = ${h}((zero_point_word) & 0xFu);`:`\\n            // The default zero point is 8 for unsigned 4-bit quantization.\\n            let zero_point = ${h}(8);`}\\n            let scale = ${a.getByOffset("b_row * n_blocks_per_col + block")};\\n            let b_data = ${i.getByIndices(`${i.type.indices}(b_row, block, 0)`)};\\n            var word_offset = local_id.x * ${t.blockSize/c};\\n            for (var i: u32 = 0; i < ${p}; i++) {\\n              ${(()=>{switch(c){case 1:return`\\n          let a_data0 = vec4<${h}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);\\n          let a_data1 = vec4<${h}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`\\n          let a_data0 = vec4<${h}>(sub_a[word_offset], sub_a[word_offset + 1]);\\n          let a_data1 = vec4<${h}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return"\\n          let a_data0 = sub_a[word_offset];\\n          let a_data1 = sub_a[word_offset + 1];";default:throw new Error(`${c}-component is not supported.`)}})()}\\n              let b_value = ${1===p?"b_data":"b_data[i]"};\\n              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);\\n              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);\\n              let b_quantized_values = mat2x4<${h}>(${Array.from({length:4},((e,t)=>`${h}(b_value_lower[${t}]), ${h}(b_value_upper[${t}])`)).join(", ")});\\n              let b_dequantized_values = (b_quantized_values - mat2x4<${h}>(${Array(8).fill("zero_point").join(",")})) * scale;\\n              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},((e,t)=>`dot(a_data${t}, b_dequantized_values[${t}])`)).join(" + ")};\\n              word_offset += ${8/c};\\n            }\\n            workgroupBarrier();\\n          }\\n\\n          if (local_idx < ${f}) {\\n            var output_value: ${d.type.value} = ${d.type.value}(0);\\n            for (var b = 0u; b < ${m}; b++) {\\n              output_value += inter_results[local_idx][b];\\n            }\\n            if (col + local_idx < uniforms.output_shape[2])\\n            {\\n              ${d.setByIndices(`${d.type.indices}(batch, row, col + local_idx)`,"output_value")}\\n            }\\n          }\\n        }`}}},Jo=(e,t)=>{Qo(e.inputs,t),32===t.blockSize&&e.adapterInfo.isVendor("intel")&&e.adapterInfo.isArchitecture("gen-12lp")?e.compute(Zo(e.inputs,t)):e.compute(Yo(e.inputs,t))},el=e=>bn(e)})),Qd=qe((()=>{td(),ld(),ud(),tl=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(1!==e[0].dataType&&10!==e[0].dataType)throw new Error("Input type must be float or float16.");if(e.length>=2){let t=2*e[0].dims.length===e[1].dims[0];if(4===e.length&&(t=2*e[3].dims[0]===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},nl=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`\\n            k = i32(${e.indicesGet("indices",s)}) - ${Rn("uniforms.pads",s,n)};\\n            if (k < 0) {\\n              break;\\n            }\\n            if (k >= i32(${Rn("uniforms.x_shape",s,t)})) {\\n              break;\\n            }\\n            offset += k * i32(${Rn("uniforms.x_strides",s,t)});\\n        `;return`\\n          value = ${e.type.value}(uniforms.constant_value);\\n          for (var i = 0; i < 1; i++) {\\n            var offset = 0;\\n            var k = 0;\\n            ${r}\\n            value = x[offset];\\n          }\\n      `},rl=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`\\n                k = i32(${e.indicesGet("indices",s)}) - ${Rn("uniforms.pads",s,n)};\\n                if (k < 0) {\\n                  k = -k;\\n                }\\n                {\\n                  let _2n_1 = 2 * (i32(${Rn("uniforms.x_shape",s,t)}) - 1);\\n                  k = k % _2n_1;\\n                  if(k >= i32(${Rn("uniforms.x_shape",s,t)})) {\\n                    k = _2n_1 - k;\\n                  }\\n                }\\n                offset += k * i32(${Rn("uniforms.x_strides",s,t)});\\n            `;return`\\n              var offset = 0;\\n              var k = 0;\\n              ${r}\\n              value = x[offset];\\n          `},sl=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`\\n                k = i32(${e.indicesGet("indices",s)}) - ${Rn("uniforms.pads",s,n)};\\n                if (k < 0) {\\n                  k = 0;\\n                }\\n                if (k >= i32(${Rn("uniforms.x_shape",s,t)})) {\\n                  k = i32(${Rn("uniforms.x_shape",s,t)}) - 1;\\n                }\\n                offset += k * i32(${Rn("uniforms.x_strides",s,t)});\\n            `;return`\\n              var offset = 0;\\n              var k = 0;\\n              ${r}\\n              value = x[offset];\\n          `},il=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`\\n                k = i32(${e.indicesGet("indices",s)}) - ${Rn("uniforms.pads",s,n)};\\n                if (k < 0)  {\\n                  k += i32(${Rn("uniforms.x_shape",s,t)}]);\\n                }\\n                if (k >= i32(${Rn("uniforms.x_shape",s,t)})) {\\n                  k -= i32(${Rn("uniforms.x_shape",s,t)});\\n                }\\n                offset += k * i32(${Rn("uniforms.x_strides",s,t)});\\n            `;return`\\n              var offset = 0;\\n              var k = 0;\\n              ${r}\\n              value = x[offset];\\n          `},al=(e,t,n)=>{switch(n.mode){case 0:return nl(e,t,n.pads.length);case 1:return rl(e,t,n.pads.length);case 2:return sl(e,t,n.pads.length);case 3:return il(e,t,n.pads.length);default:throw new Error("Invalid mode")}},ol=(e,t)=>{let n=$n.padShape(e[0].dims.slice(),t.pads),r=e[0].dims,s=[{type:12,data:$n.size(n)},{type:6,data:t.pads}],i=e.length>=3&&e[2].data;0===t.mode&&s.push({type:i?e[2].dataType:1,data:t.value}),s.push(...Mn(e[0].dims,n));return{name:"Pad",shaderCache:{hint:`${t.mode}${i}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil($n.size(n)/64)},programUniforms:s}),getShaderSource:s=>{let a=Fn("output",e[0].dataType,n.length),o=Ln("x",e[0].dataType,r.length),l=o.type.value,u=al(a,r.length,t),d=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:t.pads.length}];return 0===t.mode&&d.push({name:"constant_value",type:i?l:"f32"}),`\\n            ${s.registerUniforms(d).declareVariables(o,a)}\\n            ${s.mainStart()}\\n            ${s.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n\\n            let indices = ${a.offsetToIndices("global_idx")};\\n\\n            var value = ${l}(0);\\n            ${u}\\n            output[global_idx] = value;\\n        }`}}},ll=(e,t)=>{if(e.length>1){let n=e[1].getBigInt64Array(),r=e.length>=3&&e[2].data?10===e[2].dataType?e[2].getUint16Array()[0]:e[2].getFloat32Array()[0]:0,s=e[0].dims.length,i=new Int32Array(2*s).fill(0);if(e.length>=4){let t=e[3].getBigInt64Array();for(let e=0;e<t.length;e++)i[Number(t[e])]=Number(n[e]),i[Number(t[e])+s]=Number(n[e+t.length])}else n.forEach(((e,t)=>i[Number(t)]=Number(e)));let a=[];return i.forEach((e=>a.push(e))),{mode:t.mode,value:r,pads:a}}return t},ul=(e,t)=>{tl(e.inputs);let n=ll(e.inputs,t);e.compute(ol(e.inputs,n),{inputs:[0]})}})),Yd=qe((()=>{dt(),td(),ld(),ud(),dl=e=>{if(pe.webgpu.validateInputContent&&(!e||1!==e.length))throw new Error("Pool ops requires 1 input.")},cl=(e,t,n)=>{let r="NHWC"===t.format,s=e.dims.slice();r&&s.splice(1,0,s.pop());let i=Object.hasOwnProperty.call(t,"dilations"),a=t.kernelShape.slice(),o=t.strides.slice(),l=i?t.dilations.slice():[],u=t.pads.slice();kn.adjustPoolAttributes(n,s,a,o,l,u);let d=kn.computePoolOutputShape(n,s,o,l,a,u,t.autoPad),c=Object.assign({},t);i?Object.assign(c,{kernelShape:a,strides:o,pads:u,dilations:l,cacheKey:t.cacheKey}):Object.assign(c,{kernelShape:a,strides:o,pads:u,cacheKey:t.cacheKey});let p=d.slice();return p.push(p.splice(1,1)[0]),[c,r?p:d]},pl=(e,t)=>{let n="NHWC"===t.format,r=[{type:12,data:$n.size(e)},{type:12,data:$n.size(t.kernelShape)}],s=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let e=t.kernelShape[t.kernelShape.length-1],n=t.strides[t.strides.length-1],i=t.pads[t.pads.length/2-1],a=t.pads[t.pads.length-1],o=!!(i+a);r.push({type:12,data:e},{type:12,data:n},{type:12,data:i},{type:12,data:a}),s.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let l=!1;if(2===t.kernelShape.length){let e=t.kernelShape[t.kernelShape.length-2],n=t.strides[t.strides.length-2],i=t.pads[t.pads.length/2-2],a=t.pads[t.pads.length-2];l=!!(i+a),r.push({type:12,data:e},{type:12,data:n},{type:12,data:i},{type:12,data:a}),s.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[r,s,!0,o,l]}{if(n)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let e=$n.computeStrides(t.kernelShape);return r.push({type:12,data:e},{type:12,data:t.pads},{type:12,data:t.strides}),s.push({name:"kernelStrides",type:"u32",length:e.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length}),[r,s,!!t.pads.reduce(((e,t)=>e+t)),!1,!1]}},hl=(e,t,n,r,s,i,a,o,l,u,d,c)=>{let p="NHWC"===s.format,h=t.type.value,f=Fn("output",t.type.tensor,r);if(s.kernelShape.length<=2){let r="",u="",m="",_=n-(p?2:1);if(r=d?`\\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\\n                  xIndices[${_}] = indices[${_}] * uniforms.sw - uniforms.pwStart + i;\\n                  if (xIndices[${_}] < 0 || xIndices[${_}]\\n                      >= uniforms.x_shape[${_}]) {\\n                    pad++;\\n                    continue;\\n                  }\\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\\n                  ${i}\\n                }`:`\\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\\n                  xIndices[${_}] = indices[${_}] * uniforms.sw - uniforms.pwStart + i;\\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\\n                  ${i}\\n                }`,2===s.kernelShape.length){let e=n-(p?3:2);u=c?`\\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\\n                  xIndices[${e}] = indices[${e}] * uniforms.sh - uniforms.phStart + j;\\n                  if (xIndices[${e}] < 0 || xIndices[${e}] >= uniforms.x_shape[${e}]) {\\n                    pad += i32(uniforms.kw);\\n                    continue;\\n                  }\\n              `:`\\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\\n                  xIndices[${e}] = indices[${e}] * uniforms.sh - uniforms.phStart + j;\\n                `,m="\\n              }\\n            "}return`\\n            ${e.registerUniforms(l).declareVariables(t,f)}\\n\\n            ${e.mainStart()}\\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n\\n              let indices = ${f.offsetToIndices("global_idx")};\\n              var xIndices = ${f.offsetToIndices("global_idx")};\\n\\n              var value = ${h}(${o});\\n              var pad = 0;\\n              ${u}\\n              ${r}\\n              ${m}\\n              ${a}\\n\\n              output[global_idx] = value;\\n            }`}{if(p)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let r=s.kernelShape.length,d=s.pads.length,c="";return c=u?`\\n                if (xIndices[j] >= uniforms.x_shape[j]) {\\n                  pad++;\\n                  isPad = true;\\n                  break;\\n                }\\n              }\\n              if (!isPad) {\\n                let x_val = x[${t.indicesToOffset("xIndices")}];\\n                ${i}\\n              }`:`\\n              }\\n              let x_val = x[${t.indicesToOffset("xIndices")}];\\n              ${i}\\n            `,`\\n            ${e.registerUniforms(l).declareVariables(t,f)}\\n\\n            ${e.mainStart()}\\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n              let indices = ${f.offsetToIndices("global_idx")};\\n              var xIndices = ${f.offsetToIndices("global_idx")};\\n\\n              var offsets: array<u32, ${r}>;\\n\\n              var value = ${h}(${o});\\n              var pad = 0;\\n              var isPad = false;\\n\\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\\n                var offset = i;\\n                for (var j = 0u; j < ${r-1}u; j++) {\\n                  offsets[j] = offset / ${Rn("uniforms.kernelStrides","j",r)};\\n                  offset -= offsets[j] * ${Rn("uniforms.kernelStrides","j",r)};\\n                }\\n                offsets[${r-1}] = offset;\\n\\n                isPad = false;\\n                for (var j = ${n-r}u; j < ${n}u; j++) {\\n                  xIndices[j] = indices[j] * ${Rn("uniforms.strides",`j - ${n-r}u`,r)}\\n                    + offsets[j - ${n-r}u] - ${Rn("uniforms.pads","j - 2u",d)};\\n                  ${c}\\n              }\\n              ${a}\\n\\n              output[global_idx] = value;\\n            }`}},fl=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,ml=e=>`${fl(e)};${e.countIncludePad}`,_l=e=>`${fl(e)};${e.storageOrder};${e.dilations}`,gl=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),wl=(e,t,n,r)=>{let[s,i]=cl(t,r,n),a=Ln("x",t.dataType,t.dims.length),o=a.type.value,l="";s.countIncludePad?l+=`value /= ${o}(uniforms.kernelSize);`:l+=`value /= ${o}(i32(uniforms.kernelSize) - pad);`;let[u,d,c,p,h]=pl(i,s);u.push(...Mn(t.dims,i));return{name:e,shaderCache:{hint:`${r.cacheKey};${c};${p};${h}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil($n.size(i)/64)},programUniforms:u}),getShaderSource:e=>hl(e,a,t.dims.length,i.length,s,"value += x_val;",l,0,d,c,p,h)}},yl=e=>{let t=0!==e.count_include_pad,n=gl(e);if(0!==n.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let r={countIncludePad:t,...n,cacheKey:""};return{...r,cacheKey:ml(r)}},bl=(e,t)=>{dl(e.inputs),e.compute(wl("AveragePool",e.inputs[0],!1,t))},xl={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},vl=e=>{let t=e.format;return{format:t,...xl,cacheKey:t}},$l=(e,t)=>{dl(e.inputs),e.compute(wl("GlobalAveragePool",e.inputs[0],!0,t))},kl=(e,t,n,r)=>{let[s,i]=cl(t,r,n),a=Ln("x",t.dataType,t.dims.length),[o,l,u,d,c]=pl(i,s);return o.push(...Mn(t.dims,i)),{name:e,shaderCache:{hint:`${r.cacheKey};${u};${d};${c}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil($n.size(i)/64)},programUniforms:o}),getShaderSource:e=>hl(e,a,t.dims.length,i.length,s,"\\n      value = max(x_val, value);\\n    ","",10===t.dataType?-65504:-1e5,l,u,d,c)}},El=(e,t)=>{dl(e.inputs),e.compute(kl("MaxPool",e.inputs[0],!1,t))},Sl=e=>{let t=e.storage_order,n=e.dilations,r=gl(e);if(0!==t)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==r.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let s={storageOrder:t,dilations:n,...r,cacheKey:""};return{...s,cacheKey:_l(s)}},zl=e=>{let t=e.format;return{format:t,...xl,cacheKey:t}},Cl=(e,t)=>{dl(e.inputs),e.compute(kl("GlobalMaxPool",e.inputs[0],!0,t))}})),Zd=qe((()=>{td(),ld(),od(),ud(),Tl=(e,t)=>{if(e.length<2||e.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(3===e.length&&e[1].dims===e[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(6===e[0].dataType&&e.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(0!==e[1].dims.length&&1!==e[1].dims.length&&e[1].dims.length!==e[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(e.length>2){if(e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(e[1].dims.length!==e[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!e[1].dims.map(((t,n)=>t===e[2].dims[n])).reduce(((e,t)=>e&&t),!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(t.blockSize>0){if(0===e[1].dims.length||1===e[1].dims.length&&1===e[1].dims[0])throw new Error("blockSize must be set only for block quantization.");if(!e[1].dims.map(((n,r)=>r===t.axis||n===e[0].dims[r])).reduce(((e,t)=>e&&t),!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(e[1].dims.length!==e[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let n=e[0].dims[t.axis],r=e[1].dims[t.axis];if(t.blockSize<Math.ceil(n/r)||t.blockSize>Math.ceil(n/(r-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},Al=(e,t)=>{let n=$n.normalizeAxis(t.axis,e[0].dims.length),r=e[0].dataType,s=3===r,i=e[0].dims,a=e[1].dataType,o=$n.size(i),l=3===r||2===r,u=l?[Math.ceil($n.size(e[0].dims)/4)]:e[0].dims,d=e[1].dims,c=e.length>2?e[2]:void 0,p=c?l?[Math.ceil($n.size(c.dims)/4)]:c.dims:void 0,h=0===d.length||1===d.length&&1===d[0],f=!1===h&&1===d.length,m=On(o),_=h&&(!l||4===m),g=_?m:1,w=_&&!l?m:1,y=Ln("input",l?12:r,u.length,w),b=Ln("scale",a,d.length),x=c?Ln("zero_point",l?12:r,p.length):void 0,v=Fn("output",a,i.length,g),$=[y,b];x&&$.push(x);let k=[u,d];c&&k.push(p);let E=[{type:12,data:o/g},{type:12,data:n},{type:12,data:t.blockSize},...Mn(...k,i)];return{name:"DequantizeLinear",shaderCache:{hint:t.cacheKey,inputDependencies:x?["rank","rank","rank"]:["rank","rank"]},getShaderSource:e=>`\\n      ${e.registerUniforms([{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}]).declareVariables(...$,v)}\\n      ${e.mainStart()}\\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n          let output_indices = ${v.offsetToIndices("global_idx")};\\n\\n          // Set input x\\n          ${l?`\\n            let input = ${y.getByOffset("global_idx / 4")};\\n            let x_vec = ${s?"unpack4xI8(input)":"unpack4xU8(input)"};\\n            let x_value = ${1===g?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${y.getByOffset("global_idx")};`};\\n\\n          // Set scale input\\n          ${h?`let scale_value= ${b.getByOffset("0")}`:f?`\\n            let scale_index = ${v.indicesGet("output_indices","uniforms.axis")};\\n            let scale_value= ${b.getByOffset("scale_index")};`:`\\n            var scale_indices: ${b.type.indices} = output_indices;\\n            let index = ${b.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;\\n            ${b.indicesSet("scale_indices","uniforms.axis","index")};\\n            let scale_value= ${b.getByIndices("scale_indices")};`};\\n\\n          // Set zero-point input\\n          ${x?h?l?`\\n                let zero_point_input = ${x.getByOffset("0")};\\n                let zero_point_vec =  ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\\n                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${x.getByOffset("0")}`:f?l?`\\n                let zero_point_index = ${v.indicesGet("output_indices","uniforms.axis")};\\n                let zero_point_input = ${x.getByOffset("zero_point_index / 4")};\\n                let zero_point_vec =  ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\\n                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`\\n                let zero_point_index = ${v.indicesGet("output_indices","uniforms.axis")};\\n                let zero_point_value = ${x.getByOffset("zero_point_index")};`:l?`\\n                let zero_point_offset = ${b.indicesToOffset("scale_indices")};\\n                let zero_point_input = ${x.getByOffset("zero_point_offset / 4")};\\n                let zero_point_vec = ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\\n                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${x.getByIndices("scale_indices")};`:`let zero_point_value = ${l?s?"i32":"u32":y.type.value}(0);`};\\n      // Compute and write output\\n      ${v.setByOffset("global_idx",`${v.type.value}(x_value - zero_point_value) * scale_value`)};\\n      }`,getRunData:()=>({outputs:[{dims:i,dataType:a}],dispatchGroup:{x:Math.ceil(o/g/64),y:1,z:1},programUniforms:E})}},Il=(e,t)=>{Tl(e.inputs,t),e.compute(Al(e.inputs,t))},Ml=e=>bn({axis:e.axis,blockSize:e.blockSize})})),Jd=qe((()=>{dt(),td(),ud(),Ol=(e,t,n)=>{if(e===t||e<t&&n<0||e>t&&n>0)throw new Error("Range these inputs\' contents are invalid.")},Bl=(e,t,n,r)=>{let s=Math.abs(Math.ceil((t-e)/n)),i=[s],a=s,o=[{type:12,data:a},{type:r,data:e},{type:r,data:n},...Mn(i)];return{name:"Range",shaderCache:{hint:`${r}`},getShaderSource:e=>{let t=Fn("output",r,i.length),n=t.type.value,s=[{name:"outputSize",type:"u32"},{name:"start",type:n},{name:"delta",type:n}];return`\\n        ${e.registerUniforms(s).declareVariables(t)}\\n        ${e.mainStart()}\\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n        output[global_idx] = uniforms.start + ${n}(global_idx) * uniforms.delta;\\n      }`},getRunData:()=>({outputs:[{dims:i,dataType:r}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:o})}},Nl=e=>{let t=0,n=0,r=0;6===e.inputs[0].dataType?(t=e.inputs[0].getInt32Array()[0],n=e.inputs[1].getInt32Array()[0],r=e.inputs[2].getInt32Array()[0]):1===e.inputs[0].dataType&&(t=e.inputs[0].getFloat32Array()[0],n=e.inputs[1].getFloat32Array()[0],r=e.inputs[2].getFloat32Array()[0]),pe.webgpu.validateInputContent&&Ol(t,n,r),e.compute(Bl(t,n,r,e.inputs[0].dataType),{inputs:[]})}})),ec=qe((()=>{td(),ld(),od(),ud(),Pl=(e,t,n,r)=>{if("none"!==e&&"i32"!==r&&"u32"!==r&&"f32"!==r)throw new Error(`Input ${r} is not supported with reduction ${e}.`);let s="{\\n                var oldValue = 0;\\n                loop {\\n                  let newValueF32 =",i=`;\\n                  let newValue = bitcast<i32>(newValueF32);\\n                  let res = atomicCompareExchangeWeak(&${t}, oldValue, newValue);\\n                  if res.exchanged {\\n                    break;\\n                  }\\n                  oldValue = res.old_value;\\n                }\\n              }`;switch(e){case"none":return`${t}=${n};`;case"add":return"i32"===r||"u32"===r?`atomicAdd(&${t}, bitcast<${r}>(${n}));`:`\\n              ${s}bitcast<${r}>(oldValue) + (${n})${i}`;case"max":return"i32"===r||"u32"===r?`atomicMax(&${t}, bitcast<${r}>(${n}));`:`\\n                ${s}max(bitcast<f32>(oldValue), (${n}))${i}`;case"min":return"i32"===r||"u32"===r?`atomicMin(&${t}, bitcast<${r}>(${n}));`:`${s}min(bitcast<${r}>(oldValue), (${n}))${i}`;case"mul":return`${s}(bitcast<${r}>(oldValue) * (${n}))${i}`;default:throw new Error(`Reduction ${e} is not supported.`)}},Rl=(e,t)=>{let n=e[0].dims,r=e[1].dims,s=n,i=Math.ceil($n.size(r)/1),a=r[r.length-1],o=$n.sizeFromDimension(n,a),l=[{type:12,data:i},{type:12,data:a},{type:12,data:o},...Mn(e[1].dims,e[2].dims,s)];return{name:"ScatterND",shaderCache:{hint:`${t.cacheKey}_${t.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:l}),getShaderSource:n=>{let r=Ln("indices",e[1].dataType,e[1].dims.length),i=Ln("updates",e[2].dataType,e[2].dims.length,1),a="none"!==t.reduction&&""!==t.reduction?Un("output",e[0].dataType,s.length):Fn("output",e[0].dataType,s.length,1);return`\\n      ${n.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(r,i,a)}\\n      ${n.mainStart()}\\n        ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n  var data_offset = 0u;\\n  let indices_start = uniforms.last_index_dimension * global_idx;\\n  let indices_end = indices_start + uniforms.last_index_dimension;\\n  for (var i = indices_start; i < indices_end; i++) {\\n    var index = i32(indices[i].x);\\n    ${1===e[0].dims.length?"\\n    let element_count_dim = uniforms.output_strides;\\n    let dim_value = uniforms.output_shape;":"\\n    let element_count_dim = uniforms.output_strides[i - indices_start];\\n    let dim_value = uniforms.output_shape[i - indices_start + uniforms.last_index_dimension];"}\\n    if (index >= 0) {\\n      if (index >= i32(dim_value)) {\\n        index = i32(dim_value - 1);\\n      }\\n    } else {\\n      if (index < -i32(dim_value)) {\\n        index = 0;\\n      } else {\\n        index += i32(dim_value);\\n      }\\n    }\\n    data_offset += u32((u32(index) * element_count_dim));\\n  }\\n\\n  for (var i = 0u; i < uniforms.num_updates_elements; i++) {\\n    let value = updates[uniforms.num_updates_elements * global_idx + i];\\n    ${Pl(t.reduction,"output[data_offset + i]","value",a.type.value)}\\n  }\\n\\n      }`}}},Dl=e=>bn({reduction:e.reduction}),Ll=(e,t)=>{e.compute(Rl(e.inputs,t),{inputs:[e.inputs[1],e.inputs[2]],outputs:[]})}})),tc=qe((()=>{td(),ld(),od(),ud(),Fl=(e,t)=>{if(e.every((e=>e>0||(()=>{throw new Error("Resize requires scales input values to be positive")}))),e.length>0)if("linear"===t.mode){if(!(2===e.length||3===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]||5===e.length&&1===e[0]&&1===e[1]))throw new Error("For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1")}else if("cubic"===t.mode&&!(2===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")},Ul=(e,t,n)=>{t.every((e=>e>=0&&e<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")})));let r=new Array(n).fill(1);return t.forEach(((t,n)=>r[t]=e[n])),r},ql=(e,t,n,r,s,i)=>{let[a,o,l]=n>10?[1,2,3]:[-1,e.length>1?1:-1,-1],u=e[0].dims.length;if(a>0&&e.length>a&&e[a].dims.length>0)e[a].getFloat32Array().forEach((e=>i.push(e)));else if("tf_crop_and_resize"===t.coordinateTransformMode)throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(o>0&&e.length>o&&1===e[o].dims.length&&e[o].dims[0]>0){if(e[o].getFloat32Array().forEach((e=>r.push(e))),0!==r.length&&r.length!==u&&n>=18&&r.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Fl(r,t),t.axes.length>0&&Ul(r,t.axes,u).forEach(((e,t)=>r[t]=e))}if(l>0&&e.length>l&&1===e[l].dims.length&&e[l].dims[0]>0&&(e[l].getBigInt64Array().forEach((e=>s.push(Number(e)))),0!==s.length&&s.length!==u&&n>=18&&s.length!==t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(0!==r.length&&r.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(0!==s.length&&s.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof r<"u"&&typeof s<"u"&&r.length>0&&s.length>u)throw new Error("Resize requires only of scales or sizes to be specified")},Vl=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case"asymmetric":return`return ${t}(xResized) / ${t}(xScale);`;case"pytorch_half_pixel":return`if (lengthResized > 1) {\\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\\n                  } else {\\n                    return 0.0;\\n                  }`;case"tf_half_pixel_for_nn":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case"align_corners":return`if (lengthResized == 1) {\\n                    return 0.0;\\n                  } else {\\n                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating\\n                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\\n                    // offset-by-one error later in floor().\\n                    let whole = ${t}(xResized * (lengthOriginal - 1) / (lengthResized - 1));\\n                    let fract =\\n                        ${t}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${t}(lengthResized - 1);\\n                    return whole + fract;\\n                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {\\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\\n                        ${t}(lengthResized - 1);\\n                  } else {\\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\\n                  }`;case"half_pixel_symmetric":return`const outputWidth = ${t}xScale * ${t}(lengthResized);\\n                  const adjustment = ${t}(lengthResized) / outputWidth;\\n                  const center = ${t}(lengthOriginal) / 2;\\n                  const offset = center * (1 - adjustment);\\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case"half_pixel":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",Wl=(e,t,n)=>`fn getNearestPixelFromOriginal(xOriginal: ${n}, isDownSample: bool) -> ${n} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",jl=(e,t,n)=>{let r=new Array(n).fill(0).concat(new Array(n).fill(1)),s=0===e.length?r:e.slice();return t.length>0?(t.forEach(((e,i)=>{r[e]=s[i],r[i+n]=s[t.length+i]})),r):s},Gl=(e,t,n,r)=>{let s=[];if(n.length>0)if(r.length>0){if(e.forEach((e=>s.push(e))),Math.max(...r)>e.length)throw new Error("axes is out of bound");r.forEach(((e,t)=>s[e]=n[t]))}else n.forEach((e=>s.push(e)));else{if(0===t.length)throw new Error("Resize requires either scales or sizes.");s=e.map(((e,n)=>Math.round(e*t[n])))}return s},Hl=(e,t,n)=>{let r=(()=>{switch(n.keepAspectRatioPolicy){case"not_larger":return n.axes.length>0?Math.min(...n.axes.map((e=>t[e])),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return n.axes.length>0?Math.max(...n.axes.map((e=>t[e])),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${n.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let s=e.slice();return n.axes.length>0?(n.axes.forEach((e=>t[e]=r)),n.axes.forEach((n=>s[n]=Math.round(e[n]*t[n])))):(t.fill(r,0,t.length),s.forEach(((e,n)=>s[n]=Math.round(e*t[n])))),s},Kl=(e,t,n,r,s)=>`\\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${n.length}> {\\n      var original_indices: array<${e.type.value}, ${n.length}>;\\n      for (var i:u32 = 0; i < ${n.length}; i++) {\\n        var output_index = ${e.indicesGet("output_indices","i")};\\n        var scale = ${Rn("uniforms.scales","i",r)};\\n        var roi_low = ${Rn("uniforms.roi","i",s)};\\n        var roi_hi = ${Rn("uniforms.roi",`i + ${t.length}`,s)};\\n        if (scale == 1.0) {\\n          original_indices[i] = ${e.type.value}(output_index);\\n        } else {\\n          var input_shape_i = ${Rn("uniforms.input_shape","i",t.length)};\\n          var output_shape_i = ${Rn("uniforms.output_shape","i",n.length)};\\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\\n                                                                           input_shape_i, roi_low, roi_hi);\\n        }\\n      }\\n      return original_indices;\\n    }`,Xl=(e,t,n,r,s,i,a)=>`\\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\\n      var input_indices: ${e.type.indices};\\n      for (var i:u32 = 0; i < ${r.length}; i++) {\\n        var output_index = ${t.indicesGet("output_indices","i")};\\n        var input_index: u32;\\n        var scale = ${Rn("uniforms.scales","i",s)};\\n        if (scale == 1.0) {\\n          input_index = output_index;\\n        } else {\\n          var roi_low = ${Rn("uniforms.roi","i",i)};\\n          var roi_hi = ${Rn("uniforms.roi",`i + ${n.length}`,i)};\\n          var input_shape_i = ${Rn("uniforms.input_shape","i",n.length)};\\n          var output_shape_i = ${Rn("uniforms.output_shape","i",r.length)};\\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\\n                                                                        input_shape_i, roi_low, roi_hi);\\n          if (!${a} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\\n            if (original_idx < 0) {\\n              input_index = 0;\\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\\n              input_index = input_shape_i - 1;\\n            } else {\\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\\n            }\\n          } else {\\n            input_index = u32(original_idx);\\n          }\\n        }\\n        ${e.indicesSet("input_indices","i"," input_index")}\\n      }\\n      return input_indices;\\n    }`,Ql=(e,t)=>`\\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\\n      for (var i:u32 = 0; i < ${t.length}; i++) {\\n        var input_index = ${e.indicesGet("input_indices","i")};\\n        if (input_index < 0 || input_index >= ${Rn("uniforms.input_shape","i",t.length)}) {\\n          return false;\\n        }\\n      }\\n      return true;\\n    }`,Yl=(e,t,n,r)=>e.rank>r?`\\n    ${e.indicesSet("input_indices",t,"channel")};\\n    ${e.indicesSet("input_indices",n,"batch")};\\n`:"",Zl=(e,t,n,r,s)=>{let[i,a,o,l]=2===n.length?[-1,0,1,-1]:[0,2,3,1],u=e.type.value;return`\\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${u} {\\n      var input_indices: ${e.type.indices};\\n      ${e.indicesSet("input_indices",a,`max(0, min(row, ${n[a]} - 1))`)};\\n      ${e.indicesSet("input_indices",o,`max(0, min(col, ${n[o]} - 1))`)};\\n      ${Yl(e,l,i,2)}\\n      return ${e.getByIndices("input_indices")};\\n    }\\n\\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${u} {\\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\\n      var row:${u} = originalIndices[${a}];\\n      var col:${u} = originalIndices[${o}];\\n      ${r?`if (row < 0 || row > (${n[a]} - 1) || col < 0 || col > (${n[o]} - 1)) {\\n        return ${s};\\n      }`:""};\\n      row = max(0, min(row, ${n[a]} - 1));\\n      col = max(0, min(col, ${n[o]} - 1));\\n      var row1: u32 = u32(row);\\n      var col1: u32 = u32(col);\\n      var row2: u32 = u32(row + 1);\\n      var col2: u32 = u32(col + 1);\\n      var channel: u32 = ${n.length>2?`u32(originalIndices[${l}])`:"0"};\\n      var batch: u32 =  ${n.length>2?`u32(originalIndices[${i}])`:"0"};\\n      var x11: ${u} = getInputValue(batch, channel, row1, col1);\\n      var x12: ${u} = getInputValue(batch, channel, row1, col2);\\n      var x21: ${u} = getInputValue(batch, channel, row2, col1);\\n      var x22: ${u} = getInputValue(batch, channel, row2, col2);\\n      var dx1: ${u} = abs(row - ${u}(row1));\\n      var dx2: ${u} = abs(${u}(row2) - row);\\n      var dy1: ${u} = abs(col - ${u}(col1));\\n      var dy2: ${u} = abs(${u}(col2) - col);\\n      if (row1 == row2) {\\n        dx1 = 0.5;\\n        dx2 = 0.5;\\n      }\\n      if (col1 == col2) {\\n        dy1 = 0.5;\\n        dy2 = 0.5;\\n      }\\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\\n    }`},Jl=(e,t,n,r,s,i,a,o,l,u)=>{let d=2===n.length,[c,p]=d?[0,1]:[2,3],h=e.type.value,f=a=>{let d=a===c?"row":"col";return`\\n      fn ${d}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${h} {\\n        var output_index = ${t.indicesGet("output_indices",a)};\\n        var originalIdx: ${h} = getOriginalCoordinateFromResizedCoordinate(output_index, ${s[a]},\\n        ${r[a]}, ${n[a]}, ${i[a]}, ${i[a]} + ${n.length});\\n        var fractOriginalIdx: ${h} = originalIdx - floor(originalIdx);\\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\\n\\n        if (${o} && (originalIdx < 0 || originalIdx > (${n[a]} - 1))) {\\n          return ${l};\\n        }\\n        var data: array<${h}, 4> = array<${h}, 4>(0.0, 0.0, 0.0, 0.0);\\n        for (var i: i32 = -1; i < 3; i++) {\\n          var ${d}: ${h} = originalIdx + ${h}(i);\\n          if (${d} < 0 || ${d} >= ${n[a]}) {\\n            ${u?"coefs[i + 1] = 0.0;\\n                        continue;":o?`return ${l};`:`${d} = max(0, min(${d}, ${n[a]} - 1));`};\\n          }\\n        var input_indices_copy: ${e.type.indices} = input_indices;\\n          ${e.indicesSet("input_indices_copy",a,`u32(${d})`)};\\n          data[i + 1] = ${a===c?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};\\n        }\\n        return cubicInterpolation1D(data, coefs);\\n      }`};return`\\n    ${f(c)};\\n    ${f(p)};\\n  fn getCubicInterpolationCoefs(s: ${h}) -> array<${h}, 4> {\\n    var absS = abs(s);\\n    var coeffs: array<${h}, 4> = array<${h}, 4>(0.0, 0.0, 0.0, 0.0);\\n    var oneMinusAbsS: ${h} = 1.0 - absS;\\n    var twoMinusAbsS: ${h} = 2.0 - absS;\\n    var onePlusAbsS: ${h} = 1.0 + absS;\\n    coeffs[0] = ((${a} * onePlusAbsS - 5 * ${a}) * onePlusAbsS + 8 * ${a}) * onePlusAbsS - 4 * ${a};\\n    coeffs[1] = ((${a} + 2) * absS - (${a} + 3)) * absS * absS + 1;\\n    coeffs[2] = ((${a} + 2) * oneMinusAbsS - (${a} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\\n    coeffs[3] = ((${a} * twoMinusAbsS - 5 * ${a}) * twoMinusAbsS + 8 * ${a}) * twoMinusAbsS - 4 * ${a};\\n    return coeffs;\\n  }\\n\\n  fn cubicInterpolation1D(x: array<${h}, 4>, coefs: array<${h}, 4>) -> ${h} {\\n    var coefsSum: ${h} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\\n  }\\n\\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${h} {\\n    var input_indices: ${e.type.indices} = output_indices;\\n    return colCubicInterpolation(input_indices, output_indices);\\n  }\\n    `},eu=(e,t,n,r,s)=>{let[i,a,o,l,u]=3===n.length?[-1,0,1,2,-1]:[0,2,3,4,1],d=e.type.value;return`\\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${d} {\\n      var input_indices: ${e.type.indices};\\n      ${e.indicesSet("input_indices",a,`max(0, min(depth, ${n[a]} - 1))`)};\\n      ${e.indicesSet("input_indices",o,`max(0, min(height, ${n[o]} - 1))`)};\\n      ${e.indicesSet("input_indices",l,`max(0, min(width, ${n[l]} - 1))`)};\\n      ${Yl(e,u,i,3)}\\n      return ${e.getByIndices("input_indices")};\\n    }\\n\\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${d} {\\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\\n      var depth:${d} = originalIndices[${a}];\\n      var height:${d} = originalIndices[${o}];\\n      var width:${d} = originalIndices[${l}];\\n      ${r?`if (depth < 0 || depth > (${n[a]} - 1) || height < 0 || height > (${n[o]} - 1) || width < 0 || (width > ${n[l]} - 1)) {\\n      return ${s};\\n        }`:""};\\n\\n    depth = max(0, min(depth, ${n[a]} - 1));\\n      height = max(0, min(height, ${n[o]} - 1));\\n      width = max(0, min(width, ${n[l]} - 1));\\n      var depth1: u32 = u32(depth);\\n      var height1: u32 = u32(height);\\n      var width1: u32 = u32(width);\\n      var depth2: u32 = u32(depth + 1);\\n      var height2: u32 = u32(height + 1);\\n      var width2: u32 = u32(width + 1);\\n      var channel: u32 = ${n.length>3?`u32(originalIndices[${u}])`:"0"};\\n      var batch: u32 =  ${n.length>3?`u32(originalIndices[${i}])`:"0"};\\n\\n      var x111: ${d} = getInputValue(batch, channel, depth1, height1, width1);\\n      var x112: ${d} = getInputValue(batch, channel, depth1, height1, width2);\\n      var x121: ${d} = getInputValue(batch, channel, depth1, height2, width1);\\n      var x122: ${d} = getInputValue(batch, channel, depth1, height2, width2);\\n      var x211: ${d} = getInputValue(batch, channel, depth2, height1, width1);\\n      var x212: ${d} = getInputValue(batch, channel, depth2, height1, width2);\\n      var x221: ${d} = getInputValue(batch, channel, depth2, height2, width1);\\n      var x222: ${d} = getInputValue(batch, channel, depth2, height2, width2);\\n      var dx1: ${d} = abs(depth - ${d}(depth1));\\n      var dx2: ${d} = abs(${d}(depth2) - depth);\\n      var dy1: ${d} = abs(height - ${d}(height1));\\n      var dy2: ${d} = abs(${d}(height2) - height);\\n      var dz1: ${d} = abs(width - ${d}(width1));\\n      var dz2: ${d} = abs(${d}(width2) - width);\\n      if (depth1 == depth2) {\\n        dx1 = 0.5;\\n        dx2 = 0.5;\\n      }\\n      if (height1 == height2) {\\n        dy1 = 0.5;\\n        dy2 = 0.5;\\n      }\\n      if (width1 == width2) {\\n        dz1 = 0.5;\\n        dz2 = 0.5;\\n      }\\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\\n    }`},tu=(e,t,n,r,s,i)=>{let a=e.dims,o=jl(i,t.axes,a.length),l=Gl(a,r,s,t.axes),u=r.slice();0===r.length&&(u=a.map(((e,t)=>0===e?1:l[t]/e)),"stretch"!==t.keepAspectRatioPolicy&&(l=Hl(a,u,t)));let d=Fn("output",e.dataType,l.length),c=Ln("input",e.dataType,a.length),p=$n.size(l),h=a.length===l.length&&a.every(((e,t)=>e===l[t])),f="tf_crop_and_resize"===t.coordinateTransformMode,m=t.extrapolationValue,_=c.type.value;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${n}|${u.length>0?u:""}|${s.length>0?s:""}|${o.length>0?o:""}|${h}|${a}`,inputDependencies:["rank"]},getShaderSource:e=>`\\n      ${h?"":`\\n      ${Vl(t.coordinateTransformMode,_)};\\n      ${(()=>{switch(t.mode){case"nearest":return`\\n              ${Ql(c,a)};\\n              ${Wl(t.nearestMode,n,_)};\\n              ${Xl(c,d,a,l,u.length,o.length,f)};\\n              `;case"linear":return`\\n              ${Kl(d,a,l,u.length,o.length)};\\n              ${(()=>{if(2===a.length||4===a.length)return`${Zl(c,d,a,f,m)}`;if(3===a.length||5===a.length)return`${eu(c,d,a,f,m)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};\\n            `;case"cubic":return`\\n            ${(()=>{if(2===a.length||4===a.length)return`${Jl(c,d,a,l,u,o,t.cubicCoeffA,f,t.extrapolationValue,t.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};\\n            `;default:throw Error("Invalid resize mode")}})()};\\n      `}\\n      ${e.registerUniform("output_size","u32").registerUniform("scales","f32",u.length).registerUniform("roi","f32",o.length).declareVariables(c,d)}\\n      ${e.mainStart()}\\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n        ${h?"output[global_idx] = input[global_idx];":`\\n        let output_indices = ${d.offsetToIndices("global_idx")};\\n        var input_indices: ${c.type.indices};\\n        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\\n                if (checkInputIndices(input_indices)) {\\n                  output[global_idx] = ${c.getByIndices("input_indices")};\\n                } else {\\n                  output[global_idx] = ${t.extrapolationValue};\\n                }`;case"linear":return`output[global_idx] = ${2===a.length||4===a.length?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\\n`}\\n      }`,getRunData:()=>({outputs:[{dims:l,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:[{type:12,data:p},{type:1,data:u},{type:1,data:o},...Mn(a,l)]})}},nu=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},ru=(e,t)=>{let n=[],r=[],s=[],i=nu(e);if(0!==t.antialias)throw Error("Only default value (0) for Antialias attribute is supported");ql(e.inputs,t,i,n,r,s),e.compute(tu(e.inputs[0],t,i,n,r,s),{inputs:[0]})},su=e=>{let t=e.antialias,n=e.axes,r=e.coordinateTransformMode,s=e.cubicCoeffA,i=0!==e.excludeOutside,a=e.extrapolationValue,o=e.keepAspectRatioPolicy,l=e.mode,u=""===e.nearestMode?"simple":e.nearestMode;return bn({antialias:t,axes:n,coordinateTransformMode:r,cubicCoeffA:s,excludeOutside:i,extrapolationValue:a,keepAspectRatioPolicy:o,mode:l,nearestMode:u})}})),nc=qe((()=>{td(),ld(),od(),ud(),iu=(e,t)=>{let[n,r,s,i]=e,{numHeads:a,rotaryEmbeddingDim:o}=t;if(3!==n.dims.length&&4!==n.dims.length)throw new Error(`Input \'x\' is expected to have 3 or 4 dimensions, got ${n.dims.length}`);if(!$n.areEqual(r.dims,[])&&!$n.areEqual(r.dims,[1])&&2!==r.dims.length)throw new Error(`Input \'position_ids\' is expected to have 0, 1, or 2 dimensions, got ${r.dims.length}`);if(2!==s.dims.length)throw new Error(`Input \'cos_cache\' is expected to have 2 dimensions, got ${s.dims.length}`);if(2!==i.dims.length)throw new Error(`Input \'sin_cache\' is expected to have 2 dimensions, got ${i.dims.length}`);if(!$n.areEqual(s.dims,i.dims))throw new Error("Inputs \'cos_cache\' and \'sin_cache\' are expected to have the same shape");if(o>0&&0===a)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let l=n.dims[0],u=n.dims[n.dims.length-2],d=s.dims[0],c=$n.sizeFromDimension(n.dims,1)/u,p=0===o?2*s.dims[1]:c/a;if(o>p)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(2===r.dims.length){if(l!==r.dims[0])throw new Error(`Input \'position_ids\' dimension 0 should be of size batch_size, got ${r.dims[0]}`);if(u!==r.dims[1])throw new Error(`Input \'position_ids\' dimension 1 should be of size sequence_length, got ${r.dims[1]}`)}if(p/2!==s.dims[1]&&o/2!==s.dims[1])throw new Error(`Input \'cos_cache\' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${s.dims[1]}`);if(u>d)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},au=(e,t)=>{let{interleaved:n,numHeads:r,rotaryEmbeddingDim:s,scale:i}=t,a=e[0].dims[0],o=$n.sizeFromDimension(e[0].dims,1),l=e[0].dims[e[0].dims.length-2],u=o/l,d=e[2].dims[1],c=0===s?2*d:u/r,p=new Array(a,l,u/c,c-d),h=$n.computeStrides(p),f=[{type:1,data:i},{type:12,data:p},{type:12,data:h},...3===e[0].dims.length?new Array({type:12,data:[o,u,c,1]}):[],...4===e[0].dims.length?new Array({type:12,data:[o,c,l*c,1]}):[],...Mn(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)];return{name:"RotaryEmbedding",shaderCache:{hint:bn({interleaved:n}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:t=>{let r=Ln("input",e[0].dataType,e[0].dims.length),s=Ln("position_ids",e[1].dataType,e[1].dims.length),i=Ln("cos_cache",e[2].dataType,e[2].dims.length),a=Ln("sin_cache",e[3].dataType,e[3].dims.length),o=Fn("output",e[0].dataType,e[0].dims.length);return t.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:p.length},{name:"global_strides",type:"u32",length:h.length},{name:"input_output_strides",type:"u32",length:h.length}]),`\\n        ${t.declareVariables(r,s,i,a,o)}\\n\\n        ${t.mainStart(Cn)}\\n          let half_rotary_emb_dim = uniforms.${i.name}_shape[1];\\n          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;\\n          let size = uniforms.global_shape[0] * uniforms.global_strides[0];\\n          ${t.guardAgainstOutOfBoundsWorkgroupSizes("size")}\\n\\n          if (bsnh[3] < half_rotary_emb_dim) {\\n            let position_ids_idx =\\n                ${s.broadcastedIndicesToOffset("bsnh.xy",Fn("",s.type.tensor,2))};\\n            let position_id =\\n                u32(${s.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);\\n            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${n});\\n            let j = i + select(half_rotary_emb_dim, 1, ${n});\\n            let re = ${r.getByOffset("i")} * ${i.get("position_id","bsnh[3]")} -\\n                ${r.getByOffset("j")} * ${a.get("position_id","bsnh[3]")};\\n            ${o.setByOffset("i","re")}\\n            let im = ${r.getByOffset("i")} * ${a.get("position_id","bsnh[3]")} +\\n                ${r.getByOffset("j")} * ${i.get("position_id","bsnh[3]")};\\n            ${o.setByOffset("j","im")}\\n          } else {\\n            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;\\n            ${o.setByOffset("k",r.getByOffset("k"))}\\n          }\\n        }`},getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil($n.size(p)/Cn)},programUniforms:f})}},ou=(e,t)=>{iu(e.inputs,t),e.compute(au(e.inputs,t))}})),rc=qe((()=>{td(),ld(),ud(),lu=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],n=e[1],r=e[2];if(t.dataType!==n.dataType||t.dataType!==r.dataType)throw new Error("All inputs must have the same data type");if(3!==t.dims.length&&2!==t.dims.length)throw new Error("Input must be 2D or 3D");if(3!==n.dims.length&&2!==n.dims.length)throw new Error("Skip must be 2D or 3D");let s=t.dims[t.dims.length-1],i=t.dims[t.dims.length-2];if(n.dims[n.dims.length-1]!==s)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==i)throw new Error("Skip must have the same sequence length as input");if(1!==r.dims.length)throw new Error("Gamma must be 1D");if(r.dims[r.dims.length-1]!==s)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let t=e[3];if(1!==t.dims.length)throw new Error("Beta must be 1D");if(t.dims[t.dims.length-1]!==s)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let t=e[4];if(1!==t.dims.length)throw new Error("Bias must be 1D");if(t.dims[t.dims.length-1]!==s)throw new Error("Bias must have the same hidden size as input")}},uu=(e,t,n,r)=>{let s=t.simplified,i=e[0].dims,a=$n.size(i),o=i,l=a,u=i.slice(-1)[0],d=r?i.slice(0,-1).concat(1):[],c=!s&&e.length>3,p=e.length>4,h=r&&n>1,f=r&&n>2,m=n>3,_=64,g=On(u),w=[{type:12,data:l},{type:12,data:g},{type:12,data:u},{type:1,data:t.epsilon}],y=[{dims:o,dataType:e[0].dataType}];return n>1&&y.push({dims:d,dataType:1}),n>2&&y.push({dims:d,dataType:1}),n>3&&y.push({dims:i,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${g};${h};${f};${m}`,inputDependencies:e.map(((e,t)=>"type"))},getShaderSource:t=>{let n=[Ln("x",e[0].dataType,e[0].dims,g),Ln("skip",e[1].dataType,e[1].dims,g),Ln("gamma",e[2].dataType,e[2].dims,g)];c&&n.push(Ln("beta",e[3].dataType,e[3].dims,g)),p&&n.push(Ln("bias",e[4].dataType,e[4].dims,g)),n.push(Fn("output",e[0].dataType,o,g)),h&&n.push(Fn("mean_output",1,d)),f&&n.push(Fn("inv_std_output",1,d)),m&&n.push(Fn("input_skip_bias_sum",e[0].dataType,o,g));let r=An(e[0].dataType),i=An(1,g);return`\\n\\n      ${t.registerUniforms([{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}]).declareVariables(...n)}\\n      var<workgroup> sum_shared : array<${i}, 64>;\\n      var<workgroup> sum_squared_shared : array<${i}, 64>;\\n\\n      ${t.mainStart([_,1,1])}\\n        let ix = local_id.x;\\n        let iy = global_id.x / 64;\\n\\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\\n        var stride = hidden_size_vectorized / 64;\\n        let offset = ix * stride + iy * hidden_size_vectorized;\\n        let offset1d = stride * ix;\\n        if (ix == 63) {\\n          stride = hidden_size_vectorized - stride * ix;\\n        }\\n        for (var i: u32 = 0; i < stride; i++) {\\n          let skip_value = skip[offset + i];\\n          let bias_value = ${p?"bias[offset1d + i]":r+"(0.0)"};\\n          let input_value = x[offset + i];\\n          let value = input_value + skip_value + bias_value;\\n          ${m?"input_skip_bias_sum[offset + i] = value;":""}\\n          output[offset + i] = value;\\n          let f32_value = ${Nn(r,g,"value")};\\n          sum_shared[ix] += f32_value;\\n          sum_squared_shared[ix] += f32_value * f32_value;\\n        }\\n        workgroupBarrier();\\n\\n        var reduce_size : u32 = 64;\\n        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {\\n          reduce_size = curr_size + (reduce_size & 1);\\n          if (ix < curr_size) {\\n            sum_shared[ix] += sum_shared[ix + reduce_size];\\n            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];\\n          }\\n          workgroupBarrier();\\n        }\\n\\n        let sum = sum_shared[0];\\n        let square_sum = sum_squared_shared[0];\\n        let mean = ${Pn("sum",g)} / f32(uniforms.hidden_size);\\n        let inv_std_dev = inverseSqrt(${Pn("square_sum",g)} / f32(uniforms.hidden_size) ${s?"":"- mean * mean"} + uniforms.epsilon);\\n        ${h?"mean_output[global_idx] = mean;":""}\\n        ${f?"inv_std_output[global_idx] = inv_std_dev;":""}\\n\\n        for (var i: u32 = 0; i < stride; i++) {\\n          output[offset + i] = (output[offset + i] ${s?"":`- ${r}(mean)`}) *\\n            ${r}(inv_std_dev) * gamma[offset1d + i]\\n            ${c?"+ beta[offset1d + i]":""};\\n        }\\n      }`},getRunData:()=>({outputs:y,dispatchGroup:{x:Math.ceil(l/u)},programUniforms:w})}},du=(e,t)=>{lu(e.inputs);let n=[0];e.outputCount>1&&n.push(-3),e.outputCount>2&&n.push(-3),e.outputCount>3&&n.push(3),e.compute(uu(e.inputs,t,e.outputCount,!1),{outputs:n})}})),sc=qe((()=>{td(),ld(),od(),ud(),cu=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(0!==t.axes.length){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach(((t,n)=>{if(6!==e[n+1].dataType&&7!==e[n+1].dataType)throw new Error(`Input ${n} must be an array of int32 or int64`)}))},pu=(e,t)=>{let n=[];if(e.length>t)if(7===e[t].dataType)e[t].getBigInt64Array().forEach((e=>n.push(Number(e))));else{if(6!==e[t].dataType)throw new Error(`Input ${t} must be an array of int32 or int64`);e[t].getInt32Array().forEach((e=>n.push(Number(e))))}return n},hu=(e,t)=>{if(e.length>1){let t=pu(e,1),n=pu(e,2),r=pu(e,3);return 0===r.length&&(r=[...Array(e[0].dims.length).keys()]),bn({starts:t,ends:n,axes:r})}return t},fu=(e,t,n,r,s)=>{let i=e;return e<0&&(i+=n[r[t]]),s[t]<0?Math.max(0,Math.min(i,n[r[t]]-1)):Math.max(0,Math.min(i,n[r[t]]))},mu=(e,t,n)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\\n          var input_indices: ${e.type.indices};\\n          var carry = 0u;\\n          for (var i = ${n.length}; i >= 0; i--) {\\n            let input_shape_i = ${Rn("uniforms.input_shape","i",n.length)};\\n            let steps_i = ${Rn("uniforms.steps","i",n.length)};\\n            let signs_i = ${Rn("uniforms.signs","i",n.length)};\\n            let starts_i = ${Rn("uniforms.starts","i",n.length)};\\n            var output_index = ${t.indicesGet("output_indices","i")};\\n            var input_index = output_index * steps_i + starts_i + carry;\\n            carry = input_index / input_shape_i;\\n            input_index = input_index % input_shape_i;\\n            if (signs_i < 0) {\\n              input_index = input_shape_i - input_index - 1u + starts_i;\\n            }\\n            ${e.indicesSet("input_indices","i","input_index")};\\n          }\\n          return input_indices;\\n      }`,_u=(e,t)=>{let n=e[0].dims,r=$n.size(n),s=t.axes.length>0?$n.normalizeAxes(t.axes,n.length):[...Array(n.length).keys()],i=pu(e,4);i.forEach((e=>0!==e||(()=>{throw new Error("step cannot be 0")}))),0===i.length&&(i=Array(s.length).fill(1));let a=t.starts.map(((e,t)=>fu(e,t,n,s,i))),o=t.ends.map(((e,t)=>fu(e,t,n,s,i)));if(s.length!==a.length||s.length!==o.length)throw new Error("start, ends and axes should have the same number of elements");if(s.length!==n.length)for(let e=0;e<n.length;++e)s.includes(e)||(a.splice(e,0,0),o.splice(e,0,n[e]),i.splice(e,0,1));let l=i.map((e=>Math.sign(e)));i.forEach(((e,t,n)=>{if(e<0){let r=(o[t]-a[t])/e,s=a[t],l=s+r*i[t];a[t]=l,o[t]=s,n[t]=-e}}));let u=n.slice(0);s.forEach(((e,t)=>{u[e]=Math.ceil((o[e]-a[e])/i[e])}));let d={dims:u,dataType:e[0].dataType},c=Fn("output",e[0].dataType,u.length),p=Ln("input",e[0].dataType,e[0].dims.length),h=$n.size(u),f=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:a.length},{name:"signs",type:"i32",length:l.length},{name:"steps",type:"u32",length:i.length}],m=[{type:12,data:h},{type:12,data:a},{type:6,data:l},{type:12,data:i},...Mn(e[0].dims,u)];return{name:"Slice",shaderCache:{hint:`${l.length}_${a.length}_${i.length}`,inputDependencies:["rank"]},getShaderSource:e=>`\\n      ${e.registerUniforms(f).declareVariables(p,c)}\\n        ${mu(p,c,n)}\\n        ${e.mainStart()}\\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n          let output_indices = ${c.offsetToIndices("global_idx")};\\n          let input_indices = calculateInputIndices(output_indices);\\n          ${c.setByOffset("global_idx",p.getByIndices("input_indices"))}\\n      }`,getRunData:()=>({outputs:[d],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:m})}},gu=(e,t)=>{cu(e.inputs,t);let n=hu(e.inputs,t);e.compute(_u(e.inputs,n),{inputs:[0]})},wu=e=>{let t=e.starts,n=e.ends,r=e.axes;return bn({starts:t,ends:n,axes:r})}})),ic=qe((()=>{td(),ld(),od(),dd(),ud(),yu=e=>{if(!e||1!==e.length)throw new Error("Softmax op requires 1 input.")},bu=(e,t)=>{let n,r=e.inputs[0],s=r.dims,i=$n.size(s),a=s.length,o=$n.normalizeAxis(t.axis,a),l=o<s.length-1,u=[];l?(u=Array.from({length:a},((e,t)=>t)),u[o]=a-1,u[a-1]=o,n=e.compute(Yn(r,u),{inputs:[r],outputs:[-1]})[0]):n=r;let d=n.dims,c=d[a-1],p=i/c,h=On(c),f=c/h,m=64;1===p&&(m=256);let _=Ln("x",n.dataType,n.dims,h),g=Fn("result",n.dataType,n.dims,h),w=_.type.value,y="f32"===An(n.dataType)?`var threadMax = ${w}(-3.402823e+38f);`:`var threadMax = ${w}(-65504.0h);`,b=e.compute({name:"Softmax",shaderCache:{hint:`${h};${m}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:d,dataType:n.dataType}],dispatchGroup:{x:p},programUniforms:[{type:6,data:f}]}),getShaderSource:e=>`\\n      var<workgroup> rowMaxShared : ${w};\\n      var<workgroup> rowSumShared : ${w};\\n      var<workgroup> threadShared : array<${w}, ${m}>;\\n\\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${w} {\\n        let index = row * row_stride + col;\\n        return x[index];\\n      }\\n\\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${w}) {\\n        let index = row * row_stride + col;\\n        result[index] = value;\\n      }\\n      ${e.registerUniform("packedCols","i32").declareVariables(_,g)}\\n      ${e.mainStart(m)}\\n        let gindex = i32(global_idx);\\n        let lindex = i32(local_idx);\\n        const wg = ${m};\\n        let row = gindex / wg;\\n        let cols = uniforms.packedCols;\\n        let row_stride : i32 = uniforms.packedCols;\\n\\n        // find the rows max\\n        ${y}\\n        for (var col = lindex; col < cols; col += wg) {\\n          let value = getValue(row, col, row_stride);\\n          threadMax = max(threadMax, value);\\n        }\\n        if (lindex < cols) {\\n          threadShared[lindex] = threadMax;\\n        }\\n        workgroupBarrier();\\n\\n        var reduceSize = min(cols, wg);\\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\\n          reduceSize = currSize + (reduceSize & 1);\\n          if (lindex < currSize) {\\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\\n          }\\n          workgroupBarrier();\\n        }\\n        if (lindex == 0) {\\n          rowMaxShared = ${w}(${((e,t)=>4===t?`max(max(${e}.x, ${e}.y), max(${e}.z, ${e}.w))`:2===t?`max(${e}.x, ${e}.y)`:3===t?`max(max(${e}.x, ${e}.y), ${e}.z)`:e)("threadShared[0]",h)});\\n        }\\n        workgroupBarrier();\\n\\n        // find the rows sum\\n        var threadSum = ${w}(0.0);\\n        for (var col = lindex; col < cols; col += wg) {\\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\\n          threadSum += subExp;\\n        }\\n        threadShared[lindex] = threadSum;\\n        workgroupBarrier();\\n\\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\\n          if (lindex < currSize) {\\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\\n          }\\n          workgroupBarrier();\\n        }\\n        if (lindex == 0) {\\n          rowSumShared = ${w}(${Pn("threadShared[0]",h)});\\n        }\\n        workgroupBarrier();\\n\\n        // calculate final value for each element in the row\\n        for (var col = lindex; col < cols; col += wg) {\\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\\n          setValue(row, col, row_stride, value);\\n        }\\n      }`},{inputs:[n],outputs:[l?-1:0]})[0];l&&e.compute(Yn(b,u),{inputs:[b]})},xu=(e,t)=>{yu(e.inputs),bu(e,t)},vu=e=>bn({axis:e.axis})})),ac=qe((()=>{td(),ld(),ud(),$u=e=>Array.from(e.getBigInt64Array(),Number),ku=e=>{if(!e||2!==e.length)throw new Error("Tile requires 2 inputs.");if(1!==e[0].dataType&&10!==e[0].dataType&&6!==e[0].dataType&&12!==e[0].dataType)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(7!==e[1].dataType)throw new Error("Tile `repeats` input should be of int64 data type");if(1!==e[1].dims.length)throw new Error("Tile `repeats` input should be 1-D");if($u(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Eu=(e,t)=>{let n=[];for(let r=0;r<e.length;++r)n.push(e[r]*t[r]);return n},Su=(e,t)=>{let n=e[0].dims,r=t??$u(e[1]),s=Eu(n,r),i=$n.size(s),a=e[0].dataType,o=Ln("input",a,n.length),l=Fn("output",a,s.length);return{name:"Tile",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:12,data:i},...Mn(e[0].dims,s)]}),getShaderSource:e=>`\\n      const inputShape = ${o.indices(...n)};\\n      ${e.registerUniform("output_size","u32").declareVariables(o,l)}\\n      ${e.mainStart()}\\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n      let output_indices = ${l.offsetToIndices("global_idx")};\\n      var input_indices: ${o.type.indices};\\n      for (var i = 0; i < ${n.length}; i++) {\\n        let input_dim_i = ${o.indicesGet("uniforms.input_shape","i")};\\n        let input_dim_value = ${l.indicesGet("output_indices","i")}  % input_dim_i;\\n\\n        ${o.indicesSet("input_indices","i","input_dim_value")}\\n      }\\n      ${l.setByOffset("global_idx",o.getByIndices("input_indices"))}\\n    }`}},zu=e=>{ku(e.inputs),e.compute(Su(e.inputs),{inputs:[0]})}})),oc=qe((()=>{td(),ld(),ud(),Cu=(e,t,n,r,s)=>{let i,a=Fn("output_data",s,n.length,4),o=Ln("a_data",t[1].dataType,t[1].dims.length,4),l=Ln("b_data",t[2].dataType,t[2].dims.length,4),u=Ln("c_data",t[0].dataType,t[0].dims.length,4),d=(e,t,n)=>`select(${t}, ${e}, ${n})`;if(r){let e=(e,t,n="")=>{let r=`a_data[index_a${t}][component_a${t}]`,s=`b_data[index_b${t}][component_b${t}]`,i=`bool(c_data[index_c${t}] & (0xffu << (component_c${t} * 8)))`;return`\\n            let output_indices${t} = ${a.offsetToIndices(`global_idx * 4u + ${t}u`)};\\n            let offset_a${t} = ${o.broadcastedIndicesToOffset(`output_indices${t}`,a)};\\n            let offset_b${t} = ${l.broadcastedIndicesToOffset(`output_indices${t}`,a)};\\n            let offset_c${t} = ${u.broadcastedIndicesToOffset(`output_indices${t}`,a)};\\n            let index_a${t} = offset_a${t} / 4u;\\n            let index_b${t} = offset_b${t} / 4u;\\n            let index_c${t} = offset_c${t} / 4u;\\n            let component_a${t} = offset_a${t} % 4u;\\n            let component_b${t} = offset_b${t} % 4u;\\n            let component_c${t} = offset_c${t} % 4u;\\n            ${e}[${t}] = ${n}(${d(r,s,i)});\\n          `};i=9===s?`\\n            var data = vec4<u32>(0);\\n            ${e("data",0,"u32")}\\n            ${e("data",1,"u32")}\\n            ${e("data",2,"u32")}\\n            ${e("data",3,"u32")}\\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\\n            ${e("output_data[global_idx]",0)}\\n            ${e("output_data[global_idx]",1)}\\n            ${e("output_data[global_idx]",2)}\\n            ${e("output_data[global_idx]",3)}\\n          `}else i=a.setByOffset("global_idx",d(o.getByOffset("global_idx"),l.getByOffset("global_idx"),u.getByOffset("global_idx")));return`\\n        ${e.registerUniform("vec_size","u32").declareVariables(u,o,l,a)}\\n        ${e.mainStart()}\\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\\n        ${i}\\n      }`},Tu=e=>{let t=e[1].dims,n=e[2].dims,r=e[0].dims,s=e[1].dataType,i=!($n.areEqual(t,n)&&$n.areEqual(n,r)),a=t,o=$n.size(t);if(i){let e=vn.calcShape(vn.calcShape(t,n,!1),r,!1);if(!e)throw new Error("Can\'t perform where op on the given tensors");a=e,o=$n.size(a)}let l=Math.ceil(o/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:t=>Cu(t,e,a,i,s),getRunData:()=>({outputs:[{dims:a,dataType:s}],dispatchGroup:{x:Math.ceil(o/64/4)},programUniforms:[{type:12,data:l},...Mn(r,t,n,a)]})}},Au=e=>{e.compute(Tu(e.inputs))}})),lc=qe((()=>{hd(),fd(),md(),_d(),wd(),yd(),bd(),Td(),Id(),Md(),Od(),Bd(),Nd(),Pd(),Rd(),Dd(),Ld(),Fd(),Ud(),qd(),jd(),Gd(),Hd(),Kd(),Xd(),Vd(),Qd(),Yd(),Zd(),Jd(),ec(),pd(),tc(),nc(),rc(),sc(),ic(),Wd(),ac(),dd(),gd(),oc(),Iu=new Map([["Abs",[fs]],["Acos",[ms]],["Acosh",[_s]],["Add",[ui]],["ArgMax",[Xr,Qr]],["ArgMin",[Kr,Qr]],["Asin",[gs]],["Asinh",[ws]],["Atan",[ys]],["Atanh",[bs]],["Attention",[ss]],["AveragePool",[bl,yl]],["BatchNormalization",[ls]],["BiasAdd",[cs]],["BiasSplitGelu",[ii]],["Cast",[vs,xs]],["Ceil",[Es]],["Clip",[ks]],["Concat",[$i,ki]],["Conv",[la,sa]],["ConvTranspose",[wa,fa]],["Cos",[Ss]],["Cosh",[zs]],["CumSum",[ba,xa]],["DepthToSpace",[Ea,Sa]],["DequantizeLinear",[Il,Ml]],["Div",[di]],["Einsum",[Na,Pa]],["Elu",[Ts,Cs]],["Equal",[ci]],["Erf",[Is]],["Exp",[Ms]],["Expand",[Ua]],["FastGelu",[Va]],["Floor",[Os]],["FusedConv",[la,sa]],["Gather",[Ha,Ga]],["GatherElements",[so,ro]],["GatherBlockQuantized",[Ja,eo]],["GatherND",[Xa,Qa]],["Gelu",[Bs]],["Gemm",[lo,oo]],["GlobalAveragePool",[$l,vl]],["GlobalMaxPool",[Cl,zl]],["Greater",[mi]],["GreaterOrEqual",[gi]],["GridSample",[xo,vo]],["GroupQueryAttention",[Fo]],["HardSigmoid",[qs,Us]],["InstanceNormalization",[Wo]],["LayerNormalization",[Ho]],["LeakyRelu",[Ns,Cs]],["Less",[_i]],["LessOrEqual",[wi]],["Log",[Js]],["MatMul",[Xo]],["MatMulNBits",[Jo,el]],["MaxPool",[El,Sl]],["Mul",[pi]],["MultiHeadAttention",[To,Eo]],["Neg",[Rs]],["Not",[Ps]],["Pad",[ul]],["Pow",[hi]],["QuickGelu",[ni,Cs]],["Range",[Nl]],["Reciprocal",[Ds]],["ReduceMin",[qr]],["ReduceMean",[Rr]],["ReduceMax",[Ur]],["ReduceSum",[Wr]],["ReduceProd",[Vr]],["ReduceL1",[Dr]],["ReduceL2",[Lr]],["ReduceLogSum",[Gr]],["ReduceLogSumExp",[Fr]],["ReduceSumSquare",[jr]],["Relu",[Ls]],["Resize",[ru,su]],["RotaryEmbedding",[ou]],["ScatterND",[Ll,Dl]],["Sigmoid",[Fs]],["Sin",[Vs]],["Sinh",[Ws]],["Slice",[gu,wu]],["SkipLayerNormalization",[du]],["Split",[No,Po]],["Sqrt",[js]],["Softmax",[xu,vu]],["Sub",[fi]],["Tan",[Gs]],["Tanh",[Ks]],["ThresholdedRelu",[Zs,Cs]],["Tile",[zu]],["Transpose",[Zn,Jn]],["Where",[Au]]])})),uc=qe((()=>{dt(),rd(),ud(),Mu=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n,r,s){Ie(e.programInfo.name);let i=this.backend.device,a=this.backend.getComputePassEncoder();this.backend.writeTimestamp(2*this.backend.pendingDispatchNumber);let o=[];for(let e of t)o.push({binding:o.length,resource:{buffer:e.buffer}});for(let e of n)o.push({binding:o.length,resource:{buffer:e.buffer}});s&&o.push({binding:o.length,resource:s});let l=i.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:o,label:e.programInfo.name});if("capturing"===this.backend.sessionStatus){let t={kernelId:this.backend.currentKernelId,computePipeline:e.computePipeline,bindGroup:l,dispatchGroup:r};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(t)}a.setPipeline(e.computePipeline),a.setBindGroup(0,l),a.dispatchWorkgroups(...r),this.backend.writeTimestamp(2*this.backend.pendingDispatchNumber+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||"at-passes"===this.backend.queryType)&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Me(e.programInfo.name)}dispose(){}build(e,t){Ie(e.name);let n=this.backend.device,r=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"},{feature:"subgroups-f16",extension:"subgroups_f16"}].forEach((e=>{n.features.has(e.feature)&&r.push(`enable ${e.extension};`)}));let s=Wn(t,this.backend.device.limits),i=e.getShaderSource(s),a=`${r.join("\\n")}\\n${s.additionalImplementations}\\n${i}`,o=n.createShaderModule({code:a,label:e.name});ln("verbose",(()=>`[WebGPU] ${e.name} shader code: ${a}`));let l=n.createComputePipeline({compute:{module:o,entryPoint:"main"},layout:"auto",label:e.name});return Me(e.name),{programInfo:e,computePipeline:l,uniformVariablesInfo:s.variablesInfo}}normalizeDispatchGroupSize(e){let t="number"==typeof e?e:e.x,n="number"==typeof e?1:e.y||1,r="number"==typeof e?1:e.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=s&&n<=s&&r<=s)return[t,n,r];let i=t*n*r,a=Math.ceil(Math.sqrt(i));if(a>s){if(a=Math.ceil(Math.cbrt(i)),a>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[a,a,a]}return[a,a,1]}}})),dc=qe((()=>{dt(),td(),rd(),sd(),ad(),lc(),uc(),Ou=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let n=[];for(let r=0;r<e.length;++r){let s=e[r].dataType;switch(t[r]){case"none":n.push("");break;case"type":n.push(`${s}`);break;case"rank":{let t=e[r].dims.length;n.push(`${s};${t}`);break}case"dims":{let t=e[r].dims.join(",");n.push(`${s};${t}`);break}default:throw new Error(`unsupported input dependency: ${t[r]}`)}}return n.join("|")},Bu=(e,t,n)=>{let r=e.name;return e.shaderCache?.hint&&(r+="["+e.shaderCache.hint+"]"),r+=":"+n+`:${Ou(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,r},Nu=class{constructor(e){e&&(this.architecture=e.architecture,this.vendor=e.vendor)}isArchitecture(e){return this.architecture===e}isVendor(e){return this.vendor===e}},Pu=class{constructor(e){this.subgroupsSupported=e.features.has("subgroups"),this.subgroupsF16Supported=e.features.has("subgroups");let t=e.limits;this.subgroupsSupported&&t.minSubgroupSize&&t.maxSubgroupSize?this.subgroupSizeRange=[t.minSubgroupSize,t.maxSubgroupSize]:this.subgroupSizeRange=void 0}},Ru=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(null===this.currentKernelId)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e,t){this.env=e;let n=[],r={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize,maxBufferSize:t.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:t.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n},s=e=>t.features.has(e)&&n.push(e)&&!0;s("chromium-experimental-timestamp-query-inside-passes")||s("timestamp-query"),s("shader-f16"),s("subgroups")&&s("subgroups-f16"),this.device=await t.requestDevice(r),this.deviceInfo=new Pu(this.device),this.adapterInfo=new Nu(t.info||await t.requestAdapterInfo()),this.gpuDataManager=wn(this),this.programManager=new Mu(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,an(e.logLevel,!!e.debug),this.device.onuncapturederror=e=>{e.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${e.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:t,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let e=this.getCommandEncoder(),t={};"at-passes"===this.queryType&&(t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:2*this.pendingDispatchNumber,endOfPassWriteIndex:2*this.pendingDispatchNumber+1}),this.computePassEncoder=e.beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;let e;Ie(),this.endComputePass(),"none"!==this.queryType&&(this.commandEncoder.resolveQuerySet(this.querySet,0,2*this.pendingDispatchNumber,this.queryResolveBuffer,0),e=this.device.createBuffer({size:2*this.pendingDispatchNumber*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(e,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,2*this.pendingDispatchNumber*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,"none"!==this.queryType&&e.mapAsync(GPUMapMode.READ).then((()=>{let t=new BigUint64Array(e.getMappedRange()),n=this.pendingQueries.get(e);for(let e=0;e<t.length/2;e++){let r=n[e],s=r.kernelId,i=this.kernels.get(s),a=i.kernelType,o=i.kernelName,l=r.programName,u=r.inputTensorViews,d=r.outputTensorViews,c=t[2*e],p=t[2*e+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=c);let h=Number(c-this.queryTimeBase),f=Number(p-this.queryTimeBase);if(!Number.isSafeInteger(h)||!Number.isSafeInteger(f))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:u.map((e=>({dims:e.dims,dataType:Ht(e.dataType)}))),outputsMetadata:d.map((e=>({dims:e.dims,dataType:Ht(e.dataType)}))),kernelId:s,kernelType:a,kernelName:o,programName:l,startTime:h,endTime:f});else{let e="";u.forEach(((t,n)=>{e+=`input[${n}]: [${t.dims}] | ${Ht(t.dataType)}, `}));let t="";d.forEach(((e,n)=>{t+=`output[${n}]: [${e.dims}] | ${Ht(e.dataType)}, `})),console.log(`[profiling] kernel "${s}|${a}|${o}|${l}" ${e}${t}execution time: ${f-h} ns`)}Te("GPU",`${l}::${c}::${p}`)}e.unmap(),this.pendingQueries.delete(e)})),Me()}run(e,t,n,r,s,i){Ie(e.name);let a=[];for(let e=0;e<t.length;++e){let n=t[e].data;if(0===n)continue;let r=this.gpuDataManager.get(n);if(!r)throw new Error(`no GPU data for input: ${n}`);a.push(r)}let{outputs:o,dispatchGroup:l,programUniforms:u}=e.getRunData(t),d=0===n.length?o.map(((e,t)=>t)):n;if(d.length!==o.length)throw new Error(`Output size ${d.length} must be equal to ${o.length}.`);let c,p=[],h=[];for(let e=0;e<o.length;++e){if(!Number.isInteger(d[e])||d[e]<-3||d[e]>=i)throw new Error(`Invalid output index: ${d[e]}`);if(-3===d[e])continue;let t=-1===d[e],n=-2===d[e],a=t||n?s(o[e].dataType,o[e].dims):r(d[e],o[e].dataType,o[e].dims);if(p.push(a),0===a.data)continue;let l=this.gpuDataManager.get(a.data);if(!l)throw new Error(`no GPU data for output: ${a.data}`);if(t&&this.temporaryData.push(l),n){let e=this.kernelPersistentData.get(this.currentKernelId);e||(e=[],this.kernelPersistentData.set(this.currentKernelId,e)),e.push(l)}h.push(l)}if(a.length!==t.length||h.length!==p.length){if(0===h.length)return Me(e.name),p;throw new Error(`Program ${e.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}if(u){let e=0,t=[];u.forEach((n=>{let r="number"==typeof n.data?[n.data]:n.data;if(0===r.length)return;let s,i,a=10===n.type?2:4;10===n.type?(i=r.length>4?16:r.length>2?8:r.length*a,s=r.length>4?16:a*r.length):(i=r.length<=2?r.length*a:16,s=16),e=Math.ceil(e/i)*i,t.push(e);let o=10===n.type?8:4;e+=r.length>4?Math.ceil(r.length/o)*s:r.length*a}));let n=16;e=Math.ceil(e/n)*n;let r=new ArrayBuffer(e);u.forEach(((e,n)=>{let s=t[n],i="number"==typeof e.data?[e.data]:e.data;if(6===e.type)new Int32Array(r,s,i.length).set(i);else if(12===e.type)new Uint32Array(r,s,i.length).set(i);else if(10===e.type)new Uint16Array(r,s,i.length).set(i);else{if(1!==e.type)throw new Error(`Unsupported uniform type: ${Ht(e.type)}`);new Float32Array(r,s,i.length).set(i)}}));let s=this.gpuDataManager.create(e,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(s.buffer,0,r,0,e),this.gpuDataManager.release(s.id),c={offset:0,size:e,buffer:s.buffer}}let f=this.programManager.normalizeDispatchGroupSize(l),m=1===f[1]&&1===f[2],_=Bu(e,t,m),g=this.programManager.getArtifact(_);if(g||(g=this.programManager.build(e,f),this.programManager.setArtifact(_,g),ln("info",(()=>`[artifact] key: ${_}, programName: ${e.name}`))),u&&g.uniformVariablesInfo){if(u.length!==g.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${g.uniformVariablesInfo.length}, got ${u.length} in program "${g.programInfo.name}".`);for(let e=0;e<u.length;e++){let t=u[e],n=t.type,r="number"==typeof t.data?1:t.data.length,[s,i]=g.uniformVariablesInfo[e];if(n!==s||r!==i)throw new Error(`Uniform variable ${e} mismatch: expect type ${s} with size ${i}, got type ${n} with size ${r} in program "${g.programInfo.name}".`)}}if(ln("info",(()=>`[ProgramManager] run "${e.name}" (key=${_}) with ${f[0]}x${f[1]}x${f[2]}`)),"none"!==this.queryType||"capturing"===this.sessionStatus){let e={kernelId:this.currentKernelId,programName:g.programInfo.name,inputTensorViews:t,outputTensorViews:p};this.pendingKernels.push(e),"capturing"===this.sessionStatus&&this.capturedPendingKernels.get(this.currentSessionId).push(e)}return this.programManager.run(g,a,h,f,c),Me(e.name),p}upload(e,t){this.gpuDataManager.upload(e,t)}memcpy(e,t){this.gpuDataManager.memcpy(e,t)}async download(e,t){await this.gpuDataManager.download(e,t)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,t,n,r){let s=Iu.get(e);if(!s)throw new Error(`kernel not implemented: ${e}`);let i={kernelType:e,kernelName:r,kernelEntry:s[0],attributes:[s[1],n]};this.kernels.set(t,i)}releaseKernel(e){let t=this.kernelPersistentData.get(e);if(t){for(let e of t)this.gpuDataManager.release(e.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,t,n){let r=this.kernels.get(e);if(!r)throw new Error(`kernel not created: ${e}`);let s=r.kernelType,i=r.kernelName,a=r.kernelEntry,o=r.attributes;if(null!==this.currentKernelId)throw new Error(`kernel "[${s}] ${i}" is not allowed to be called recursively`);this.currentKernelId=e,o[0]&&(o[1]=o[0](o[1]),o[0]=void 0),ln("info",(()=>`[WebGPU] Start to run kernel "[${s}] ${i}"...`));let l=this.env.debug;this.temporaryData=[];try{return l&&this.device.pushErrorScope("validation"),a(t,o[1]),0}catch(e){return n.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${i}" failed. ${e}`)),1}finally{l&&n.push(this.device.popErrorScope().then((e=>e?`GPU validation error for kernel "[${s}] ${i}": ${e.message}`:null)));for(let e of this.temporaryData)this.gpuDataManager.release(e.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,t,n,r){let s=this.sessionExternalDataMapping.get(e);s||(s=new Map,this.sessionExternalDataMapping.set(e,s));let i=s.get(t),a=this.gpuDataManager.registerExternalBuffer(n,r,i);return s.set(t,[a,n]),a}unregisterBuffers(e){let t=this.sessionExternalDataMapping.get(e);t&&(t.forEach((e=>this.gpuDataManager.unregisterExternalBuffer(e[0]))),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let t=this.gpuDataManager.get(e);if(!t)throw new Error(`no GPU data for buffer: ${e}`);return t.buffer}createDownloader(e,t,n){return async()=>{let r=await _n(this,e,t);return un(r.buffer,n)}}writeTimestamp(e){"inside-passes"===this.queryType&&this.computePassEncoder.writeTimestamp(this.querySet,e)}setQueryType(){this.queryType="none",("default"===this.env.webgpu.profiling?.mode||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),"none"!==this.queryType&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2*this.maxDispatchNumber}),this.queryResolveBuffer=this.device.createBuffer({size:2*this.maxDispatchNumber*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){ln("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){ln("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){ln("info","replay"),this.sessionStatus="replaying";let e=this.capturedCommandList.get(this.currentSessionId),t=this.capturedPendingKernels.get(this.currentSessionId),n=e.length;this.pendingKernels=[];for(let r=0;r<n;r++){let n=this.getComputePassEncoder(),s=e[r];this.writeTimestamp(2*this.pendingDispatchNumber),n.setPipeline(s.computePipeline),n.setBindGroup(0,s.bindGroup),n.dispatchWorkgroups(...s.dispatchGroup),this.writeTimestamp(2*this.pendingDispatchNumber+1),this.pendingDispatchNumber++,"none"!==this.queryType&&this.pendingKernels.push(t[r]),(this.pendingDispatchNumber>=this.maxDispatchNumber||"at-passes"===this.queryType)&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(e){this.unregisterBuffers(e),this.capturedCommandList.has(e)&&this.capturedCommandList.delete(e),this.capturedPendingKernels.has(e)&&this.capturedPendingKernels.delete(e),this.gpuDataManager.onReleaseSession(e)}onRunStart(e){this.currentSessionId=e,this.setQueryType()}}})),cc=qe((()=>{rd(),Du=1,Lu=()=>Du++,Fu=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),Uu=(e,t)=>{let n=Fu.get(e);if(!n)throw new Error("Unsupported data type.");return t.length>0?Math.ceil(t.reduce(((e,t)=>e*t))*n/8):0},qu=class{constructor(e){this.sessionId=e.sessionId,this.mlContext=e.context,this.mlTensor=e.tensor,this.dataType=e.dataType,this.tensorShape=e.shape}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return Uu(this.dataType,this.tensorShape)}destroy(){ln("verbose",(()=>"[WebNN] TensorWrapper.destroy")),this.mlTensor.destroy()}write(e){this.mlContext.writeTensor(this.mlTensor,e)}async read(e){return e?this.mlContext.readTensor(this.mlTensor,e):this.mlContext.readTensor(this.mlTensor)}sameTypeAndShape(e,t){return this.dataType===e&&this.tensorShape.length===t.length&&this.tensorShape.every(((e,n)=>e===t[n]))}},Vu=class{constructor(e,t){this.tensorManager=e,this.wrapper=t}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(e,t,n){if(this.wrapper){if(this.wrapper.sameTypeAndShape(e,t))return this.wrapper.tensor;if(n){if(this.wrapper.byteLength!==Uu(e,t))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let r=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(e,t,r,!0,!0),n&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(e){if(this.wrapper){if(e.byteLength===this.wrapper.byteLength)return void this.wrapper.write(e);ln("verbose",(()=>"Data size does not match tensor size. Releasing tensor.")),this.releaseTensor()}this.activeUpload?this.activeUpload.set(e):this.activeUpload=new Uint8Array(e)}async download(e){if(this.activeUpload)return e?void(e instanceof ArrayBuffer?new Uint8Array(e).set(this.activeUpload):new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(this.activeUpload)):this.activeUpload.buffer;if(!this.wrapper)throw new Error("Tensor has not been created.");return e?this.wrapper.read(e):this.wrapper.read()}},Wu=class{constructor(e){this.backend=e,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}reserveTensorId(){let e=Lu();return this.tensorTrackersById.set(e,new Vu(this)),e}releaseTensorId(e){let t=this.tensorTrackersById.get(e);t&&(this.tensorTrackersById.delete(e),t.tensorWrapper&&this.releaseTensor(t.tensorWrapper))}async ensureTensor(e,t,n,r){ln("verbose",(()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${e}, dataType: ${t}, shape: ${n}, copyOld: ${r}}`));let s=this.tensorTrackersById.get(e);if(!s)throw new Error("Tensor not found.");return s.ensureTensor(t,n,r)}upload(e,t){let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");n.upload(t)}async download(e,t){ln("verbose",(()=>`[WebNN] TensorManager.download {tensorId: ${e}, dstBuffer: ${t?.byteLength}}`));let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");return n.download(t)}releaseTensorsForSession(e){for(let t of this.freeTensors)t.sessionId===e&&t.destroy();this.freeTensors=this.freeTensors.filter((t=>t.sessionId!==e))}registerTensor(e,t,n,r){let s=Lu(),i=new qu({sessionId:this.backend.currentSessionId,context:e,tensor:t,dataType:n,shape:r});return this.tensorTrackersById.set(s,new Vu(this,i)),this.externalTensors.add(i),s}async getCachedTensor(e,t,n,r,s){let i=this.backend.currentSessionId;for(let[n,r]of this.freeTensors.entries())if(r.sameTypeAndShape(e,t)){ln("verbose",(()=>`[WebNN] Reusing tensor {dataType: ${e}, shape: ${t}}`));let r=this.freeTensors.splice(n,1)[0];return r.sessionId=i,r}let a=this.backend.currentContext;ln("verbose",(()=>`[WebNN] MLContext.createTensor {dataType: ${e}, shape: ${t}}`));let o=await a.createTensor({dataType:e,shape:t,dimensions:t,usage:n,writable:r,readable:s});return new qu({sessionId:i,context:a,tensor:o,dataType:e,shape:t})}releaseTensor(e){this.externalTensors.has(e)&&this.externalTensors.delete(e),this.freeTensors.push(e)}},ju=(...e)=>new Wu(...e)})),pc=qe((()=>{td(),Yu(),sd(),cc(),rd(),Gu=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),Hu=(e,t)=>{if(e===t)return!0;if(void 0===e||void 0===t)return!1;let n=Object.keys(e).sort(),r=Object.keys(t).sort();return n.length===r.length&&n.every(((n,s)=>n===r[s]&&e[n]===t[n]))},Ku=class{constructor(e){this.tensorManager=ju(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],an(e.logLevel,!!e.debug)}get currentSessionId(){if(void 0===this.activeSessionId)throw new Error("No active session");return this.activeSessionId}onRunStart(e){this.activeSessionId=e}async createMLContext(e){if(e instanceof GPUDevice){let t=this.mlContextCache.findIndex((t=>t.gpuDevice===e));if(-1!==t)return this.mlContextCache[t].mlContext;{let t=await navigator.ml.createContext(e);return this.mlContextCache.push({gpuDevice:e,mlContext:t}),t}}if(void 0===e){let e=this.mlContextCache.findIndex((e=>void 0===e.options&&void 0===e.gpuDevice));if(-1!==e)return this.mlContextCache[e].mlContext;{let e=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:e}),e}}let t=this.mlContextCache.findIndex((t=>Hu(t.options,e)));if(-1!==t)return this.mlContextCache[t].mlContext;{let t=await navigator.ml.createContext(e);return this.mlContextCache.push({options:e,mlContext:t}),t}}get currentContext(){let e=this.getMLContext(this.currentSessionId);if(!e)throw new Error(`No MLContext found for session ${this.currentSessionId}`);return e}registerMLContext(e,t){this.mlContextBySessionId.set(e,t);let n=this.sessionIdsByMLContext.get(t);n||(n=new Set,this.sessionIdsByMLContext.set(t,n)),n.add(e)}onReleaseSession(e){let t=this.mlContextBySessionId.get(e);if(!t)return;this.tensorManager.releaseTensorsForSession(e),this.mlContextBySessionId.delete(e);let n=this.sessionIdsByMLContext.get(t);if(n.delete(e),0===n.size){this.sessionIdsByMLContext.delete(t);let e=this.mlContextCache.findIndex((e=>e.mlContext===t));-1!==e&&this.mlContextCache.splice(e,1)}}getMLContext(e){return this.mlContextBySessionId.get(e)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(e){ln("verbose",(()=>`[WebNN] releaseTensorId {tensorId: ${e}}`)),this.tensorManager.releaseTensorId(e)}async ensureTensor(e,t,n,r){let s=Gu.get(t);if(!s)throw new Error(`Unsupported ONNX data type: ${t}`);return this.tensorManager.ensureTensor(e,s,n,r)}uploadTensor(e,t){if(!Pt().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");ln("verbose",(()=>`[WebNN] uploadTensor {tensorId: ${e}, data: ${t.byteLength}}`)),this.tensorManager.upload(e,t)}async downloadTensor(e,t){return this.tensorManager.download(e,t)}createMLTensorDownloader(e,t){return async()=>{let n=await this.tensorManager.download(e);return un(n,t)}}registerMLTensor(e,t,n){let r=Gu.get(t);if(!r)throw new Error(`Unsupported ONNX data type: ${t}`);let s=this.tensorManager.registerTensor(this.currentContext,e,r,n);return ln("verbose",(()=>`[WebNN] registerMLTensor {tensor: ${e}, dataType: ${r}, dimensions: ${n}} -> {tensorId: ${s}}`)),s}registerMLConstant(e,t,n,r,s,i){if(!i)throw new Error("External mounted files are not available.");let a=e;e.startsWith("./")&&(a=e.substring(2));let o=i.get(a);if(!o)throw new Error(`File with name ${a} not found in preloaded files.`);if(t+n>o.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let l,u=o.slice(t,t+n).buffer;switch(s.dataType){case"float32":l=new Float32Array(u);break;case"float16":l=new Uint16Array(u);break;case"int32":l=new Int32Array(u);break;case"uint32":l=new Uint32Array(u);break;case"int64":l=new BigInt64Array(u);break;case"uint64":l=new BigUint64Array(u);break;case"int8":l=new Int8Array(u);break;case"int4":case"uint4":case"uint8":l=new Uint8Array(u);break;default:throw new Error(`Unsupported data type: ${s.dataType} in creating WebNN Constant from external data.`)}return ln("verbose",(()=>`[WebNN] registerMLConstant {dataType: ${s.dataType}, shape: ${s.shape}}}`)),r.constant(s,l)}flush(){}}})),hc={};Ve(hc,{init:()=>_c});var fc,mc,_c,gc,wc,yc,bc,xc,vc,$c,kc,Ec,Sc,zc,Cc,Tc,Ac,Ic,Mc,Oc,Bc,Nc,Pc,Rc,Dc,Lc,Fc,Uc,qc,Vc,Wc,jc,Gc,Hc,Kc,Xc,Qc=qe((()=>{td(),dc(),rd(),ld(),pc(),fc=class e{constructor(e,t,n,r){this.module=e,this.dataType=t,this.data=n,this.dims=r}getFloat32Array(){if(1!==this.dataType)throw new Error("Invalid data type");let e=$n.size(this.dims);return 0===e?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(7!==this.dataType)throw new Error("Invalid data type");let e=$n.size(this.dims);return 0===e?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(6!==this.dataType)throw new Error("Invalid data type");let e=$n.size(this.dims);return 0===e?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}getUint16Array(){if(10!==this.dataType&&4!==this.dataType)throw new Error("Invalid data type");let e=$n.size(this.dims);return 0===e?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,e)}reshape(t){if($n.size(t)!==$n.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},mc=class{constructor(e,t,n){this.module=e,this.backend=t,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=t.adapterInfo,this.deviceInfo=t.deviceInfo;let r=e.PTR_SIZE,s=n/e.PTR_SIZE,i=4===r?"i32":"i64";this.opKernelContext=Number(e.getValue(r*s++,i));let a=Number(e.getValue(r*s++,i));this.outputCount=Number(e.getValue(r*s++,i)),this.customDataOffset=Number(e.getValue(r*s++,"*")),this.customDataSize=Number(e.getValue(r*s++,i));let o=[];for(let t=0;t<a;t++){let t=Number(e.getValue(r*s++,i)),n=Number(e.getValue(r*s++,"*")),a=Number(e.getValue(r*s++,i)),l=[];for(let t=0;t<a;t++)l.push(Number(e.getValue(r*s++,i)));o.push(new fc(e,t,n,l))}this.inputs=o}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(e,t){let n=t?.inputs?.map((e=>"number"==typeof e?this.inputs[e]:e))??this.inputs,r=t?.outputs??[];return this.backend.run(e,n,r,((e,t,n)=>new fc(this.module,t,this.output(e,n),n)),((e,t)=>{let n=Kt(e,t);if(!n)throw new Error(`Unsupported data type: ${e}`);let r=n>0?this.backend.gpuDataManager.create(n).id:0;return new fc(this.module,e,r,t)}),this.outputCount)}output(e,t){let n=this.module.stackSave();try{let n=this.module.PTR_SIZE,r=4===n?"i32":"i64",s=this.module.stackAlloc((1+t.length)*n);this.module.setValue(s,t.length,r);for(let e=0;e<t.length;e++)this.module.setValue(s+n*(e+1),t[e],r);return this.module._JsepOutput(this.opKernelContext,e,s)}catch(n){throw new Error(`Failed to generate kernel\'s output[${e}] with dims [${t}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(n)}}},_c=async(e,t,n,r)=>{let s=t.jsepInit;if(!s)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if("webgpu"===e){let e=new Ru;await e.initialize(n,r),s("webgpu",[e,t=>e.alloc(Number(t)),t=>e.free(t),(n,r,s,i=!1)=>{if(i)ln("verbose",(()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(n)}, dst=${Number(r)}, size=${Number(s)}`)),e.memcpy(Number(n),Number(r));else{ln("verbose",(()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(n)}, gpuDataId=${Number(r)}, size=${Number(s)}`));let i=t.HEAPU8.subarray(Number(n>>>0),Number(n>>>0)+Number(s));e.upload(Number(r),i)}},async(n,r,s)=>{ln("verbose",(()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${n}, dataOffset=${r}, size=${s}`)),await e.download(Number(n),(()=>t.HEAPU8.subarray(Number(r)>>>0,Number(r+s)>>>0)))},(n,r,s)=>e.createKernel(n,Number(r),s,t.UTF8ToString(t._JsepGetNodeName(Number(r)))),t=>e.releaseKernel(t),(n,r,s,i)=>{ln("verbose",(()=>`[WebGPU] jsepRun: sessionHandle=${s}, kernel=${n}, contextDataOffset=${r}`));let a=new mc(t,e,Number(r));return e.computeKernel(Number(n),a,i)},()=>e.captureBegin(),()=>e.captureEnd(),()=>e.replay()])}else{let e=new Ku(n);s("webnn",[e,()=>e.reserveTensorId(),t=>e.releaseTensorId(t),async(t,n,r,s)=>e.ensureTensor(t,n,r,s),(t,n)=>{e.uploadTensor(t,n)},async(t,n)=>e.downloadTensor(t,n)])}}})),Yc=qe((()=>{Ju(),ed(),td(),Yu(),Zu(),nd(),gc=(e,t)=>{0!==Pt()._OrtInit(e,t)&&Lt("Can\'t initialize onnxruntime.")},wc=async e=>{gc(e.wasm.numThreads,Qt(e.logLevel))},yc=async(e,t)=>{{let n=(Qc(),We(hc)).init;if("webgpu"===t){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let t=e.webgpu.adapter;if(t){if("object"!=typeof t.limits||"object"!=typeof t.features||"function"!=typeof t.requestDevice)throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let n=e.webgpu.powerPreference;if(void 0!==n&&"low-power"!==n&&"high-performance"!==n)throw new Error(`Invalid powerPreference setting: "${n}"`);let r=e.webgpu.forceFallbackAdapter;if(void 0!==r&&"boolean"!=typeof r)throw new Error(`Invalid forceFallbackAdapter setting: "${r}"`);if(t=await navigator.gpu.requestAdapter({powerPreference:n,forceFallbackAdapter:r}),!t)throw new Error(\'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.\')}await n("webgpu",Pt(),e,t)}if("webnn"===t){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await n("webnn",Pt(),e)}}},bc=new Map,xc=e=>{let t=Pt(),n=t.stackSave();try{let n=t.PTR_SIZE,r=t.stackAlloc(2*n);0!==t._OrtGetInputOutputCount(e,r,r+n)&&Lt("Can\'t get session input/output count.");let s=4===n?"i32":"i64";return[Number(t.getValue(r,s)),Number(t.getValue(r+n,s))]}finally{t.stackRestore(n)}},vc=e=>{let t=Pt(),n=t._malloc(e.byteLength);if(0===n)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},$c=async(e,t)=>{let n,r,s=Pt();Array.isArray(e)?[n,r]=e:e.buffer===s.HEAPU8.buffer?[n,r]=[e.byteOffset,e.byteLength]:[n,r]=vc(e);let i=0,a=0,o=0,l=[],u=[],d=[];try{if([a,l]=jt(t),t?.externalData&&s.mountExternalData){let e=[];for(let n of t.externalData){let t="string"==typeof n?n:n.path;e.push(en("string"==typeof n?n:n.data).then((e=>{s.mountExternalData(t,e)})))}await Promise.all(e)}for(let e of t?.executionProviders??[])if("webnn"===("string"==typeof e?e:e.name)){if(s.shouldTransferToMLTensor=!1,"string"!=typeof e){let t=e,n=t?.context,r=t?.gpuDevice,i=t?.deviceType,a=t?.powerPreference;s.currentContext=n||(r?await s.jsepCreateMLContext(r):await s.jsepCreateMLContext({deviceType:i,powerPreference:a}))}else s.currentContext=await s.jsepCreateMLContext();break}i=await s._OrtCreateSession(n,r,a),0===i&&Lt("Can\'t create a session."),s.jsepOnCreateSession?.(),s.currentContext&&(s.jsepRegisterMLContext(i,s.currentContext),s.currentContext=void 0,s.shouldTransferToMLTensor=!0);let[e,c]=xc(i),p=!!t?.enableGraphCapture,h=[],f=[],m=[];for(let t=0;t<e;t++){let e=s._OrtGetInputName(i,t);0===e&&Lt("Can\'t get an input name."),u.push(e),h.push(s.UTF8ToString(e))}for(let e=0;e<c;e++){let n=s._OrtGetOutputName(i,e);0===n&&Lt("Can\'t get an output name."),d.push(n);let r=s.UTF8ToString(n);f.push(r);{if(p&&void 0===t?.preferredOutputLocation){m.push("gpu-buffer");continue}let e="string"==typeof t?.preferredOutputLocation?t.preferredOutputLocation:t?.preferredOutputLocation?.[r]??"cpu";if("cpu"!==e&&"cpu-pinned"!==e&&"gpu-buffer"!==e&&"ml-tensor"!==e)throw new Error(`Not supported preferred output location: ${e}.`);if(p&&"gpu-buffer"!==e)throw new Error(`Not supported preferred output location: ${e}. Only \'gpu-buffer\' location is supported when enableGraphCapture is true.`);m.push(e)}}let _=null;return m.some((e=>"gpu-buffer"===e||"ml-tensor"===e))&&(o=s._OrtCreateBinding(i),0===o&&Lt("Can\'t create IO binding."),_={handle:o,outputPreferredLocations:m,outputPreferredLocationsEncoded:m.map((e=>Jt(e)))}),bc.set(i,[i,u,d,_,p,!1]),[i,h,f]}catch(e){throw u.forEach((e=>s._OrtFree(e))),d.forEach((e=>s._OrtFree(e))),0!==o&&0!==s._OrtReleaseBinding(o)&&Lt("Can\'t release IO binding."),0!==i&&0!==s._OrtReleaseSession(i)&&Lt("Can\'t release session."),e}finally{s._free(n),0!==a&&0!==s._OrtReleaseSessionOptions(a)&&Lt("Can\'t release session options."),l.forEach((e=>s._free(e))),s.unmountExternalData?.()}},kc=e=>{let t=Pt(),n=bc.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[r,s,i,a,o]=n;a&&(o&&0!==t._OrtClearBoundOutputs(a.handle)&&Lt("Can\'t clear bound outputs."),0!==t._OrtReleaseBinding(a.handle)&&Lt("Can\'t release IO binding.")),t.jsepOnReleaseSession?.(e),s.forEach((e=>t._OrtFree(e))),i.forEach((e=>t._OrtFree(e))),0!==t._OrtReleaseSession(r)&&Lt("Can\'t release session."),bc.delete(e)},Ec=(e,t,n,r,s,i=!1)=>{if(!e)return void t.push(0);let a,o,l=Pt(),u=l.PTR_SIZE,d=e[0],c=e[1],p=e[3];if("string"===d&&("gpu-buffer"===p||"ml-tensor"===p))throw new Error("String tensor is not supported on GPU.");if(i&&"gpu-buffer"!==p)throw new Error(`External buffer must be provided for input/output index ${s} when enableGraphCapture is true.`);if("gpu-buffer"===p){let t=e[2].gpuBuffer;o=Kt(Gt(d),c);let n=l.jsepRegisterBuffer;if(!n)throw new Error(\'Tensor location "gpu-buffer" is not supported without using WebGPU.\');a=n(r,s,t,o)}else if("ml-tensor"===p){let t=e[2].mlTensor;o=Kt(Gt(d),c);let n=l.jsepRegisterMLTensor;if(!n)throw new Error(\'Tensor location "ml-tensor" is not supported without using WebNN.\');a=n(t,Gt(d),c)}else{let t=e[2];if(Array.isArray(t)){o=u*t.length,a=l._malloc(o),n.push(a);for(let e=0;e<t.length;e++){if("string"!=typeof t[e])throw new TypeError(`tensor data at index ${e} is not a string`);l.setValue(a+e*u,Rt(t[e],n),"*")}}else o=t.byteLength,a=l._malloc(o),n.push(a),l.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),a)}let h=l.stackSave(),f=l.stackAlloc(4*c.length);try{c.forEach(((e,t)=>l.setValue(f+t*u,e,4===u?"i32":"i64")));let e=l._OrtCreateTensor(Gt(d),a,o,f,c.length,Jt(p));0===e&&Lt(`Can\'t create tensor for input/output. session=${r}, index=${s}.`),t.push(e)}finally{l.stackRestore(h)}},Sc=async(e,t,n,r,s,i)=>{let a=Pt(),o=a.PTR_SIZE,l=bc.get(e);if(!l)throw new Error(`cannot run inference. invalid session id: ${e}`);let u=l[0],d=l[1],c=l[2],p=l[3],h=l[4],f=l[5],m=t.length,_=r.length,g=0,w=[],y=[],b=[],x=[],v=a.stackSave(),$=a.stackAlloc(m*o),k=a.stackAlloc(m*o),E=a.stackAlloc(_*o),S=a.stackAlloc(_*o);try{a.jsepOnRunStart?.(u),[g,w]=Ft(i);for(let r=0;r<m;r++)Ec(n[r],y,x,e,t[r],h);for(let t=0;t<_;t++)Ec(s[t],b,x,e,m+r[t],h);for(let e=0;e<m;e++)a.setValue($+e*o,y[e],"*"),a.setValue(k+e*o,d[t[e]],"*");for(let e=0;e<_;e++)a.setValue(E+e*o,b[e],"*"),a.setValue(S+e*o,c[r[e]],"*");if(p&&!f){let{handle:n,outputPreferredLocations:i,outputPreferredLocationsEncoded:o}=p;if(d.length!==m)throw new Error(`input count from feeds (${m}) is expected to be always equal to model\'s input count (${d.length}).`);for(let r=0;r<m;r++){let s=t[r];0!==await a._OrtBindInput(n,d[s],y[r])&&Lt(`Can\'t bind input[${r}] for session=${e}.`)}for(let t=0;t<_;t++){let l=r[t];s[t]?.[3]?0!==a._OrtBindOutput(n,c[l],b[t],0)&&Lt(`Can\'t bind pre-allocated output[${t}] for session=${e}.`):0!==a._OrtBindOutput(n,c[l],0,o[l])&&Lt(`Can\'t bind output[${t}] to ${i[t]} for session=${e}.`)}bc.set(e,[u,d,c,p,h,!0])}let l;l=p?await a._OrtRunWithBinding(u,p.handle,_,E,g):await a._OrtRun(u,k,$,m,S,_,E,g),0!==l&&Lt("failed to call OrtRun().");let v=[];for(let e=0;e<_;e++){let t=Number(a.getValue(E+e*o,"*"));if(t===b[e]){v.push(s[e]);continue}let n,i=a.stackSave(),l=a.stackAlloc(4*o),u=!1,d=0;try{0!==a._OrtGetTensorData(t,l,l+o,l+2*o,l+3*o)&&Lt(`Can\'t access output tensor data on index ${e}.`);let s=4===o?"i32":"i64",i=Number(a.getValue(l,s));d=a.getValue(l+o,"*");let c=a.getValue(l+2*o,"*"),h=Number(a.getValue(l+3*o,s)),f=[];for(let e=0;e<h;e++)f.push(Number(a.getValue(c+e*o,s)));0!==a._OrtFree(c)&&Lt("Can\'t free memory for tensor dims.");let m=f.reduce(((e,t)=>e*t),1);n=Ht(i);let _=p?.outputPreferredLocations[r[e]];if("string"===n){if("gpu-buffer"===_||"ml-tensor"===_)throw new Error("String tensor is not supported on GPU.");let e=[];for(let t=0;t<m;t++){let n=a.getValue(d+t*o,"*"),r=a.getValue(d+(t+1)*o,"*"),s=t===m-1?void 0:r-n;e.push(a.UTF8ToString(n,s))}v.push([n,f,e,"cpu"])}else if("gpu-buffer"===_&&m>0){let e=a.jsepGetBuffer;if(!e)throw new Error(\'preferredLocation "gpu-buffer" is not supported without using WebGPU.\');let r=e(d),s=Kt(i,m);if(void 0===s||!Yt(n))throw new Error(`Unsupported data type: ${n}`);u=!0,v.push([n,f,{gpuBuffer:r,download:a.jsepCreateDownloader(r,s,n),dispose:()=>{0!==a._OrtReleaseTensor(t)&&Lt("Can\'t release tensor.")}},"gpu-buffer"])}else if("ml-tensor"===_&&m>0){let e=a.jsepEnsureTensor;if(!e)throw new Error(\'preferredLocation "ml-tensor" is not supported without using WebNN.\');if(void 0===Kt(i,m)||!Zt(n))throw new Error(`Unsupported data type: ${n}`);let r=await e(d,i,f,!1);u=!0,v.push([n,f,{mlTensor:r,download:a.jsepCreateMLTensorDownloader(d,n),dispose:()=>{a.jsepReleaseTensorId(d),a._OrtReleaseTensor(t)}},"ml-tensor"])}else{let e=new(Xt(n))(m);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(a.HEAPU8.subarray(d,d+e.byteLength)),v.push([n,f,e,"cpu"])}}finally{a.stackRestore(i),"string"===n&&d&&a._free(d),u||a._OrtReleaseTensor(t)}}return p&&!h&&(0!==a._OrtClearBoundOutputs(p.handle)&&Lt("Can\'t clear bound outputs."),bc.set(e,[u,d,c,p,h,!1])),v}finally{a.stackRestore(v),y.forEach((e=>a._OrtReleaseTensor(e))),b.forEach((e=>a._OrtReleaseTensor(e))),x.forEach((e=>a._free(e))),0!==g&&a._OrtReleaseRunOptions(g),w.forEach((e=>a._free(e)))}},zc=e=>{let t=Pt(),n=bc.get(e);if(!n)throw new Error("invalid session id");let r=n[0],s=t._OrtEndProfiling(r);0===s&&Lt("Can\'t get an profile file name."),t._OrtFree(s)},Cc=e=>{let t=[];for(let n of e){let e=n[2];!Array.isArray(e)&&"buffer"in e&&t.push(e.buffer)}return t}})),Zc=qe((()=>{dt(),Yc(),Yu(),Qu(),Tc=()=>!!pe.wasm.proxy&&typeof document<"u",Ic=!1,Mc=!1,Oc=!1,Pc=new Map,Rc=(e,t)=>{let n=Pc.get(e);n?n.push(t):Pc.set(e,[t])},Dc=()=>{if(Ic||!Mc||Oc||!Ac)throw new Error("worker not ready")},Lc=e=>{switch(e.data.type){case"init-wasm":Ic=!1,e.data.err?(Oc=!0,Nc[1](e.data.err)):(Mc=!0,Nc[0]()),Bc&&(URL.revokeObjectURL(Bc),Bc=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let t=Pc.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}}},Fc=async()=>{if(!Mc){if(Ic)throw new Error("multiple calls to \'initWasm()\' detected.");if(Oc)throw new Error("previous call to \'initWasm()\' failed.");if(Ic=!0,Tc())return new Promise(((e,t)=>{Ac?.terminate(),St().then((([n,r])=>{try{(Ac=r).onerror=e=>t(e),Ac.onmessage=Lc,Nc=[e,t];let s={type:"init-wasm",in:pe};Ac.postMessage(s),Bc=n}catch(e){t(e)}}),t)}));try{await Nt(pe.wasm),await wc(pe),Mc=!0}catch(e){throw Oc=!0,e}finally{Ic=!1}}},Uc=async e=>{if(Tc())return Dc(),new Promise(((t,n)=>{Rc("init-ep",[t,n]);let r={type:"init-ep",in:{epName:e,env:pe}};Ac.postMessage(r)}));await yc(pe,e)},qc=async e=>Tc()?(Dc(),new Promise(((t,n)=>{Rc("copy-from",[t,n]);let r={type:"copy-from",in:{buffer:e}};Ac.postMessage(r,[e.buffer])}))):vc(e),Vc=async(e,t)=>{if(Tc()){if(t?.preferredOutputLocation)throw new Error(\'session option "preferredOutputLocation" is not supported for proxy.\');return Dc(),new Promise(((n,r)=>{Rc("create",[n,r]);let s={type:"create",in:{model:e,options:{...t}}},i=[];e instanceof Uint8Array&&i.push(e.buffer),Ac.postMessage(s,i)}))}return $c(e,t)},Wc=async e=>{if(Tc())return Dc(),new Promise(((t,n)=>{Rc("release",[t,n]);let r={type:"release",in:e};Ac.postMessage(r)}));kc(e)},jc=async(e,t,n,r,s,i)=>{if(Tc()){if(n.some((e=>"cpu"!==e[3])))throw new Error("input tensor on GPU is not supported for proxy.");if(s.some((e=>e)))throw new Error("pre-allocated output tensor is not supported for proxy.");return Dc(),new Promise(((s,a)=>{Rc("run",[s,a]);let o=n,l={type:"run",in:{sessionId:e,inputIndices:t,inputs:o,outputIndices:r,options:i}};Ac.postMessage(l,Cc(o))}))}return Sc(e,t,n,r,s,i)},Gc=async e=>{if(Tc())return Dc(),new Promise(((t,n)=>{Rc("end-profiling",[t,n]);let r={type:"end-profiling",in:e};Ac.postMessage(r)}));zc(e)}})),Jc=qe((()=>{dt(),Zc(),td(),ct(),nd(),Hc=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},Kc=e=>{switch(e[3]){case"cpu":return new Ce(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!Yt(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:r,dispose:s}=e[2];return Ce.fromGpuBuffer(n,{dataType:t,dims:e[1],download:r,dispose:s})}case"ml-tensor":{let t=e[0];if(!Zt(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:n,download:r,dispose:s}=e[2];return Ce.fromMLTensor(n,{dataType:t,dims:e[1],download:r,dispose:s})}default:throw new Error(`invalid data location: ${e[3]}`)}},Xc=class{async fetchModelAndCopyToWasmMemory(e){return qc(await en(e))}async loadModel(e,t){let n;Ie(),n="string"==typeof e?await this.fetchModelAndCopyToWasmMemory(e):e,[this.sessionId,this.inputNames,this.outputNames]=await Vc(n,t),Me()}async dispose(){return Wc(this.sessionId)}async run(e,t,n){Ie();let r=[],s=[];Object.entries(e).forEach((e=>{let t=e[0],n=e[1],i=this.inputNames.indexOf(t);if(-1===i)throw new Error(`invalid input \'${t}\'`);r.push(n),s.push(i)}));let i=[],a=[];Object.entries(t).forEach((e=>{let t=e[0],n=e[1],r=this.outputNames.indexOf(t);if(-1===r)throw new Error(`invalid output \'${t}\'`);i.push(n),a.push(r)}));let o=r.map(((e,t)=>Hc(e,(()=>`input "${this.inputNames[s[t]]}"`)))),l=i.map(((e,t)=>e?Hc(e,(()=>`output "${this.outputNames[a[t]]}"`)):null)),u=await jc(this.sessionId,s,o,a,l,n),d={};for(let e=0;e<u.length;e++)d[this.outputNames[a[e]]]=i[e]??Kc(u[e]);return Me(),d}startProfiling(){}endProfiling(){Gc(this.sessionId)}}})),ep={};Ve(ep,{OnnxruntimeWebAssemblyBackend:()=>np,initializeFlags:()=>tp,wasmBackend:()=>rp});var tp,np,rp,sp=qe((()=>{dt(),Zc(),Jc(),Qu(),tp=()=>{if(("number"!=typeof pe.wasm.initTimeout||pe.wasm.initTimeout<0)&&(pe.wasm.initTimeout=0),!1===pe.wasm.simd&&console.warn(\'Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.\'),"boolean"!=typeof pe.wasm.proxy&&(pe.wasm.proxy=!1),"boolean"!=typeof pe.wasm.trace&&(pe.wasm.trace=!1),"number"!=typeof pe.wasm.numThreads||!Number.isInteger(pe.wasm.numThreads)||pe.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)pe.wasm.numThreads=1;else{let e=typeof navigator>"u"?Ue("node:os").cpus().length:navigator.hardwareConcurrency;pe.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},rp=new(np=class{async init(e){tp(),await Fc(),await Uc(e)}async createInferenceSessionHandler(e,t){let n=new Xc;return await n.loadModel(e,t),Promise.resolve(n)}})}));dt(),dt(),dt();var ip=ut;{let e=(sp(),We(ep)).wasmBackend;ae("webgpu",e,5),ae("webnn",e,5),ae("cpu",e,10),ae("wasm",e,10)}Object.defineProperty(pe.versions,"web",{value:"1.21.0-dev.20241205-d27fecd3d3",enumerable:!0});new Map;let ap="warning";const op={wasm:{},webgl:{},webgpu:{},versions:{common:"1.20.1"},set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);ap=e}},get logLevel(){return ap}};Object.defineProperty(op,"logLevel",{enumerable:!0});const lp=(e,t)=>{if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");const{height:n,width:r}=t,s=t.norm??{mean:255,bias:0};let i,a;i="number"==typeof s.mean?[s.mean,s.mean,s.mean,s.mean]:[s.mean[0],s.mean[1],s.mean[2],s.mean[3]??255],a="number"==typeof s.bias?[s.bias,s.bias,s.bias,s.bias]:[s.bias[0],s.bias[1],s.bias[2],s.bias[3]??0];const o=void 0!==t.format?t.format:"RGBA",l=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",u=n*r,d="RGBA"===l?new Float32Array(4*u):new Float32Array(3*u);let c=4,p=0,h=1,f=2,m=3,_=0,g=u,w=2*u,y=-1;"RGB"===o&&(c=3,p=0,h=1,f=2,m=-1),"RGBA"===l?y=3*u:"RBG"===l?(_=0,w=u,g=2*u):"BGR"===l&&(w=0,g=u,_=2*u);for(let t=0;t<u;t++,p+=c,f+=c,h+=c,m+=c)d[_++]=(e[p]+a[0])/i[0],d[g++]=(e[h]+a[1])/i[1],d[w++]=(e[f]+a[2])/i[2],-1!==y&&-1!==m&&(d[y++]=(e[m]+a[3])/i[3]);return new pp("float32",d,"RGBA"===l?[1,4,n,r]:[1,3,n,r])},up=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),dp=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let cp=!1;class pp{constructor(e,t,n){let r,s;if((()=>{if(!cp){cp=!0;const e="undefined"!=typeof BigInt64Array&&BigInt64Array.from,t="undefined"!=typeof BigUint64Array&&BigUint64Array.from,n="undefined"!=typeof Float16Array&&Float16Array.from;e&&(up.set("int64",BigInt64Array),dp.set(BigInt64Array,"int64")),t&&(up.set("uint64",BigUint64Array),dp.set(BigUint64Array,"uint64")),n?(up.set("float16",Float16Array),dp.set(Float16Array,"float16")):up.set("float16",Uint16Array)}})(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,r=e.type,s=e.dims,e.location){case"cpu-pinned":{const t=up.get(r);if(!t)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw new TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"uint8"!==r&&"bool"!==r&&"uint4"!==r&&"int4"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;case"ml-tensor":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"uint64"!==r&&"int8"!==r&&"uint8"!==r&&"bool"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break;default:throw new Error(`Tensor constructor: unsupported location \'${this.dataLocation}\'`)}else{let i,a;if("string"==typeof e)if(r=e,a=n,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor\'s data must be a string array.");i=t}else{const n=up.get(e);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e&&n===Uint16Array||"uint4"===e||"int4"===e)throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${n.name} as data.`);i="uint64"===e||"int64"===e?n.from(t,BigInt):n.from(t)}else if(t instanceof n)i=t;else{if(!(t instanceof Uint8ClampedArray))throw new TypeError(`A ${r} tensor\'s data must be type of ${n}`);if("uint8"!==e)throw new TypeError("A Uint8ClampedArray tensor\'s data must be type of uint8");i=Uint8Array.from(t)}}else if(a=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");const t=typeof e[0];if("string"===t)r="string",i=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);r="bool",i=Uint8Array.from(e)}}else if(e instanceof Uint8ClampedArray)r="uint8",i=Uint8Array.from(e);else{const t=dp.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=t,i=e}if(void 0===a)a=[i.length];else if(!Array.isArray(a))throw new TypeError("A tensor\'s dims must be a number array");s=a,this.cpuData=i,this.dataLocation="cpu"}const i=(e=>{let t=1;for(let n=0;n<e.length;n++){const r=e[n];if("number"!=typeof r||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t})(s);if(this.cpuData&&i!==this.cpuData.length&&("uint4"!==r&&"int4"!==r||Math.ceil(i/2)!==this.cpuData.length))throw new Error(`Tensor\'s size(${i}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=s,this.size=i}static async fromImage(e,t){return(async(e,t)=>{const n="undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement,r="undefined"!=typeof ImageData&&e instanceof ImageData,s="undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap,i="string"==typeof e;let a,o=t??{};const l=()=>{if("undefined"!=typeof document)return document.createElement("canvas");if("undefined"!=typeof OffscreenCanvas)return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},u=e=>"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas?e.getContext("2d"):null;if(n){const n=l();n.width=e.width,n.height=e.height;const r=u(n);if(null==r)throw new Error("Can not access image data");{let n=e.height,s=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(n=t.resizedHeight,s=t.resizedWidth),void 0!==t){if(o=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");o.tensorFormat="RGBA",o.height=n,o.width=s}else o.tensorFormat="RGBA",o.height=n,o.width=s;r.drawImage(e,0,0),a=r.getImageData(0,0,s,n).data}}else{if(!r){if(s){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");const n=l();n.width=e.width,n.height=e.height;const r=u(n);if(null!=r){const t=e.height,n=e.width;return r.drawImage(e,0,0,n,t),a=r.getImageData(0,0,n,t).data,o.height=t,o.width=n,lp(a,o)}throw new Error("Can not access image data")}if(i)return new Promise(((t,n)=>{const r=l(),s=u(r);if(!e||!s)return n();const i=new Image;i.crossOrigin="Anonymous",i.src=e,i.onload=()=>{r.width=i.width,r.height=i.height,s.drawImage(i,0,0,r.width,r.height);const e=s.getImageData(0,0,r.width,r.height);o.height=r.height,o.width=r.width,t(lp(e.data,o))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{let n,r;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(n=t.resizedHeight,r=t.resizedWidth):(n=e.height,r=e.width),void 0!==t&&(o=t),o.format="RGBA",o.height=n,o.width=r,void 0!==t){const t=l();t.width=r,t.height=n;const s=u(t);if(null==s)throw new Error("Can not access image data");s.putImageData(e,0,0),a=s.getImageData(0,0,r,n).data}else a=e.data}}if(void 0!==a)return lp(a,o);throw new Error("Input data provided is not supported - aborted tensor creation")})(e,t)}static fromTexture(e,t){return((e,t)=>{const{width:n,height:r,download:s,dispose:i}=t;return new pp({location:"texture",type:"float32",texture:e,dims:[1,r,n,4],download:s,dispose:i})})(e,t)}static fromGpuBuffer(e,t){return((e,t)=>{const{dataType:n,dims:r,download:s,dispose:i}=t;return new pp({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:r,download:s,dispose:i})})(e,t)}static fromMLTensor(e,t){return((e,t)=>{const{dataType:n,dims:r,download:s,dispose:i}=t;return new pp({location:"ml-tensor",type:n??"float32",mlTensor:e,dims:r,download:s,dispose:i})})(e,t)}static fromPinnedBuffer(e,t,n){return((e,t,n)=>new pp({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]}))(e,t,n)}toDataURL(e){return((e,t)=>{const n="undefined"!=typeof document?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];const r=n.getContext("2d");if(null!=r){let s,i;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(s=e.dims[2],i=e.dims[3]):(s=e.dims[3],i=e.dims[2]);const a=void 0!==t?.format?t.format:"RGB",o=t?.norm;let l,u;void 0===o||void 0===o.mean?l=[255,255,255,255]:"number"==typeof o.mean?l=[o.mean,o.mean,o.mean,o.mean]:(l=[o.mean[0],o.mean[1],o.mean[2],0],void 0!==o.mean[3]&&(l[3]=o.mean[3])),void 0===o||void 0===o.bias?u=[0,0,0,0]:"number"==typeof o.bias?u=[o.bias,o.bias,o.bias,o.bias]:(u=[o.bias[0],o.bias[1],o.bias[2],0],void 0!==o.bias[3]&&(u[3]=o.bias[3]));const d=i*s;let c=0,p=d,h=2*d,f=-1;"RGBA"===a?(c=0,p=d,h=2*d,f=3*d):"RGB"===a?(c=0,p=d,h=2*d):"RBG"===a&&(c=0,h=d,p=2*d);for(let t=0;t<i;t++)for(let n=0;n<s;n++){const s=(e.data[c++]-u[0])*l[0],i=(e.data[p++]-u[1])*l[1],a=(e.data[h++]-u[2])*l[2],o=-1===f?255:(e.data[f++]-u[3])*l[3];r.fillStyle="rgba("+s+","+i+","+a+","+o+")",r.fillRect(n,t,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}throw new Error("Can not access image data")})(this,e)}toImageData(e){return((e,t)=>{const n="undefined"!=typeof document?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let r;if(null==n)throw new Error("Can not access image data");{let s,i,a;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(s=e.dims[2],i=e.dims[1],a=e.dims[3]):(s=e.dims[3],i=e.dims[2],a=e.dims[1]);const o=void 0!==t&&void 0!==t.format?t.format:"RGB",l=t?.norm;let u,d;void 0===l||void 0===l.mean?u=[255,255,255,255]:"number"==typeof l.mean?u=[l.mean,l.mean,l.mean,l.mean]:(u=[l.mean[0],l.mean[1],l.mean[2],255],void 0!==l.mean[3]&&(u[3]=l.mean[3])),void 0===l||void 0===l.bias?d=[0,0,0,0]:"number"==typeof l.bias?d=[l.bias,l.bias,l.bias,l.bias]:(d=[l.bias[0],l.bias[1],l.bias[2],0],void 0!==l.bias[3]&&(d[3]=l.bias[3]));const c=i*s;if(void 0!==t&&(void 0!==t.format&&4===a&&"RGBA"!==t.format||3===a&&"RGB"!==t.format&&"BGR"!==t.format))throw new Error("Tensor format doesn\'t match input tensor dims");const p=4;let h=0,f=1,m=2,_=3,g=0,w=c,y=2*c,b=-1;"RGBA"===o?(g=0,w=c,y=2*c,b=3*c):"RGB"===o?(g=0,w=c,y=2*c):"RBG"===o&&(g=0,y=c,w=2*c),r=n.createImageData(s,i);for(let t=0;t<i*s;h+=p,f+=p,m+=p,_+=p,t++)r.data[h]=(e.data[g++]-d[0])*u[0],r.data[f]=(e.data[w++]-d[1])*u[1],r.data[m]=(e.data[y++]-d[2])*u[2],r.data[_]=-1===b?255:(e.data[b++]-d[3])*u[3]}return r})(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return((e,t)=>{switch(e.location){case"cpu":return new pp(e.type,e.data,t);case"cpu-pinned":return new pp({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new pp({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new pp({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new pp({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}})(this,e)}}const hp=pp;const fp=Object.freeze({auto:null,gpu:null,cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:{name:"webnn",deviceType:"cpu"},"webnn-npu":{name:"webnn",deviceType:"npu"},"webnn-gpu":{name:"webnn",deviceType:"gpu"},"webnn-cpu":{name:"webnn",deviceType:"cpu"}}),mp=[];let _p,gp;const wp=Symbol.for("onnxruntime");if(wp in globalThis)gp=globalThis[wp];else if(g.IS_NODE_ENV){switch(gp=Ne??Pe,process.platform){case"win32":mp.push("dml");break;case"linux":"x64"===process.arch&&mp.push("cuda")}mp.push("cpu"),_p=["cpu"]}else gp=e,g.IS_WEBNN_AVAILABLE&&mp.push("webnn-npu","webnn-gpu","webnn-cpu","webnn"),g.IS_WEBGPU_AVAILABLE&&mp.push("webgpu"),mp.push("wasm"),_p=["wasm"];const yp=gp.InferenceSession;let bp=null;async function xp(e,t,n){bp&&await bp;const r=yp.create(e,t);bp??=r;const s=await r;return s.config=n,s}function vp(e){return e instanceof gp.Tensor}const $p=gp?.env;function kp(){return $p?.wasm?.proxy}$p?.wasm&&($p.wasm.wasmPaths=`https://cdn.jsdelivr.net/npm/@huggingface/transformers@${v.version}/dist/`,$p.wasm.proxy=!1,"undefined"!=typeof crossOriginIsolated&&crossOriginIsolated||($p.wasm.numThreads=1)),$p?.webgpu&&($p.webgpu.powerPreference="high-performance"),v.backends.onnx=$p;const Ep=async(e,t,n)=>{const r=await xp(new Uint8Array(e),t);return async e=>{const t=Object.fromEntries(Object.entries(e).map((([e,t])=>[e,t.ort_tensor]))),s=await r.run(t);return Array.isArray(n)?n.map((e=>new Cp(s[e]))):new Cp(s[n])}};class Sp{static session_options={};static get bilinear_interpolate_4d(){return this._bilinear_interpolate_4d||(this._bilinear_interpolate_4d=Ep([8,9,18,0,58,128,1,10,40,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,17,10,4,109,111,100,101,34,6,108,105,110,101,97,114,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bilinear_interpolate_4d}static get bicubic_interpolate_4d(){return this._bicubic_interpolate_4d||(this._bicubic_interpolate_4d=Ep([8,9,18,0,58,127,10,39,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,16,10,4,109,111,100,101,34,5,99,117,98,105,99,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bicubic_interpolate_4d}static get matmul(){return this._matmul||(this._matmul=Ep([8,9,18,0,58,55,10,17,10,1,97,10,1,98,18,1,99,34,6,77,97,116,77,117,108,18,1,114,90,9,10,1,97,18,4,10,2,8,1,90,9,10,1,98,18,4,10,2,8,1,98,9,10,1,99,18,4,10,2,8,1,66,2,16,20],this.session_options,"c")),this._matmul}static get stft(){return this._stft||(this._stft=Ep([8,7,18,0,58,148,1,10,38,10,1,115,10,1,106,10,1,119,10,1,108,18,1,111,34,4,83,84,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,115,90,26,10,1,115,18,21,10,19,8,1,18,15,10,3,18,1,98,10,3,18,1,115,10,3,18,1,99,90,11,10,1,106,18,6,10,4,8,7,18,0,90,16,10,1,119,18,11,10,9,8,1,18,5,10,3,18,1,119,90,11,10,1,108,18,6,10,4,8,7,18,0,98,31,10,1,111,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,102,10,3,18,1,100,10,3,18,1,99,66,2,16,17],this.session_options,"o")),this._stft}static get rfft(){return this._rfft||(this._rfft=Ep([8,9,18,0,58,97,10,33,10,1,120,10,0,10,1,97,18,1,121,34,3,68,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,100,90,21,10,1,120,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,90,11,10,1,97,18,6,10,4,8,7,18,0,98,21,10,1,121,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,66,2,16,20],this.session_options,"y")),this._rfft}static get top_k(){return this._top_k||(this._top_k=Ep([8,10,18,0,58,73,10,18,10,1,120,10,1,107,18,1,118,18,1,105,34,4,84,111,112,75,18,1,116,90,9,10,1,120,18,4,10,2,8,1,90,15,10,1,107,18,10,10,8,8,7,18,4,10,2,8,1,98,9,10,1,118,18,4,10,2,8,1,98,9,10,1,105,18,4,10,2,8,7,66,2,16,21],this.session_options,["v","i"])),this._top_k}static get slice(){return this._slice||(this._slice=Ep([8,7,18,0,58,96,10,25,10,1,120,10,1,115,10,1,101,10,1,97,10,1,116,18,1,121,34,5,83,108,105,99,101,18,1,114,90,9,10,1,120,18,4,10,2,8,1,90,9,10,1,115,18,4,10,2,8,7,90,9,10,1,101,18,4,10,2,8,7,90,9,10,1,97,18,4,10,2,8,7,90,9,10,1,116,18,4,10,2,8,7,98,9,10,1,121,18,4,10,2,8,1,66,2,16,13],this.session_options,"y")),this._slice}}const zp=Object.freeze({float32:Float32Array,float16:Uint16Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array,uint4:Uint8Array,int4:Int8Array});class Cp{get dims(){return this.ort_tensor.dims}set dims(e){this.ort_tensor.dims=e}get type(){return this.ort_tensor.type}get data(){return this.ort_tensor.data}get size(){return this.ort_tensor.size}get location(){return this.ort_tensor.location}ort_tensor;constructor(...e){return vp(e[0])?this.ort_tensor=e[0]:this.ort_tensor=new hp(e[0],e[1],e[2]),new Proxy(this,{get:(e,t)=>{if("string"==typeof t){let n=Number(t);if(Number.isInteger(n))return e._getitem(n)}return e[t]},set:(e,t,n)=>e[t]=n})}dispose(){this.ort_tensor.dispose()}*[Symbol.iterator](){const[e,...t]=this.dims;if(t.length>0){const n=t.reduce(((e,t)=>e*t));for(let r=0;r<e;++r)yield this._subarray(r,n,t)}else yield*this.data}_getitem(e){const[t,...n]=this.dims;if(e=Pp(e,t),n.length>0){const t=n.reduce(((e,t)=>e*t));return this._subarray(e,t,n)}return new Cp(this.type,[this.data[e]],n)}indexOf(e){const t=this.data;for(let n=0;n<t.length;++n)if(t[n]==e)return n;return-1}_subarray(e,t,n){const r=e*t,s=(e+1)*t,i="subarray"in this.data?this.data.subarray(r,s):this.data.slice(r,s);return new Cp(this.type,i,n)}item(){const e=this.data;if(1!==e.length)throw new Error(`a Tensor with ${e.length} elements cannot be converted to Scalar`);return e[0]}tolist(){return function e(t,n){const r=t.length,s=n.reduce(((e,t)=>e*t));if(r!==s)throw Error(`cannot reshape array of size ${r} into shape (${n})`);let i=t;for(let e=n.length-1;e>=0;e--)i=i.reduce(((t,r)=>{let s=t[t.length-1];return s.length<n[e]?s.push(r):t.push([r]),t}),[[]]);return i[0]}(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){const e=this.data;for(let t=0;t<e.length;++t)e[t]=1/(1+Math.exp(-e[t]));return this}map(e){return this.clone().map_(e)}map_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]=e(t[n],n,t);return this}mul(e){return this.clone().mul_(e)}mul_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]*=e;return this}div(e){return this.clone().div_(e)}div_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]/=e;return this}add(e){return this.clone().add_(e)}add_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]+=e;return this}sub(e){return this.clone().sub_(e)}sub_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]-=e;return this}clone(){return new Cp(this.type,this.data.slice(),this.dims.slice())}slice(...e){const t=[],n=[];for(let r=0;r<this.dims.length;++r){let s=e[r];if(null==s)n.push([0,this.dims[r]]),t.push(this.dims[r]);else if("number"==typeof s)s=Pp(s,this.dims[r],r),n.push([s,s+1]);else{if(!Array.isArray(s)||2!==s.length)throw new Error(`Invalid slice: ${s}`);{let[e,i]=s;if(e=null===e?0:Pp(e,this.dims[r],r,!1),i=null===i?this.dims[r]:Pp(i,this.dims[r],r,!1),e>i)throw new Error(`Invalid slice: ${s}`);const a=[Math.max(e,0),Math.min(i,this.dims[r])];n.push(a),t.push(a[1]-a[0])}}}const r=n.map((([e,t])=>t-e)),s=r.reduce(((e,t)=>e*t)),i=this.data,a=new i.constructor(s),o=this.stride();for(let e=0;e<s;++e){let t=0;for(let s=r.length-1,i=e;s>=0;--s){const e=r[s];t+=(i%e+n[s][0])*o[s],i=Math.floor(i/e)}a[e]=i[t]}return new Cp(this.type,a,t)}permute(...e){return function t(e,n){const[r,s]=function i(e,t,n){const r=new Array(n.length),s=new Array(n.length);for(let e=n.length-1,i=1;e>=0;--e)s[e]=i,r[e]=t[n[e]],i*=r[e];const i=n.map(((e,t)=>s[n.indexOf(t)])),a=new e.constructor(e.length);for(let n=0;n<e.length;++n){let r=0;for(let e=t.length-1,s=n;e>=0;--e)r+=s%t[e]*i[e],s=Math.floor(s/t[e]);a[r]=e[n]}return[a,r]}(e.data,e.dims,n);return new Cp(e.type,r,s)}(this,e)}transpose(...e){return this.permute(...e)}sum(e=null,t=!1){return this.norm(1,e,t)}norm(e="fro",t=null,n=!1){if("fro"===e)e=2;else if("string"==typeof e)throw Error(`Unsupported norm: ${e}`);const r=this.data;if(null===t){let t=r.reduce(((t,n)=>t+n**e),0)**(1/e);return new Cp(this.type,[t],[])}t=Pp(t,this.dims.length);const s=this.dims.slice();s[t]=1;const i=new r.constructor(r.length/this.dims[t]);for(let n=0;n<r.length;++n){let a=0;for(let e=this.dims.length-1,r=n,i=1;e>=0;--e){const n=this.dims[e];if(e!==t){a+=r%n*i,i*=s[e]}r=Math.floor(r/n)}i[a]+=r[n]**e}if(1!==e)for(let t=0;t<i.length;++t)i[t]=i[t]**(1/e);return n||s.splice(t,1),new Cp(this.type,i,s)}normalize_(e=2,t=1){t=Pp(t,this.dims.length);const n=this.norm(e,t,!0),r=this.data,s=n.data;for(let e=0;e<r.length;++e){let n=0;for(let r=this.dims.length-1,s=e,i=1;r>=0;--r){const e=this.dims[r];if(r!==t){n+=s%e*i,i*=this.dims[r]}s=Math.floor(s/e)}r[e]/=s[n]}return this}normalize(e=2,t=1){return this.clone().normalize_(e,t)}stride(){return function e(t){const n=new Array(t.length);for(let e=t.length-1,r=1;e>=0;--e)n[e]=r,r*=t[e];return n}(this.dims)}squeeze(e=null){return new Cp(this.type,this.data,Bp(this.dims,e))}squeeze_(e=null){return this.dims=Bp(this.dims,e),this}unsqueeze(e=null){return new Cp(this.type,this.data,Np(this.dims,e))}unsqueeze_(e=null){return this.dims=Np(this.dims,e),this}flatten_(e=0,t=-1){t=(t+this.dims.length)%this.dims.length;let n=this.dims.slice(0,e),r=this.dims.slice(e,t+1),s=this.dims.slice(t+1);return this.dims=[...n,r.reduce(((e,t)=>e*t),1),...s],this}flatten(e=0,t=-1){return this.clone().flatten_(e,t)}view(...e){let t=-1;for(let n=0;n<e.length;++n)if(-1===e[n]){if(-1!==t)throw new Error("Only one dimension can be inferred");t=n}const n=this.data;if(-1!==t){const r=e.reduce(((e,n,r)=>r!==t?e*n:e),1);e[t]=n.length/r}return new Cp(this.type,n,e)}neg_(){const e=this.data;for(let t=0;t<e.length;++t)e[t]=-e[t];return this}neg(){return this.clone().neg_()}clamp_(e,t){const n=this.data;for(let r=0;r<n.length;++r)n[r]=Math.min(Math.max(n[r],e),t);return this}clamp(e,t){return this.clone().clamp_(e,t)}round_(){const e=this.data;for(let t=0;t<e.length;++t)e[t]=Math.round(e[t]);return this}round(){return this.clone().round_()}mean(e=null,t=!1){return Fp(this,e,t)}to(e){if(this.type===e)return this;if(!zp.hasOwnProperty(e))throw new Error(`Unsupported type: ${e}`);let t;const n=["int64","uint64"].includes(this.type),r=["int64","uint64"].includes(e);return n&&!r?t=Number:!n&&r&&(t=BigInt),new Cp(e,zp[e].from(this.data,t),this.dims)}}function Tp(e,[t,n],r="bilinear",s=!1){const i=e.dims.at(-3)??1,a=e.dims.at(-2),o=e.dims.at(-1);let l=function u(e,[t,n,r],[s,i],a="bilinear",o=!1){const l=i/r,u=s/n,d=new e.constructor(s*i*t),c=n*r,p=s*i;for(let a=0;a<s;++a)for(let s=0;s<i;++s){const o=a*i+s,h=(s+.5)/l-.5,f=(a+.5)/u-.5;let m=Math.floor(h),_=Math.floor(f);const g=Math.min(m+1,r-1),w=Math.min(_+1,n-1);m=Math.max(m,0),_=Math.max(_,0);const y=h-m,b=f-_,x=(1-y)*(1-b),v=y*(1-b),$=(1-y)*b,k=y*b,E=_*r,S=w*r,z=E+m,C=E+g,T=S+m,A=S+g;for(let n=0;n<t;++n){const t=n*c;d[n*p+o]=x*e[t+z]+v*e[t+C]+$*e[t+T]+k*e[t+A]}}return d}(e.data,[i,a,o],[t,n],r,s);return new Cp(e.type,l,[i,t,n])}async function Ap(e,{size:t=null,mode:n="bilinear"}={}){if(4!==e.dims.length)throw new Error("`interpolate_4d` currently only supports 4D input.");if(!t)throw new Error("`interpolate_4d` requires a `size` argument.");let r,s;if(2===t.length)r=[...e.dims.slice(0,2),...t];else if(3===t.length)r=[e.dims[0],...t];else{if(4!==t.length)throw new Error("`size` must be of length 2, 3, or 4.");r=t}if("bilinear"===n)s=await Sp.bilinear_interpolate_4d;else{if("bicubic"!==n)throw new Error(`Unsupported mode: ${n}`);s=await Sp.bicubic_interpolate_4d}const i=new Cp("int64",new BigInt64Array(r.map(BigInt)),[r.length]);return await s({x:e,s:i})}async function Ip(e,t){const n=await Sp.top_k;return t=null===t?e.dims.at(-1):Math.min(t,e.dims.at(-1)),await n({x:e,k:new Cp("int64",[BigInt(t)],[1])})}const Mp=e=>new Cp("int64",e,[e.length]);async function Op(e,t,n,r,s){const i=await Sp.slice;return await i({x:e,s:Mp(t),e:Mp(n),a:Mp(r),t:Mp(s??new Array(r.length).fill(1))})}function Bp(e,t){return e=e.slice(),null===t?e=e.filter((e=>1!==e)):"number"==typeof t?1===e[t]&&e.splice(t,1):Array.isArray(t)&&(e=e.filter(((e,n)=>1!==e||!t.includes(n)))),e}function Np(e,t){return t=Pp(t,e.length+1),(e=e.slice()).splice(t,0,1),e}function Pp(e,t,n=null,r=!0){if(r&&(e<-t||e>=t))throw new Error(`IndexError: index ${e} is out of bounds for dimension${null===n?"":" "+n} with size ${t}`);return e<0&&(e=(e%t+t)%t),e}function Rp(e,t=0){t=Pp(t,e[0].dims.length);const n=e[0].dims.slice();n[t]=e.reduce(((e,n)=>e+n.dims[t]),0);const r=n.reduce(((e,t)=>e*t),1),s=new e[0].data.constructor(r),i=e[0].type;if(0===t){let t=0;for(const n of e){const e=n.data;s.set(e,t),t+=e.length}}else{let r=0;for(let i=0;i<e.length;++i){const{data:a,dims:o}=e[i];for(let e=0;e<a.length;++e){let i=0;for(let s=o.length-1,a=e,l=1;s>=0;--s){const e=o[s];let u=a%e;s===t&&(u+=r),i+=u*l,l*=n[s],a=Math.floor(a/e)}s[i]=a[e]}r+=o[t]}}return new Cp(i,s,n)}function Dp(e,t=0){return Rp(e.map((e=>e.unsqueeze(t))),t)}function Lp(e,t=null,n=1,r=!1){const s=e.data,i=e.dims;if(null===t){const t=s.reduce(((e,t)=>e+t),0)/s.length,r=Math.sqrt(s.reduce(((e,n)=>e+(n-t)**2),0)/(s.length-n)),i=new Cp(e.type,[t],[]);return[new Cp(e.type,[r],[]),i]}const a=Fp(e,t=Pp(t,i.length),r),o=a.data,l=i.slice();l[t]=1;const u=new s.constructor(s.length/i[t]);for(let e=0;e<s.length;++e){let n=0;for(let r=i.length-1,s=e,a=1;r>=0;--r){const e=i[r];if(r!==t){n+=s%e*a,a*=l[r]}s=Math.floor(s/e)}u[n]+=(s[e]-o[n])**2}for(let e=0;e<u.length;++e)u[e]=Math.sqrt(u[e]/(i[t]-n));r||l.splice(t,1);return[new Cp(e.type,u,l),a]}function Fp(e,t=null,n=!1){const r=e.data;if(null===t){const t=r.reduce(((e,t)=>e+t),0);return new Cp(e.type,[t/r.length],[])}const s=e.dims;t=Pp(t,s.length);const i=s.slice();i[t]=1;const a=new r.constructor(r.length/s[t]);for(let e=0;e<r.length;++e){let n=0;for(let r=s.length-1,a=e,o=1;r>=0;--r){const e=s[r];if(r!==t){n+=a%e*o,o*=i[r]}a=Math.floor(a/e)}a[n]+=r[e]}if(1!==s[t])for(let e=0;e<a.length;++e)a[e]=a[e]/s[t];return n||i.splice(t,1),new Cp(e.type,a,i)}function Up(e,t,n,r){const s=e.reduce(((e,t)=>e*t),1);return new Cp(n,new r(s).fill(t),e)}function qp(e,t){let n,r;if("number"==typeof t)n="float32",r=Float32Array;else if("bigint"==typeof t)n="int64",r=BigInt64Array;else{if("boolean"!=typeof t)throw new Error("Unsupported data type: "+typeof t);n="bool",r=Uint8Array}return Up(e,t,n,r)}function Vp(e,t){return qp(e.dims,t)}function Wp(e){return Up(e,1n,"int64",BigInt64Array)}function jp(e){return Wp(e.dims)}function Gp(e){return Up(e,0n,"int64",BigInt64Array)}class Hp{constructor(e=((e,t)=>e>t),t=Infinity){this._heap=[],this._comparator=e,this._maxSize=t}get size(){return this._heap.length}isEmpty(){return 0===this.size}peek(){return this._heap[0]}push(...e){return this.extend(e)}extend(e){for(const t of e)if(this.size<this._maxSize)this._heap.push(t),this._siftUp();else{const e=this._smallest();this._comparator(t,this._heap[e])&&(this._heap[e]=t,this._siftUpFrom(e))}return this.size}pop(){const e=this.peek(),t=this.size-1;return t>0&&this._swap(0,t),this._heap.pop(),this._siftDown(),e}replace(e){const t=this.peek();return this._heap[0]=e,this._siftDown(),t}_parent(e){return(e+1>>>1)-1}_left(e){return 1+(e<<1)}_right(e){return e+1<<1}_greater(e,t){return this._comparator(this._heap[e],this._heap[t])}_swap(e,t){const n=this._heap[e];this._heap[e]=this._heap[t],this._heap[t]=n}_siftUp(){this._siftUpFrom(this.size-1)}_siftUpFrom(e){for(;e>0&&this._greater(e,this._parent(e));)this._swap(e,this._parent(e)),e=this._parent(e)}_siftDown(){let e=0;for(;this._left(e)<this.size&&this._greater(this._left(e),e)||this._right(e)<this.size&&this._greater(this._right(e),e);){const t=this._right(e)<this.size&&this._greater(this._right(e),this._left(e))?this._right(e):this._left(e);this._swap(e,t),e=t}}_smallest(){return 2**Math.floor(Math.log2(this.size))-1}}class Kp{constructor(){this.root=Xp.default()}extend(e){for(const t of e)this.push(t)}push(e){let t=this.root;for(const n of e){let e=t.children.get(n);void 0===e&&(e=Xp.default(),t.children.set(n,e)),t=e}t.isLeaf=!0}*commonPrefixSearch(e){let t=this.root;if(void 0===t)return;let n="";for(const r of e){if(n+=r,t=t.children.get(r),void 0===t)return;t.isLeaf&&(yield n)}}}class Xp{constructor(e,t){this.isLeaf=e,this.children=t}static default(){return new Xp(!1,new Map)}}class Qp{constructor(e,t,n){this.chars=Array.from(e),this.len=this.chars.length,this.bosTokenId=t,this.eosTokenId=n,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},(()=>[])),this.endNodes=Array.from({length:this.len+1},(()=>[]));const r=new Yp(this.bosTokenId,0,0,0,0),s=new Yp(this.eosTokenId,1,this.len,0,0);this.nodes.push(r.clone()),this.nodes.push(s.clone()),this.beginNodes[this.len].push(s),this.endNodes[0].push(r)}insert(e,t,n,r){const s=this.nodes.length,i=new Yp(r,s,e,t,n);this.beginNodes[e].push(i),this.endNodes[e+t].push(i),this.nodes.push(i)}viterbi(){const e=this.len;let t=0;for(;t<=e;){if(0==this.beginNodes[t].length)return[];for(let e of this.beginNodes[t]){e.prev=null;let n=0,r=null;for(let s of this.endNodes[t]){const t=s.backtraceScore+e.score;(null===r||t>n)&&(r=s.clone(),n=t)}if(null===r)return[];e.prev=r,e.backtraceScore=n}++t}const n=[],r=this.beginNodes[e][0].prev;if(null===r)return[];let s=r.clone();for(;null!==s.prev;){n.push(s.clone());const e=s.clone();s=e.prev.clone()}return n.reverse(),n}piece(e){return this.chars.slice(e.pos,e.pos+e.length).join("")}tokens(){return this.viterbi().map((e=>this.piece(e)))}tokenIds(){return this.viterbi().map((e=>e.tokenId))}}class Yp{constructor(e,t,n,r,s){this.tokenId=e,this.nodeId=t,this.pos=n,this.length=r,this.score=s,this.prev=null,this.backtraceScore=0}clone(){const e=new Yp(this.tokenId,this.nodeId,this.pos,this.length,this.score);return e.prev=this.prev,e.backtraceScore=this.backtraceScore,e}}var Zp=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",NullLiteral:"NullLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",Is:"Is",NotIn:"NotIn",Else:"Else",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator",Macro:"Macro",EndMacro:"EndMacro"}),Jp=Object.freeze({set:Zp.Set,for:Zp.For,in:Zp.In,is:Zp.Is,if:Zp.If,else:Zp.Else,endif:Zp.EndIf,elif:Zp.ElseIf,endfor:Zp.EndFor,and:Zp.And,or:Zp.Or,not:Zp.Not,"not in":Zp.NotIn,macro:Zp.Macro,endmacro:Zp.EndMacro,true:Zp.BooleanLiteral,false:Zp.BooleanLiteral,none:Zp.NullLiteral,True:Zp.BooleanLiteral,False:Zp.BooleanLiteral,None:Zp.NullLiteral}),eh=class{constructor(e,t){this.value=e,this.type=t}};function th(e){return/\\w/.test(e)}function nh(e){return/[0-9]/.test(e)}var rh=[["{%",Zp.OpenStatement],["%}",Zp.CloseStatement],["{{",Zp.OpenExpression],["}}",Zp.CloseExpression],["(",Zp.OpenParen],[")",Zp.CloseParen],["{",Zp.OpenCurlyBracket],["}",Zp.CloseCurlyBracket],["[",Zp.OpenSquareBracket],["]",Zp.CloseSquareBracket],[",",Zp.Comma],[".",Zp.Dot],[":",Zp.Colon],["|",Zp.Pipe],["<=",Zp.ComparisonBinaryOperator],[">=",Zp.ComparisonBinaryOperator],["==",Zp.ComparisonBinaryOperator],["!=",Zp.ComparisonBinaryOperator],["<",Zp.ComparisonBinaryOperator],[">",Zp.ComparisonBinaryOperator],["+",Zp.AdditiveBinaryOperator],["-",Zp.AdditiveBinaryOperator],["*",Zp.MultiplicativeBinaryOperator],["/",Zp.MultiplicativeBinaryOperator],["%",Zp.MultiplicativeBinaryOperator],["=",Zp.Equals]],sh=new Map([["n","\\n"],["t","\\t"],["r","\\r"],["b","\\b"],["f","\\f"],["v","\\v"],["\'","\'"],[\'"\',\'"\'],["\\\\","\\\\"]]);var ih=class{type="Statement"},ah=class extends ih{constructor(e){super(),this.body=e}type="Program"},oh=class extends ih{constructor(e,t,n){super(),this.test=e,this.body=t,this.alternate=n}type="If"},lh=class extends ih{constructor(e,t,n,r){super(),this.loopvar=e,this.iterable=t,this.body=n,this.defaultBlock=r}type="For"},uh=class extends ih{constructor(e,t){super(),this.assignee=e,this.value=t}type="Set"},dh=class extends ih{constructor(e,t,n){super(),this.name=e,this.args=t,this.body=n}type="Macro"},ch=class extends ih{type="Expression"},ph=class extends ch{constructor(e,t,n){super(),this.object=e,this.property=t,this.computed=n}type="MemberExpression"},hh=class extends ch{constructor(e,t){super(),this.callee=e,this.args=t}type="CallExpression"},fh=class extends ch{constructor(e){super(),this.value=e}type="Identifier"},mh=class extends ch{constructor(e){super(),this.value=e}type="Literal"},_h=class extends mh{type="NumericLiteral"},gh=class extends mh{type="StringLiteral"},wh=class extends mh{type="BooleanLiteral"},yh=class extends mh{type="NullLiteral"},bh=class extends mh{type="ArrayLiteral"},xh=class extends mh{type="TupleLiteral"},vh=class extends mh{type="ObjectLiteral"},$h=class extends ch{constructor(e,t,n){super(),this.operator=e,this.left=t,this.right=n}type="BinaryExpression"},kh=class extends ch{constructor(e,t){super(),this.operand=e,this.filter=t}type="FilterExpression"},Eh=class extends ch{constructor(e,t){super(),this.iterable=e,this.test=t}type="SelectExpression"},Sh=class extends ch{constructor(e,t,n){super(),this.operand=e,this.negate=t,this.test=n}type="TestExpression"},zh=class extends ch{constructor(e,t){super(),this.operator=e,this.argument=t}type="UnaryExpression"},Ch=class extends ch{constructor(e=void 0,t=void 0,n=void 0){super(),this.start=e,this.stop=t,this.step=n}type="SliceExpression"},Th=class extends ch{constructor(e,t){super(),this.key=e,this.value=t}type="KeywordArgumentExpression"};function Ah(e){const t=new ah([]);let n=0;function r(t,r){const s=e[n++];if(!s||s.type!==t)throw new Error(`Parser Error: ${r}. ${s.type} !== ${t}.`);return s}function s(){switch(e[n].type){case Zp.Text:return function t(){return new gh(r(Zp.Text,"Expected text token").value)}();case Zp.OpenStatement:return function c(){let t;switch(r(Zp.OpenStatement,"Expected opening statement token"),e[n].type){case Zp.Set:++n,t=o(),r(Zp.CloseStatement,"Expected closing statement token");break;case Zp.If:++n,t=l(),r(Zp.OpenStatement,"Expected {% token"),r(Zp.EndIf,"Expected endif token"),r(Zp.CloseStatement,"Expected %} token");break;case Zp.Macro:++n,t=function c(){const e=x();if("Identifier"!==e.type)throw new SyntaxError("Expected identifier following macro statement");const t=g();r(Zp.CloseStatement,"Expected closing statement token");const n=[];for(;i(Zp.OpenStatement,Zp.EndMacro);)n.push(s());return new dh(e,t,n)}(),r(Zp.OpenStatement,"Expected {% token"),r(Zp.EndMacro,"Expected endmacro token"),r(Zp.CloseStatement,"Expected %} token");break;case Zp.For:++n,t=function p(){const e=u(!0);if(!(e instanceof fh||e instanceof xh))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${e.type} instead`);r(Zp.In,"Expected `in` keyword following loop variable");const t=d();r(Zp.CloseStatement,"Expected closing statement token");const o=[];for(;i(Zp.OpenStatement,Zp.EndFor)&&i(Zp.OpenStatement,Zp.Else);)o.push(s());const l=[];if(a(Zp.OpenStatement,Zp.Else))for(++n,++n,r(Zp.CloseStatement,"Expected closing statement token");i(Zp.OpenStatement,Zp.EndFor);)l.push(s());return new lh(e,t,o,l)}(),r(Zp.OpenStatement,"Expected {% token"),r(Zp.EndFor,"Expected endfor token"),r(Zp.CloseStatement,"Expected %} token");break;default:throw new SyntaxError(`Unknown statement type: ${e[n].type}`)}return t}();case Zp.OpenExpression:return function p(){r(Zp.OpenExpression,"Expected opening expression token");const e=d();return r(Zp.CloseExpression,"Expected closing expression token"),e}();default:throw new SyntaxError(`Unexpected token type: ${e[n].type}`)}}function i(...t){return n+t.length<=e.length&&t.some(((t,r)=>t!==e[n+r].type))}function a(...t){return n+t.length<=e.length&&t.every(((t,r)=>t===e[n+r].type))}function o(){const e=d();if(a(Zp.Equals)){++n;const t=o();return new uh(e,t)}return e}function l(){const t=d();r(Zp.CloseStatement,"Expected closing statement token");const i=[],o=[];for(;e[n]?.type!==Zp.OpenStatement||e[n+1]?.type!==Zp.ElseIf&&e[n+1]?.type!==Zp.Else&&e[n+1]?.type!==Zp.EndIf;)i.push(s());if(e[n]?.type===Zp.OpenStatement&&e[n+1]?.type!==Zp.EndIf)if(++n,a(Zp.ElseIf))r(Zp.ElseIf,"Expected elseif token"),o.push(l());else for(r(Zp.Else,"Expected else token"),r(Zp.CloseStatement,"Expected closing statement token");e[n]?.type!==Zp.OpenStatement||e[n+1]?.type!==Zp.EndIf;)o.push(s());return new oh(t,i,o)}function u(e=!1){const t=e?x:d,r=[t()],s=a(Zp.Comma);for(;s&&(++n,r.push(t()),a(Zp.Comma)););return s?new xh(r):r[0]}function d(){return function e(){const e=c();if(a(Zp.If)){++n;const t=c();if(a(Zp.Else)){++n;const r=c();return new oh(t,[e],[r])}return new Eh(e,t)}return e}()}function c(){let t=p();for(;a(Zp.Or);){const r=e[n];++n;const s=p();t=new $h(r,t,s)}return t}function p(){let t=h();for(;a(Zp.And);){const r=e[n];++n;const s=h();t=new $h(r,t,s)}return t}function h(){let t;for(;a(Zp.Not);){const r=e[n];++n;const s=h();t=new zh(r,s)}return t??function r(){let t=f();for(;a(Zp.ComparisonBinaryOperator)||a(Zp.In)||a(Zp.NotIn);){const r=e[n];++n;const s=f();t=new $h(r,t,s)}return t}()}function f(){let t=y();for(;a(Zp.AdditiveBinaryOperator);){const r=e[n];++n;const s=y();t=new $h(r,t,s)}return t}function m(){const t=function s(){let t=x();for(;a(Zp.Dot)||a(Zp.OpenSquareBracket);){const s=e[n];let i;++n;const a=s.type!==Zp.Dot;if(a)i=w(),r(Zp.CloseSquareBracket,"Expected closing square bracket");else if(i=x(),"Identifier"!==i.type)throw new SyntaxError("Expected identifier following dot operator");t=new ph(t,i,a)}return t}();return a(Zp.OpenParen)?_(t):t}function _(e){let t=new hh(e,g());return a(Zp.OpenParen)&&(t=_(t)),t}function g(){r(Zp.OpenParen,"Expected opening parenthesis for arguments list");const e=function t(){const e=[];for(;!a(Zp.CloseParen);){let t=d();if(a(Zp.Equals)){if(++n,!(t instanceof fh))throw new SyntaxError("Expected identifier for keyword argument");const e=d();t=new Th(t,e)}e.push(t),a(Zp.Comma)&&++n}return e}();return r(Zp.CloseParen,"Expected closing parenthesis for arguments list"),e}function w(){const e=[];let t=!1;for(;!a(Zp.CloseSquareBracket);)a(Zp.Colon)?(e.push(void 0),++n,t=!0):(e.push(d()),a(Zp.Colon)&&(++n,t=!0));if(0===e.length)throw new SyntaxError("Expected at least one argument for member/slice expression");if(t){if(e.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new Ch(...e)}return e[0]}function y(){let t=b();for(;a(Zp.MultiplicativeBinaryOperator);){const r=e[n];++n;const s=b();t=new $h(r,t,s)}return t}function b(){let e=function t(){let e=m();for(;a(Zp.Pipe);){++n;let t=x();if(!(t instanceof fh))throw new SyntaxError("Expected identifier for the filter");a(Zp.OpenParen)&&(t=_(t)),e=new kh(e,t)}return e}();for(;a(Zp.Is);){++n;const t=a(Zp.Not);t&&++n;let r=x();if(r instanceof wh?r=new fh(r.value.toString()):r instanceof yh&&(r=new fh("none")),!(r instanceof fh))throw new SyntaxError("Expected identifier for the test");e=new Sh(e,t,r)}return e}function x(){const t=e[n];switch(t.type){case Zp.NumericLiteral:return++n,new _h(Number(t.value));case Zp.StringLiteral:return++n,new gh(t.value);case Zp.BooleanLiteral:return++n,new wh("true"===t.value.toLowerCase());case Zp.NullLiteral:return++n,new yh(null);case Zp.Identifier:return++n,new fh(t.value);case Zp.OpenParen:{++n;const t=u();if(e[n].type!==Zp.CloseParen)throw new SyntaxError(`Expected closing parenthesis, got ${e[n].type} instead`);return++n,t}case Zp.OpenSquareBracket:{++n;const e=[];for(;!a(Zp.CloseSquareBracket);)e.push(d()),a(Zp.Comma)&&++n;return++n,new bh(e)}case Zp.OpenCurlyBracket:{++n;const e=new Map;for(;!a(Zp.CloseCurlyBracket);){const t=d();r(Zp.Colon,"Expected colon between key and value in object literal");const s=d();e.set(t,s),a(Zp.Comma)&&++n}return++n,new vh(e)}default:throw new SyntaxError(`Unexpected token: ${t.type}`)}}for(;n<e.length;)t.body.push(s());return t}function Ih(e,t,n=1){void 0===t&&(t=e,e=0);const r=[];for(let s=e;s<t;s+=n)r.push(s);return r}function Mh(e,t,n,r=1){const s=Math.sign(r);s>=0?(t=(t??=0)<0?Math.max(e.length+t,0):Math.min(t,e.length),n=(n??=e.length)<0?Math.max(e.length+n,0):Math.min(n,e.length)):(t=(t??=e.length-1)<0?Math.max(e.length+t,-1):Math.min(t,e.length-1),n=(n??=-1)<-1?Math.max(e.length+n,-1):Math.min(n,e.length-1));const i=[];for(let a=t;s*a<s*n;a+=r)i.push(e[a]);return i}function Oh(e){return e.replace(/\\b\\w/g,(e=>e.toUpperCase()))}var Bh=class{type="RuntimeValue";value;builtins=new Map;constructor(e=void 0){this.value=e}__bool__(){return new Rh(!!this.value)}},Nh=class extends Bh{type="NumericValue"},Ph=class extends Bh{type="StringValue";builtins=new Map([["upper",new qh((()=>new Ph(this.value.toUpperCase())))],["lower",new qh((()=>new Ph(this.value.toLowerCase())))],["strip",new qh((()=>new Ph(this.value.trim())))],["title",new qh((()=>new Ph(Oh(this.value))))],["length",new Nh(this.value.length)],["rstrip",new qh((()=>new Ph(this.value.trimEnd())))],["lstrip",new qh((()=>new Ph(this.value.trimStart())))]])},Rh=class extends Bh{type="BooleanValue"},Dh=class extends Bh{type="ObjectValue";__bool__(){return new Rh(this.value.size>0)}builtins=new Map([["get",new qh((([e,t])=>{if(!(e instanceof Ph))throw new Error(`Object key must be a string: got ${e.type}`);return this.value.get(e.value)??t??new Vh}))],["items",new qh((()=>new Fh(Array.from(this.value.entries()).map((([e,t])=>new Fh([new Ph(e),t]))))))]])},Lh=class extends Dh{type="KeywordArgumentsValue"},Fh=class extends Bh{type="ArrayValue";builtins=new Map([["length",new Nh(this.value.length)]]);__bool__(){return new Rh(this.value.length>0)}},Uh=class extends Fh{type="TupleValue"},qh=class extends Bh{type="FunctionValue"},Vh=class extends Bh{type="NullValue"},Wh=class extends Bh{type="UndefinedValue"},jh=class{constructor(e){this.parent=e}variables=new Map([["namespace",new qh((e=>{if(0===e.length)return new Dh(new Map);if(1!==e.length||!(e[0]instanceof Dh))throw new Error("`namespace` expects either zero arguments or a single object argument");return e[0]}))]]);tests=new Map([["boolean",e=>"BooleanValue"===e.type],["callable",e=>e instanceof qh],["odd",e=>{if("NumericValue"!==e.type)throw new Error(`Cannot apply test "odd" to type: ${e.type}`);return e.value%2!=0}],["even",e=>{if("NumericValue"!==e.type)throw new Error(`Cannot apply test "even" to type: ${e.type}`);return e.value%2==0}],["false",e=>"BooleanValue"===e.type&&!e.value],["true",e=>"BooleanValue"===e.type&&e.value],["none",e=>"NullValue"===e.type],["string",e=>"StringValue"===e.type],["number",e=>"NumericValue"===e.type],["integer",e=>"NumericValue"===e.type&&Number.isInteger(e.value)],["iterable",e=>"ArrayValue"===e.type||"StringValue"===e.type],["mapping",e=>"ObjectValue"===e.type],["lower",e=>{const t=e.value;return"StringValue"===e.type&&t===t.toLowerCase()}],["upper",e=>{const t=e.value;return"StringValue"===e.type&&t===t.toUpperCase()}],["none",e=>"NullValue"===e.type],["defined",e=>"UndefinedValue"!==e.type],["undefined",e=>"UndefinedValue"===e.type],["equalto",(e,t)=>e.value===t.value],["eq",(e,t)=>e.value===t.value]]);set(e,t){return this.declareVariable(e,Hh(t))}declareVariable(e,t){if(this.variables.has(e))throw new SyntaxError(`Variable already declared: ${e}`);return this.variables.set(e,t),t}setVariable(e,t){return this.variables.set(e,t),t}resolve(e){if(this.variables.has(e))return this;if(this.parent)return this.parent.resolve(e);throw new Error(`Unknown variable: ${e}`)}lookupVariable(e){try{return this.resolve(e).variables.get(e)??new Wh}catch{return new Wh}}},Gh=class{global;constructor(e){this.global=e??new jh}run(e){return this.evaluate(e,this.global)}evaluateBinaryExpression(e,t){const n=this.evaluate(e.left,t);switch(e.operator.value){case"and":return n.__bool__().value?this.evaluate(e.right,t):n;case"or":return n.__bool__().value?n:this.evaluate(e.right,t)}const r=this.evaluate(e.right,t);switch(e.operator.value){case"==":return new Rh(n.value==r.value);case"!=":return new Rh(n.value!=r.value)}if(n instanceof Wh||r instanceof Wh)throw new Error("Cannot perform operation on undefined values");if(n instanceof Vh||r instanceof Vh)throw new Error("Cannot perform operation on null values");if(n instanceof Nh&&r instanceof Nh)switch(e.operator.value){case"+":return new Nh(n.value+r.value);case"-":return new Nh(n.value-r.value);case"*":return new Nh(n.value*r.value);case"/":return new Nh(n.value/r.value);case"%":return new Nh(n.value%r.value);case"<":return new Rh(n.value<r.value);case">":return new Rh(n.value>r.value);case">=":return new Rh(n.value>=r.value);case"<=":return new Rh(n.value<=r.value)}else if(n instanceof Fh&&r instanceof Fh){if("+"===e.operator.value)return new Fh(n.value.concat(r.value))}else if(r instanceof Fh){const t=void 0!==r.value.find((e=>e.value===n.value));switch(e.operator.value){case"in":return new Rh(t);case"not in":return new Rh(!t)}}if((n instanceof Ph||r instanceof Ph)&&"+"===e.operator.value)return new Ph(n.value.toString()+r.value.toString());if(n instanceof Ph&&r instanceof Ph)switch(e.operator.value){case"in":return new Rh(r.value.includes(n.value));case"not in":return new Rh(!r.value.includes(n.value))}if(n instanceof Ph&&r instanceof Dh)switch(e.operator.value){case"in":return new Rh(r.value.has(n.value));case"not in":return new Rh(!r.value.has(n.value))}throw new SyntaxError(`Unknown operator "${e.operator.value}" between ${n.type} and ${r.type}`)}evaluateArguments(e,t){const n=[],r=new Map;for(const s of e)if("KeywordArgumentExpression"===s.type){const e=s;r.set(e.key.value,this.evaluate(e.value,t))}else{if(r.size>0)throw new Error("Positional arguments must come before keyword arguments");n.push(this.evaluate(s,t))}return[n,r]}evaluateFilterExpression(e,t){const n=this.evaluate(e.operand,t);if("Identifier"===e.filter.type){const t=e.filter;if("tojson"===t.value)return new Ph(Kh(n));if(n instanceof Fh)switch(t.value){case"list":return n;case"first":return n.value[0];case"last":return n.value[n.value.length-1];case"length":return new Nh(n.value.length);case"reverse":return new Fh(n.value.reverse());case"sort":return new Fh(n.value.sort(((e,t)=>{if(e.type!==t.type)throw new Error(`Cannot compare different types: ${e.type} and ${t.type}`);switch(e.type){case"NumericValue":return e.value-t.value;case"StringValue":return e.value.localeCompare(t.value);default:throw new Error(`Cannot compare type: ${e.type}`)}})));default:throw new Error(`Unknown ArrayValue filter: ${t.value}`)}else if(n instanceof Ph)switch(t.value){case"length":return new Nh(n.value.length);case"upper":return new Ph(n.value.toUpperCase());case"lower":return new Ph(n.value.toLowerCase());case"title":return new Ph(Oh(n.value));case"capitalize":return new Ph(n.value.charAt(0).toUpperCase()+n.value.slice(1));case"trim":return new Ph(n.value.trim());case"indent":return new Ph(n.value.split("\\n").map(((e,t)=>0===t||0===e.length?e:"    "+e)).join("\\n"));case"string":return n;default:throw new Error(`Unknown StringValue filter: ${t.value}`)}else{if(n instanceof Nh){if("abs"===t.value)return new Nh(Math.abs(n.value));throw new Error(`Unknown NumericValue filter: ${t.value}`)}if(n instanceof Dh)switch(t.value){case"items":return new Fh(Array.from(n.value.entries()).map((([e,t])=>new Fh([new Ph(e),t]))));case"length":return new Nh(n.value.size);default:throw new Error(`Unknown ObjectValue filter: ${t.value}`)}}throw new Error(`Cannot apply filter "${t.value}" to type: ${n.type}`)}if("CallExpression"===e.filter.type){const r=e.filter;if("Identifier"!==r.callee.type)throw new Error(`Unknown filter: ${r.callee.type}`);const s=r.callee.value;if("tojson"===s){const[,e]=this.evaluateArguments(r.args,t),s=e.get("indent")??new Vh;if(!(s instanceof Nh||s instanceof Vh))throw new Error("If set, indent must be a number");return new Ph(Kh(n,s.value))}if(n instanceof Fh){switch(s){case"selectattr":case"rejectattr":{const e="selectattr"===s;if(n.value.some((e=>!(e instanceof Dh))))throw new Error(`\\`${s}\\` can only be applied to array of objects`);if(r.args.some((e=>"StringLiteral"!==e.type)))throw new Error(`arguments of \\`${s}\\` must be strings`);const[i,a,o]=r.args.map((e=>this.evaluate(e,t)));let l;if(a){const e=t.tests.get(a.value);if(!e)throw new Error(`Unknown test: ${a.value}`);l=e}else l=(...e)=>e[0].__bool__().value;const u=n.value.filter((t=>{const n=t.value.get(i.value),r=!!n&&l(n,o);return e?r:!r}));return new Fh(u)}case"map":{const[,e]=this.evaluateArguments(r.args,t);if(e.has("attribute")){const t=e.get("attribute");if(!(t instanceof Ph))throw new Error("attribute must be a string");const r=e.get("default"),s=n.value.map((e=>{if(!(e instanceof Dh))throw new Error("items in map must be an object");return e.value.get(t.value)??r??new Wh}));return new Fh(s)}throw new Error("`map` expressions without `attribute` set are not currently supported.")}}throw new Error(`Unknown ArrayValue filter: ${s}`)}if(n instanceof Ph){if("indent"===s){const[e,s]=this.evaluateArguments(r.args,t),i=e.at(0)??s.get("width")??new Nh(4);if(!(i instanceof Nh))throw new Error("width must be a number");const a=e.at(1)??s.get("first")??new Rh(!1),o=e.at(2)??s.get("blank")??new Rh(!1),l=n.value.split("\\n"),u=" ".repeat(i.value),d=l.map(((e,t)=>!a.value&&0===t||!o.value&&0===e.length?e:u+e));return new Ph(d.join("\\n"))}throw new Error(`Unknown StringValue filter: ${s}`)}throw new Error(`Cannot apply filter "${s}" to type: ${n.type}`)}throw new Error(`Unknown filter: ${e.filter.type}`)}evaluateTestExpression(e,t){const n=this.evaluate(e.operand,t),r=t.tests.get(e.test.value);if(!r)throw new Error(`Unknown test: ${e.test.value}`);const s=r(n);return new Rh(e.negate?!s:s)}evaluateUnaryExpression(e,t){const n=this.evaluate(e.argument,t);if("not"===e.operator.value)return new Rh(!n.value);throw new SyntaxError(`Unknown operator: ${e.operator.value}`)}evalProgram(e,t){return this.evaluateBlock(e.body,t)}evaluateBlock(e,t){let n="";for(const r of e){const e=this.evaluate(r,t);"NullValue"!==e.type&&"UndefinedValue"!==e.type&&(n+=e.value)}return new Ph(n)}evaluateIdentifier(e,t){return t.lookupVariable(e.value)}evaluateCallExpression(e,t){const[n,r]=this.evaluateArguments(e.args,t);r.size>0&&n.push(new Lh(r));const s=this.evaluate(e.callee,t);if("FunctionValue"!==s.type)throw new Error(`Cannot call something that is not a function: got ${s.type}`);return s.value(n,t)}evaluateSliceExpression(e,t,n){if(!(e instanceof Fh||e instanceof Ph))throw new Error("Slice object must be an array or string");const r=this.evaluate(t.start,n),s=this.evaluate(t.stop,n),i=this.evaluate(t.step,n);if(!(r instanceof Nh||r instanceof Wh))throw new Error("Slice start must be numeric or undefined");if(!(s instanceof Nh||s instanceof Wh))throw new Error("Slice stop must be numeric or undefined");if(!(i instanceof Nh||i instanceof Wh))throw new Error("Slice step must be numeric or undefined");return e instanceof Fh?new Fh(Mh(e.value,r.value,s.value,i.value)):new Ph(Mh(Array.from(e.value),r.value,s.value,i.value).join(""))}evaluateMemberExpression(e,t){const n=this.evaluate(e.object,t);let r,s;if(e.computed){if("SliceExpression"===e.property.type)return this.evaluateSliceExpression(n,e.property,t);r=this.evaluate(e.property,t)}else r=new Ph(e.property.value);if(n instanceof Dh){if(!(r instanceof Ph))throw new Error(`Cannot access property with non-string: got ${r.type}`);s=n.value.get(r.value)??n.builtins.get(r.value)}else if(n instanceof Fh||n instanceof Ph)if(r instanceof Nh)s=n.value.at(r.value),n instanceof Ph&&(s=new Ph(n.value.at(r.value)));else{if(!(r instanceof Ph))throw new Error(`Cannot access property with non-string/non-number: got ${r.type}`);s=n.builtins.get(r.value)}else{if(!(r instanceof Ph))throw new Error(`Cannot access property with non-string: got ${r.type}`);s=n.builtins.get(r.value)}return s instanceof Bh?s:new Wh}evaluateSet(e,t){const n=this.evaluate(e.value,t);if("Identifier"===e.assignee.type){const r=e.assignee.value;t.setVariable(r,n)}else{if("MemberExpression"!==e.assignee.type)throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(e.assignee)}`);{const r=e.assignee,s=this.evaluate(r.object,t);if(!(s instanceof Dh))throw new Error("Cannot assign to member of non-object");if("Identifier"!==r.property.type)throw new Error("Cannot assign to member with non-identifier property");s.value.set(r.property.value,n)}}return new Vh}evaluateIf(e,t){const n=this.evaluate(e.test,t);return this.evaluateBlock(n.__bool__().value?e.body:e.alternate,t)}evaluateFor(e,t){const n=new jh(t);let r,s;if("SelectExpression"===e.iterable.type){const t=e.iterable;s=this.evaluate(t.iterable,n),r=t.test}else s=this.evaluate(e.iterable,n);if(!(s instanceof Fh))throw new Error(`Expected iterable type in for loop: got ${s.type}`);const i=[],a=[];for(let t=0;t<s.value.length;++t){const o=new jh(n),l=s.value[t];let u;if("Identifier"===e.loopvar.type)u=t=>t.setVariable(e.loopvar.value,l);else{if("TupleLiteral"!==e.loopvar.type)throw new Error(`Invalid loop variable(s): ${e.loopvar.type}`);{const t=e.loopvar;if("ArrayValue"!==l.type)throw new Error(`Cannot unpack non-iterable type: ${l.type}`);const n=l;if(t.value.length!==n.value.length)throw new Error(`Too ${t.value.length>n.value.length?"few":"many"} items to unpack`);u=e=>{for(let r=0;r<t.value.length;++r){if("Identifier"!==t.value[r].type)throw new Error(`Cannot unpack non-identifier type: ${t.value[r].type}`);e.setVariable(t.value[r].value,n.value[r])}}}}if(r){u(o);if(!this.evaluate(r,o).__bool__().value)continue}i.push(l),a.push(u)}let o="",l=!0;for(let t=0;t<i.length;++t){const r=new Map([["index",new Nh(t+1)],["index0",new Nh(t)],["revindex",new Nh(i.length-t)],["revindex0",new Nh(i.length-t-1)],["first",new Rh(0===t)],["last",new Rh(t===i.length-1)],["length",new Nh(i.length)],["previtem",t>0?i[t-1]:new Wh],["nextitem",t<i.length-1?i[t+1]:new Wh]]);n.setVariable("loop",new Dh(r)),a[t](n);o+=this.evaluateBlock(e.body,n).value,l=!1}if(l){o+=this.evaluateBlock(e.defaultBlock,n).value}return new Ph(o)}evaluateMacro(e,t){return t.setVariable(e.name.value,new qh(((t,n)=>{const r=new jh(n);let s;t=t.slice(),"KeywordArgumentsValue"===t.at(-1)?.type&&(s=t.pop());for(let n=0;n<e.args.length;++n){const i=e.args[n],a=t[n];if("Identifier"===i.type){const e=i;if(!a)throw new Error(`Missing positional argument: ${e.value}`);r.setVariable(e.value,a)}else{if("KeywordArgumentExpression"!==i.type)throw new Error(`Unknown argument type: ${i.type}`);{const e=i,t=a??s?.value.get(e.key.value)??this.evaluate(e.value,r);r.setVariable(e.key.value,t)}}}return this.evaluateBlock(e.body,r)}))),new Vh}evaluate(e,t){if(void 0===e)return new Wh;switch(e.type){case"Program":return this.evalProgram(e,t);case"Set":return this.evaluateSet(e,t);case"If":return this.evaluateIf(e,t);case"For":return this.evaluateFor(e,t);case"Macro":return this.evaluateMacro(e,t);case"NumericLiteral":return new Nh(Number(e.value));case"StringLiteral":return new Ph(e.value);case"BooleanLiteral":return new Rh(e.value);case"NullLiteral":return new Vh(e.value);case"ArrayLiteral":return new Fh(e.value.map((e=>this.evaluate(e,t))));case"TupleLiteral":return new Uh(e.value.map((e=>this.evaluate(e,t))));case"ObjectLiteral":{const n=new Map;for(const[r,s]of e.value){const e=this.evaluate(r,t);if(!(e instanceof Ph))throw new Error(`Object keys must be strings: got ${e.type}`);n.set(e.value,this.evaluate(s,t))}return new Dh(n)}case"Identifier":return this.evaluateIdentifier(e,t);case"CallExpression":return this.evaluateCallExpression(e,t);case"MemberExpression":return this.evaluateMemberExpression(e,t);case"UnaryExpression":return this.evaluateUnaryExpression(e,t);case"BinaryExpression":return this.evaluateBinaryExpression(e,t);case"FilterExpression":return this.evaluateFilterExpression(e,t);case"TestExpression":return this.evaluateTestExpression(e,t);default:throw new SyntaxError(`Unknown node type: ${e.type}`)}}};function Hh(e){switch(typeof e){case"number":return new Nh(e);case"string":return new Ph(e);case"boolean":return new Rh(e);case"undefined":return new Wh;case"object":return null===e?new Vh:Array.isArray(e)?new Fh(e.map(Hh)):new Dh(new Map(Object.entries(e).map((([e,t])=>[e,Hh(t)]))));case"function":return new qh(((t,n)=>Hh(e(...t.map((e=>e.value)))??null)));default:throw new Error(`Cannot convert to runtime value: ${e}`)}}function Kh(e,t,n){const r=n??0;switch(e.type){case"NullValue":case"UndefinedValue":return"null";case"NumericValue":case"StringValue":case"BooleanValue":return JSON.stringify(e.value);case"ArrayValue":case"ObjectValue":{const n=t?" ".repeat(t):"",s="\\n"+n.repeat(r),i=s+n;if("ArrayValue"===e.type){const n=e.value.map((e=>Kh(e,t,r+1)));return t?`[${i}${n.join(`,${i}`)}${s}]`:`[${n.join(", ")}]`}{const n=Array.from(e.value.entries()).map((([e,n])=>{const s=`"${e}": ${Kh(n,t,r+1)}`;return t?`${i}${s}`:s}));return t?`{${n.join(",")}${s}}`:`{${n.join(", ")}}`}}default:throw new Error(`Cannot convert to JSON: ${e.type}`)}}var Xh=class{parsed;constructor(e){const t=function n(e,t={}){const n=[],r=function s(e,t={}){return e.endsWith("\\n")&&(e=e.slice(0,-1)),e=e.replace(/{#.*?#}/gs,"{##}"),t.lstrip_blocks&&(e=e.replace(/^[ \\t]*({[#%])/gm,"$1")),t.trim_blocks&&(e=e.replace(/([#%]})\\n/g,"$1")),e.replace(/{##}/g,"").replace(/-%}\\s*/g,"%}").replace(/\\s*{%-/g,"{%").replace(/-}}\\s*/g,"}}").replace(/\\s*{{-/g,"{{")}(e,t);let i=0;const a=e=>{let t="";for(;e(r[i]);)if("\\\\"!==r[i]){if(t+=r[i++],i>=r.length)throw new SyntaxError("Unexpected end of input")}else{if(++i,i>=r.length)throw new SyntaxError("Unexpected end of input");const e=r[i++],n=sh.get(e);if(void 0===n)throw new SyntaxError(`Unexpected escaped character: ${e}`);t+=n}return t};e:for(;i<r.length;){const e=n.at(-1)?.type;if(void 0===e||e===Zp.CloseStatement||e===Zp.CloseExpression){let e="";for(;i<r.length&&("{"!==r[i]||"%"!==r[i+1]&&"{"!==r[i+1]);)e+=r[i++];if(e.length>0){n.push(new eh(e,Zp.Text));continue}}a((e=>/\\s/.test(e)));const t=r[i];if("-"===t||"+"===t){const e=n.at(-1)?.type;if(e===Zp.Text||void 0===e)throw new SyntaxError(`Unexpected character: ${t}`);switch(e){case Zp.Identifier:case Zp.NumericLiteral:case Zp.BooleanLiteral:case Zp.NullLiteral:case Zp.StringLiteral:case Zp.CloseParen:case Zp.CloseSquareBracket:break;default:{++i;const e=a(nh);n.push(new eh(`${t}${e}`,e.length>0?Zp.NumericLiteral:Zp.UnaryOperator));continue}}}for(const[e,t]of rh)if(r.slice(i,i+e.length)===e){n.push(new eh(e,t)),i+=e.length;continue e}if("\'"!==t&&\'"\'!==t)if(nh(t)){const e=a(nh);n.push(new eh(e,Zp.NumericLiteral))}else{if(!th(t))throw new SyntaxError(`Unexpected character: ${t}`);{const e=a(th),t=Object.hasOwn(Jp,e)?Jp[e]:Zp.Identifier;t===Zp.In&&n.at(-1)?.type===Zp.Not?(n.pop(),n.push(new eh("not in",Zp.NotIn))):n.push(new eh(e,t))}}else{++i;const e=a((e=>e!==t));n.push(new eh(e,Zp.StringLiteral)),++i}}return n}(e,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=Ah(t)}render(e){const t=new jh;t.set("false",!1),t.set("true",!0),t.set("raise_exception",(e=>{throw new Error(e)})),t.set("range",Ih);for(const[n,r]of Object.entries(e))t.set(n,r);return new Gh(t).run(this.parsed).value}};const Qh=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],Yh=new Map(Qh),Zh=new Map([...Qh.map((([e,t])=>[t,e])),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);async function Jh(e,t){const n=await Promise.all([W(e,"tokenizer.json",!0,t),W(e,"tokenizer_config.json",!0,t)]);return null!==t.legacy&&(n[1].legacy=t.legacy),n}function ef(e,t=!0){if(void 0!==e.Regex){let t=e.Regex.replace(/\\\\([#&~])/g,"$1");for(const[e,n]of df)t=t.replaceAll(e,n);return new RegExp(t,"gu")}if(void 0!==e.String){const n=S(e.String);return new RegExp(t?n:`(${n})`,"gu")}return console.warn("Unknown pattern type:",e),null}function tf(e){return new Map(Object.entries(e))}function nf(e){const t=e.dims;switch(t.length){case 1:return e.tolist();case 2:if(1!==t[0])throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return e.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${t.length}.`)}}function rf(e){return e.replace(/ \\./g,".").replace(/ \\?/g,"?").replace(/ \\!/g,"!").replace(/ ,/g,",").replace(/ \\\' /g,"\'").replace(/ n\\\'t/g,"n\'t").replace(/ \\\'m/g,"\'m").replace(/ \\\'s/g,"\'s").replace(/ \\\'ve/g,"\'ve").replace(/ \\\'re/g,"\'re")}function sf(e){return e.replace(/\\p{M}/gu,"")}function af(e){return e>=19968&&e<=40959||e>=13312&&e<=19903||e>=131072&&e<=173791||e>=173824&&e<=177983||e>=177984&&e<=178207||e>=178208&&e<=183983||e>=63744&&e<=64255||e>=194560&&e<=195103}const of="\\\\p{P}\\\\u0021-\\\\u002F\\\\u003A-\\\\u0040\\\\u005B-\\\\u0060\\\\u007B-\\\\u007E",lf=new RegExp(`^[${of}]+$`,"gu"),uf=".,!?",df=new Map([["(?i:\'s|\'t|\'re|\'ve|\'m|\'ll|\'d)","(?:\'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"],[` ?[^(\\\\s|[${uf}])]+`,` ?[^\\\\s${uf}]+`]]);class cf{constructor(e){this.content=e.content,this.id=e.id,this.single_word=e.single_word??!1,this.lstrip=e.lstrip??!1,this.rstrip=e.rstrip??!1,this.special=e.special??!1,this.normalized=e.normalized??null}}class pf extends k{constructor(e){super(),this.config=e,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(e,...t){switch(e.type){case"WordPiece":return new hf(e);case"Unigram":return new ff(e,...t);case"BPE":return new wf(e);default:if(e.vocab)return Array.isArray(e.vocab)?new ff(e,...t):new yf(e,...t);throw new Error(`Unknown TokenizerModel type: ${e.type}`)}}_call(e){return e=this.encode(e),this.fuse_unk&&(e=function t(e,n,r){const s=[];let i=0;for(;i<e.length;)if(s.push(e[i]),(n.get(e[i])??r)===r)for(;++i<e.length&&(n.get(e[i])??r)===r;)n.get(s.at(-1))!==r&&(s[s.length-1]+=e[i]);else++i;return s}(e,this.tokens_to_ids,this.unk_token_id)),e}encode(e){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(e){return e.map((e=>this.tokens_to_ids.get(e)??this.unk_token_id))}convert_ids_to_tokens(e){return e.map((e=>this.vocab[e]??this.unk_token))}}class hf extends pf{constructor(e){super(e),this.tokens_to_ids=tf(e.vocab),this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.max_input_chars_per_word=e.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e}encode(e){const t=[];for(const n of e){const e=[...n];if(e.length>this.max_input_chars_per_word){t.push(this.unk_token);continue}let r=!1,s=0;const i=[];for(;s<e.length;){let t=e.length,n=null;for(;s<t;){let r=e.slice(s,t).join("");if(s>0&&(r=this.config.continuing_subword_prefix+r),this.tokens_to_ids.has(r)){n=r;break}--t}if(null===n){r=!0;break}i.push(n),s=t}r?t.push(this.unk_token):t.push(...i)}return t}}class ff extends pf{constructor(e,t){super(e);const n=e.vocab.length;this.vocab=new Array(n),this.scores=new Array(n);for(let t=0;t<n;++t){const n=e.vocab[t];this.vocab[t]=n[0],this.scores[t]=n[1]}this.unk_token_id=e.unk_id,this.unk_token=this.vocab[e.unk_id],this.tokens_to_ids=new Map(this.vocab.map(((e,t)=>[e,t]))),this.bos_token=" ",this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=t.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.unk_token=this.vocab[this.unk_token_id],this.minScore=K(this.scores)[0],this.unk_score=this.minScore-10,this.scores[this.unk_token_id]=this.unk_score,this.trie=new Kp,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(e){const t=e.chars;let n=0;for(;n<t.length;){let r=!1;const s=[],i=t.slice(n).join(""),a=this.trie.commonPrefixSearch(i);for(const t of a){s.push(t);const i=this.tokens_to_ids.get(t),a=this.scores[i],o=O(t);e.insert(n,o,a,i),r||1!==o||(r=!0)}r||e.insert(n,1,this.unk_score,this.unk_token_id),n+=1}}tokenize(e){const t=new Qp(e,this.bos_token_id,this.eos_token_id);return this.populateNodes(t),t.tokens()}encode(e){const t=[];for(const n of e){const e=this.tokenize(n);t.push(...e)}return t}}const mf=(()=>{const e=[...Array.from({length:"~".charCodeAt(0)-"!".charCodeAt(0)+1},((e,t)=>t+"!".charCodeAt(0))),...Array.from({length:"".charCodeAt(0)-"".charCodeAt(0)+1},((e,t)=>t+"".charCodeAt(0))),...Array.from({length:"".charCodeAt(0)-"".charCodeAt(0)+1},((e,t)=>t+"".charCodeAt(0)))],t=e.slice();let n=0;for(let r=0;r<256;++r)e.includes(r)||(e.push(r),t.push(256+n),n+=1);const r=t.map((e=>String.fromCharCode(e)));return Object.fromEntries(e.map(((e,t)=>[e,r[t]])))})(),_f=function gf(e){return Object.fromEntries(Object.entries(e).map((([e,t])=>[t,e])))}(mf);class wf extends pf{constructor(e){super(e),this.tokens_to_ids=tf(e.vocab),this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e;const t=Array.isArray(e.merges[0]);this.merges=t?e.merges:e.merges.map((e=>e.split(" ",2))),this.bpe_ranks=new Map(this.merges.map(((e,t)=>[JSON.stringify(e),t]))),this.end_of_word_suffix=e.end_of_word_suffix,this.continuing_subword_suffix=e.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.cache=new Map}bpe(e){if(0===e.length)return[];const t=this.cache.get(e);if(void 0!==t)return t;const n=Array.from(e);this.end_of_word_suffix&&(n[n.length-1]+=this.end_of_word_suffix);let r=[];if(n.length>1){const e=new Hp(((e,t)=>e.score<t.score));let t={token:n[0],bias:0,prev:null,next:null},s=t;for(let t=1;t<n.length;++t){const r={bias:t/n.length,token:n[t],prev:s,next:null};s.next=r,this._add_node(e,s),s=r}for(;!e.isEmpty();){const n=e.pop();if(n.deleted||!n.next||n.next.deleted)continue;if(n.deleted=!0,n.next.deleted=!0,n.prev){const e={...n.prev};n.prev.deleted=!0,n.prev=e,e.prev?e.prev.next=e:t=e}const r={token:n.token+n.next.token,bias:n.bias,prev:n.prev,next:n.next.next};r.prev?(r.prev.next=r,this._add_node(e,r.prev)):t=r,r.next&&(r.next.prev=r,this._add_node(e,r))}for(let e=t;null!==e;e=e.next)r.push(e.token)}else r=n;if(this.continuing_subword_suffix)for(let e=0;e<r.length-1;++e)r[e]+=this.continuing_subword_suffix;return this.cache.set(e,r),r}_add_node(e,t){const n=this.bpe_ranks.get(JSON.stringify([t.token,t.next.token]));void 0!==n&&(t.score=n+t.bias,e.push(t))}encode(e){const t=[];for(const n of e){if(this.ignore_merges&&this.tokens_to_ids.has(n)){t.push(n);continue}const e=this.bpe(n);for(const n of e)if(this.tokens_to_ids.has(n))t.push(n);else if(this.byte_fallback){const e=Array.from(this.text_encoder.encode(n)).map((e=>`<0x${e.toString(16).toUpperCase().padStart(2,"0")}>`));e.every((e=>this.tokens_to_ids.has(e)))?t.push(...e):t.push(this.unk_token)}else t.push(this.unk_token)}return t}}class yf extends pf{constructor(e,t){super(e),this.tokens_to_ids=tf(t.target_lang?e.vocab[t.target_lang]:e.vocab),this.bos_token=t.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=t.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=t.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=t.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e}encode(e){return e}}class bf extends k{constructor(e){super(),this.config=e}static fromConfig(e){if(null===e)return null;switch(e.type){case"BertNormalizer":return new Af(e);case"Precompiled":return new nm(e);case"Sequence":return new Tf(e);case"Replace":return new xf(e);case"NFC":return new vf(e);case"NFKC":return new $f(e);case"NFKD":return new kf(e);case"Strip":return new Ef(e);case"StripAccents":return new Sf(e);case"Lowercase":return new zf(e);case"Prepend":return new Cf(e);default:throw new Error(`Unknown Normalizer type: ${e.type}`)}}normalize(e){throw Error("normalize should be implemented in subclass.")}_call(e){return this.normalize(e)}}class xf extends bf{normalize(e){const t=ef(this.config.pattern);return null===t?e:e.replaceAll(t,this.config.content)}}class vf extends bf{normalize(e){return e=e.normalize("NFC")}}class $f extends bf{normalize(e){return e=e.normalize("NFKC")}}class kf extends bf{normalize(e){return e=e.normalize("NFKD")}}class Ef extends bf{normalize(e){return this.config.strip_left&&this.config.strip_right?e=e.trim():(this.config.strip_left&&(e=e.trimStart()),this.config.strip_right&&(e=e.trimEnd())),e}}class Sf extends bf{normalize(e){return e=sf(e)}}class zf extends bf{normalize(e){return e=e.toLowerCase()}}class Cf extends bf{normalize(e){return e=this.config.prepend+e}}class Tf extends bf{constructor(e){super(e),this.normalizers=e.normalizers.map((e=>bf.fromConfig(e)))}normalize(e){return this.normalizers.reduce(((e,t)=>t.normalize(e)),e)}}class Af extends bf{_tokenize_chinese_chars(e){const t=[];for(let n=0;n<e.length;++n){const r=e[n];af(r.charCodeAt(0))?(t.push(" "),t.push(r),t.push(" ")):t.push(r)}return t.join("")}stripAccents(e){return e.normalize("NFD").replace(/\\p{Mn}/gu,"")}_is_control(e){switch(e){case"\\t":case"\\n":case"\\r":return!1;default:return/^\\p{Cc}|\\p{Cf}|\\p{Co}|\\p{Cs}$/u.test(e)}}_clean_text(e){const t=[];for(const n of e){const e=n.charCodeAt(0);0===e||65533===e||this._is_control(n)||(/^\\s$/.test(n)?t.push(" "):t.push(n))}return t.join("")}normalize(e){return this.config.clean_text&&(e=this._clean_text(e)),this.config.handle_chinese_chars&&(e=this._tokenize_chinese_chars(e)),this.config.lowercase?(e=e.toLowerCase(),!1!==this.config.strip_accents&&(e=this.stripAccents(e))):this.config.strip_accents&&(e=this.stripAccents(e)),e}}class If extends k{static fromConfig(e){if(null===e)return null;switch(e.type){case"BertPreTokenizer":return new Mf(e);case"Sequence":return new rm(e);case"Whitespace":return new sm(e);case"WhitespaceSplit":return new im(e);case"Metaspace":return new em(e);case"ByteLevel":return new Of(e);case"Split":return new Bf(e);case"Punctuation":return new Nf(e);case"Digits":return new Pf(e);case"Replace":return new am(e);default:throw new Error(`Unknown PreTokenizer type: ${e.type}`)}}pre_tokenize_text(e,t){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(e,t){return(Array.isArray(e)?e.map((e=>this.pre_tokenize_text(e,t))):this.pre_tokenize_text(e,t)).flat()}_call(e,t){return this.pre_tokenize(e,t)}}class Mf extends If{constructor(e){super(),this.pattern=new RegExp(`[^\\\\s${of}]+|[${of}]`,"gu")}pre_tokenize_text(e,t){return e.trim().match(this.pattern)||[]}}class Of extends If{constructor(e){super(),this.config=e,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=/\'s|\'t|\'re|\'ve|\'m|\'ll|\'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+/gu,this.byte_encoder=mf,this.text_encoder=new TextEncoder}pre_tokenize_text(e,t){this.add_prefix_space&&!e.startsWith(" ")&&(e=" "+e);return(this.use_regex?e.match(this.pattern)||[]:[e]).map((e=>Array.from(this.text_encoder.encode(e),(e=>this.byte_encoder[e])).join("")))}}class Bf extends If{constructor(e){super(),this.config=e,this.pattern=ef(this.config.pattern,this.config.invert)}pre_tokenize_text(e,t){return null===this.pattern?[]:this.config.invert?e.match(this.pattern)||[]:"removed"===this.config.behavior?.toLowerCase()?e.split(this.pattern).filter((e=>e)):function n(e,t){const n=[];let r=0;for(const s of e.matchAll(t)){const t=s[0];r<s.index&&n.push(e.slice(r,s.index)),t.length>0&&n.push(t),r=s.index+t.length}return r<e.length&&n.push(e.slice(r)),n}(e,this.pattern)}}class Nf extends If{constructor(e){super(),this.config=e,this.pattern=new RegExp(`[^${of}]+|[${of}]+`,"gu")}pre_tokenize_text(e,t){return e.match(this.pattern)||[]}}class Pf extends If{constructor(e){super(),this.config=e;const t="[^\\\\d]+|\\\\d"+(this.config.individual_digits?"":"+");this.pattern=new RegExp(t,"gu")}pre_tokenize_text(e,t){return e.match(this.pattern)||[]}}class Rf extends k{constructor(e){super(),this.config=e}static fromConfig(e){if(null===e)return null;switch(e.type){case"TemplateProcessing":return new Ff(e);case"ByteLevel":return new Uf(e);case"RobertaProcessing":return new Lf(e);case"BertProcessing":return new Df(e);case"Sequence":return new qf(e);default:throw new Error(`Unknown PostProcessor type: ${e.type}`)}}post_process(e,...t){throw Error("post_process should be implemented in subclass.")}_call(e,...t){return this.post_process(e,...t)}}class Df extends Rf{constructor(e){super(e),this.cls=e.cls[0],this.sep=e.sep[0]}post_process(e,t=null,{add_special_tokens:n=!0}={}){n&&(e=T([this.cls],e,[this.sep]));let r=new Array(e.length).fill(0);if(null!==t){const s=n&&this instanceof Lf?[this.sep]:[],i=n?[this.sep]:[];e=T(e,s,t,i),r=T(r,new Array(t.length+s.length+i.length).fill(1))}return{tokens:e,token_type_ids:r}}}class Lf extends Df{}class Ff extends Rf{constructor(e){super(e),this.single=e.single,this.pair=e.pair}post_process(e,t=null,{add_special_tokens:n=!0}={}){const r=null===t?this.single:this.pair;let s=[],i=[];for(const a of r)"SpecialToken"in a?n&&(s.push(a.SpecialToken.id),i.push(a.SpecialToken.type_id)):"Sequence"in a&&("A"===a.Sequence.id?(s=T(s,e),i=T(i,new Array(e.length).fill(a.Sequence.type_id))):"B"===a.Sequence.id&&(s=T(s,t),i=T(i,new Array(t.length).fill(a.Sequence.type_id))));return{tokens:s,token_type_ids:i}}}class Uf extends Rf{post_process(e,t=null){return t&&(e=T(e,t)),{tokens:e}}}class qf extends Rf{constructor(e){super(e),this.processors=e.processors.map((e=>Rf.fromConfig(e)))}post_process(e,t=null,n={}){let r;for(const s of this.processors)if(s instanceof Uf){if(e=s.post_process(e).tokens,t){t=s.post_process(t).tokens}}else{const i=s.post_process(e,t,n);e=i.tokens,r=i.token_type_ids}return{tokens:e,token_type_ids:r}}}class Vf extends k{constructor(e){super(),this.config=e,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=e.trim_offsets}static fromConfig(e){if(null===e)return null;switch(e.type){case"WordPiece":return new Kf(e);case"Metaspace":return new tm(e);case"ByteLevel":return new Xf(e);case"Replace":return new Wf(e);case"ByteFallback":return new jf(e);case"Fuse":return new Gf(e);case"Strip":return new Hf(e);case"Sequence":return new Yf(e);case"CTC":return new Qf(e);case"BPEDecoder":return new Zf(e);default:throw new Error(`Unknown Decoder type: ${e.type}`)}}_call(e){return this.decode(e)}decode(e){return this.decode_chain(e).join("")}decode_chain(e){throw Error("`decode_chain` should be implemented in subclass.")}}class Wf extends Vf{decode_chain(e){const t=ef(this.config.pattern);return null===t?e:e.map((e=>e.replaceAll(t,this.config.content)))}}class jf extends Vf{constructor(e){super(e),this.text_decoder=new TextDecoder}decode_chain(e){const t=[];let n=[];for(const r of e){let e=null;if(6===r.length&&r.startsWith("<0x")&&r.endsWith(">")){const t=parseInt(r.slice(3,5),16);isNaN(t)||(e=t)}if(null!==e)n.push(e);else{if(n.length>0){const e=this.text_decoder.decode(Uint8Array.from(n));t.push(e),n=[]}t.push(r)}}if(n.length>0){const e=this.text_decoder.decode(Uint8Array.from(n));t.push(e),n=[]}return t}}class Gf extends Vf{decode_chain(e){return[e.join("")]}}class Hf extends Vf{constructor(e){super(e),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(e){return e.map((e=>{let t=0;for(let n=0;n<this.start&&e[n]===this.content;++n)t=n+1;let n=e.length;for(let t=0;t<this.stop;++t){const r=e.length-t-1;if(e[r]!==this.content)break;n=r}return e.slice(t,n)}))}}class Kf extends Vf{constructor(e){super(e),this.cleanup=e.cleanup}decode_chain(e){return e.map(((e,t)=>(0!==t&&(e=e.startsWith(this.config.prefix)?e.replace(this.config.prefix,""):" "+e),this.cleanup&&(e=rf(e)),e)))}}class Xf extends Vf{constructor(e){super(e),this.byte_decoder=_f,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(e){const t=e.join(""),n=new Uint8Array([...t].map((e=>this.byte_decoder[e])));return this.text_decoder.decode(n)}decode_chain(e){const t=[];let n=[];for(const r of e)void 0!==this.added_tokens.find((e=>e.content===r))?(n.length>0&&(t.push(this.convert_tokens_to_string(n)),n=[]),t.push(r)):n.push(r);return n.length>0&&t.push(this.convert_tokens_to_string(n)),t}}class Qf extends Vf{constructor(e){super(e),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(e){if(0===e.length)return"";const t=[e[0]];for(let n=1;n<e.length;++n)e[n]!==t.at(-1)&&t.push(e[n]);let n=t.filter((e=>e!==this.pad_token)).join("");return this.cleanup&&(n=rf(n).replaceAll(this.word_delimiter_token," ").trim()),n}decode_chain(e){return[this.convert_tokens_to_string(e)]}}class Yf extends Vf{constructor(e){super(e),this.decoders=e.decoders.map((e=>Vf.fromConfig(e)))}decode_chain(e){return this.decoders.reduce(((e,t)=>t.decode_chain(e)),e)}}class Zf extends Vf{constructor(e){super(e),this.suffix=this.config.suffix}decode_chain(e){return e.map(((t,n)=>t.replaceAll(this.suffix,n===e.length-1?"":" ")))}}class Jf extends Vf{decode_chain(e){let t="";for(let n=1;n<e.length;n+=2)t+=e[n];return[t]}}class em extends If{constructor(e){super(),this.addPrefixSpace=e.add_prefix_space,this.replacement=e.replacement,this.strRep=e.str_rep||this.replacement,this.prepend_scheme=e.prepend_scheme??"always"}pre_tokenize_text(e,{section_index:t}={}){let n=e.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!n.startsWith(this.replacement)&&("always"===this.prepend_scheme||"first"===this.prepend_scheme&&0===t)&&(n=this.strRep+n),[n]}}class tm extends Vf{constructor(e){super(e),this.addPrefixSpace=e.add_prefix_space,this.replacement=e.replacement}decode_chain(e){const t=[];for(let n=0;n<e.length;++n){let r=e[n].replaceAll(this.replacement," ");this.addPrefixSpace&&0==n&&r.startsWith(" ")&&(r=r.substring(1)),t.push(r)}return t}}class nm extends bf{constructor(e){super(e),this.charsmap=e.precompiled_charsmap}normalize(e){if((e=(e=e.replace(/[\\u0001-\\u0008\\u000B\\u000E-\\u001F\\u007F\\u008F\\u009F]/gm,"")).replace(/[\\u0009\\u000A\\u000C\\u000D\\u00A0\\u1680\\u2000-\\u200F\\u2028\\u2029\\u202F\\u205F\\u2581\\u3000\\uFEFF\\uFFFD]/gm," ")).includes("")){const t=e.split("");e=t.map((e=>e.normalize("NFKC"))).join("")}else e=e.normalize("NFKC");return e}}class rm extends If{constructor(e){super(),this.tokenizers=e.pretokenizers.map((e=>If.fromConfig(e)))}pre_tokenize_text(e,t){return this.tokenizers.reduce(((e,n)=>n.pre_tokenize(e,t)),[e])}}class sm extends If{constructor(e){super()}pre_tokenize_text(e,t){return e.match(/\\w+|[^\\w\\s]+/g)||[]}}class im extends If{constructor(e){super()}pre_tokenize_text(e,t){return function n(e){return e.match(/\\S+/g)||[]}(e)}}class am extends If{constructor(e){super(),this.config=e,this.pattern=ef(this.config.pattern),this.content=this.config.content}pre_tokenize_text(e,t){return null===this.pattern?[e]:[e.replaceAll(this.pattern,this.config.content)]}}const om=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function lm(e,t,n,r){for(const s of Object.keys(e)){const i=t-e[s].length,a=n(s),o=new Array(i).fill(a);e[s]="right"===r?T(e[s],o):T(o,e[s])}}function um(e,t){for(const n of Object.keys(e))e[n].length=t}class dm extends k{return_token_type_ids=!1;padding_side="right";constructor(e,t){super(),this._tokenizer_config=t,this.normalizer=bf.fromConfig(e.normalizer),this.pre_tokenizer=If.fromConfig(e.pre_tokenizer),this.model=pf.fromConfig(e.model,t),this.post_processor=Rf.fromConfig(e.post_processor),this.decoder=Vf.fromConfig(e.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const t of e.added_tokens){const e=new cf(t);this.added_tokens.push(e),this.model.tokens_to_ids.set(e.content,e.id),this.model.vocab[e.id]=e.content,e.special&&(this.special_tokens.push(e.content),this.all_special_ids.push(e.id))}if(this.additional_special_tokens=t.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_regex=this.added_tokens.length>0?new RegExp(this.added_tokens.slice().sort(((e,t)=>t.content.length-e.content.length)).map((e=>`${e.lstrip?"\\\\s*":""}(${S(e.content)})${e.rstrip?"\\\\s*":""}`)).join("|")):null,this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.bos_token=this.getToken("bos_token"),this.bos_token_id=this.model.tokens_to_ids.get(this.bos_token),this.eos_token=this.getToken("eos_token"),this.eos_token_id=this.model.tokens_to_ids.get(this.eos_token),this.model_max_length=t.model_max_length,this.remove_space=t.remove_space,this.clean_up_tokenization_spaces=t.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=t.do_lowercase_and_remove_accent??!1,t.padding_side&&(this.padding_side=t.padding_side),this.legacy=!1,this.chat_template=t.chat_template??null,Array.isArray(this.chat_template)){const e=Object.create(null);for(const{name:t,template:n}of this.chat_template){if("string"!=typeof t||"string"!=typeof n)throw new Error(\'Chat template must be a list of objects with "name" and "template" properties\');e[t]=n}this.chat_template=e}this._compiled_template_cache=new Map}getToken(...e){for(const t of e){const e=this._tokenizer_config[t];if(e){if("object"==typeof e){if("AddedToken"===e.__type)return e.content;throw Error(`Unknown token: ${e}`)}return e}}return null}static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:i="main",legacy:a=null}={}){return new this(...await Jh(e,{progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:i,legacy:a}))}_call(e,{text_pair:t=null,add_special_tokens:n=!0,padding:r=!1,truncation:s=null,max_length:i=null,return_tensor:a=!0,return_token_type_ids:o=null}={}){const l=Array.isArray(e);let u;if(l){if(0===e.length)throw Error("text array must be non-empty");if(null!==t){if(!Array.isArray(t))throw Error("text_pair must also be an array");if(e.length!==t.length)throw Error("text and text_pair must have the same length");u=e.map(((e,r)=>this._encode_plus(e,{text_pair:t[r],add_special_tokens:n,return_token_type_ids:o})))}else u=e.map((e=>this._encode_plus(e,{add_special_tokens:n,return_token_type_ids:o})))}else{if(null==e)throw Error("text may not be null or undefined");if(Array.isArray(t))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");u=[this._encode_plus(e,{text_pair:t,add_special_tokens:n,return_token_type_ids:o})]}if(null===i?i="max_length"===r?this.model_max_length:X(u.map((e=>e.input_ids.length)))[0]:s||console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=true` to explicitly truncate examples to max length."),i=Math.min(i,this.model_max_length??Infinity),r||s)for(let e=0;e<u.length;++e)u[e].input_ids.length!==i&&(u[e].input_ids.length>i?s&&um(u[e],i):r&&lm(u[e],i,(e=>"input_ids"===e?this.pad_token_id:0),this.padding_side));const d={};if(a){if((!r||!s)&&u.some((e=>{for(const t of Object.keys(e))if(e[t].length!==u[0][t]?.length)return!0;return!1})))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with \'padding=true\' and \'truncation=true\' to have batched tensors with the same length.");const e=[u.length,u[0].input_ids.length];for(const t of Object.keys(u[0]))d[t]=new Cp("int64",BigInt64Array.from(u.flatMap((e=>e[t])).map(BigInt)),e)}else{for(const e of Object.keys(u[0]))d[e]=u.map((t=>t[e]));if(!l)for(const e of Object.keys(d))d[e]=d[e][0]}return d}_encode_text(e){if(null===e)return null;const t=(this.added_tokens_regex?e.split(this.added_tokens_regex).filter((e=>e)):[e]).map(((e,t)=>{if(void 0!==this.added_tokens.find((t=>t.content===e)))return e;{if(!0===this.remove_space&&(e=e.trim().split(/\\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(e=function n(e){return sf(e.toLowerCase())}(e)),null!==this.normalizer&&(e=this.normalizer(e)),0===e.length)return[];const r=null!==this.pre_tokenizer?this.pre_tokenizer(e,{section_index:t}):[e];return this.model(r)}})).flat();return t}_encode_plus(e,{text_pair:t=null,add_special_tokens:n=!0,return_token_type_ids:r=null}={}){const{tokens:s,token_type_ids:i}=this._tokenize_helper(e,{pair:t,add_special_tokens:n}),a=this.model.convert_tokens_to_ids(s),o={input_ids:a,attention_mask:new Array(a.length).fill(1)};return(r??this.return_token_type_ids)&&i&&(o.token_type_ids=i),o}_tokenize_helper(e,{pair:t=null,add_special_tokens:n=!1}={}){const r=this._encode_text(e),s=this._encode_text(t);return this.post_processor?this.post_processor(r,s,{add_special_tokens:n}):{tokens:T(r??[],s??[])}}tokenize(e,{pair:t=null,add_special_tokens:n=!1}={}){return this._tokenize_helper(e,{pair:t,add_special_tokens:n}).tokens}encode(e,{text_pair:t=null,add_special_tokens:n=!0,return_token_type_ids:r=null}={}){return this._encode_plus(e,{text_pair:t,add_special_tokens:n,return_token_type_ids:r}).input_ids}batch_decode(e,t={}){return e instanceof Cp&&(e=e.tolist()),e.map((e=>this.decode(e,t)))}decode(e,t={}){if(e instanceof Cp&&(e=nf(e)),!Array.isArray(e)||0===e.length||!function n(e){return Number.isInteger(e)||"bigint"==typeof e}(e[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(e,t)}decode_single(e,{skip_special_tokens:t=!1,clean_up_tokenization_spaces:n=null}){let r=this.model.convert_ids_to_tokens(e);t&&(r=r.filter((e=>!this.special_tokens.includes(e))));let s=this.decoder?this.decoder(r):r.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(s=s.replaceAll(this.decoder.end_of_word_suffix," "),t&&(s=s.trim())),(n??this.clean_up_tokenization_spaces)&&(s=rf(s)),s}get_chat_template({chat_template:e=null,tools:t=null}={}){if(this.chat_template&&"object"==typeof this.chat_template){const n=this.chat_template;if(null!==e&&Object.hasOwn(n,e))e=n[e];else if(null===e)if(null!==t&&"tool_use"in n)e=n.tool_use;else{if(!("default"in n))throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the \'chat_template\' argument. Available template names are ${Object.keys(n).sort()}.`);e=n.default}}else if(null===e){if(!this.chat_template)throw Error("Cannot use apply_chat_template() because tokenizer.chat_template is not set and no template argument was passed! For information about writing templates and setting the tokenizer.chat_template attribute, please see the documentation at https://huggingface.co/docs/transformers/main/en/chat_templating");e=this.chat_template}return e}apply_chat_template(e,{tools:t=null,documents:n=null,chat_template:r=null,add_generation_prompt:s=!1,tokenize:i=!0,padding:a=!1,truncation:o=!1,max_length:l=null,return_tensor:u=!0,return_dict:d=!1,tokenizer_kwargs:c={},...p}={}){if("string"!=typeof(r=this.get_chat_template({chat_template:r,tools:t})))throw Error("chat_template must be a string, but got "+typeof r);let h=this._compiled_template_cache.get(r);void 0===h&&(h=new Xh(r),this._compiled_template_cache.set(r,h));const f=Object.create(null);for(const e of om){const t=this.getToken(e);t&&(f[e]=t)}const m=h.render({messages:e,add_generation_prompt:s,tools:t,documents:n,...f,...p});if(i){const e=this._call(m,{add_special_tokens:!1,padding:a,truncation:o,max_length:l,return_tensor:u,...c});return d?e:e.input_ids}return m}}class cm extends dm{return_token_type_ids=!0}class pm extends dm{return_token_type_ids=!0}class hm extends dm{return_token_type_ids=!0}class fm extends dm{return_token_type_ids=!0}class mm extends dm{return_token_type_ids=!0}class _m extends dm{return_token_type_ids=!0}class gm extends dm{return_token_type_ids=!0}class wm extends dm{return_token_type_ids=!0}class ym extends dm{return_token_type_ids=!0}class bm extends dm{}class xm extends dm{}class vm extends dm{return_token_type_ids=!0;constructor(e,t){super(e,t),console.warn(\'WARNING: `XLMTokenizer` is not yet supported by Hugging Face\\\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.\')}}class $m extends dm{return_token_type_ids=!0}class km extends dm{}class Em extends dm{}class Sm extends dm{}class zm extends dm{constructor(e,t){super(e,t),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter((e=>this.languageRegex.test(e))),this.lang_to_token=e=>e}_build_translation_inputs(e,t,n){return qm(this,e,t,n)}}class Cm extends zm{}class Tm extends dm{}class Am extends dm{}const Im="";class Mm extends dm{padding_side="left";constructor(e,t){super(e,t),this.legacy=t.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new em({replacement:Im,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(e){if(null===e)return null;if(this.legacy||0===e.length)return super._encode_text(e);let t=super._encode_text(Im+e.replaceAll(Im," "));return t.length>1&&t[0]===Im&&this.special_tokens.includes(t[1])&&(t=t.slice(1)),t}}class Om extends dm{}class Bm extends dm{}class Nm extends dm{}class Pm extends dm{}class Rm extends dm{}class Dm extends dm{}class Lm extends dm{}class Fm extends dm{}class Um extends dm{}function qm(e,t,n,r){if(!("language_codes"in e)||!Array.isArray(e.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in e&&e.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in e)||"function"!=typeof e.lang_to_token)throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const s=r.src_lang,i=r.tgt_lang;if(!e.language_codes.includes(i))throw new Error(`Target language code "${i}" is not valid. Must be one of: {${e.language_codes.join(", ")}}`);if(void 0!==s){if(!e.language_codes.includes(s))throw new Error(`Source language code "${s}" is not valid. Must be one of: {${e.language_codes.join(", ")}}`);for(const t of e.post_processor.config.single)if("SpecialToken"in t&&e.languageRegex.test(t.SpecialToken.id)){t.SpecialToken.id=e.lang_to_token(s);break}}return r.forced_bos_token_id=e.model.convert_tokens_to_ids([e.lang_to_token(i)])[0],e._call(t,n)}class Vm extends dm{constructor(e,t){super(e,t),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter((e=>this.languageRegex.test(e))),this.lang_to_token=e=>e}_build_translation_inputs(e,t,n){return qm(this,e,t,n)}}class Wm extends dm{constructor(e,t){super(e,t),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter((e=>this.languageRegex.test(e))).map((e=>e.slice(2,-2))),this.lang_to_token=e=>`__${e}__`}_build_translation_inputs(e,t,n){return qm(this,e,t,n)}}class jm extends dm{get timestamp_begin(){return this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1}_decode_asr(e,{return_timestamps:t=!1,return_language:n=!1,time_precision:r=null,force_full_sequences:s=!0}={}){if(null===r)throw Error("Must specify time_precision");let i=null;const a="word"===t;function o(){return{language:i,timestamp:[null,null],text:""}}const l=[];let u=o(),d=0;const c=this.timestamp_begin,p=c+1500;let h=[],f=[],m=!1,_=null;const g=new Set(this.all_special_ids);for(const n of e){const e=n.tokens,s=a?n.token_timestamps:null;let w=null,y=c;if("stride"in n){const[t,s,i]=n.stride;if(d-=s,_=t-i,s&&(y=s/r+c),i)for(let t=e.length-1;t>=0;--t){const n=Number(e[t]);if(n>=c){if(null!==w&&(n-c)*r<_)break;w=n}}}let b=[],x=[];for(let n=0;n<e.length;++n){const _=Number(e[n]);if(g.has(_)){const e=this.decode([_]),n=Yh.get(e.slice(2,-2));if(void 0!==n){if(null!==i&&n!==i&&!t){h.push(b);const e=this.findLongestCommonSequence(h)[0],t=this.decode(e);u.text=t,l.push(u),h=[],b=[],u=o()}i=u.language=n}}else if(_>=c&&_<=p){const e=te((_-c)*r+d,2);if(null!==w&&_>=w)m=!0;else if(m||h.length>0&&_<y)m=!1;else if(null===u.timestamp[0])u.timestamp[0]=e;else if(e===u.timestamp[0]);else{u.timestamp[1]=e,h.push(b),a&&f.push(x);const[t,n]=this.findLongestCommonSequence(h,f),r=this.decode(t);u.text=r,a&&(u.words=this.collateWordTimestamps(t,n,i)),l.push(u),h=[],b=[],f=[],x=[],u=o()}}else if(b.push(_),a){let e,t=te(s[n]+d,2);if(n+1<s.length){e=te(s[n+1]+d,2);const i=this.decode([_]);lf.test(i)&&(e=te(Math.min(t+r,e),2))}else e=null;x.push([t,e])}}if("stride"in n){const[e,t,r]=n.stride;d+=e-r}b.length>0?(h.push(b),a&&f.push(x)):h.every((e=>0===e.length))&&(u=o(),h=[],b=[],f=[],x=[])}if(h.length>0){if(s&&t)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[e,n]=this.findLongestCommonSequence(h,f),r=this.decode(e);u.text=r,a&&(u.words=this.collateWordTimestamps(e,n,i)),l.push(u)}let w=Object.create(null);const y=l.map((e=>e.text)).join("");if(t||n){for(let e=0;e<l.length;++e){const r=l[e];t||delete r.timestamp,n||delete r.language}if(a){const e=[];for(const t of l)for(const n of t.words)e.push(n);w={chunks:e}}else w={chunks:l}}return[y,w]}findLongestCommonSequence(e,t=null){let n=e[0],r=n.length,s=[];const i=Array.isArray(t)&&t.length>0;let a=i?[]:null,o=i?t[0]:null;for(let l=1;l<e.length;++l){const u=e[l];let d=0,c=[r,r,0,0];const p=u.length;for(let e=1;e<r+p;++e){const s=Math.max(0,r-e),a=Math.min(r,r+p-e),h=n.slice(s,a),f=Math.max(0,e-r),m=Math.min(p,e),_=u.slice(f,m);if(h.length!==_.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");let g;g=i?h.filter(((e,n)=>e===_[n]&&o[s+n]<=t[l][f+n])).length:h.filter(((e,t)=>e===_[t])).length;const w=g/e+e/1e4;g>1&&w>d&&(d=w,c=[s,a,f,m])}const[h,f,m,_]=c,g=Math.floor((f+h)/2),w=Math.floor((_+m)/2);s.push(...n.slice(0,g)),n=u.slice(w),r=n.length,i&&(a.push(...o.slice(0,g)),o=t[l].slice(w))}return s.push(...n),i?(a.push(...o),[s,a]):[s,[]]}collateWordTimestamps(e,t,n){const[r,s,i]=this.combineTokensIntoWords(e,n),a=[];for(let e=0;e<r.length;++e){const n=i[e];a.push({text:r[e],timestamp:[t[n.at(0)][0],t[n.at(-1)][1]]})}return a}combineTokensIntoWords(e,t,n="\\"\'([{-",r="\\"\'.,!?:)]}"){let s,i,a;return["chinese","japanese","thai","lao","myanmar"].includes(t=t??"english")?[s,i,a]=this.splitTokensOnUnicode(e):[s,i,a]=this.splitTokensOnSpaces(e),this.mergePunctuations(s,i,a,n,r)}decode(e,t){let n;return t?.decode_with_timestamps?(e instanceof Cp&&(e=nf(e)),n=this.decodeWithTimestamps(e,t)):n=super.decode(e,t),n}decodeWithTimestamps(e,t){const n=t?.time_precision??.02,r=Array.from(this.all_special_ids).at(-1)+1;let s=[[]];for(let t of e)if(t=Number(t),t>=r){const e=((t-r)*n).toFixed(2);s.push(`<|${e}|>`),s.push([])}else s[s.length-1].push(t);return s=s.map((e=>"string"==typeof e?e:super.decode(e,t))),s.join("")}splitTokensOnUnicode(e){const t=this.decode(e,{decode_with_timestamps:!0}),n=[],r=[],s=[];let i=[],a=[],o=0;for(let l=0;l<e.length;++l){const u=e[l];i.push(u),a.push(l);const d=this.decode(i,{decode_with_timestamps:!0});d.includes("")&&""!==t[o+d.indexOf("")]||(n.push(d),r.push(i),s.push(a),i=[],a=[],o+=d.length)}return[n,r,s]}splitTokensOnSpaces(e){const[t,n,r]=this.splitTokensOnUnicode(e),s=[],i=[],a=[],o=new RegExp(`^[${of}]$`,"gu");for(let e=0;e<t.length;++e){const l=t[e],u=n[e],d=r[e],c=u[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),p=l.startsWith(" "),h=l.trim(),f=o.test(h);if(c||p||f||0===s.length)s.push(l),i.push(u),a.push(d);else{const e=s.length-1;s[e]+=l,i[e].push(...u),a[e].push(...d)}}return[s,i,a]}mergePunctuations(e,t,n,r,s){const i=structuredClone(e),a=structuredClone(t),o=structuredClone(n);let l=i.length-2,u=i.length-1;for(;l>=0;)i[l].startsWith(" ")&&r.includes(i[l].trim())?(i[u]=i[l]+i[u],a[u]=T(a[l],a[u]),o[u]=T(o[l],o[u]),i[l]="",a[l]=[],o[l]=[]):u=l,--l;for(l=0,u=1;u<i.length;)!i[l].endsWith(" ")&&s.includes(i[u])?(i[l]+=i[u],a[l]=T(a[l],a[u]),o[l]=T(o[l],o[u]),i[u]="",a[u]=[],o[u]=[]):l=u,++u;return[i.filter((e=>e)),a.filter((e=>e.length>0)),o.filter((e=>e.length>0))]}}class Gm extends dm{}class Hm extends dm{}class Km extends dm{}class Xm extends dm{constructor(e,t){super(e,t),this.languageRegex=/^(>>\\w+<<)\\s*/g,this.supported_language_codes=this.model.vocab.filter((e=>this.languageRegex.test(e))),console.warn(\'WARNING: `MarianTokenizer` is not yet supported by Hugging Face\\\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.\')}_encode_text(e){if(null===e)return null;const[t,...n]=e.trim().split(this.languageRegex);if(0===n.length)return super._encode_text(t);if(2===n.length){const[e,t]=n;return this.supported_language_codes.includes(e)||console.warn(`Unsupported language code "${e}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),T([e],super._encode_text(t))}}}class Qm extends dm{}class Ym extends dm{}class Zm extends dm{}class Jm extends dm{}class e_ extends dm{}class t_ extends dm{constructor(e,t){super(e,t),this.decoder=new Jf({})}}class n_ extends dm{}class r_ extends dm{}class s_{static TOKENIZER_CLASS_MAPPING={T5Tokenizer:km,DistilBertTokenizer:bm,CamembertTokenizer:xm,DebertaTokenizer:mm,DebertaV2Tokenizer:_m,BertTokenizer:cm,HerbertTokenizer:gm,ConvBertTokenizer:wm,RoFormerTokenizer:ym,XLMTokenizer:vm,ElectraTokenizer:$m,MobileBertTokenizer:hm,SqueezeBertTokenizer:fm,AlbertTokenizer:pm,GPT2Tokenizer:Em,BartTokenizer:Sm,MBartTokenizer:zm,MBart50Tokenizer:Cm,RobertaTokenizer:Tm,WhisperTokenizer:jm,CodeGenTokenizer:Gm,CLIPTokenizer:Hm,SiglipTokenizer:Km,MarianTokenizer:Xm,BloomTokenizer:Am,NllbTokenizer:Vm,M2M100Tokenizer:Wm,LlamaTokenizer:Mm,CodeLlamaTokenizer:Om,XLMRobertaTokenizer:Bm,MPNetTokenizer:Nm,FalconTokenizer:Pm,GPTNeoXTokenizer:Rm,EsmTokenizer:Dm,Wav2Vec2CTCTokenizer:Qm,BlenderbotTokenizer:Ym,BlenderbotSmallTokenizer:Zm,SpeechT5Tokenizer:Jm,NougatTokenizer:e_,VitsTokenizer:t_,Qwen2Tokenizer:Lm,GemmaTokenizer:Fm,Grok1Tokenizer:Um,CohereTokenizer:n_,MgpstrTokenizer:r_,PreTrainedTokenizer:dm};static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:i="main",legacy:a=null}={}){const[o,l]=await Jh(e,{progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:i,legacy:a}),u=l.tokenizer_class?.replace(/Fast$/,"")??"PreTrainedTokenizer";let d=this.TOKENIZER_CLASS_MAPPING[u];return d||(console.warn(`Unknown tokenizer class "${u}", attempting to construct from base class.`),d=dm),new d(o,l)}}function i_(e){const t={};let n={};switch(e.model_type){case"llava":case"paligemma":case"florence2":case"llava_onevision":case"idefics3":n=i_(e.text_config);break;case"moondream1":n=i_(e.phi_config);break;case"musicgen":n=i_(e.decoder);break;case"multi_modality":n=i_(e.language_config);break;case"gpt2":case"gptj":case"jais":case"codegen":case"gpt_bigcode":t.num_heads="n_head",t.num_layers="n_layer",t.hidden_size="n_embd";break;case"gpt_neox":case"stablelm":case"opt":case"falcon":t.num_heads="num_attention_heads",t.num_layers="num_hidden_layers",t.hidden_size="hidden_size";break;case"llama":case"olmo":case"olmo2":case"mobilellm":case"granite":case"cohere":case"mistral":case"starcoder2":case"qwen2":case"qwen2_vl":case"phi":case"phi3":case"phi3_v":t.num_heads="num_key_value_heads",t.num_layers="num_hidden_layers",t.hidden_size="hidden_size",t.num_attention_heads="num_attention_heads";break;case"gemma":case"gemma2":t.num_heads="num_key_value_heads",t.num_layers="num_hidden_layers",t.dim_kv="head_dim";break;case"openelm":t.num_heads="num_kv_heads",t.num_layers="num_transformer_layers",t.dim_kv="head_dim";break;case"gpt_neo":case"donut-swin":t.num_heads="num_heads",t.num_layers="num_layers",t.hidden_size="hidden_size";break;case"bloom":t.num_heads="n_head",t.num_layers="n_layer",t.hidden_size="hidden_size";break;case"mpt":t.num_heads="n_heads",t.num_layers="n_layers",t.hidden_size="d_model";break;case"exaone":t.num_heads="num_key_value_heads",t.num_layers="num_layers",t.dim_kv="head_dim",t.num_attention_heads="num_attention_heads";break;case"t5":case"mt5":case"longt5":t.num_decoder_layers="num_decoder_layers",t.num_decoder_heads="num_heads",t.decoder_dim_kv="d_kv",t.num_encoder_layers="num_layers",t.num_encoder_heads="num_heads",t.encoder_dim_kv="d_kv";break;case"bart":case"mbart":case"marian":case"whisper":case"m2m_100":case"blenderbot":case"blenderbot-small":case"florence2_language":t.num_decoder_layers="decoder_layers",t.num_decoder_heads="decoder_attention_heads",t.decoder_hidden_size="d_model",t.num_encoder_layers="encoder_layers",t.num_encoder_heads="encoder_attention_heads",t.encoder_hidden_size="d_model";break;case"speecht5":t.num_decoder_layers="decoder_layers",t.num_decoder_heads="decoder_attention_heads",t.decoder_hidden_size="hidden_size",t.num_encoder_layers="encoder_layers",t.num_encoder_heads="encoder_attention_heads",t.encoder_hidden_size="hidden_size";break;case"trocr":t.num_encoder_layers=t.num_decoder_layers="decoder_layers",t.num_encoder_heads=t.num_decoder_heads="decoder_attention_heads",t.encoder_hidden_size=t.decoder_hidden_size="d_model";break;case"musicgen_decoder":case"moonshine":t.num_encoder_layers=t.num_decoder_layers="num_hidden_layers",t.num_encoder_heads=t.num_decoder_heads="num_attention_heads",t.encoder_hidden_size=t.decoder_hidden_size="hidden_size";break;case"vision-encoder-decoder":const r=i_(e.decoder),s="num_decoder_layers"in r,i=M(e,["model_type","is_encoder_decoder"]);return s?(i.num_decoder_layers=r.num_decoder_layers,i.num_decoder_heads=r.num_decoder_heads,i.decoder_hidden_size=r.decoder_hidden_size,i.num_encoder_layers=r.num_encoder_layers,i.num_encoder_heads=r.num_encoder_heads,i.encoder_hidden_size=r.encoder_hidden_size):(i.num_layers=r.num_layers,i.num_heads=r.num_heads,i.hidden_size=r.hidden_size),i}const r={...n,...M(e,["model_type","multi_query","is_encoder_decoder"])};for(const n in t)r[n]=e[t[n]];return r}function a_(e,{prefix:t="past_key_values",batch_size:n=1}={}){const r={},s=e.normalized_config;if(s.is_encoder_decoder&&"num_encoder_heads"in s&&"num_decoder_heads"in s){const e=s.encoder_dim_kv??s.encoder_hidden_size/s.num_encoder_heads,i=s.decoder_dim_kv??s.decoder_hidden_size/s.num_decoder_heads,a=[n,s.num_encoder_heads,0,e],o=[n,s.num_decoder_heads,0,i];for(let e=0;e<s.num_decoder_layers;++e)r[`${t}.${e}.encoder.key`]=a,r[`${t}.${e}.encoder.value`]=a,r[`${t}.${e}.decoder.key`]=o,r[`${t}.${e}.decoder.value`]=o}else{const e=s.num_heads,i=s.num_layers,a=s.dim_kv??s.hidden_size/(s.num_attention_heads??e);if("falcon"===s.model_type){const s=[n*e,0,a];for(let e=0;e<i;++e)r[`${t}.${e}.key`]=s,r[`${t}.${e}.value`]=s}else if(s.multi_query){const s=[n*e,0,2*a];for(let e=0;e<i;++e)r[`${t}.${e}.key_value`]=s}else if("bloom"===s.model_type){const s=[n*e,a,0],o=[n*e,0,a];for(let e=0;e<i;++e)r[`${t}.${e}.key`]=s,r[`${t}.${e}.value`]=o}else if("openelm"===s.model_type)for(let s=0;s<i;++s){const i=[n,e[s],0,a];r[`${t}.${s}.key`]=i,r[`${t}.${s}.value`]=i}else{const s=[n,e,0,a];for(let e=0;e<i;++e)r[`${t}.${e}.key`]=s,r[`${t}.${e}.value`]=s}}return r}class o_{model_type=null;is_encoder_decoder=!1;max_position_embeddings;"transformers.js_config";constructor(e){Object.assign(this,e),this.normalized_config=i_(this)}static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:i="main"}={}){!n||n instanceof o_||(n=new o_(n));const a=n??await async function o(e,t){return await W(e,"config.json",!0,t)}(e,{progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:i});return new this(a)}}class l_{static async from_pretrained(...e){return o_.from_pretrained(...e)}}const u_=Object.freeze({auto:"auto",gpu:"gpu",cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:"webnn","webnn-npu":"webnn-npu","webnn-gpu":"webnn-gpu","webnn-cpu":"webnn-cpu"}),d_=function(){let e;return async function(){if(void 0===e)if(g.IS_WEBGPU_AVAILABLE)try{const t=await navigator.gpu.requestAdapter();e=t.features.has("shader-f16")}catch(t){e=!1}else e=!1;return e}}(),c_=Object.freeze({auto:"auto",fp32:"fp32",fp16:"fp16",q8:"q8",int8:"int8",uint8:"uint8",q4:"q4",bnb4:"bnb4",q4f16:"q4f16"}),p_=Object.freeze({[u_.wasm]:c_.q8}),h_=Object.freeze({[c_.fp32]:"",[c_.fp16]:"_fp16",[c_.int8]:"_int8",[c_.uint8]:"_uint8",[c_.q8]:"_quantized",[c_.q4]:"_q4",[c_.q4f16]:"_q4f16",[c_.bnb4]:"_bnb4"}),f_="https://github.com/huggingface/transformers.js/issues/new/choose",m_="preprocessor_config.json",__=m_;class g_ extends k{_call(e,t){throw Error("`_call` should be implemented in a subclass")}}class w_ extends k{_call(e,t){throw Error("`_call` should be implemented in a subclass")}}class y_ extends k{constructor(){super(),this.processors=[]}push(e){this.processors.push(e)}extend(e){this.processors.push(...e)}_call(e,t){let n=t;for(const t of this.processors)n=t(e,n);return n}[Symbol.iterator](){return this.processors.values()}}class b_ extends g_{constructor(e){super(),this.bos_token_id=e}_call(e,t){for(let n=0;n<e.length;++n)if(1===e[n].length){const e=t[n].data;e.fill(-Infinity),e[this.bos_token_id]=0}return t}}class x_ extends g_{constructor(e,t){super(),this.max_length=e,this.eos_token_id=Array.isArray(t)?t:[t]}_call(e,t){for(let n=0;n<e.length;++n)if(e[n].length===this.max_length-1){const e=t[n].data;e.fill(-Infinity);for(const t of this.eos_token_id)e[t]=0}return t}}class v_ extends g_{constructor(e,t){super(),this.begin_suppress_tokens=e,this.begin_index=t}_call(e,t){for(let n=0;n<e.length;++n)if(e[n].length===this.begin_index){const e=t[n].data;for(const t of this.begin_suppress_tokens)e[t]=-Infinity}return t}}class $_ extends g_{constructor(e,t){super(),this.eos_token_id=Array.isArray(e.eos_token_id)?e.eos_token_id[0]:e.eos_token_id,this.no_timestamps_token_id=e.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=t.length,t.at(-1)===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=e.max_initial_timestamp_index}_call(e,t){for(let n=0;n<e.length;++n){const r=t[n].data;if(r[this.no_timestamps_token_id]=-Infinity,e[n].length===this.begin_index-1){r.fill(-Infinity),r[this.timestamp_begin]=0;continue}const s=e[n].slice(this.begin_index),i=s.length>=1&&s[s.length-1]>=this.timestamp_begin,a=s.length<2||s[s.length-2]>=this.timestamp_begin;if(i&&(a?r.subarray(this.timestamp_begin).fill(-Infinity):r.subarray(0,this.eos_token_id).fill(-Infinity)),e[n].length===this.begin_index&&null!==this.max_initial_timestamp_index){const e=this.timestamp_begin+this.max_initial_timestamp_index;r.subarray(e+1).fill(-Infinity)}const o=H(r);Math.log(o.subarray(this.timestamp_begin).map(Math.exp).reduce(((e,t)=>e+t)))>X(o.subarray(0,this.timestamp_begin))[0]&&r.subarray(0,this.timestamp_begin).fill(-Infinity)}return t}}class k_ extends g_{constructor(e){super(),this.no_repeat_ngram_size=e}getNgrams(e){const t=e.length,n=[];for(let r=0;r<t+1-this.no_repeat_ngram_size;++r){const t=[];for(let n=0;n<this.no_repeat_ngram_size;++n)t.push(e[r+n]);n.push(t.map(Number))}const r=new Map;for(const e of n){const t=e.slice(0,e.length-1),n=JSON.stringify(t),s=r.get(n)??[];s.push(e[e.length-1]),r.set(n,s)}return r}getGeneratedNgrams(e,t){const n=t.slice(t.length+1-this.no_repeat_ngram_size,t.length);return e.get(JSON.stringify(n.map(Number)))??[]}calcBannedNgramTokens(e){const t=[];if(e.length+1<this.no_repeat_ngram_size)return t;{const t=this.getNgrams(e);return this.getGeneratedNgrams(t,e)}}_call(e,t){for(let n=0;n<e.length;++n){const r=t[n].data,s=this.calcBannedNgramTokens(e[n]);for(const e of s)r[e]=-Infinity}return t}}class E_ extends g_{constructor(e){super(),this.penalty=e}_call(e,t){for(let n=0;n<e.length;++n){const r=t[n].data;for(const t of new Set(e[n])){const e=Number(t);r[e]<0?r[e]*=this.penalty:r[e]/=this.penalty}}return t}}class S_ extends g_{constructor(e,t){super(),this.min_length=e,this.eos_token_id=Array.isArray(t)?t:[t]}_call(e,t){for(let n=0;n<e.length;++n)if(e[n].length<this.min_length){const e=t[n].data;for(const t of this.eos_token_id)e[t]=-Infinity}return t}}class z_ extends g_{constructor(e,t,n){super(),this.prompt_length_to_skip=e,this.min_new_tokens=t,this.eos_token_id=Array.isArray(n)?n:[n]}_call(e,t){for(let n=0;n<e.length;++n){if(e[n].length-this.prompt_length_to_skip<this.min_new_tokens){const e=t[n].data;for(const t of this.eos_token_id)e[t]=-Infinity}}return t}}class C_ extends g_{constructor(e,t){super(),this.bad_words_ids=e,this.eos_token_id=Array.isArray(t)?t:[t]}_call(e,t){for(let n=0;n<e.length;++n){const r=t[n].data,s=e[n];for(const e of this.bad_words_ids){let t=!0;for(let n=1;n<=e.length-1&&e.length<s.length;++n)if(e.at(-n-1)!=s.at(-n)){t=!1;break}t&&(r[e.at(-1)]=-Infinity)}}return t}}class T_ extends g_{constructor(e){if(super(),e<=1)throw new Error(`Require guidance scale >1 to use the classifier free guidance processor, got guidance scale ${e}.`);this.guidance_scale=e}_call(e,t){if(t.dims[0]!==2*e.length)throw new Error(`Logits should have twice the batch size of the input ids, the first half of batches corresponding to the conditional inputs, and the second half of batches corresponding to the unconditional inputs. Got batch size ${t.dims[0]} for the logits and ${e.length} for the input ids.`);const n=e.length,r=t.slice([0,n],null),s=t.slice([n,t.dims[0]],null);for(let e=0;e<s.data.length;++e)s.data[e]+=(r.data[e]-s.data[e])*this.guidance_scale;return s}}class A_ extends w_{constructor(e){if(super(),"number"!=typeof e||e<=0){let t=`\\`temperature\\` (=${e}) must be a strictly positive float, otherwise your next token scores will be invalid.`;0===e&&(t+=" If you\'re looking for greedy decoding strategies, set `do_sample=false`.")}this.temperature=e}_call(e,t){const n=t.data;for(let e=0;e<n.length;++e)n[e]/=this.temperature;return t}}class I_ extends w_{constructor(e,{filter_value:t=-Infinity,min_tokens_to_keep:n=1}={}){if(super(),e<0||e>1)throw new Error(`\\`top_p\\` must be a float > 0 and < 1, but is ${e}`);if(!Number.isInteger(n)||n<1)throw new Error(`\\`min_tokens_to_keep\\` must be a positive integer, but is ${n}`);this.top_p=e,this.filter_value=t,this.min_tokens_to_keep=n}}class M_ extends w_{constructor(e,{filter_value:t=-Infinity,min_tokens_to_keep:n=1}={}){if(super(),!Number.isInteger(e)||e<0)throw new Error(`\\`top_k\\` must be a positive integer, but is ${e}`);this.top_k=Math.max(e,n),this.filter_value=t}}class O_{max_length=20;max_new_tokens=null;min_length=0;min_new_tokens=null;early_stopping=!1;max_time=null;do_sample=!1;num_beams=1;num_beam_groups=1;penalty_alpha=null;use_cache=!0;temperature=1;top_k=50;top_p=1;typical_p=1;epsilon_cutoff=0;eta_cutoff=0;diversity_penalty=0;repetition_penalty=1;encoder_repetition_penalty=1;length_penalty=1;no_repeat_ngram_size=0;bad_words_ids=null;force_words_ids=null;renormalize_logits=!1;constraints=null;forced_bos_token_id=null;forced_eos_token_id=null;remove_invalid_values=!1;exponential_decay_length_penalty=null;suppress_tokens=null;streamer=null;begin_suppress_tokens=null;forced_decoder_ids=null;guidance_scale=null;num_return_sequences=1;output_attentions=!1;output_hidden_states=!1;output_scores=!1;return_dict_in_generate=!1;pad_token_id=null;bos_token_id=null;eos_token_id=null;encoder_no_repeat_ngram_size=0;decoder_start_token_id=null;generation_kwargs={};constructor(e){Object.assign(this,M(e,Object.getOwnPropertyNames(this)))}}var B_=s(655);let N_,P_,R_;const D_=g.IS_BROWSER_ENV||g.IS_WEBWORKER_ENV;if(D_)N_=(e,t)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(e,t)},R_=self.createImageBitmap,P_=self.ImageData;else{if(!B_)throw new Error("Unable to load image processing library.");R_=async e=>{const t=(await e.metadata()).channels,{data:n,info:r}=await e.rotate().raw().toBuffer({resolveWithObject:!0}),s=new U_(new Uint8ClampedArray(n),r.width,r.height,r.channels);return void 0!==t&&t!==r.channels&&s.convert(t),s}}const L_={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},F_=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class U_{constructor(e,t,n,r){this.data=e,this.width=t,this.height=n,this.channels=r}get size(){return[this.width,this.height]}static async read(e){if(e instanceof U_)return e;if("string"==typeof e||e instanceof URL)return await this.fromURL(e);throw new Error("Unsupported input type: "+typeof e)}static fromCanvas(e){if(!D_)throw new Error("fromCanvas() is only supported in browser environments.");const t=e.getContext("2d").getImageData(0,0,e.width,e.height).data;return new U_(t,e.width,e.height,4)}static async fromURL(e){const t=await F(e);if(200!==t.status)throw new Error(`Unable to read image from "${e}" (${t.status} ${t.statusText})`);const n=await t.blob();return this.fromBlob(n)}static async fromBlob(e){if(D_){const t=await R_(e),n=N_(t.width,t.height).getContext("2d");return n.drawImage(t,0,0),new this(n.getImageData(0,0,t.width,t.height).data,t.width,t.height,4)}{const t=B_(await e.arrayBuffer());return await R_(t)}}static fromTensor(e,t="CHW"){if(3!==e.dims.length)throw new Error(`Tensor should have 3 dimensions, but has ${e.dims.length} dimensions.`);if("CHW"===t)e=e.transpose(1,2,0);else if("HWC"!==t)throw new Error(`Unsupported channel format: ${t}`);if(!(e.data instanceof Uint8ClampedArray||e.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${e.type}`);switch(e.dims[2]){case 1:case 2:case 3:case 4:return new U_(e.data,e.dims[1],e.dims[0],e.dims[2]);default:throw new Error(`Unsupported number of channels: ${e.dims[2]}`)}}grayscale(){if(1===this.channels)return this;const e=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let t=0,n=0;t<this.data.length;t+=this.channels){const r=this.data[t],s=this.data[t+1],i=this.data[t+2];e[n++]=Math.round(.2989*r+.587*s+.114*i)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,1)}rgb(){if(3===this.channels)return this;const e=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let t=0,n=0;t<this.data.length;++t)e[n++]=this.data[t],e[n++]=this.data[t],e[n++]=this.data[t];break;case 4:for(let t=0,n=0;t<this.data.length;t+=4)e[n++]=this.data[t],e[n++]=this.data[t+1],e[n++]=this.data[t+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,3)}rgba(){if(4===this.channels)return this;const e=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let t=0,n=0;t<this.data.length;++t)e[n++]=this.data[t],e[n++]=this.data[t],e[n++]=this.data[t],e[n++]=255;break;case 3:for(let t=0,n=0;t<this.data.length;t+=3)e[n++]=this.data[t],e[n++]=this.data[t+1],e[n++]=this.data[t+2],e[n++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,4)}putAlpha(e){if(e.width!==this.width||e.height!==this.height)throw new Error(`Expected mask size to be ${this.width}x${this.height}, but got ${e.width}x${e.height}`);if(1!==e.channels)throw new Error(`Expected mask to have 1 channel, but got ${e.channels}`);const t=this.data,n=e.data,r=this.width*this.height;if(3===this.channels){const e=new Uint8ClampedArray(4*r);for(let s=0,i=0,a=0;s<r;++s)e[a++]=t[i++],e[a++]=t[i++],e[a++]=t[i++],e[a++]=n[s];return this._update(e,this.width,this.height,4)}if(4===this.channels){for(let e=0;e<r;++e)t[4*e+3]=n[e];return this}throw new Error(`Expected image to have 3 or 4 channels, but got ${this.channels}`)}async resize(e,t,{resample:n=2}={}){if(this.width===e&&this.height===t)return this;let r=L_[n]??n;const s=z(e),i=z(t);if(s&&i)return this;if(s?e=t/this.height*this.width:i&&(t=e/this.width*this.height),D_){const n=this.channels,r=this.toCanvas(),s=N_(e,t).getContext("2d");s.drawImage(r,0,0,e,t);return new U_(s.getImageData(0,0,e,t).data,e,t,4).convert(n)}{let n=this.toSharp();switch(r){case"box":case"hamming":"box"!==r&&"hamming"!==r||(console.warn(`Resampling method ${r} is not yet supported. Using bilinear instead.`),r="bilinear");case"nearest":case"bilinear":case"bicubic":n=n.affine([e/this.width,0,0,t/this.height],{interpolator:r});break;case"lanczos":n=n.resize({width:e,height:t,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${r} is not supported.`)}return await R_(n)}}async pad([e,t,n,r]){if(e=Math.max(e,0),t=Math.max(t,0),n=Math.max(n,0),r=Math.max(r,0),0===e&&0===t&&0===n&&0===r)return this;if(D_){const s=this.channels,i=this.toCanvas(),a=this.width+e+t,o=this.height+n+r,l=N_(a,o).getContext("2d");l.drawImage(i,0,0,this.width,this.height,e,n,this.width,this.height);return new U_(l.getImageData(0,0,a,o).data,a,o,4).convert(s)}{const s=this.toSharp().extend({left:e,right:t,top:n,bottom:r});return await R_(s)}}async crop([e,t,n,r]){if(e=Math.max(e,0),t=Math.max(t,0),n=Math.min(n,this.width-1),r=Math.min(r,this.height-1),0===e&&0===t&&n===this.width-1&&r===this.height-1)return this;const s=n-e+1,i=r-t+1;if(D_){const n=this.channels,r=this.toCanvas(),a=N_(s,i).getContext("2d");a.drawImage(r,e,t,s,i,0,0,s,i);return new U_(a.getImageData(0,0,s,i).data,s,i,4).convert(n)}{const n=this.toSharp().extract({left:e,top:t,width:s,height:i});return await R_(n)}}async center_crop(e,t){if(this.width===e&&this.height===t)return this;const n=(this.width-e)/2,r=(this.height-t)/2;if(D_){const s=this.channels,i=this.toCanvas(),a=N_(e,t).getContext("2d");let o=0,l=0,u=0,d=0;n>=0?o=n:u=-n,r>=0?l=r:d=-r,a.drawImage(i,o,l,e,t,u,d,e,t);return new U_(a.getImageData(0,0,e,t).data,e,t,4).convert(s)}{let s=this.toSharp();if(n>=0&&r>=0)s=s.extract({left:Math.floor(n),top:Math.floor(r),width:e,height:t});else if(n<=0&&r<=0){const i=Math.floor(-r),a=Math.floor(-n);s=s.extend({top:i,left:a,right:e-this.width-a,bottom:t-this.height-i})}else{let i=[0,0],a=0;r<0?(i[0]=Math.floor(-r),i[1]=t-this.height-i[0]):a=Math.floor(r);let o=[0,0],l=0;n<0?(o[0]=Math.floor(-n),o[1]=e-this.width-o[0]):l=Math.floor(n),s=s.extend({top:i[0],bottom:i[1],left:o[0],right:o[1]}).extract({left:l,top:a,width:e,height:t})}return await R_(s)}}async toBlob(e="image/png",t=1){if(!D_)throw new Error("toBlob() is only supported in browser environments.");const n=this.toCanvas();return await n.convertToBlob({type:e,quality:t})}toTensor(e="CHW"){let t=new Cp("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if("HWC"===e);else{if("CHW"!==e)throw new Error(`Unsupported channel format: ${e}`);t=t.permute(2,0,1)}return t}toCanvas(){if(!D_)throw new Error("toCanvas() is only supported in browser environments.");const e=this.clone().rgba(),t=N_(e.width,e.height),n=new P_(e.data,e.width,e.height);return t.getContext("2d").putImageData(n,0,0),t}split(){const{data:e,width:t,height:n,channels:r}=this,s=e.constructor,i=e.length/r,a=Array.from({length:r},(()=>new s(i)));for(let t=0;t<i;++t){const n=r*t;for(let s=0;s<r;++s)a[s][t]=e[n+s]}return a.map((e=>new U_(e,t,n,1)))}_update(e,t,n,r=null){return this.data=e,this.width=t,this.height=n,null!==r&&(this.channels=r),this}clone(){return new U_(this.data.slice(),this.width,this.height,this.channels)}convert(e){if(this.channels===e)return this;switch(e){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(e){if(!D_){if(v.useFS){const t=this.toSharp();return await t.toFile(e)}throw new Error("Unable to save the image because filesystem is disabled in this environment.")}{if(g.IS_WEBWORKER_ENV)throw new Error("Unable to save an image from a Web Worker.");const t=e.split(".").pop().toLowerCase(),n=F_.get(t)??"image/png",r=await this.toBlob(n),s=URL.createObjectURL(r),i=document.createElement("a");i.href=s,i.download=e,i.click(),i.remove()}}toSharp(){if(D_)throw new Error("toSharp() is only supported in server-side environments.");return B_(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}U_.read.bind(U_);class q_ extends k{_call(e,t){throw Error("StoppingCriteria needs to be subclassed")}}class V_ extends k{constructor(){super(),this.criteria=[]}push(e){this.criteria.push(e)}extend(e){e instanceof V_?e=e.criteria:e instanceof q_&&(e=[e]),this.criteria.push(...e)}_call(e,t){const n=new Array(e.length).fill(!1);for(const r of this.criteria){const s=r(e,t);for(let e=0;e<n.length;++e)n[e]||=s[e]}return n}[Symbol.iterator](){return this.criteria.values()}}class W_ extends q_{constructor(e,t=null){super(),this.max_length=e,this.max_position_embeddings=t}_call(e){return e.map((e=>e.length>=this.max_length))}}class j_ extends q_{constructor(e){super(),Array.isArray(e)||(e=[e]),this.eos_token_id=e}_call(e,t){return e.map((e=>{const t=e.at(-1);return this.eos_token_id.some((e=>t==e))}))}}class G_ extends k{constructor(e){super(),this.generation_config=e}async _call(e){return this.sample(e)}async sample(e){throw Error("sample should be implemented in subclasses.")}getLogits(e,t){let n=e.dims.at(-1),r=e.data;if(-1===t)r=r.slice(-n);else{let e=t*n;r=r.slice(e,e+n)}return r}randomSelect(e){let t=0;for(let n=0;n<e.length;++n)t+=e[n];let n=Math.random()*t;for(let t=0;t<e.length;++t)if(n-=e[t],n<=0)return t;return 0}static getSampler(e){if(e.do_sample)return new K_(e);if(e.num_beams>1)return new X_(e);if(e.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${e.num_return_sequences}.`);return new H_(e)}}class H_ extends G_{async sample(e){const t=X(e.data)[1];return[[BigInt(t),0]]}}class K_ extends G_{async sample(e){let t=e.dims.at(-1);this.generation_config.top_k>0&&(t=Math.min(this.generation_config.top_k,t));const[n,r]=await Ip(e,t),s=G(n.data);return Array.from({length:this.generation_config.num_beams},(()=>{const e=this.randomSelect(s);return[r.data[e],Math.log(s[e])]}))}}class X_ extends G_{async sample(e){let t=e.dims.at(-1);this.generation_config.top_k>0&&(t=Math.min(this.generation_config.top_k,t));const[n,r]=await Ip(e,t),s=G(n.data);return Array.from({length:this.generation_config.num_beams},((e,t)=>[r.data[t],Math.log(s[t])]))}}class Q_ extends O_{return_timestamps=null;return_token_timestamps=null;num_frames=null;alignment_heads=null;task=null;language=null;no_timestamps_token_id=null;prompt_ids=null;is_multilingual=null;lang_to_id=null;task_to_id=null;max_initial_timestamp_index=1}const Y_=0,Z_=1,J_=2,eg=3,tg=4,ng=5,rg=6,sg=7,ig=8,ag=9,og=new Map,lg=new Map,ug=new Map;async function dg(e,t,n){const r=n.config?.["transformers.js_config"]??{};let s=n.device??r.device;s&&"string"!=typeof s&&(s.hasOwnProperty(t)?s=s[t]:(console.warn(`device not specified for "${t}". Using the default device.`),s=null));const i=s??(g.IS_NODE_ENV?"cpu":"wasm"),a=function o(e=null){if(!e)return _p;switch(e){case"auto":return mp;case"gpu":return mp.filter((e=>["webgpu","cuda","dml","webnn-gpu"].includes(e)))}if(mp.includes(e))return[fp[e]??e];throw new Error(`Unsupported device: "${e}". Should be one of: ${mp.join(", ")}.`)}(i);let l=n.dtype??r.dtype;if("string"!=typeof l&&(l&&l.hasOwnProperty(t)?l=l[t]:(l=p_[i]??c_.fp32,console.warn(`dtype not specified for "${t}". Using the default dtype (${l}) for this device (${i}).`))),l===c_.auto){let e=r.dtype;"string"!=typeof e&&(e=e[t]),l=e&&e!==c_.auto&&c_.hasOwnProperty(e)?e:p_[i]??c_.fp32}const u=l;if(!h_.hasOwnProperty(u))throw new Error(`Invalid dtype: ${u}. Should be one of: ${Object.keys(c_).join(", ")}`);if(u===c_.fp16&&"webgpu"===i&&!await d_())throw new Error(`The device (${i}) does not support fp16.`);const d=r.kv_cache_dtype?"string"==typeof r.kv_cache_dtype?r.kv_cache_dtype:r.kv_cache_dtype[u]??"float32":void 0;if(d&&!["float32","float16"].includes(d))throw new Error(`Invalid kv_cache_dtype: ${d}. Should be one of: float32, float16`);const c={dtype:u,kv_cache_dtype:d},p=h_[u],h=`${n.subfolder??""}/${t}${p}.onnx`,f={...n.session_options};f.executionProviders??=a;const m=r.free_dimension_overrides;m?f.freeDimensionOverrides??=m:i.startsWith("webnn")&&!f.freeDimensionOverrides&&console.warn(\'WebNN does not currently support dynamic shapes and requires `free_dimension_overrides` to be set in config.json as a field within "transformers.js_config". When `free_dimension_overrides` is not set, you may experience significant performance degradation.\');const _=V(e,h,!0,n),w=n.use_external_data_format??r.use_external_data_format;let y=[];if(w&&(!0===w||"object"==typeof w&&w.hasOwnProperty(t)&&!0===w[t])){if(g.IS_NODE_ENV)throw new Error("External data format is not yet supported in Node.js");const r=`${t}${p}.onnx_data`,s=`${n.subfolder??""}/${r}`;y.push(new Promise((async(t,i)=>{const a=await V(e,s,!0,n);t({path:r,data:a})})))}else void 0!==f.externalData&&(y=f.externalData.map((async t=>{if("string"==typeof t.data){const r=await V(e,t.data,!0,n);return{...t,data:r}}return t})));if(y.length>0&&(f.externalData=await Promise.all(y)),"webgpu"===i){const e=a_(n.config,{prefix:"present"});if(Object.keys(e).length>0&&!kp()){const t={};for(const n in e)t[n]="gpu-buffer";f.preferredOutputLocation=t}}return{buffer:await _,session_options:f,session_config:c}}async function cg(e,t,n){return Object.fromEntries(await Promise.all(Object.keys(t).map((async r=>{const{buffer:s,session_options:i,session_config:a}=await dg(e,t[r],n);return[r,await xp(s,i,a)]}))))}async function pg(e,t,n){return Object.fromEntries(await Promise.all(Object.keys(t).map((async r=>[r,await W(e,t[r],!1,n)]))))}async function hg(e,t){const n=function r(e,t){const n=Object.create(null),r=[];for(const s of e.inputNames){const e=t[s];e instanceof Cp?n[s]=kp()?e.clone():e:r.push(s)}if(r.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${r.join(", ")}.`);const s=Object.keys(t).length,i=e.inputNames.length;if(s>i){let n=Object.keys(t).filter((t=>!e.inputNames.includes(t)));console.warn(`WARNING: Too many inputs were provided (${s} > ${i}). The following inputs will be ignored: "${n.join(", ")}".`)}return n}(e,t);try{const t=Object.fromEntries(Object.entries(n).map((([e,t])=>[e,t.ort_tensor])));let r=await e.run(t);return r=fg(r),r}catch(e){const t=Object.fromEntries(Object.entries(n).map((([e,{type:t,dims:n,data:r}])=>[e,{type:t,dims:n,data:r}])));throw console.error(`An error occurred during model execution: "${e}".`),console.error("Inputs given to model:",t),e}}function fg(e){for(let t in e)vp(e[t])?e[t]=new Cp(e[t]):"object"==typeof e[t]&&fg(e[t]);return e}function mg(e){if(e instanceof Cp)return e;if(0===e.length)throw Error("items must be non-empty");if(Array.isArray(e[0])){if(e.some((t=>t.length!==e[0].length)))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with \'padding=True\' and/or \'truncation=True\' to have batched tensors with the same length.");return new Cp("int64",BigInt64Array.from(e.flat().map((e=>BigInt(e)))),[e.length,e[0].length])}return new Cp("int64",BigInt64Array.from(e.map((e=>BigInt(e)))),[1,e.length])}function _g(e){return new Cp("bool",[e],[1])}async function gg(e,t){let{encoder_outputs:n,input_ids:r,decoder_input_ids:s,...i}=t;if(!n){const r=M(t,e.sessions.model.inputNames);n=(await wg(e,r)).last_hidden_state}i.input_ids=s,i.encoder_hidden_states=n,e.sessions.decoder_model_merged.inputNames.includes("encoder_attention_mask")&&(i.encoder_attention_mask=t.attention_mask);return await yg(e,i,!0)}async function wg(e,t){const n=e.sessions.model,r=M(t,n.inputNames);if(n.inputNames.includes("inputs_embeds")&&!r.inputs_embeds){if(!t.input_ids)throw new Error("Both `input_ids` and `inputs_embeds` are missing in the model inputs.");r.inputs_embeds=await e.encode_text({input_ids:t.input_ids})}return n.inputNames.includes("token_type_ids")&&!r.token_type_ids&&(r.token_type_ids=new Cp("int64",new BigInt64Array(r.input_ids.data.length),r.input_ids.dims)),await hg(n,r)}async function yg(e,t,n=!1){const r=e.sessions[n?"decoder_model_merged":"model"],{past_key_values:s,...i}=t;if(r.inputNames.includes("use_cache_branch")&&(i.use_cache_branch=_g(!!s)),r.inputNames.includes("position_ids")&&i.attention_mask&&!i.position_ids){const t="paligemma"===e.config.model_type?1:0;i.position_ids=function n(e,t=null,r=0){const{input_ids:s,inputs_embeds:i,attention_mask:a}=e,{data:o,dims:l}=vg(a,r);let u=new Cp("int64",o,l);if(t){const e=-(s??i).dims.at(1);u=u.slice(null,[e,null])}return u}(i,s,t)}e.addPastKeyValues(i,s);const a=M(i,r.inputNames);return await hg(r,a)}function bg({image_token_id:e,inputs_embeds:t,image_features:n,input_ids:r,attention_mask:s}){const i=r.tolist().map((t=>t.reduce(((t,n,r)=>(n==e&&t.push(r),t)),[]))),a=i.reduce(((e,t)=>e+t.length),0),o=n.dims[0];if(a!==o)throw new Error(`Image features and image tokens do not match: tokens: ${a}, features ${o}`);let l=0;for(let e=0;e<i.length;++e){const r=i[e],s=t[e];for(let e=0;e<r.length;++e)s[r[e]].data.set(n[l++].data)}return{inputs_embeds:t,attention_mask:s}}async function xg(e,{input_ids:t=null,attention_mask:n=null,pixel_values:r=null,position_ids:s=null,inputs_embeds:i=null,past_key_values:a=null,generation_config:o=null,logits_processor:l=null,...u}){if(!i)if(i=await e.encode_text({input_ids:t,...u}),r&&1!==t.dims[1]){const s=await e.encode_image({pixel_values:r,...u});({inputs_embeds:i,attention_mask:n}=e._merge_input_ids_with_image_features({image_features:s,inputs_embeds:i,input_ids:t,attention_mask:n}))}else if(a&&r&&1===t.dims[1]){const e=t.dims[1],r=Object.values(a)[0].dims.at(-2);n=Rp([Wp([t.dims[0],r]),n.slice(null,[n.dims[1]-e,n.dims[1]])],1)}if(!s&&"qwen2_vl"===e.config.model_type){const{image_grid_thw:r,video_grid_thw:i}=u;[s]=e.get_rope_index(t,r,i,n)}return await yg(e,{inputs_embeds:i,past_key_values:a,attention_mask:n,position_ids:s,generation_config:o,logits_processor:l},!0)}function vg(e,t=0){const[n,r]=e.dims,s=e.data,i=new BigInt64Array(s.length);for(let e=0;e<n;++e){const n=e*r;let a=BigInt(t);for(let e=0;e<r;++e){const t=n+e;0n===s[t]?i[t]=BigInt(1):(i[t]=a,a+=s[t])}}return{data:i,dims:e.dims}}function $g(e,t,n,r){if(n.past_key_values){const t=Object.values(n.past_key_values)[0].dims.at(-2),{input_ids:r,attention_mask:s}=n;if(s&&s.dims[1]>r.dims[1]);else if(t<r.dims[1])n.input_ids=r.slice(null,[t,null]);else if(null!=e.config.image_token_index&&r.data.some((t=>t==e.config.image_token_index))){const s=e.config.num_image_tokens;if(!s)throw new Error("`num_image_tokens` is missing in the model configuration.");const i=r.dims[1]-(t-s);n.input_ids=r.slice(null,[-i,null]),n.attention_mask=Wp([1,t+i])}}return n}function kg(e,t,n,r){return n.past_key_values&&(t=t.map((e=>[e.at(-1)]))),{...n,decoder_input_ids:mg(t)}}function Eg(e,...t){return e.config.is_encoder_decoder?kg(e,...t):$g(e,...t)}function Sg(e,t,n,r){const s=!!n.past_key_values;if(null!==r.guidance_scale&&r.guidance_scale>1&&(s?n.input_ids=Rp([n.input_ids,n.input_ids],0):(n.input_ids=Rp([n.input_ids,Vp(n.input_ids,BigInt(r.pad_token_id))],0),n.attention_mask=Rp([n.attention_mask,Vp(n.attention_mask,0n)],0))),!s&&n.pixel_values||(n.pixel_values=qp([0,0,3,384,384],1)),s){const e=0,t=1,r=e>0?1:0,s=1;n.images_seq_mask=new Cp("bool",new Array(e+t).fill(!0).fill(!1,0,t),[s,e+t]),n.images_emb_mask=new Cp("bool",new Array(e).fill(!!r),[s,1,e])}return n}class zg extends k{main_input_name="input_ids";forward_params=["input_ids","attention_mask"];constructor(e,t,n){super(),this.config=e,this.sessions=t,this.configs=n;const r=ug.get(this.constructor),s=og.get(r);switch(this.can_generate=!1,this._forward=null,this._prepare_inputs_for_generation=null,s){case tg:this.can_generate=!0,this._forward=yg,this._prepare_inputs_for_generation=$g;break;case J_:case eg:case sg:this.can_generate=!0,this._forward=gg,this._prepare_inputs_for_generation=kg;break;case Z_:this._forward=gg;break;case rg:this.can_generate=!0,this._forward=xg,this._prepare_inputs_for_generation=Eg;break;case ag:this.can_generate=!0,this._prepare_inputs_for_generation=Eg;break;case ig:this.can_generate=!0,this._prepare_inputs_for_generation=Sg;break;default:this._forward=wg}this.can_generate&&this.forward_params.push("past_key_values"),this.custom_config=this.config["transformers.js_config"]??{}}async dispose(){const e=[];for(const t of Object.values(this.sessions))t?.handler?.dispose&&e.push(t.handler.dispose());return await Promise.all(e)}static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:i="main",model_file_name:a=null,subfolder:o="onnx",device:l=null,dtype:u=null,use_external_data_format:d=null,session_options:c={}}={}){let p={progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:i,model_file_name:a,subfolder:o,device:l,dtype:u,use_external_data_format:d,session_options:c};const h=ug.get(this),f=og.get(h);let m;if(n=p.config=await l_.from_pretrained(e,p),f===tg)m=await Promise.all([cg(e,{model:p.model_file_name??"model"},p),pg(e,{generation_config:"generation_config.json"},p)]);else if(f===J_||f===eg)m=await Promise.all([cg(e,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},p),pg(e,{generation_config:"generation_config.json"},p)]);else if(f===ng)m=await Promise.all([cg(e,{model:"vision_encoder",prompt_encoder_mask_decoder:"prompt_encoder_mask_decoder"},p)]);else if(f===Z_)m=await Promise.all([cg(e,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},p)]);else if(f===rg){const t={embed_tokens:"embed_tokens",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};n.is_encoder_decoder&&(t.model="encoder_model"),m=await Promise.all([cg(e,t,p),pg(e,{generation_config:"generation_config.json"},p)])}else if(f===sg)m=await Promise.all([cg(e,{model:"text_encoder",decoder_model_merged:"decoder_model_merged",encodec_decode:"encodec_decode"},p),pg(e,{generation_config:"generation_config.json"},p)]);else if(f===ig)m=await Promise.all([cg(e,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"language_model",lm_head:"lm_head",gen_head:"gen_head",gen_img_embeds:"gen_img_embeds",image_decode:"image_decode"},p),pg(e,{generation_config:"generation_config.json"},p)]);else if(f===ag)m=await Promise.all([cg(e,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"model",vision_encoder:"vision_encoder"},p),pg(e,{generation_config:"generation_config.json"},p)]);else{if(f!==Y_){const e=h??n?.model_type;"custom"!==e&&console.warn(`Model type for \'${e}\' not found, assuming encoder-only architecture. Please report this at ${f_}.`)}m=await Promise.all([cg(e,{model:p.model_file_name??"model"},p)])}return new this(n,...m)}async _call(e){return await this.forward(e)}async forward(e){return await this._forward(this,e)}get generation_config(){return this.configs?.generation_config??null}_get_logits_warper(e){const t=new y_;return null!==e.temperature&&1!==e.temperature&&t.push(new A_(e.temperature)),null!==e.top_k&&0!==e.top_k&&t.push(new M_(e.top_k)),null!==e.top_p&&e.top_p<1&&t.push(new I_(e.top_p)),t}_get_logits_processor(e,t,n=null){const r=new y_;if(null!==e.repetition_penalty&&1!==e.repetition_penalty&&r.push(new E_(e.repetition_penalty)),null!==e.no_repeat_ngram_size&&e.no_repeat_ngram_size>0&&r.push(new k_(e.no_repeat_ngram_size)),null!==e.bad_words_ids&&r.push(new C_(e.bad_words_ids,e.eos_token_id)),null!==e.min_length&&null!==e.eos_token_id&&e.min_length>0&&r.push(new S_(e.min_length,e.eos_token_id)),null!==e.min_new_tokens&&null!==e.eos_token_id&&e.min_new_tokens>0&&r.push(new z_(t,e.min_new_tokens,e.eos_token_id)),null!==e.forced_bos_token_id&&r.push(new b_(e.forced_bos_token_id)),null!==e.forced_eos_token_id&&r.push(new x_(e.max_length,e.forced_eos_token_id)),null!==e.begin_suppress_tokens){const n=t>1||null===e.forced_bos_token_id?t:t+1;r.push(new v_(e.begin_suppress_tokens,n))}return null!==e.guidance_scale&&e.guidance_scale>1&&r.push(new T_(e.guidance_scale)),null!==n&&r.extend(n),r}_prepare_generation_config(e,t,n=O_){const r={...this.config};for(const e of["decoder","generator","text_config"])e in r&&Object.assign(r,r[e]);const s=new n(r);return Object.assign(s,this.generation_config??{}),e&&Object.assign(s,e),t&&Object.assign(s,M(t,Object.getOwnPropertyNames(s))),s}_get_stopping_criteria(e,t=null){const n=new V_;return null!==e.max_length&&n.push(new W_(e.max_length,this.config.max_position_embeddings??null)),null!==e.eos_token_id&&n.push(new j_(e.eos_token_id)),t&&n.extend(t),n}_validate_model_class(){if(!this.can_generate){const e=[r$,fk,Hv,ov],t=ug.get(this.constructor),n=new Set,r=this.config.model_type;for(const t of e){const e=t.get(r);e&&n.add(e[0])}let s=`The current model class (${t}) is not compatible with \\`.generate()\\`, as it doesn\'t have a language model head.`;throw n.size>0&&(s+=` Please use the following class instead: ${[...n].join(", ")}`),Error(s)}}prepare_inputs_for_generation(...e){return this._prepare_inputs_for_generation(this,...e)}_update_model_kwargs_for_generation({generated_input_ids:e,outputs:t,model_inputs:n,is_encoder_decoder:r}){return n.past_key_values=this.getPastKeyValues(t,n.past_key_values),n.input_ids=new Cp("int64",e.flat(),[e.length,1]),r||(n.attention_mask=Rp([n.attention_mask,Wp([n.attention_mask.dims[0],1])],1)),n.position_ids=null,n}_prepare_model_inputs({inputs:e,bos_token_id:t,model_kwargs:n}){const r=M(n,this.forward_params),s=this.main_input_name;if(s in r){if(e)throw new Error("`inputs`: {inputs}` were passed alongside {input_name} which is not allowed. Make sure to either pass {inputs} or {input_name}=...")}else r[s]=e;return{inputs_tensor:r[s],model_inputs:r,model_input_name:s}}async _prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:e,model_inputs:t,model_input_name:n,generation_config:r}){if(this.sessions.model.inputNames.includes("inputs_embeds")&&!t.inputs_embeds&&"_prepare_inputs_embeds"in this){const{input_ids:e,pixel_values:n,attention_mask:r,...s}=t;t={...s,...M(await this._prepare_inputs_embeds(t),["inputs_embeds","attention_mask"])}}let{last_hidden_state:s}=await wg(this,t);if(null!==r.guidance_scale&&r.guidance_scale>1)s=Rp([s,Vp(s,0)],0),"attention_mask"in t&&(t.attention_mask=Rp([t.attention_mask,(i=t.attention_mask,Gp(i.dims))],0));else if(t.decoder_input_ids){const e=mg(t.decoder_input_ids).dims[0];if(e!==s.dims[0]){if(1!==s.dims[0])throw new Error(`The encoder outputs have a different batch size (${s.dims[0]}) than the decoder inputs (${e}).`);s=Rp(Array.from({length:e},(()=>s)),0)}}var i;return t.encoder_outputs=s,t}_prepare_decoder_input_ids_for_generation({batch_size:e,model_input_name:t,model_kwargs:n,decoder_start_token_id:r,bos_token_id:s,generation_config:i}){let{decoder_input_ids:a,...o}=n;if(!(a instanceof Cp)){if(a)Array.isArray(a[0])||(a=Array.from({length:e},(()=>a)));else if(r??=s,"musicgen"===this.config.model_type)a=Array.from({length:e*this.config.decoder.num_codebooks},(()=>[r]));else if(Array.isArray(r)){if(r.length!==e)throw new Error(`\\`decoder_start_token_id\\` expcted to have length ${e} but got ${r.length}`);a=r}else a=Array.from({length:e},(()=>[r]));a=mg(a)}return n.decoder_attention_mask=jp(a),{input_ids:a,model_inputs:o}}async generate({inputs:e=null,generation_config:t=null,logits_processor:n=null,stopping_criteria:r=null,streamer:s=null,...i}){this._validate_model_class(),t=this._prepare_generation_config(t,i);let{inputs_tensor:a,model_inputs:o,model_input_name:l}=this._prepare_model_inputs({inputs:e,model_kwargs:i});const u=this.config.is_encoder_decoder;let d;u&&("encoder_outputs"in o||(o=await this._prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:a,model_inputs:o,model_input_name:l,generation_config:t}))),u?({input_ids:d,model_inputs:o}=this._prepare_decoder_input_ids_for_generation({batch_size:o[l].dims.at(0),model_input_name:l,model_kwargs:o,decoder_start_token_id:t.decoder_start_token_id,bos_token_id:t.bos_token_id,generation_config:t})):d=o[l];let c=d.dims.at(-1);null!==t.max_new_tokens&&(t.max_length=c+t.max_new_tokens);const p=this._get_logits_processor(t,c,n),h=this._get_stopping_criteria(t,r),f=o[l].dims.at(0),m=G_.getSampler(t),_=new Array(f).fill(0),g=d.tolist();let w;s&&s.put(g);let y={};for(;;){if(o=this.prepare_inputs_for_generation(g,o,t),w=await this.forward(o),t.output_attentions&&t.return_dict_in_generate){const e=this.getAttentions(w);for(const t in e)t in y||(y[t]=[]),y[t].push(e[t])}const e=p(g,w.logits.slice(null,-1,null)),n=[];for(let t=0;t<e.dims.at(0);++t){const r=e[t],s=await m(r);for(const[e,r]of s){const s=BigInt(e);_[t]+=r,g[t].push(s),n.push([s]);break}}s&&s.put(n);if(h(g).every((e=>e)))break;o=this._update_model_kwargs_for_generation({generated_input_ids:n,outputs:w,model_inputs:o,is_encoder_decoder:u})}s&&s.end();const b=this.getPastKeyValues(w,o.past_key_values,!0),x=new Cp("int64",g.flat(),[g.length,g[0].length]);if(t.return_dict_in_generate)return{sequences:x,past_key_values:b,...y};for(const e of Object.values(w))"gpu-buffer"===e.location&&e.dispose();return x}getPastKeyValues(e,t,n=!1){const r=Object.create(null);for(const s in e)if(s.startsWith("present")){const i=s.replace("present","past_key_values"),a=s.includes("encoder");if(r[i]=a&&t?t[i]:e[s],t&&(!a||n)){const e=t[i];"gpu-buffer"===e.location&&e.dispose()}}return r}getAttentions(e){const t={};for(const n of["cross_attentions","encoder_attentions","decoder_attentions"])for(const r in e)r.startsWith(n)&&(n in t||(t[n]=[]),t[n].push(e[r]));return t}addPastKeyValues(e,t){if(t)Object.assign(e,t);else{const t=this.sessions.decoder_model_merged??this.sessions.model,n=t?.config?.kv_cache_dtype??"float32",r="float16"===n?new Uint16Array:[],s=(e[this.main_input_name]??e.attention_mask)?.dims?.[0]??1,i=a_(this.config,{batch_size:s});for(const t in i)e[t]=new Cp(n,r,i[t])}}async encode_image({pixel_values:e}){const t=(await hg(this.sessions.vision_encoder,{pixel_values:e})).image_features;return this.config.num_image_tokens||(console.warn(`The number of image tokens was not set in the model configuration. Setting it to the number of features detected by the vision encoder (${t.dims[1]}).`),this.config.num_image_tokens=t.dims[1]),t}async encode_text({input_ids:e}){return(await hg(this.sessions.embed_tokens,{input_ids:e})).inputs_embeds}}class Cg{}class Tg extends zg{}class Ag extends zg{}class Ig extends zg{}class Mg extends zg{}class Og extends zg{}class Bg extends zg{}class Ng extends zg{}class Pg extends zg{}class Rg extends zg{}class Dg extends zg{}class Lg extends zg{}class Fg extends zg{}class Ug extends zg{}class qg extends zg{}class Vg extends zg{forward_params=["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"]}class Wg extends zg{}class jg extends zg{}class Gg extends zg{}class Hg extends zg{}class Kg extends zg{}class Xg extends zg{}class Qg extends zg{}class Yg extends zg{}class Zg extends zg{}class Jg extends zg{}class ew extends zg{requires_attention_mask=!1;main_input_name="input_features";forward_params=["input_features","attention_mask","decoder_input_ids","decoder_attention_mask","past_key_values"]}class tw extends zg{requires_attention_mask=!1;main_input_name="input_values";forward_params=["input_values","decoder_input_ids","past_key_values"]}class nw extends zg{main_input_name="pixel_values";forward_params=["pixel_values","decoder_input_ids","encoder_hidden_states","past_key_values"]}class rw extends zg{forward_params=["input_ids","attention_mask","pixel_values","position_ids","past_key_values"]}class sw extends rw{_merge_input_ids_with_image_features({inputs_embeds:e,image_features:t,input_ids:n,attention_mask:r}){const s=this.config.image_token_index,i=n.tolist().map((e=>e.findIndex((e=>e==s)))),a=i.every((e=>-1===e)),o=i.every((e=>-1!==e));if(!a&&!o)throw new Error("Every input should contain either 0 or 1 image token.");if(a)return{inputs_embeds:e,attention_mask:r};const l=[],u=[];for(let n=0;n<i.length;++n){const s=i[n],a=e[n],o=t[n],d=r[n];l.push(Rp([a.slice([0,s]),o,a.slice([s+1,a.dims[0]])],0)),u.push(Rp([d.slice([0,s]),Wp([o.dims[0]]),d.slice([s+1,d.dims[0]])],0))}return{inputs_embeds:Dp(l,0),attention_mask:Dp(u,0)}}}class iw extends zg{forward_params=["input_ids","inputs_embeds","attention_mask","pixel_values","encoder_outputs","decoder_input_ids","decoder_inputs_embeds","decoder_attention_mask","past_key_values"];main_input_name="inputs_embeds"}class aw extends zg{forward_params=["input_ids","attention_mask","pixel_values","position_ids","past_key_values"]}class ow extends zg{forward_params=["input_ids","attention_mask","pixel_values","pixel_attention_mask","position_ids","past_key_values"]}class lw extends ow{async encode_image({pixel_values:e,pixel_attention_mask:t}){return(await hg(this.sessions.vision_encoder,{pixel_values:e,pixel_attention_mask:t})).image_features}_merge_input_ids_with_image_features(e){const t=e.image_features.dims.at(-1),n=e.image_features.view(-1,t);return bg({image_token_id:this.config.image_token_id,...e,image_features:n})}}class uw extends zg{forward_params=["input_ids","inputs_embeds","attention_mask","position_ids","pixel_values","image_sizes","past_key_values"]}class dw extends uw{async forward({input_ids:e=null,attention_mask:t=null,pixel_values:n=null,image_sizes:r=null,position_ids:s=null,inputs_embeds:i=null,past_key_values:a=null,generation_config:o=null,logits_processor:l=null,...u}){if(!i){let t;if(n&&1!==e.dims[1]){if(!r)throw new Error("`image_sizes` must be provided when `pixel_values` is provided.");({image_features:t}=await hg(this.sessions.vision_encoder,{pixel_values:n,image_sizes:r}))}else{const e=this.config.normalized_config.hidden_size;t=new Cp("float32",[],[0,e])}({inputs_embeds:i}=await hg(this.sessions.prepare_inputs_embeds,{input_ids:e,image_features:t}))}return await yg(this,{inputs_embeds:i,past_key_values:a,attention_mask:t,position_ids:s,generation_config:o,logits_processor:l},!1)}}class cw extends zg{}class pw extends zg{}class hw extends zg{}class fw extends zg{}class mw extends zg{}class _w extends zg{}class gw extends zg{}class ww extends zg{}class yw extends zg{}class bw extends zg{}class xw extends zg{}class vw extends zg{}class $w extends zg{}class kw extends zg{}class Ew extends zg{}class Sw extends zg{}class zw extends zg{}class Cw extends zg{}class Tw extends zg{}class Aw extends zg{}class Iw extends zg{}class Mw extends zg{}class Ow extends zg{}class Bw extends zg{forward_params=["input_ids","attention_mask","position_ids","past_key_values","pixel_values","image_grid_thw"]}class Nw extends zg{}class Pw extends zg{}class Rw extends zg{}class Dw extends zg{}class Lw extends zg{}class Fw extends zg{}class Uw extends zg{}class qw extends zg{}class Vw extends zg{}class Ww extends zg{}class jw extends zg{}class Gw extends zg{}class Hw extends zg{}class Kw extends zg{}class Xw extends zg{}class Qw extends zg{}class Yw extends zg{}class Zw extends zg{}class Jw extends zg{}class ey extends zg{}class ty extends ey{async _call(e){return new ry(await super._call(e))}}class ny extends Cg{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class ry extends Cg{constructor({logits:e,pred_boxes:t,pred_masks:n}){super(),this.logits=e,this.pred_boxes=t,this.pred_masks=n}}class sy extends zg{}class iy extends Cg{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class ay extends zg{}class oy extends ny{}class ly extends zg{}class uy extends zg{}class dy extends zg{}class cy extends zg{}class py extends zg{}class hy extends zg{}class fy extends zg{}class my extends zg{}class _y extends zg{}class gy extends zg{}class wy extends zg{}class yy extends zg{}class by extends zg{}class xy extends zg{}class vy extends zg{}class $y extends zg{}class ky extends Cg{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class Ey extends zg{}class Sy extends Cg{constructor({iou_scores:e,pred_masks:t}){super(),this.iou_scores=e,this.pred_masks=t}}class zy extends zg{}class Cy extends zg{}class Ty extends zg{}class Ay extends zg{}class Iy extends zg{}class My extends zg{}class Oy extends zg{}class By extends zg{}class Ny extends zg{}class Py extends zg{}class Ry extends zg{}class Dy extends zg{}class Ly extends zg{}class Fy extends zg{}class Uy extends zg{}class qy extends zg{}class Vy extends qy{async _call(e){return new hS(await super._call(e))}}class Wy extends zg{}class jy extends zg{}class Gy extends zg{}class Hy extends zg{forward_params=["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"];_apply_and_filter_by_delay_pattern_mask(e){const[t,n]=e.dims,r=this.config.decoder.num_codebooks,s=n-r;let i=0;for(let t=0;t<e.size;++t){if(e.data[t]===this.config.decoder.pad_token_id)continue;const a=t%n-Math.floor(t/n)%r;a>0&&a<=s&&(e.data[i++]=e.data[t])}const a=Math.floor(t/r),o=i/(a*r);return new Cp(e.type,e.data.slice(0,i),[a,r,o])}prepare_inputs_for_generation(e,t,n){let r=structuredClone(e);for(let e=0;e<r.length;++e)for(let t=0;t<r[e].length;++t)e%this.config.decoder.num_codebooks>=t&&(r[e][t]=BigInt(this.config.decoder.pad_token_id));null!==n.guidance_scale&&n.guidance_scale>1&&(r=r.concat(r));return super.prepare_inputs_for_generation(r,t,n)}async generate(e){const t=await super.generate(e),n=this._apply_and_filter_by_delay_pattern_mask(t).unsqueeze_(0),{audio_values:r}=await hg(this.sessions.encodec_decode,{audio_codes:n});return r}}class Ky extends zg{}class Xy extends zg{}class Qy extends zg{}class Yy extends zg{}class Zy extends zg{}class Jy extends zg{}class eb extends Cg{constructor({char_logits:e,bpe_logits:t,wp_logits:n}){super(),this.char_logits=e,this.bpe_logits=t,this.wp_logits=n}get logits(){return[this.char_logits,this.bpe_logits,this.wp_logits]}}class tb extends zg{}class nb extends zg{}class rb extends zg{}class sb{static MODEL_CLASS_MAPPINGS=null;static BASE_IF_FAIL=!1;static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:i="main",model_file_name:a=null,subfolder:o="onnx",device:l=null,dtype:u=null,use_external_data_format:d=null,session_options:c={}}={}){const p={progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:i,model_file_name:a,subfolder:o,device:l,dtype:u,use_external_data_format:d,session_options:c};if(p.config=await l_.from_pretrained(e,p),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);for(const t of this.MODEL_CLASS_MAPPINGS){const n=t.get(p.config.model_type);if(n)return await n[1].from_pretrained(e,p)}if(this.BASE_IF_FAIL)return console.warn(`Unknown model class "${p.config.model_type}", attempting to construct from base class.`),await zg.from_pretrained(e,p);throw Error(`Unsupported model type: ${p.config.model_type}`)}}const ib=new Map([["bert",["BertModel",class ab extends Tg{}]],["nomic_bert",["NomicBertModel",class ob extends Ag{}]],["roformer",["RoFormerModel",class lb extends Ig{}]],["electra",["ElectraModel",class ub extends Og{}]],["esm",["EsmModel",class db extends Dg{}]],["convbert",["ConvBertModel",class cb extends Mg{}]],["camembert",["CamembertModel",class pb extends Bg{}]],["deberta",["DebertaModel",class hb extends Ng{}]],["deberta-v2",["DebertaV2Model",class fb extends Pg{}]],["mpnet",["MPNetModel",class mb extends Fg{}]],["albert",["AlbertModel",class _b extends qg{}]],["distilbert",["DistilBertModel",class gb extends Rg{}]],["roberta",["RobertaModel",class wb extends Qg{}]],["xlm",["XLMModel",class yb extends Yg{}]],["xlm-roberta",["XLMRobertaModel",class bb extends Zg{}]],["clap",["ClapModel",class xb extends Uy{}]],["clip",["CLIPModel",class vb extends cw{}]],["clipseg",["CLIPSegModel",class $b extends mw{}]],["chinese_clip",["ChineseCLIPModel",class kb extends hw{}]],["siglip",["SiglipModel",class Eb extends pw{}]],["jina_clip",["JinaCLIPModel",class Sb extends fw{async forward(e){const t=!e.input_ids,n=!e.pixel_values;if(t&&n)throw new Error("Either `input_ids` or `pixel_values` should be provided.");if(t&&(e.input_ids=Wp([e.pixel_values.dims[0],1])),n){const{image_size:t}=this.config.vision_config;e.pixel_values=qp([0,3,t,t],0)}const{text_embeddings:r,image_embeddings:s,l2norm_text_embeddings:i,l2norm_image_embeddings:a}=await super.forward(e),o={};return t||(o.text_embeddings=r,o.l2norm_text_embeddings=i),n||(o.image_embeddings=s,o.l2norm_image_embeddings=a),o}}]],["mobilebert",["MobileBertModel",class zb extends Lg{}]],["squeezebert",["SqueezeBertModel",class Cb extends Ug{}]],["wav2vec2",["Wav2Vec2Model",class Tb extends Ty{}]],["wav2vec2-bert",["Wav2Vec2BertModel",class Ab extends By{}]],["unispeech",["UniSpeechModel",class Ib extends My{}]],["unispeech-sat",["UniSpeechSatModel",class Mb extends Oy{}]],["hubert",["HubertModel",class Ob extends Ty{}]],["wavlm",["WavLMModel",class Bb extends Ny{}]],["audio-spectrogram-transformer",["ASTModel",class Nb extends Jg{}]],["vits",["VitsModel",Vy]],["pyannote",["PyAnnoteModel",class Pb extends Ay{}]],["wespeaker-resnet",["WeSpeakerResNetModel",class Rb extends Iy{}]],["detr",["DetrModel",class Db extends ey{}]],["rt_detr",["RTDetrModel",class Lb extends sy{}]],["table-transformer",["TableTransformerModel",class Fb extends ay{}]],["vit",["ViTModel",class Ub extends Fw{}]],["ijepa",["IJepaModel",class qb extends Uw{}]],["pvt",["PvtModel",class Vb extends Vw{}]],["vit_msn",["ViTMSNModel",class Wb extends jw{}]],["vit_mae",["ViTMAEModel",class jb extends Ww{}]],["groupvit",["GroupViTModel",class Gb extends Gw{}]],["fastvit",["FastViTModel",class Hb extends Hw{}]],["mobilevit",["MobileViTModel",class Kb extends Xw{}]],["mobilevitv2",["MobileViTV2Model",class Xb extends Qw{}]],["owlvit",["OwlViTModel",class Qb extends Yw{}]],["owlv2",["Owlv2Model",class Yb extends Zw{}]],["beit",["BeitModel",class Zb extends Jw{}]],["deit",["DeiTModel",class Jb extends ly{}]],["hiera",["HieraModel",class ex extends uy{}]],["convnext",["ConvNextModel",class tx extends by{}]],["convnextv2",["ConvNextV2Model",class nx extends xy{}]],["dinov2",["Dinov2Model",class rx extends vy{}]],["resnet",["ResNetModel",class sx extends dy{}]],["swin",["SwinModel",class ix extends cy{}]],["swin2sr",["Swin2SRModel",class ax extends py{}]],["donut-swin",["DonutSwinModel",class ox extends yy{}]],["yolos",["YolosModel",class lx extends $y{}]],["dpt",["DPTModel",class ux extends hy{}]],["glpn",["GLPNModel",class dx extends wy{}]],["hifigan",["SpeechT5HifiGan",class cx extends zg{main_input_name="spectrogram"}]],["efficientnet",["EfficientNetModel",class px extends Gy{}]],["decision_transformer",["DecisionTransformerModel",class hx extends Zy{}]],["patchtst",["PatchTSTForPrediction",class fx extends nb{}]],["patchtsmixer",["PatchTSMixerForPrediction",class mx extends rb{}]],["mobilenet_v1",["MobileNetV1Model",class _x extends Ky{}]],["mobilenet_v2",["MobileNetV2Model",class gx extends Xy{}]],["mobilenet_v3",["MobileNetV3Model",class wx extends Qy{}]],["mobilenet_v4",["MobileNetV4Model",class yx extends Yy{}]],["maskformer",["MaskFormerModel",class bx extends gy{}]],["mgp-str",["MgpstrForSceneTextRecognition",class xx extends tb{async _call(e){return new eb(await super._call(e))}}]]]),vx=new Map([["t5",["T5Model",class $x extends Vg{}]],["longt5",["LongT5Model",class kx extends Wg{}]],["mt5",["MT5Model",class Ex extends jg{}]],["bart",["BartModel",class Sx extends Gg{}]],["mbart",["MBartModel",class zx extends Hg{}]],["marian",["MarianModel",class Cx extends zy{}]],["whisper",["WhisperModel",class Tx extends ew{}]],["m2m_100",["M2M100Model",class Ax extends Cy{}]],["blenderbot",["BlenderbotModel",class Ix extends Kg{}]],["blenderbot-small",["BlenderbotSmallModel",class Mx extends Xg{}]]]),Ox=new Map([["bloom",["BloomModel",class Bx extends Rw{}]],["jais",["JAISModel",class Nx extends gw{}]],["gpt2",["GPT2Model",class Px extends _w{}]],["gptj",["GPTJModel",class Rx extends bw{}]],["gpt_bigcode",["GPTBigCodeModel",class Dx extends xw{}]],["gpt_neo",["GPTNeoModel",class Lx extends ww{}]],["gpt_neox",["GPTNeoXModel",class Fx extends yw{}]],["codegen",["CodeGenModel",class Ux extends vw{}]],["llama",["LlamaModel",class qx extends $w{}]],["exaone",["ExaoneModel",class Vx extends kw{}]],["olmo",["OlmoModel",class Wx extends Sw{}]],["olmo2",["Olmo2Model",class jx extends zw{}]],["mobilellm",["MobileLLMModel",class Gx extends Ew{}]],["granite",["GraniteModel",class Hx extends Cw{}]],["cohere",["CohereModel",class Kx extends Tw{}]],["gemma",["GemmaModel",class Xx extends Aw{}]],["gemma2",["Gemma2Model",class Qx extends Iw{}]],["openelm",["OpenELMModel",class Yx extends Mw{}]],["qwen2",["Qwen2Model",class Zx extends Ow{}]],["phi",["PhiModel",class Jx extends Nw{}]],["phi3",["Phi3Model",class ev extends Pw{}]],["mpt",["MptModel",class tv extends Dw{}]],["opt",["OPTModel",class nv extends Lw{}]],["mistral",["MistralModel",class rv extends Dy{}]],["starcoder2",["Starcoder2Model",class sv extends Ly{}]],["falcon",["FalconModel",class iv extends Fy{}]],["stablelm",["StableLmModel",class av extends jy{}]]]),ov=new Map([["speecht5",["SpeechT5ForSpeechToText",class lv extends Py{}]],["whisper",["WhisperForConditionalGeneration",class uv extends ew{_prepare_generation_config(e,t){return super._prepare_generation_config(e,t,Q_)}_retrieve_init_tokens(e){const t=[e.decoder_start_token_id];let n=e.language;const r=e.task;if(e.is_multilingual){n||(console.warn("No language specified - defaulting to English (en)."),n="en");const s=function i(e){e=e.toLowerCase();let t=Zh.get(e);if(void 0===t){if(!Yh.has(e)){const t=2===e.length?Yh.keys():Yh.values();throw new Error(`Language "${e}" is not supported. Must be one of: ${JSON.stringify(t)}`)}t=e}return t}(n),a=`<|${s}|>`;t.push(e.lang_to_id[a]),t.push(e.task_to_id[r??"transcribe"])}else if(n||r)throw new Error("Cannot specify `task` or `language` for an English-only model. If the model is intended to be multilingual, pass `is_multilingual=true` to generate, or update the generation config.");return!e.return_timestamps&&e.no_timestamps_token_id&&t.at(-1)!==e.no_timestamps_token_id?t.push(e.no_timestamps_token_id):e.return_timestamps&&t.at(-1)===e.no_timestamps_token_id&&(console.warn("<|notimestamps|> prompt token is removed from generation_config since `return_timestamps` is set to `true`."),t.pop()),t.filter((e=>null!=e))}async generate({inputs:e=null,generation_config:t=null,logits_processor:n=null,stopping_criteria:r=null,...s}){t=this._prepare_generation_config(t,s);const i=s.decoder_input_ids??this._retrieve_init_tokens(t);if(t.return_timestamps&&(n??=new y_,n.push(new $_(t,i))),t.begin_suppress_tokens&&(n??=new y_,n.push(new v_(t.begin_suppress_tokens,i.length))),t.return_token_timestamps){if(!t.alignment_heads)throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");"translate"===t.task&&console.warn("Token-level timestamps may not be reliable for task \'translate\'."),t.output_attentions=!0,t.return_dict_in_generate=!0}const a=await super.generate({inputs:e,generation_config:t,logits_processor:n,decoder_input_ids:i,...s});return t.return_token_timestamps&&(a.token_timestamps=this._extract_token_timestamps(a,t.alignment_heads,t.num_frames)),a}_extract_token_timestamps(e,t,n=null,r=.02){if(!e.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");null==n&&console.warn("`num_frames` has not been set, meaning the entire audio will be analyzed. This may lead to inaccurate token-level timestamps for short audios (< 30 seconds).");let s=this.config.median_filter_width;void 0===s&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),s=7);const i=e.cross_attentions,a=Array.from({length:this.config.decoder_layers},((e,t)=>Rp(i.map((e=>e[t])),2))),o=Dp(t.map((([e,t])=>{if(e>=a.length)throw new Error(`Layer index ${e} is out of bounds for cross attentions (length ${a.length}).`);return n?a[e].slice(null,t,null,[0,n]):a[e].slice(null,t)}))).transpose(1,0,2,3),[l,u]=Lp(o,-2,0,!0),d=o.clone();for(let e=0;e<d.dims[0];++e){const t=d[e];for(let n=0;n<t.dims[0];++n){const r=t[n],i=l[e][n][0].data,a=u[e][n][0].data;for(let e=0;e<r.dims[0];++e){let t=r[e].data;for(let e=0;e<t.length;++e)t[e]=(t[e]-a[e])/i[e];t.set(ee(t,s))}}}const c=[Fp(d,1)],p=e.sequences.dims,h=new Cp("float32",new Float32Array(p[0]*p[1]),p);for(let e=0;e<p[0];++e){const t=c[e].neg().squeeze_(0),[n,s]=ne(t.tolist()),i=T([1],Array.from({length:n.length-1},((e,t)=>n[t+1]-n[t]))).map((e=>!!e)),a=[];for(let e=0;e<i.length;++e)i[e]&&a.push(s[e]*r);h[e].data.set(a,1)}return h}}]],["moonshine",["MoonshineForConditionalGeneration",class dv extends tw{}]]]),cv=new Map([["speecht5",["SpeechT5ForTextToSpeech",class pv extends Py{async generate_speech(e,t,{threshold:n=.5,minlenratio:r=0,maxlenratio:s=20,vocoder:i=null}={}){const a={input_ids:e},{encoder_outputs:o,encoder_attention_mask:l}=await wg(this,a),u=o.dims[1]/this.config.reduction_factor,d=Math.floor(u*s),c=Math.floor(u*r),p=this.config.num_mel_bins;let h=[],f=null,m=null,_=0;for(;;){++_;const e=_g(!!m);let r;r=m?m.output_sequence_out:new Cp("float32",new Float32Array(p),[1,1,p]);let s={use_cache_branch:e,output_sequence:r,encoder_attention_mask:l,speaker_embeddings:t,encoder_hidden_states:o};this.addPastKeyValues(s,f),m=await hg(this.sessions.decoder_model_merged,s),f=this.getPastKeyValues(m,f);const{prob:i,spectrum:a}=m;if(h.push(a),_>=c&&(Array.from(i.data).filter((e=>e>=n)).length>0||_>=d))break}const g=Rp(h),{waveform:w}=await hg(i.sessions.model,{spectrogram:g});return{spectrogram:g,waveform:w}}}]]]),hv=new Map([["vits",["VitsModel",Vy]],["musicgen",["MusicgenForConditionalGeneration",Hy]]]),fv=new Map([["bert",["BertForSequenceClassification",class mv extends Tg{async _call(e){return new aS(await super._call(e))}}]],["roformer",["RoFormerForSequenceClassification",class _v extends Ig{async _call(e){return new aS(await super._call(e))}}]],["electra",["ElectraForSequenceClassification",class gv extends Og{async _call(e){return new aS(await super._call(e))}}]],["esm",["EsmForSequenceClassification",class wv extends Dg{async _call(e){return new aS(await super._call(e))}}]],["convbert",["ConvBertForSequenceClassification",class yv extends Mg{async _call(e){return new aS(await super._call(e))}}]],["camembert",["CamembertForSequenceClassification",class bv extends Bg{async _call(e){return new aS(await super._call(e))}}]],["deberta",["DebertaForSequenceClassification",class xv extends Ng{async _call(e){return new aS(await super._call(e))}}]],["deberta-v2",["DebertaV2ForSequenceClassification",class vv extends Pg{async _call(e){return new aS(await super._call(e))}}]],["mpnet",["MPNetForSequenceClassification",class $v extends Fg{async _call(e){return new aS(await super._call(e))}}]],["albert",["AlbertForSequenceClassification",class kv extends qg{async _call(e){return new aS(await super._call(e))}}]],["distilbert",["DistilBertForSequenceClassification",class Ev extends Rg{async _call(e){return new aS(await super._call(e))}}]],["roberta",["RobertaForSequenceClassification",class Sv extends Qg{async _call(e){return new aS(await super._call(e))}}]],["xlm",["XLMForSequenceClassification",class zv extends Yg{async _call(e){return new aS(await super._call(e))}}]],["xlm-roberta",["XLMRobertaForSequenceClassification",class Cv extends Zg{async _call(e){return new aS(await super._call(e))}}]],["bart",["BartForSequenceClassification",class Tv extends Gg{async _call(e){return new aS(await super._call(e))}}]],["mbart",["MBartForSequenceClassification",class Av extends Hg{async _call(e){return new aS(await super._call(e))}}]],["mobilebert",["MobileBertForSequenceClassification",class Iv extends Lg{async _call(e){return new aS(await super._call(e))}}]],["squeezebert",["SqueezeBertForSequenceClassification",class Mv extends Ug{async _call(e){return new aS(await super._call(e))}}]]]),Ov=new Map([["bert",["BertForTokenClassification",class Bv extends Tg{async _call(e){return new lS(await super._call(e))}}]],["roformer",["RoFormerForTokenClassification",class Nv extends Ig{async _call(e){return new lS(await super._call(e))}}]],["electra",["ElectraForTokenClassification",class Pv extends Og{async _call(e){return new lS(await super._call(e))}}]],["esm",["EsmForTokenClassification",class Rv extends Dg{async _call(e){return new lS(await super._call(e))}}]],["convbert",["ConvBertForTokenClassification",class Dv extends Mg{async _call(e){return new lS(await super._call(e))}}]],["camembert",["CamembertForTokenClassification",class Lv extends Bg{async _call(e){return new lS(await super._call(e))}}]],["deberta",["DebertaForTokenClassification",class Fv extends Ng{async _call(e){return new lS(await super._call(e))}}]],["deberta-v2",["DebertaV2ForTokenClassification",class Uv extends Pg{async _call(e){return new lS(await super._call(e))}}]],["mpnet",["MPNetForTokenClassification",class qv extends Fg{async _call(e){return new lS(await super._call(e))}}]],["distilbert",["DistilBertForTokenClassification",class Vv extends Rg{async _call(e){return new lS(await super._call(e))}}]],["roberta",["RobertaForTokenClassification",class Wv extends Qg{async _call(e){return new lS(await super._call(e))}}]],["xlm",["XLMForTokenClassification",class jv extends Yg{async _call(e){return new lS(await super._call(e))}}]],["xlm-roberta",["XLMRobertaForTokenClassification",class Gv extends Zg{async _call(e){return new lS(await super._call(e))}}]]]),Hv=new Map([["t5",["T5ForConditionalGeneration",class Kv extends Vg{}]],["longt5",["LongT5ForConditionalGeneration",class Xv extends Wg{}]],["mt5",["MT5ForConditionalGeneration",class Qv extends jg{}]],["bart",["BartForConditionalGeneration",class Yv extends Gg{}]],["mbart",["MBartForConditionalGeneration",class Zv extends Hg{}]],["marian",["MarianMTModel",class Jv extends zy{}]],["m2m_100",["M2M100ForConditionalGeneration",class e$ extends Cy{}]],["blenderbot",["BlenderbotForConditionalGeneration",class t$ extends Kg{}]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",class n$ extends Xg{}]]]),r$=new Map([["bloom",["BloomForCausalLM",class s$ extends Rw{}]],["gpt2",["GPT2LMHeadModel",class i$ extends _w{}]],["jais",["JAISLMHeadModel",class a$ extends gw{}]],["gptj",["GPTJForCausalLM",class o$ extends bw{}]],["gpt_bigcode",["GPTBigCodeForCausalLM",class l$ extends xw{}]],["gpt_neo",["GPTNeoForCausalLM",class u$ extends ww{}]],["gpt_neox",["GPTNeoXForCausalLM",class d$ extends yw{}]],["codegen",["CodeGenForCausalLM",class c$ extends vw{}]],["llama",["LlamaForCausalLM",class p$ extends $w{}]],["exaone",["ExaoneForCausalLM",class h$ extends kw{}]],["olmo",["OlmoForCausalLM",class f$ extends Sw{}]],["olmo2",["Olmo2ForCausalLM",class m$ extends zw{}]],["mobilellm",["MobileLLMForCausalLM",class _$ extends Ew{}]],["granite",["GraniteForCausalLM",class g$ extends Cw{}]],["cohere",["CohereForCausalLM",class w$ extends Tw{}]],["gemma",["GemmaForCausalLM",class y$ extends Aw{}]],["gemma2",["Gemma2ForCausalLM",class b$ extends Iw{}]],["openelm",["OpenELMForCausalLM",class x$ extends Mw{}]],["qwen2",["Qwen2ForCausalLM",class v$ extends Ow{}]],["phi",["PhiForCausalLM",class $$ extends Nw{}]],["phi3",["Phi3ForCausalLM",class k$ extends Pw{}]],["mpt",["MptForCausalLM",class E$ extends Dw{}]],["opt",["OPTForCausalLM",class S$ extends Lw{}]],["mbart",["MBartForCausalLM",class z$ extends Hg{}]],["mistral",["MistralForCausalLM",class C$ extends Dy{}]],["starcoder2",["Starcoder2ForCausalLM",class T$ extends Ly{}]],["falcon",["FalconForCausalLM",class A$ extends Fy{}]],["trocr",["TrOCRForCausalLM",class I$ extends Ry{}]],["stablelm",["StableLmForCausalLM",class M$ extends jy{}]],["phi3_v",["Phi3VForCausalLM",dw]]]),O$=new Map([["multi_modality",["MultiModalityCausalLM",class B$ extends Jy{forward_params=["input_ids","pixel_values","images_seq_mask","images_emb_mask","attention_mask","position_ids","past_key_values"];constructor(...e){super(...e),this._generation_mode="text"}async forward(e){const t=this._generation_mode??"text";let n;if("text"!==t&&e.past_key_values){const t=this.sessions.gen_img_embeds,r=M({image_ids:e.input_ids},t.inputNames);n=await hg(t,r)}else{const t=this.sessions.prepare_inputs_embeds,r=M(e,t.inputNames);n=await hg(t,r)}const r={...e,...n},s=await yg(this,r),i=this.sessions["text"===t?"lm_head":"gen_head"];if(!i)throw new Error(`Unable to find "${i}" generation head`);const a=await hg(i,M(s,i.inputNames));return{...n,...s,...a}}async generate(e){return this._generation_mode="text",super.generate(e)}async generate_images(e){this._generation_mode="image";const t=(e.inputs??e[this.main_input_name]).dims[1],n=(await super.generate(e)).slice(null,[t,null]),r=this.sessions.image_decode,{decoded_image:s}=await hg(r,{generated_tokens:n}),i=s.add_(1).mul_(127.5).clamp_(0,255).to("uint8"),a=[];for(const e of i){const t=U_.fromTensor(e);a.push(t)}return a}}]]]),N$=new Map([["bert",["BertForMaskedLM",class P$ extends Tg{async _call(e){return new uS(await super._call(e))}}]],["roformer",["RoFormerForMaskedLM",class R$ extends Ig{async _call(e){return new uS(await super._call(e))}}]],["electra",["ElectraForMaskedLM",class D$ extends Og{async _call(e){return new uS(await super._call(e))}}]],["esm",["EsmForMaskedLM",class L$ extends Dg{async _call(e){return new uS(await super._call(e))}}]],["convbert",["ConvBertForMaskedLM",class F$ extends Mg{async _call(e){return new uS(await super._call(e))}}]],["camembert",["CamembertForMaskedLM",class U$ extends Bg{async _call(e){return new uS(await super._call(e))}}]],["deberta",["DebertaForMaskedLM",class q$ extends Ng{async _call(e){return new uS(await super._call(e))}}]],["deberta-v2",["DebertaV2ForMaskedLM",class V$ extends Pg{async _call(e){return new uS(await super._call(e))}}]],["mpnet",["MPNetForMaskedLM",class W$ extends Fg{async _call(e){return new uS(await super._call(e))}}]],["albert",["AlbertForMaskedLM",class j$ extends qg{async _call(e){return new uS(await super._call(e))}}]],["distilbert",["DistilBertForMaskedLM",class G$ extends Rg{async _call(e){return new uS(await super._call(e))}}]],["roberta",["RobertaForMaskedLM",class H$ extends Qg{async _call(e){return new uS(await super._call(e))}}]],["xlm",["XLMWithLMHeadModel",class K$ extends Yg{async _call(e){return new uS(await super._call(e))}}]],["xlm-roberta",["XLMRobertaForMaskedLM",class X$ extends Zg{async _call(e){return new uS(await super._call(e))}}]],["mobilebert",["MobileBertForMaskedLM",class Q$ extends Lg{async _call(e){return new uS(await super._call(e))}}]],["squeezebert",["SqueezeBertForMaskedLM",class Y$ extends Ug{async _call(e){return new uS(await super._call(e))}}]]]),Z$=new Map([["bert",["BertForQuestionAnswering",class J$ extends Tg{async _call(e){return new dS(await super._call(e))}}]],["roformer",["RoFormerForQuestionAnswering",class ek extends Ig{async _call(e){return new dS(await super._call(e))}}]],["electra",["ElectraForQuestionAnswering",class tk extends Og{async _call(e){return new dS(await super._call(e))}}]],["convbert",["ConvBertForQuestionAnswering",class nk extends Mg{async _call(e){return new dS(await super._call(e))}}]],["camembert",["CamembertForQuestionAnswering",class rk extends Bg{async _call(e){return new dS(await super._call(e))}}]],["deberta",["DebertaForQuestionAnswering",class sk extends Ng{async _call(e){return new dS(await super._call(e))}}]],["deberta-v2",["DebertaV2ForQuestionAnswering",class ik extends Pg{async _call(e){return new dS(await super._call(e))}}]],["mpnet",["MPNetForQuestionAnswering",class ak extends Fg{async _call(e){return new dS(await super._call(e))}}]],["albert",["AlbertForQuestionAnswering",class ok extends qg{async _call(e){return new dS(await super._call(e))}}]],["distilbert",["DistilBertForQuestionAnswering",class lk extends Rg{async _call(e){return new dS(await super._call(e))}}]],["roberta",["RobertaForQuestionAnswering",class uk extends Qg{async _call(e){return new dS(await super._call(e))}}]],["xlm",["XLMForQuestionAnswering",class dk extends Yg{async _call(e){return new dS(await super._call(e))}}]],["xlm-roberta",["XLMRobertaForQuestionAnswering",class ck extends Zg{async _call(e){return new dS(await super._call(e))}}]],["mobilebert",["MobileBertForQuestionAnswering",class pk extends Lg{async _call(e){return new dS(await super._call(e))}}]],["squeezebert",["SqueezeBertForQuestionAnswering",class hk extends Ug{async _call(e){return new dS(await super._call(e))}}]]]),fk=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",nw]],["idefics3",["Idefics3ForConditionalGeneration",lw]]]),mk=new Map([["llava",["LlavaForConditionalGeneration",sw]],["llava_onevision",["LlavaOnevisionForConditionalGeneration",class _k extends sw{}]],["moondream1",["Moondream1ForConditionalGeneration",class gk extends sw{}]],["florence2",["Florence2ForConditionalGeneration",class wk extends iw{_merge_input_ids_with_image_features({inputs_embeds:e,image_features:t,input_ids:n,attention_mask:r}){return{inputs_embeds:Rp([t,e],1),attention_mask:Rp([Wp(t.dims.slice(0,2)),r],1)}}async _prepare_inputs_embeds({input_ids:e,pixel_values:t,inputs_embeds:n,attention_mask:r}){if(!e&&!t)throw new Error("Either `input_ids` or `pixel_values` should be provided.");let s,i;return e&&(s=await this.encode_text({input_ids:e})),t&&(i=await this.encode_image({pixel_values:t})),s&&i?({inputs_embeds:n,attention_mask:r}=this._merge_input_ids_with_image_features({inputs_embeds:s,image_features:i,input_ids:e,attention_mask:r})):n=s||i,{inputs_embeds:n,attention_mask:r}}async forward({input_ids:e,pixel_values:t,attention_mask:n,decoder_input_ids:r,decoder_attention_mask:s,encoder_outputs:i,past_key_values:a,inputs_embeds:o,decoder_inputs_embeds:l}){if(o||({inputs_embeds:o,attention_mask:n}=await this._prepare_inputs_embeds({input_ids:e,pixel_values:t,inputs_embeds:o,attention_mask:n})),!i){let{last_hidden_state:e}=await wg(this,{inputs_embeds:o,attention_mask:n});i=e}if(!l){if(!r)throw new Error("Either `decoder_input_ids` or `decoder_inputs_embeds` should be provided.");l=await this.encode_text({input_ids:r})}const u={inputs_embeds:l,attention_mask:s,encoder_attention_mask:n,encoder_hidden_states:i,past_key_values:a};return await yg(this,u,!0)}}]],["qwen2-vl",["Qwen2VLForConditionalGeneration",class yk extends Bw{get_rope_index(e,t,n,r){const{vision_config:s,image_token_id:i,video_token_id:a,vision_start_token_id:o}=this.config,l=s.spatial_merge_size??2,u=[];if(t||n){let s=e.tolist();r||(r=jp(e));const d=r.tolist(),c=Array.from({length:3},(t=>Array.from({length:e.dims[0]},(t=>Array.from({length:e.dims[1]},(e=>1)))))),p=t?t.tolist():[],h=n?n.tolist():[];let f=0,m=0;for(let e=0;e<s.length;++e){const t=s[e].filter(((t,n)=>1==d[e][n])),n=t.reduce(((e,t,n)=>(t==o&&e.push(n),e)),[]).map((e=>t[e+1])),r=n.filter((e=>e==i)).length,_=n.filter((e=>e==a)).length;let g=[],w=0,y=r,b=_;for(let e=0;e<n.length;++e){const e=t.findIndex(((e,t)=>t>w&&e==i)),n=t.findIndex(((e,t)=>t>w&&e==a)),r=y>0&&-1!==e?e:t.length+1,s=b>0&&-1!==n?n:t.length+1;let o,u,d,c;r<s?([u,d,c]=p[f],++f,--y,o=r):([u,d,c]=h[m],++m,--b,o=s);const[_,x,v]=[Number(u),Math.floor(Number(d)/l),Math.floor(Number(c)/l)],$=o-w,k=g.length>0?X(g.at(-1))[0]+1:0;g.push(Array.from({length:3*$},((e,t)=>k+t%$)));const E=$+k,S=_*x*v,z=Array.from({length:S},((e,t)=>E+Math.floor(t/(x*v)))),C=Array.from({length:S},((e,t)=>E+Math.floor(t/v)%x)),T=Array.from({length:S},((e,t)=>E+t%v));g.push([z,C,T].flat()),w=o+S}if(w<t.length){const e=g.length>0?X(g.at(-1))[0]+1:0,n=t.length-w;g.push(Array.from({length:3*n},((t,r)=>e+r%n)))}const x=g.reduce(((e,t)=>e+t.length),0),v=new Array(x);let $=0;for(let e=0;e<3;++e)for(let t=0;t<g.length;++t){const n=g[t],r=n.length/3;for(let t=e*r;t<(e+1)*r;++t)v[$++]=n[t]}let k=0;const E=d[e];for(let t=0;t<E.length;++t)if(1==E[t]){for(let n=0;n<3;++n)c[n][e][t]=v[n*x/3+k];++k}const S=X(v)[0];u.push(S+1-s[e].length)}return[new Cp("int64",c.flat(Infinity),[3,e.dims[0],e.dims[1]]),new Cp("int64",u,[u.length,1])]}if(r){const{data:e,dims:t}=vg(r),n=BigInt64Array.from({length:3*e.length},((t,n)=>e[n%e.length])),s=Array.from({length:t[0]},((n,r)=>X(e.subarray(t[1]*r,t[1]*(r+1)))[0]+1+t[1]));return[new Cp("int64",n,[3,...t]),new Cp("int64",s,[s.length,1])]}{const[t,n]=e.dims,r=BigInt64Array.from({length:3*t*n},((e,r)=>BigInt(Math.floor(r%n/t))));return[new Cp("int64",r,[3,...e.dims]),Gp([t,1])]}}async encode_image({pixel_values:e,image_grid_thw:t}){return(await hg(this.sessions.vision_encoder,{pixel_values:e,grid_thw:t})).image_features}_merge_input_ids_with_image_features(e){return bg({image_token_id:this.config.image_token_id,...e})}prepare_inputs_for_generation(e,t,n){if(t.attention_mask&&!t.position_ids)if(t.past_key_values){t.pixel_values=null;const e=BigInt(Object.values(t.past_key_values)[0].dims.at(-2)),n=t.rope_deltas.map((t=>e+t));t.position_ids=Dp([n,n,n],0)}else[t.position_ids,t.rope_deltas]=this.get_rope_index(t.input_ids,t.image_grid_thw,t.video_grid_thw,t.attention_mask);return t}}]],["idefics3",["Idefics3ForConditionalGeneration",lw]],["paligemma",["PaliGemmaForConditionalGeneration",class bk extends aw{_merge_input_ids_with_image_features(e){const t=e.image_features.dims.at(-1),n=e.image_features.view(-1,t);return bg({image_token_id:this.config.image_token_index,...e,image_features:n})}}]]]),xk=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",nw]]]),vk=new Map([["vit",["ViTForImageClassification",class $k extends Fw{async _call(e){return new aS(await super._call(e))}}]],["ijepa",["IJepaForImageClassification",class kk extends Uw{async _call(e){return new aS(await super._call(e))}}]],["pvt",["PvtForImageClassification",class Ek extends Vw{async _call(e){return new aS(await super._call(e))}}]],["vit_msn",["ViTMSNForImageClassification",class Sk extends jw{async _call(e){return new aS(await super._call(e))}}]],["fastvit",["FastViTForImageClassification",class zk extends Hw{async _call(e){return new aS(await super._call(e))}}]],["mobilevit",["MobileViTForImageClassification",class Ck extends Xw{async _call(e){return new aS(await super._call(e))}}]],["mobilevitv2",["MobileViTV2ForImageClassification",class Tk extends Qw{async _call(e){return new aS(await super._call(e))}}]],["beit",["BeitForImageClassification",class Ak extends Jw{async _call(e){return new aS(await super._call(e))}}]],["deit",["DeiTForImageClassification",class Ik extends ly{async _call(e){return new aS(await super._call(e))}}]],["hiera",["HieraForImageClassification",class Mk extends uy{async _call(e){return new aS(await super._call(e))}}]],["convnext",["ConvNextForImageClassification",class Ok extends by{async _call(e){return new aS(await super._call(e))}}]],["convnextv2",["ConvNextV2ForImageClassification",class Bk extends xy{async _call(e){return new aS(await super._call(e))}}]],["dinov2",["Dinov2ForImageClassification",class Nk extends vy{async _call(e){return new aS(await super._call(e))}}]],["resnet",["ResNetForImageClassification",class Pk extends dy{async _call(e){return new aS(await super._call(e))}}]],["swin",["SwinForImageClassification",class Rk extends cy{async _call(e){return new aS(await super._call(e))}}]],["segformer",["SegformerForImageClassification",class Dk extends Wy{}]],["efficientnet",["EfficientNetForImageClassification",class Lk extends Gy{async _call(e){return new aS(await super._call(e))}}]],["mobilenet_v1",["MobileNetV1ForImageClassification",class Fk extends Ky{async _call(e){return new aS(await super._call(e))}}]],["mobilenet_v2",["MobileNetV2ForImageClassification",class Uk extends Xy{async _call(e){return new aS(await super._call(e))}}]],["mobilenet_v3",["MobileNetV3ForImageClassification",class qk extends Qy{async _call(e){return new aS(await super._call(e))}}]],["mobilenet_v4",["MobileNetV4ForImageClassification",class Vk extends Yy{async _call(e){return new aS(await super._call(e))}}]]]),Wk=new Map([["detr",["DetrForObjectDetection",class jk extends ey{async _call(e){return new ny(await super._call(e))}}]],["rt_detr",["RTDetrForObjectDetection",class Gk extends sy{async _call(e){return new iy(await super._call(e))}}]],["table-transformer",["TableTransformerForObjectDetection",class Hk extends ay{async _call(e){return new oy(await super._call(e))}}]],["yolos",["YolosForObjectDetection",class Kk extends $y{async _call(e){return new ky(await super._call(e))}}]]]),Xk=new Map([["owlvit",["OwlViTForObjectDetection",class Qk extends Yw{}]],["owlv2",["Owlv2ForObjectDetection",class Yk extends Zw{}]]]),Zk=new Map([["detr",["DetrForSegmentation",ty]],["clipseg",["CLIPSegForImageSegmentation",class Jk extends mw{}]]]),eE=new Map([["segformer",["SegformerForSemanticSegmentation",class tE extends Wy{}]],["sapiens",["SapiensForSemanticSegmentation",class nE extends my{}]]]),rE=new Map([["detr",["DetrForSegmentation",ty]],["maskformer",["MaskFormerForInstanceSegmentation",class sE extends gy{}]]]),iE=new Map([["sam",["SamModel",class aE extends Ey{async get_image_embeddings({pixel_values:e}){return await wg(this,{pixel_values:e})}async forward(e){if(e.image_embeddings&&e.image_positional_embeddings||(e={...e,...await this.get_image_embeddings(e)}),!e.input_labels&&e.input_points){const t=e.input_points.dims.slice(0,-1),n=t.reduce(((e,t)=>e*t),1);e.input_labels=new Cp("int64",new BigInt64Array(n).fill(1n),t)}const t={image_embeddings:e.image_embeddings,image_positional_embeddings:e.image_positional_embeddings};return e.input_points&&(t.input_points=e.input_points),e.input_labels&&(t.input_labels=e.input_labels),e.input_boxes&&(t.input_boxes=e.input_boxes),await hg(this.sessions.prompt_encoder_mask_decoder,t)}async _call(e){return new Sy(await super._call(e))}}]]]),oE=new Map([["wav2vec2",["Wav2Vec2ForCTC",class lE extends Ty{async _call(e){return new cS(await super._call(e))}}]],["wav2vec2-bert",["Wav2Vec2BertForCTC",class uE extends By{async _call(e){return new cS(await super._call(e))}}]],["unispeech",["UniSpeechForCTC",class dE extends My{async _call(e){return new cS(await super._call(e))}}]],["unispeech-sat",["UniSpeechSatForCTC",class cE extends Oy{async _call(e){return new cS(await super._call(e))}}]],["wavlm",["WavLMForCTC",class pE extends Ny{async _call(e){return new cS(await super._call(e))}}]],["hubert",["HubertForCTC",class hE extends Ty{async _call(e){return new cS(await super._call(e))}}]]]),fE=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",class mE extends Ty{async _call(e){return new aS(await super._call(e))}}]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",class _E extends By{async _call(e){return new aS(await super._call(e))}}]],["unispeech",["UniSpeechForSequenceClassification",class gE extends My{async _call(e){return new aS(await super._call(e))}}]],["unispeech-sat",["UniSpeechSatForSequenceClassification",class wE extends Oy{async _call(e){return new aS(await super._call(e))}}]],["wavlm",["WavLMForSequenceClassification",class yE extends Ny{async _call(e){return new aS(await super._call(e))}}]],["hubert",["HubertForSequenceClassification",class bE extends Ty{async _call(e){return new aS(await super._call(e))}}]],["audio-spectrogram-transformer",["ASTForAudioClassification",class xE extends Jg{}]]]),vE=new Map([["wavlm",["WavLMForXVector",class $E extends Ny{async _call(e){return new oS(await super._call(e))}}]]]),kE=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",class EE extends Oy{async _call(e){return new lS(await super._call(e))}}]],["wavlm",["WavLMForAudioFrameClassification",class SE extends Ny{async _call(e){return new lS(await super._call(e))}}]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",class zE extends Ty{async _call(e){return new lS(await super._call(e))}}]],["pyannote",["PyAnnoteForAudioFrameClassification",class CE extends Ay{async _call(e){return new lS(await super._call(e))}}]]]),TE=new Map([["vitmatte",["VitMatteForImageMatting",class AE extends Kw{async _call(e){return new pS(await super._call(e))}}]]]),IE=new Map([["patchtst",["PatchTSTForPrediction",class ME extends nb{}]],["patchtsmixer",["PatchTSMixerForPrediction",class OE extends rb{}]]]),BE=new Map([["swin2sr",["Swin2SRForImageSuperResolution",class NE extends py{}]]]),PE=new Map([["dpt",["DPTForDepthEstimation",class RE extends hy{}]],["depth_anything",["DepthAnythingForDepthEstimation",class DE extends fy{}]],["glpn",["GLPNForDepthEstimation",class LE extends wy{}]],["sapiens",["SapiensForDepthEstimation",class FE extends my{}]],["depth_pro",["DepthProForDepthEstimation",class UE extends _y{}]]]),qE=new Map([["sapiens",["SapiensForNormalEstimation",class VE extends my{}]]]),WE=new Map([["vitpose",["VitPoseForPoseEstimation",class jE extends qw{}]]]),GE=new Map([["clip",["CLIPVisionModelWithProjection",class HE extends cw{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"vision_model",...t})}}]],["siglip",["SiglipVisionModel",class KE extends cw{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"vision_model",...t})}}]],["jina_clip",["JinaCLIPVisionModel",class XE extends fw{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"vision_model",...t})}}]]]),QE=[[ib,Y_],[vx,Z_],[Ox,tg],[fv,Y_],[Ov,Y_],[Hv,J_],[ov,J_],[r$,tg],[O$,ig],[N$,Y_],[Z$,Y_],[fk,eg],[mk,rg],[vk,Y_],[Zk,Y_],[rE,Y_],[eE,Y_],[TE,Y_],[IE,Y_],[BE,Y_],[PE,Y_],[qE,Y_],[WE,Y_],[Wk,Y_],[Xk,Y_],[iE,ng],[oE,Y_],[fE,Y_],[cv,J_],[hv,Y_],[vE,Y_],[kE,Y_],[GE,Y_]];for(const[e,t]of QE)for(const[n,r]of e.values())og.set(n,t),ug.set(r,n),lg.set(n,r);const YE=[["MusicgenForConditionalGeneration",Hy,sg],["Phi3VForCausalLM",dw,ag],["CLIPTextModelWithProjection",class ZE extends cw{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"text_model",...t})}},Y_],["SiglipTextModel",class JE extends pw{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"text_model",...t})}},Y_],["JinaCLIPTextModel",class eS extends fw{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"text_model",...t})}},Y_],["ClapTextModelWithProjection",class tS extends Uy{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"text_model",...t})}},Y_],["ClapAudioModelWithProjection",class nS extends Uy{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"audio_model",...t})}},Y_]];for(const[e,t,n]of YE)og.set(e,n),ug.set(t,e),lg.set(e,t);class rS extends sb{static MODEL_CLASS_MAPPINGS=QE.map((e=>e[0]));static BASE_IF_FAIL=!0}class sS extends sb{static MODEL_CLASS_MAPPINGS=[fv]}class iS extends sb{static MODEL_CLASS_MAPPINGS=[Hv]}class aS extends Cg{constructor({logits:e}){super(),this.logits=e}}class oS extends Cg{constructor({logits:e,embeddings:t}){super(),this.logits=e,this.embeddings=t}}class lS extends Cg{constructor({logits:e}){super(),this.logits=e}}class uS extends Cg{constructor({logits:e}){super(),this.logits=e}}class dS extends Cg{constructor({start_logits:e,end_logits:t}){super(),this.start_logits=e,this.end_logits=t}}class cS extends Cg{constructor({logits:e}){super(),this.logits=e}}class pS extends Cg{constructor({alphas:e}){super(),this.alphas=e}}class hS extends Cg{constructor({waveform:e,spectrogram:t}){super(),this.waveform=e,this.spectrogram=t}}class fS extends k{static classes=["image_processor_class","tokenizer_class","feature_extractor_class"];static uses_processor_config=!1;constructor(e,t){super(),this.config=e,this.components=t}get image_processor(){return this.components.image_processor}get tokenizer(){return this.components.tokenizer}get feature_extractor(){return this.components.feature_extractor}apply_chat_template(e,t={}){if(!this.tokenizer)throw new Error("Unable to apply chat template without a tokenizer.");return this.tokenizer.apply_chat_template(e,{tokenize:!1,...t})}batch_decode(...e){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.batch_decode(...e)}async _call(e,...t){for(const n of[this.image_processor,this.feature_extractor,this.tokenizer])if(n)return n(e,...t);throw new Error("No image processor, feature extractor, or tokenizer found.")}static async from_pretrained(e,t){const[n,r]=await Promise.all([this.uses_processor_config?W(e,"processor_config.json",!0,t):{},Promise.all(this.classes.filter((e=>e in this)).map((async n=>{const r=await this[n].from_pretrained(e,t);return[n.replace(/_class$/,""),r]}))).then(Object.fromEntries)]);return new this(n,r)}}function mS(e,t,n=0,r=null){const s=e/t;let i=function a(e){const t=Math.round(e);return Math.abs(e)%1==.5?t%2==0?t:t-1:t}(s)*t;return null!==r&&i>r&&(i=Math.floor(s)*t),i<n&&(i=Math.ceil(s)*t),i}function _S([e,t],n){return[Math.max(Math.floor(e/n),1)*n,Math.max(Math.floor(t/n),1)*n]}function gS([e,t,n,r]){return[e-n/2,t-r/2,e+n/2,t+r/2]}function wS(e,t=.5,n=null,r=!1){const s=e.logits,i=e.pred_boxes,[a,o,l]=s.dims;if(null!==n&&n.length!==a)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let u=[];for(let e=0;e<a;++e){let a=null!==n?n[e]:null,d={boxes:[],classes:[],scores:[]},c=s[e],p=i[e];for(let e=0;e<o;++e){let n,s=c[e],i=[];if(r){n=s.sigmoid().data;for(let e=0;e<n.length;++e)n[e]>t&&i.push(e)}else{let e=X(s.data)[1];if(e===l-1)continue;if(n=G(s.data),n[e]<t)continue;i.push(e)}for(const t of i){let r=p[e].data;r=gS(r),null!==a&&(r=r.map(((e,t)=>e*a[(t+1)%2]))),d.boxes.push(r),d.classes.push(t),d.scores.push(n[t])}}u.push(d)}return u}function yS(e,t,n,r){const s=[],i=[],a=[];for(let o=0;o<e.dims[0];++o){const l=e[o],u=t[o],d=X(l.data)[1];if(d===r)continue;const c=G(l.data)[d];c>n&&(s.push(u),i.push(c),a.push(d))}return[s,i,a]}function bS(e,t,n,r=.5,s=.8){const i=[];let a=0,o=0;const l=t[n].data;for(let t=0;t<e.length;++t)e[t]===n&&(i.push(t),++a),l[t]>=r&&++o;let u=a>0&&o>0;if(u){u=a/o>s}return[u,i]}function xS(e,t,n,r,s,i=null,a=null){const[o,l]=a??e[0].dims,u=new Cp("int32",new Int32Array(o*l),[o,l]),d=[];if(null!==a)for(let t=0;t<e.length;++t)e[t]=Tp(e[t],a,"bilinear",!1);const c=new Int32Array(e[0].data.length),p=new Float32Array(e[0].data.length);for(let n=0;n<e.length;++n){let r=t[n];const s=e[n].data;for(let e=0;e<s.length;++e)s[e]*=r,s[e]>p[e]&&(c[e]=n,p[e]=s[e])}let h=0;const f=u.data;for(let i=0;i<n.length;++i){const a=n[i],[o,l]=bS(c,e,i,r,s);if(o){++h;for(const e of l)f[e]=h;d.push({id:h,label_id:a,score:t[i]})}}return[u,d]}function vS(e,t=.5,n=.5,r=.8,s=null,i=null){null===s&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),s=new Set);const a=e.class_queries_logits??e.logits,o=(e.masks_queries_logits??e.pred_masks).sigmoid();let[l,u,d]=a.dims;if(d-=1,null!==i&&i.length!==l)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let c=[];for(let e=0;e<l;++e){let l=null!==i?i[e]:null,u=a[e],p=o[e],[h,f,m]=yS(u,p,t,d);if(0===m.length){let[e,t]=l??p.dims.slice(-2),n=new Cp("int32",new Int32Array(e*t).fill(-1),[e,t]);c.push({segmentation:n,segments_info:[]});continue}let[_,g]=xS(h,f,m,n,r,s,l);c.push({segmentation:_,segments_info:g})}return c}function $S(e,t=.5,n=null){throw new Error("`post_process_instance_segmentation` is not yet implemented.")}class kS extends k{constructor(e){super(),this.image_mean=e.image_mean??e.mean,this.image_std=e.image_std??e.std,this.resample=e.resample??2,this.do_rescale=e.do_rescale??!0,this.rescale_factor=e.rescale_factor??1/255,this.do_normalize=e.do_normalize,this.do_thumbnail=e.do_thumbnail,this.size=e.size??e.image_size,this.do_resize=e.do_resize??void 0!==this.size,this.size_divisibility=e.size_divisibility??e.size_divisor,this.do_center_crop=e.do_center_crop,this.crop_size=e.crop_size,this.do_convert_rgb=e.do_convert_rgb??!0,this.do_crop_margin=e.do_crop_margin,this.pad_size=e.pad_size,this.do_pad=e.do_pad,this.do_pad&&!this.pad_size&&this.size&&void 0!==this.size.width&&void 0!==this.size.height&&(this.pad_size=this.size),this.do_flip_channel_order=e.do_flip_channel_order??!1,this.config=e}async thumbnail(e,t,n=2){const r=e.height,s=e.width,i=t.height,a=t.width;let o=Math.min(r,i),l=Math.min(s,a);return o===r&&l===s?e:(r>s?l=Math.floor(s*o/r):s>r&&(o=Math.floor(r*l/s)),await e.resize(l,o,{resample:n}))}async crop_margin(e,t=200){const n=e.clone().grayscale(),r=K(n.data)[0],s=X(n.data)[0]-r;if(0===s)return e;const i=t/255;let a=n.width,o=n.height,l=0,u=0;const d=n.data;for(let e=0;e<n.height;++e){const t=e*n.width;for(let c=0;c<n.width;++c)(d[t+c]-r)/s<i&&(a=Math.min(a,c),o=Math.min(o,e),l=Math.max(l,c),u=Math.max(u,e))}return e=await e.crop([a,o,l,u])}pad_image(e,t,n,{mode:r="constant",center:s=!1,constant_values:i=0}={}){const[a,o,l]=t;let u,d;if("number"==typeof n?(u=n,d=n):"square"===n?u=d=Math.max(a,o):(u=n.width,d=n.height),u!==o||d!==a){const n=new Float32Array(u*d*l);if(Array.isArray(i))for(let e=0;e<n.length;++e)n[e]=i[e%l];else 0!==i&&n.fill(i);const[c,p]=s?[Math.floor((u-o)/2),Math.floor((d-a)/2)]:[0,0];for(let t=0;t<a;++t){const r=(t+p)*u,s=t*o;for(let t=0;t<o;++t){const i=(r+t+c)*l,a=(s+t)*l;for(let t=0;t<l;++t)n[i+t]=e[a+t]}}if("symmetric"===r){if(s)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const t=a-1,r=o-1;for(let s=0;s<d;++s){const i=s*u,d=I(s,t)*o;for(let t=0;t<u;++t){if(s<a&&t<o)continue;const u=(i+t)*l,c=(d+I(t,r))*l;for(let t=0;t<l;++t)n[u+t]=e[c+t]}}}e=n,t=[d,u,l]}return[e,t]}rescale(e){for(let t=0;t<e.length;++t)e[t]=this.rescale_factor*e[t]}get_resize_output_image_size(e,t){const[n,r]=e.size;let s,i;if(this.do_thumbnail){const{height:e,width:n}=t;s=Math.min(e,n)}else Number.isInteger(t)?(s=t,i=this.config.max_size??s):void 0!==t&&(s=t.shortest_edge,i=t.longest_edge);if(void 0!==s||void 0!==i){const e=void 0===s?1:Math.max(s/n,s/r),t=n*e,a=r*e,o=void 0===i?1:Math.min(i/t,i/a);let l=Math.floor(Number((t*o).toFixed(2))),u=Math.floor(Number((a*o).toFixed(2)));return void 0!==this.size_divisibility&&([l,u]=_S([l,u],this.size_divisibility)),[l,u]}if(void 0!==t&&void 0!==t.width&&void 0!==t.height){let e=t.width,s=t.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let t=s/r,i=e/n;Math.abs(1-i)<Math.abs(1-t)?t=i:i=t,s=mS(t*r,this.config.ensure_multiple_of),e=mS(i*n,this.config.ensure_multiple_of)}return[e,s]}if(void 0!==this.size_divisibility)return _S([n,r],this.size_divisibility);if(void 0!==t.min_pixels&&void 0!==t.max_pixels){const{min_pixels:e,max_pixels:s}=t;return function i(e,t,n=28,r=3136,s=1003520){if(e<n||t<n)throw new Error(`height:${e} or width:${t} must be larger than factor:${n}`);if(Math.max(e,t)/Math.min(e,t)>200)throw new Error("absolute aspect ratio must be smaller than 200, got "+Math.max(e,t)/Math.min(e,t));let i=Math.round(e/n)*n,a=Math.round(t/n)*n;if(i*a>s){const r=Math.sqrt(e*t/s);i=Math.floor(e/r/n)*n,a=Math.floor(t/r/n)*n}else if(i*a<r){const s=Math.sqrt(r/(e*t));i=Math.ceil(e*s/n)*n,a=Math.ceil(t*s/n)*n}return[i,a]}(r,n,this.config.patch_size*this.config.merge_size,e,s)}throw new Error(`Could not resize image due to unsupported \\`this.size\\` option in config: ${JSON.stringify(t)}`)}async resize(e){const[t,n]=this.get_resize_output_image_size(e,this.size);return await e.resize(t,n,{resample:this.resample})}async preprocess(e,{do_normalize:t=null,do_pad:n=null,do_convert_rgb:r=null,do_convert_grayscale:s=null,do_flip_channel_order:i=null}={}){this.do_crop_margin&&(e=await this.crop_margin(e));const[a,o]=e.size;if(r??this.do_convert_rgb?e=e.rgb():s&&(e=e.grayscale()),this.do_resize&&(e=await this.resize(e)),this.do_thumbnail&&(e=await this.thumbnail(e,this.size,this.resample)),this.do_center_crop){let t,n;Number.isInteger(this.crop_size)?(t=this.crop_size,n=this.crop_size):(t=this.crop_size.width,n=this.crop_size.height),e=await e.center_crop(t,n)}const l=[e.height,e.width];let u=Float32Array.from(e.data),d=[e.height,e.width,e.channels];if(this.do_rescale&&this.rescale(u),t??this.do_normalize){let t=this.image_mean;Array.isArray(this.image_mean)||(t=new Array(e.channels).fill(t));let n=this.image_std;if(Array.isArray(this.image_std)||(n=new Array(e.channels).fill(t)),t.length!==e.channels||n.length!==e.channels)throw new Error(`When set to arrays, the length of \\`image_mean\\` (${t.length}) and \\`image_std\\` (${n.length}) must match the number of channels in the image (${e.channels}).`);for(let r=0;r<u.length;r+=e.channels)for(let s=0;s<e.channels;++s)u[r+s]=(u[r+s]-t[s])/n[s]}if(n??this.do_pad)if(this.pad_size){const t=this.pad_image(u,[e.height,e.width,e.channels],this.pad_size);[u,d]=t}else if(this.size_divisibility){const[e,t]=_S([d[1],d[0]],this.size_divisibility);[u,d]=this.pad_image(u,d,{width:e,height:t})}if(i??this.do_flip_channel_order){if(3!==d[2])throw new Error("Flipping channel order is only supported for RGB images.");for(let e=0;e<u.length;e+=3){const t=u[e];u[e]=u[e+2],u[e+2]=t}}return{original_size:[o,a],reshaped_input_size:l,pixel_values:new Cp("float32",u,d).permute(2,0,1)}}async _call(e,...t){Array.isArray(e)||(e=[e]);const n=await Promise.all(e.map((e=>this.preprocess(e))));return{pixel_values:Dp(n.map((e=>e.pixel_values)),0),original_sizes:n.map((e=>e.original_size)),reshaped_input_sizes:n.map((e=>e.reshaped_input_size))}}static async from_pretrained(e,t){return new this(await W(e,__,!0,t))}}class ES extends kS{}class SS extends kS{}class zS extends kS{}class CS extends kS{}class TS extends CS{}class AS extends kS{constructor(e){super(e),this.crop_pct=this.config.crop_pct??.875}async resize(e){const t=this.size?.shortest_edge;if(void 0===t)throw new Error("Size dictionary must contain \'shortest_edge\' key.");if(t<384){const n=Math.floor(t/this.crop_pct),[r,s]=this.get_resize_output_image_size(e,{shortest_edge:n});e=await e.resize(r,s,{resample:this.resample}),e=await e.center_crop(t,t)}else e=await e.resize(t,t,{resample:this.resample});return e}}class IS extends AS{}class MS extends kS{}class OS extends MS{}class BS extends kS{async _call(e){const t=await super._call(e),n=qp([t.pixel_values.dims[0],64,64],1n);return{...t,pixel_mask:n}}post_process_object_detection(...e){return wS(...e)}post_process_panoptic_segmentation(...e){return vS(...e)}post_process_instance_segmentation(...e){return $S(...e)}}class NS extends BS{}class PS extends kS{pad_image(e,t,n,r={}){const[s,i,a]=t;let o=this.image_mean;Array.isArray(this.image_mean)||(o=new Array(a).fill(o));let l=this.image_std;Array.isArray(l)||(l=new Array(a).fill(o));const u=o.map(((e,t)=>-e/l[t]));return super.pad_image(e,t,n,{center:!0,constant_values:u,...r})}}class RS extends PS{}class DS extends kS{}class LS extends DS{}class FS extends kS{constructor(e){super(e),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map((e=>e*e)))}}class US extends kS{}class qS extends kS{constructor(e){super(e),this.do_image_splitting=e.do_image_splitting??!0,this.max_image_size=e.max_image_size}get_resize_for_vision_encoder(e,t){let[n,r]=e.dims.slice(-2);const s=r/n;return r>=n?(r=Math.ceil(r/t)*t,n=Math.floor(r/s),n=Math.ceil(n/t)*t):(n=Math.ceil(n/t)*t,r=Math.floor(n*s),r=Math.ceil(r/t)*t),{height:n,width:r}}async _call(e,{do_image_splitting:t=null,return_row_col_info:n=!1}={}){let r;if(Array.isArray(e)){if(0===e.length||!e[0])throw new Error("No images provided.");r=Array.isArray(e[0])?e:[e]}else r=[[e]];let s=[],i=[],a=[];const o=[],l=[];for(const e of r){let n=await Promise.all(e.map((e=>this.preprocess(e))));o.push(...n.map((e=>e.original_size))),l.push(...n.map((e=>e.reshaped_input_size))),n.forEach((e=>e.pixel_values.unsqueeze_(0)));const{longest_edge:r}=this.max_image_size;let u;if(t??this.do_image_splitting){let e=new Array(n.length),t=new Array(n.length);u=await Promise.all(n.map((async(n,s)=>{const i=this.get_resize_for_vision_encoder(n.pixel_values,r),a=await Ap(n.pixel_values,{size:[i.height,i.width]}),{frames:o,num_splits_h:l,num_splits_w:u}=await this.split_image(a,this.max_image_size);return e[s]=l,t[s]=u,Rp(o,0)}))),i.push(e),a.push(t)}else{const e=[r,r];u=await Promise.all(n.map((t=>Ap(t.pixel_values,{size:e})))),i.push(new Array(n.length).fill(0)),a.push(new Array(n.length).fill(0))}s.push(Rp(u,0))}const u=s.length,[d,c,p,h]=s[0].dims;let f,m;if(1===u)f=s[0].unsqueeze_(0),m=qp([u,d,p,h],!0);else{const e=Math.max(...s.map((e=>e.dims.at(0))));m=qp([u,e,p,h],!0);const t=m.data,n=e*p*h;for(let r=0;r<u;++r){const i=s[r].dims[0];if(i<e){s[r]=Rp([s[r],qp([e-i,c,p,h],0)],0);const a=r*n+i*p*h,o=(r+1)*n;t.fill(!1,a,o)}}f=Dp(s,0)}return{pixel_values:f,pixel_attention_mask:m,original_sizes:o,reshaped_input_sizes:l,...n?{rows:i,cols:a}:{}}}async split_image(e,{longest_edge:t}){const n=t,r=t,s=[],[i,a]=e.dims.slice(-2);let o=0,l=0;if(i>n||a>r){o=Math.ceil(i/n),l=Math.ceil(a/r);const t=Math.ceil(i/o),u=Math.ceil(a/l);for(let n=0;n<o;++n)for(let r=0;r<l;++r){let d,c,p,h;n===o-1?(c=i-t,h=i):(c=n*t,h=(n+1)*t),r===l-1?(d=a-u,p=a):(d=r*u,p=(r+1)*u);const f=[c,d],m=[h,p],_=await Op(e,f,m,[2,3]);s.push(_)}const d=n,c=r;i===d&&a===c||(e=await Ap(e,{size:[d,c]}))}return s.push(e),{frames:s,num_splits_h:o,num_splits_w:l}}}class VS extends kS{constructor(e){super({do_pad:!0,pad_size:{width:e.image_size,height:e.image_size},...e}),this.constant_values=this.config.background_color.map((e=>e*this.rescale_factor))}pad_image(e,t,n,r){return super.pad_image(e,t,n,{constant_values:this.constant_values,center:!0,...r})}}class WS extends kS{constructor(e){const{resize_mode:t,fill_color:n,interpolation:r,size:s,...i}=e;super({...i,size:"squash"===t?{width:s,height:s}:"shortest"===t?{shortest_edge:s}:{longest_edge:s},resample:"bicubic"===r?3:2,do_center_crop:!0,crop_size:s,do_normalize:!0})}}class jS extends kS{}class GS extends kS{post_process_panoptic_segmentation(...e){return vS(...e)}post_process_instance_segmentation(...e){return $S(...e)}}class HS extends GS{}class KS extends GS{}class XS extends kS{}class QS extends XS{}class YS extends kS{}class ZS extends YS{}class JS extends kS{}class ez extends JS{}class tz extends kS{}class nz extends tz{}class rz extends kS{}class sz extends rz{}class iz extends PS{}class az extends kS{post_process_object_detection(...e){return wS(...e)}}class oz extends az{}class lz extends az{}const uz=336,dz=[2,3],{ceil:cz,floor:pz,sqrt:hz}=Math;class fz extends kS{constructor(e){super({...e,do_normalize:!0,do_pad:!0,pad_size:"custom",do_convert_rgb:!0,do_resize:!0}),this._num_crops=e.num_crops}calc_num_image_tokens_from_image_size(e,t){const{num_img_tokens:n}=this.config;return pz((pz(t/uz)*pz(e/uz)+1)*n+1+(pz(t/uz)+1)*hz(n))}get_resize_output_image_size(e,t){const n=this._num_crops,[r,s]=e.size;let i=r/s,a=1;for(;a*Math.ceil(a/i)<=n;)a+=1;a-=1;const o=Math.floor(336*a);return[o,Math.floor(o/i)]}pad_image(e,t,n,r={}){const[s,i]=t,a=uz*cz(s/uz),o=uz*cz(i/uz),l=[1,1,1].map(((e,t)=>(e-this.image_mean[t])/this.image_std[t]));return super.pad_image(e,t,{width:o,height:a},{center:!0,constant_values:l,...r})}async _call(e,{num_crops:t=null}={}){if(this._num_crops=t??=this.config.num_crops,t<4||hz(t)%1!=0)throw new Error("num_crops must be a square number >= 4");Array.isArray(e)||(e=[e]);const n=e.length,r=await Promise.all(e.map((e=>this.preprocess(e)))),s=r.map((e=>e.original_size)),i=r.map((e=>e.reshaped_input_size)),a=[];for(const{pixel_values:e}of r){e.unsqueeze_(0);const[n,r]=e.dims.slice(-2),s=await Ap(e,{size:[uz,uz],mode:"bicubic"});if(t>0){const i=[],o=hz(t),l=pz(r/o),u=pz(n/o);for(let t=0;t<o;++t)for(let s=0;s<o;++s){let a,d,c,p;t===o-1?(d=n-u,p=n):(d=t*u,p=(t+1)*u),s===o-1?(a=r-l,c=r):(a=s*l,c=(s+1)*l);const h=[d,a],f=[p,c],m=await Op(e,h,f,dz);i.push(m)}const d=await Ap(Rp(i,0),{size:[uz,uz],mode:"bicubic"});a.push(Rp([s,d],0))}else a.push(s)}const o=Dp(a,0),l=i.map((e=>e.map((e=>uz*cz(e/uz)))));return{pixel_values:o,original_sizes:s,reshaped_input_sizes:i,image_sizes:new Cp("int64",l.flat(),[n,2]),num_img_tokens:l.map((([e,t])=>this.calc_num_image_tokens_from_image_size(t,e)))}}}class mz extends kS{}class _z extends kS{async _call(e,...t){const{pixel_values:n,original_sizes:r,reshaped_input_sizes:s}=await super._call(e,...t);let i=n;const{temporal_patch_size:a,merge_size:o,patch_size:l}=this.config;1===i.dims[0]&&(i=Rp(Array.from({length:a},(()=>i)),0));const u=i.dims[0]/a,d=i.dims[1],c=Math.floor(i.dims[2]/l),p=Math.floor(i.dims[3]/l);return{pixel_values:i.view(u,a,d,Math.floor(c/o),o,l,Math.floor(p/o),o,l).permute(0,3,6,4,7,2,1,5,8).view(u*c*p,d*a*l*l),image_grid_thw:new Cp("int64",[u,c,p],[1,3]),original_sizes:r,reshaped_input_sizes:s}}}class gz extends kS{post_process_object_detection(...e){return wS(...e)}}class wz extends kS{reshape_input_points(e,t,n,r=!1){let s=C(e=structuredClone(e));if(3===s.length)r||(s=[1,...s]),e=[e];else if(4!==s.length)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let r=0;r<e.length;++r){let s=t[r],i=n[r],a=[i[0]/s[0],i[1]/s[1]];for(let t=0;t<e[r].length;++t)for(let n=0;n<e[r][t].length;++n)for(let s=0;s<e[r][t][n].length;++s)e[r][t][n][s]*=a[s%2]}return new Cp("float32",Float32Array.from(e.flat(Infinity)),s)}add_input_labels(e,t){let n=C(e);if(2===n.length)n=[1,...n],e=[e];else if(3!==n.length)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(n.some(((e,n)=>e!==t.dims[n])))throw Error(`The first ${n.length} dimensions of \'input_points\' and \'input_labels\' must be the same.`);return new Cp("int64",e.flat(Infinity).map(BigInt),n)}async _call(e,{input_points:t=null,input_labels:n=null,input_boxes:r=null}={}){const s=await super._call(e);if(t&&(s.input_points=this.reshape_input_points(t,s.original_sizes,s.reshaped_input_sizes)),n){if(!s.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");s.input_labels=this.add_input_labels(n,s.input_points)}return r&&(s.input_boxes=this.reshape_input_points(r,s.original_sizes,s.reshaped_input_sizes,!0)),s}async post_process_masks(e,t,n,{mask_threshold:r=0,binarize:s=!0,pad_size:i=null}={}){const a=[],o=[(i=i??this.pad_size).height,i.width];for(let i=0;i<t.length;++i){const l=t[i],u=n[i];let d=await Ap(e[i],{mode:"bilinear",size:o});if(d=d.slice(null,null,[0,u[0]],[0,u[1]]),d=await Ap(d,{mode:"bilinear",size:l}),s){const e=d.data,t=new Uint8Array(e.length);for(let n=0;n<e.length;++n)e[n]>r&&(t[n]=1);d=new Cp("bool",t,d.dims)}a.push(d)}return a}generate_crop_boxes(e,t,{crop_n_layers:n=0,overlap_ratio:r=512/1500,points_per_crop:s=32,crop_n_points_downscale_factor:i=1}={}){}}class yz extends kS{post_process_semantic_segmentation(...e){return function t(e,n=null){const r=e.logits,s=r.dims[0];if(null!==n&&n.length!==s)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const i=[];for(let e=0;e<s;++e){const t=null!==n?n[e]:null;let s=r[e];null!==t&&(s=Tp(s,t,"bilinear",!1));const[a,o]=t??s.dims.slice(-2),l=new Cp("int32",new Int32Array(a*o),[a,o]),u=s[0].data,d=l.data;for(let e=1;e<s.dims[0];++e){const t=s[e].data;for(let n=0;n<t.length;++n)t[n]>u[n]&&(u[n]=t[n],d[n]=e)}const c=new Array(s.dims[0]);for(let e=0;e<d.length;++e){const t=d[e];c[t]=t}const p=c.filter((e=>void 0!==e));i.push({segmentation:l,labels:p})}return i}(...e)}}class bz extends yz{}class xz extends kS{}class vz extends kS{pad_image(e,t,n,r={}){const[s,i,a]=t;return super.pad_image(e,t,{width:i+(n-i%n)%n,height:s+(n-s%n)%n},{mode:"symmetric",center:!1,constant_values:-1,...r})}}class $z extends kS{}class kz extends $z{}class Ez extends kS{async _call(e,t){Array.isArray(e)||(e=[e]),Array.isArray(t)||(t=[t]);const n=await Promise.all(e.map((e=>this.preprocess(e)))),r=await Promise.all(t.map((e=>this.preprocess(e,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0}))));return{pixel_values:Dp(n.map(((e,t)=>Rp([e.pixel_values,r[t].pixel_values],0))),0),original_sizes:n.map((e=>e.original_size)),reshaped_input_sizes:n.map((e=>e.reshaped_input_size))}}}class Sz extends kS{post_process_pose_estimation(e,t,{threshold:n=null}={}){const r=e.tolist(),[s,i,a,o]=e.dims,l=[];for(let e=0;e<s;++e){const s=r[e],i=t[e],u=[];for(let e=0;e<i.length;++e){const t=i[e],r=[],l=[],d=[],c=t.at(-2)/o,p=t.at(-1)/a;for(let e=0;e<s.length;++e){let[t,i]=[0,0],a=0,o=-Infinity;const u=s[e];for(let e=0;e<u.length;++e){const n=u[e];for(let r=0;r<n.length;++r){const s=n[r];a+=s,o=Math.max(o,s),t+=(r+.5)*s,i+=e*s}}if(null!=n&&o<n)continue;const h=[c*t/a,p*i/a];r.push(h),d.push(e),l.push(o)}u.push({bbox:t,scores:l,labels:d,keypoints:r})}l.push(u)}return l}}class zz extends kS{post_process_object_detection(...e){return wS(...e)}}class Cz extends zz{}class Tz{static async from_pretrained(e,n={}){const r=await W(e,__,!0,n),s=r.image_processor_type??r.feature_extractor_type;let i=t[s];return i||(void 0!==s&&console.warn(`Image processor type \'${s}\' not found, assuming base ImageProcessor. Please report this at ${f_}.`),i=kS),new i(r)}}class Az extends fS{static tokenizer_class=s_;static image_processor_class=Tz;constructor(e,t){super(e,t);const{tasks_answer_post_processing_type:n,task_prompts_without_inputs:r,task_prompts_with_input:s}=this.image_processor.config;this.tasks_answer_post_processing_type=new Map(Object.entries(n??{})),this.task_prompts_without_inputs=new Map(Object.entries(r??{})),this.task_prompts_with_input=new Map(Object.entries(s??{})),this.regexes={quad_boxes:/(.+?)<loc_(\\d+)><loc_(\\d+)><loc_(\\d+)><loc_(\\d+)><loc_(\\d+)><loc_(\\d+)><loc_(\\d+)><loc_(\\d+)>/gm,bboxes:/([^<]+)?<loc_(\\d+)><loc_(\\d+)><loc_(\\d+)><loc_(\\d+)>/gm},this.size_per_bin=1e3}construct_prompts(e){"string"==typeof e&&(e=[e]);const t=[];for(const n of e)if(this.task_prompts_without_inputs.has(n))t.push(this.task_prompts_without_inputs.get(n));else{for(const[e,r]of this.task_prompts_with_input)if(n.includes(e)){t.push(r.replaceAll("{input}",n).replaceAll(e,""));break}t.length!==e.length&&t.push(n)}return t}post_process_generation(e,t,n){const r=this.tasks_answer_post_processing_type.get(t)??"pure_text";let s;switch(e=e.replaceAll("<s>","").replaceAll("</s>",""),r){case"pure_text":s=e;break;case"description_with_bboxes":case"bboxes":case"phrase_grounding":case"ocr":const i="ocr"===r?"quad_boxes":"bboxes",a=e.matchAll(this.regexes[i]),o=[],l=[];for(const[e,t,...r]of a)o.push(t?t.trim():o.at(-1)??""),l.push(r.map(((e,t)=>(Number(e)+.5)/this.size_per_bin*n[t%2])));s={labels:o,[i]:l};break;default:throw new Error(`Task "${t}" (of type "${r}") not yet implemented.`)}return{[t]:s}}async _call(e,t=null,n={}){if(!e&&!t)throw new Error("Either text or images must be provided");return{...await this.image_processor(e,n),...t?this.tokenizer(t,n):{}}}}const Iz={char:["char_decode",1],bpe:["bpe_decode",2],wp:["wp_decode",102]};class Mz extends fS{static tokenizer_class=s_;static image_processor_class=Tz;get char_tokenizer(){return this.components.char_tokenizer}get bpe_tokenizer(){return this.components.bpe_tokenizer}get wp_tokenizer(){return this.components.wp_tokenizer}_decode_helper(e,t){if(!Iz.hasOwnProperty(t))throw new Error(`Format ${t} is not supported.`);const[n,r]=Iz[t],s=this[n].bind(this),[i,a]=e.dims,o=[],l=[],u=e.tolist();for(let e=0;e<i;++e){const t=u[e],n=[],s=[];for(let e=1;e<a;++e){const[i,a]=X(G(t[e]));if(s.push(i),a==r)break;n.push(a)}const i=s.length>0?s.reduce(((e,t)=>e*t),1):0;l.push(n),o.push(i)}return[s(l),o]}char_decode(e){return this.char_tokenizer.batch_decode(e).map((e=>e.replaceAll(" ","")))}bpe_decode(e){return this.bpe_tokenizer.batch_decode(e)}wp_decode(e){return this.wp_tokenizer.batch_decode(e).map((e=>e.replaceAll(" ","")))}batch_decode([e,t,n]){const[r,s]=this._decode_helper(e,"char"),[i,a]=this._decode_helper(t,"bpe"),[o,l]=this._decode_helper(n,"wp"),u=[],d=[];for(let e=0;e<r.length;++e){const[t,n]=X([s[e],a[e],l[e]]);u.push([r[e],i[e],o[e]][n]),d.push(t)}return{generated_text:u,scores:d,char_preds:r,bpe_preds:i,wp_preds:o}}static async from_pretrained(...e){const t=await super.from_pretrained(...e),n=await s_.from_pretrained("Xenova/gpt2"),r=await s_.from_pretrained("Xenova/bert-base-uncased");return t.components={image_processor:t.image_processor,char_tokenizer:t.tokenizer,bpe_tokenizer:n,wp_tokenizer:r},t}async _call(e,t=null){const n=await this.image_processor(e);return t&&(n.labels=this.tokenizer(t).input_ids),n}}class Oz extends k{constructor(e){super(),this.config=e}static async from_pretrained(e,t){return new this(await W(e,m_,!0,t))}}function Bz(e,t){if(!(e instanceof Float32Array||e instanceof Float64Array))throw new Error(`${t} expects input to be a Float32Array or a Float64Array, but got ${e?.constructor?.name??typeof e} instead. If using the feature extractor directly, remember to use \\`read_audio(url, sampling_rate)\\` to obtain the raw audio data of the file/url.`)}function Nz(e,t){if(e<1)return new Float64Array;if(1===e)return new Float64Array([1]);const n=1-t,r=2*Math.PI/(e-1),s=new Float64Array(e);for(let i=0;i<e;++i)s[i]=t-n*Math.cos(i*r);return s}function Pz(e){return Nz(e,.5)}const Rz={htk:e=>2595*Math.log10(1+e/700),kaldi:e=>1127*Math.log(1+e/700),slaney:(e,t=1e3,n=15,r=27/Math.log(6.4))=>e>=t?n+Math.log(e/t)*r:3*e/200};function Dz(e,t="htk"){const n=Rz[t];if(!n)throw new Error(\'mel_scale should be one of "htk", "slaney" or "kaldi".\');return"number"==typeof e?n(e):e.map((e=>n(e)))}const Lz={htk:e=>700*(10**(e/2595)-1),kaldi:e=>700*(Math.exp(e/1127)-1),slaney:(e,t=1e3,n=15,r=Math.log(6.4)/27)=>e>=n?t*Math.exp(r*(e-n)):200*e/3};function Fz(e,t,n){const r=(t-e)/(n-1);return Float64Array.from({length:n},((t,n)=>e+r*n))}function Uz(e,t,n,r,s,i=null,a="htk",o=!1){if(null!==i&&"slaney"!==i)throw new Error(\'norm must be one of null or "slaney"\');const l=Fz(Dz(n,a),Dz(r,a),t+2);let u,d=function c(e,t="htk"){const n=Lz[t];if(!n)throw new Error(\'mel_scale should be one of "htk", "slaney" or "kaldi".\');return"number"==typeof e?n(e):e.map((e=>n(e)))}(l,a);if(o){const t=s/(2*e);u=Dz(Float64Array.from({length:e},((e,n)=>n*t)),a),d=l}else u=Fz(0,Math.floor(s/2),e);const p=function h(e,t){const n=Float64Array.from({length:t.length-1},((e,n)=>t[n+1]-t[n])),r=Array.from({length:e.length},(()=>new Array(t.length)));for(let n=0;n<e.length;++n){const s=r[n];for(let r=0;r<t.length;++r)s[r]=t[r]-e[n]}const s=t.length-2,i=Array.from({length:s},(()=>new Array(e.length)));for(let t=0;t<e.length;++t){const e=r[t];for(let r=0;r<s;++r){const s=-e[r]/n[r],a=e[r+2]/n[r+1];i[r][t]=Math.max(0,Math.min(s,a))}}return i}(u,d);if(null!==i&&"slaney"===i)for(let n=0;n<t;++n){const t=p[n],r=2/(d[n+2]-d[n]);for(let n=0;n<e;++n)t[n]*=r}return p}function qz(e,t,n,r,s){if(n<=0)throw new Error("reference must be greater than zero");if(r<=0)throw new Error("min_value must be greater than zero");n=Math.max(r,n);const i=Math.log10(n);for(let n=0;n<e.length;++n)e[n]=t*Math.log10(Math.max(r,e[n])-i);if(null!==s){if(s<=0)throw new Error("db_range must be greater than zero");const t=X(e)[0]-s;for(let n=0;n<e.length;++n)e[n]=Math.max(e[n],t)}return e}async function Vz(e,t,n,r,{fft_length:s=null,power:i=1,center:a=!0,pad_mode:o="reflect",onesided:l=!0,preemphasis:u=null,mel_filters:d=null,mel_floor:c=1e-10,log_mel:p=null,reference:h=1,min_value:f=1e-10,db_range:m=null,remove_dc_offset:_=null,min_num_frames:g=null,max_num_frames:w=null,do_pad:y=!0,transpose:b=!1}={}){const x=t.length;if(null===s&&(s=n),n>s)throw Error(`frame_length (${n}) may not be larger than fft_length (${s})`);if(x!==n)throw new Error(`Length of the window (${x}) must equal frame_length (${n})`);if(r<=0)throw new Error("hop_length must be greater than zero");if(null===i&&null!==d)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(a){if("reflect"!==o)throw new Error(`pad_mode="${o}" not implemented yet.`);const t=Math.floor((s-1)/2)+1;e=function n(e,t,r){const s=new e.constructor(e.length+t+r),i=e.length-1;for(let n=0;n<e.length;++n)s[t+n]=e[n];for(let n=1;n<=t;++n)s[t-n]=e[I(n,i)];for(let n=1;n<=r;++n)s[i+t+n]=e[I(i-n,i)];return s}(e,t,t)}let v=Math.floor(1+Math.floor((e.length-n)/r));null!==g&&v<g&&(v=g);const $=l?Math.floor(s/2)+1:s;let k=v,E=v;null!==w&&(w>v?y&&(E=w):E=k=w);const S=new J(s),z=new Float64Array(s),C=new Float64Array(S.outputBufferSize),T=new Float32Array($*E);for(let s=0;s<k;++s){const i=s*r,a=Math.min(e.length-i,n);a!==n&&z.fill(0,0,n);for(let t=0;t<a;++t)z[t]=e[i+t];if(_){let e=0;for(let t=0;t<a;++t)e+=z[t];const t=e/a;for(let e=0;e<a;++e)z[e]-=t}if(null!==u){for(let e=a-1;e>=1;--e)z[e]-=u*z[e-1];z[0]*=1-u}for(let e=0;e<t.length;++e)z[e]*=t[e];S.realTransform(C,z);for(let e=0;e<$;++e){const t=e<<1;T[e*E+s]=C[t]**2+C[t+1]**2}}if(null!==i&&2!==i){const e=2/i;for(let t=0;t<T.length;++t)T[t]**=e}const A=d.length;let M=await async function O(e,t){const n=await Sp.matmul;return await n({a:e,b:t})}(new Cp("float32",d.flat(),[A,$]),new Cp("float32",T,[$,E]));b&&(M=M.transpose(1,0));const B=M.data;for(let e=0;e<B.length;++e)B[e]=Math.max(c,B[e]);if(null!==i&&null!==p){const e=Math.min(B.length,k*A);switch(p){case"log":for(let t=0;t<e;++t)B[t]=Math.log(B[t]);break;case"log10":for(let t=0;t<e;++t)B[t]=Math.log10(B[t]);break;case"dB":if(1===i)!function t(e,n=1,r=1e-5,s=null){return qz(e,20,n,r,s)}(B,h,f,m);else{if(2!==i)throw new Error(`Cannot use log_mel option \'${p}\' with power ${i}`);!function e(t,n=1,r=1e-10,s=null){return qz(t,10,n,r,s)}(B,h,f,m)}break;default:throw new Error(`log_mel must be one of null, \'log\', \'log10\' or \'dB\'. Got \'${p}\'`)}}return M}function Wz(e,t,{periodic:n=!0,frame_length:r=null,center:s=!0}={}){const i=n?e+1:e;let a;switch(t){case"boxcar":a=new Float64Array(i).fill(1);break;case"hann":case"hann_window":a=Pz(i);break;case"hamming":a=function e(t){return Nz(t,.54)}(i);break;case"povey":a=Pz(i).map((e=>Math.pow(e,.85)));break;default:throw new Error(`Unknown window type ${t}.`)}if(n&&(a=a.subarray(0,e)),null===r)return a;if(e>r)throw new Error(`Length of the window (${e}) may not be larger than frame_length (${r})`);return a}class jz extends Oz{constructor(e){super(e);const t=this.config.sampling_rate,n=Uz(256,this.config.num_mel_bins,20,Math.floor(t/2),t,null,"kaldi",!0);for(let e=0;e<n.length;++e)n[e].push(0);this.mel_filters=n,this.window=Wz(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}async _extract_fbank_features(e,t){return Vz(e,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1.192092955078125e-7,remove_dc_offset:!0,max_num_frames:t,transpose:!0})}async _call(e){Bz(e,"ASTFeatureExtractor");const t=await this._extract_fbank_features(e,this.config.max_length);if(this.config.do_normalize){const e=2*this.std,n=t.data;for(let t=0;t<n.length;++t)n[t]=(n[t]-this.mean)/e}return{input_values:t.unsqueeze_(0)}}}class Gz extends Oz{constructor(e){super(e),this.mel_filters=Uz(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=Uz(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=Wz(this.config.fft_window_size,"hann")}async _get_input_mel(e,t,n,r){let s,i=!1;const a=e.length-t;if(a>0){if("rand_trunc"!==n)throw new Error(`Truncation strategy "${n}" not implemented`);{i=!0;const n=Math.floor(Math.random()*(a+1));e=e.subarray(n,n+t),s=await this._extract_fbank_features(e,this.mel_filters_slaney,this.config.nb_max_samples)}}else{if(a<0){let n=new Float64Array(t);if(n.set(e),"repeat"===r)for(let r=e.length;r<t;r+=e.length)n.set(e.subarray(0,Math.min(e.length,t-r)),r);else if("repeatpad"===r)for(let t=e.length;t<-a;t+=e.length)n.set(e,t);e=n}if("fusion"===n)throw new Error(`Truncation strategy "${n}" not implemented`);s=await this._extract_fbank_features(e,this.mel_filters_slaney,this.config.nb_max_samples)}return s.unsqueeze_(0)}async _extract_fbank_features(e,t,n=null){return Vz(e,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:t,log_mel:"dB",max_num_frames:n,do_pad:!1,transpose:!0})}async _call(e,{max_length:t=null}={}){Bz(e,"ClapFeatureExtractor");return{input_features:(await this._get_input_mel(e,t??this.config.nb_max_samples,this.config.truncation,this.config.padding)).unsqueeze_(0)}}}class Hz extends Oz{async _call(e){Bz(e,"MoonshineFeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));const t=[1,e.length];return{input_values:new Cp("float32",e,t)}}}class Kz extends Oz{async _call(e){Bz(e,"PyAnnoteFeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));const t=[1,1,e.length];return{input_values:new Cp("float32",e,t)}}samples_to_frames(e){return(e-this.config.offset)/this.config.step}post_process_speaker_diarization(e,t){const n=t/this.samples_to_frames(t)/this.config.sampling_rate,r=[];for(const t of e.tolist()){const e=[];let s=-1;for(let n=0;n<t.length;++n){const r=G(t[n]),[i,a]=X(r),[o,l]=[n,n+1];a!==s?(s=a,e.push({id:a,start:o,end:l,score:i})):(e.at(-1).end=l,e.at(-1).score+=i)}r.push(e.map((({id:e,start:t,end:r,score:s})=>({id:e,start:t*n,end:r*n,confidence:s/(r-t)}))))}return r}}class Xz extends Oz{constructor(e){super(e);const t=this.config.sampling_rate,n=Uz(256,this.config.num_mel_bins,20,Math.floor(t/2),t,null,"kaldi",!0);for(let e=0;e<n.length;++e)n[e].push(0);this.mel_filters=n,this.window=Wz(400,"povey",{periodic:!1})}async _extract_fbank_features(e,t){return Vz(e=e.map((e=>32768*e)),this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1.192092955078125e-7,remove_dc_offset:!0,max_num_frames:t,transpose:!0})}async _call(e,{padding:t=!0,pad_to_multiple_of:n=2,do_normalize_per_mel_bins:r=!0,return_attention_mask:s=!0}={}){Bz(e,"SeamlessM4TFeatureExtractor");let i,a=await this._extract_fbank_features(e,this.config.max_length);if(r){const[e,t]=a.dims,n=a.data;for(let r=0;r<t;++r){let s=0;for(let i=0;i<e;++i)s+=n[i*t+r];const i=s/e;let a=0;for(let s=0;s<e;++s)a+=(n[s*t+r]-i)**2;a/=e-1;const o=Math.sqrt(a+1e-7);for(let s=0;s<e;++s){const e=s*t+r;n[e]=(n[e]-i)/o}}}if(t){const[e,t]=a.dims,r=a.data,o=e%n;if(o>0){const n=new Float32Array(t*(e+o));n.set(r),n.fill(this.config.padding_value,r.length);const l=e+o;a=new Cp(a.type,n,[l,t]),s&&(i=new Cp("int64",new BigInt64Array(l),[1,l]),i.data.fill(1n,0,e))}}const[o,l]=a.dims,u=this.config.stride;if(0!==o%u)throw new Error(`The number of frames (${o}) must be a multiple of the stride (${u}).`);const d=a.view(1,Math.floor(o/u),l*u),c={input_features:d};if(s){const e=d.dims[1],t=new BigInt64Array(e);if(i){const e=i.data;for(let n=1,r=0;n<o;n+=u,++r)t[r]=e[n]}else t.fill(1n);c.attention_mask=new Cp("int64",t,[1,e])}return c}}class Qz extends Oz{}class Yz extends Oz{_zero_mean_unit_var_norm(e){const t=e.reduce(((e,t)=>e+t),0)/e.length,n=e.reduce(((e,n)=>e+(n-t)**2),0)/e.length;return e.map((e=>(e-t)/Math.sqrt(n+1e-7)))}async _call(e){Bz(e,"Wav2Vec2FeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));let t=e;this.config.do_normalize&&(t=this._zero_mean_unit_var_norm(t));const n=[1,t.length];return{input_values:new Cp("float32",t,n),attention_mask:new Cp("int64",new BigInt64Array(t.length).fill(1n),n)}}}class Zz extends Oz{constructor(e){super(e);const t=this.config.sampling_rate,n=Uz(256,this.config.num_mel_bins,20,Math.floor(t/2),t,null,"kaldi",!0);for(let e=0;e<n.length;++e)n[e].push(0);this.mel_filters=n,this.window=Wz(400,"hamming",{periodic:!1}),this.min_num_frames=this.config.min_num_frames}async _extract_fbank_features(e){return Vz(e=e.map((e=>32768*e)),this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1.192092955078125e-7,remove_dc_offset:!0,transpose:!0,min_num_frames:this.min_num_frames})}async _call(e){Bz(e,"WeSpeakerFeatureExtractor");const t=(await this._extract_fbank_features(e)).unsqueeze_(0);if(null===this.config.fbank_centering_span){const e=t.mean(1).data,n=t.data,[r,s,i]=t.dims;for(let t=0;t<r;++t){const r=t*s*i,a=t*i;for(let t=0;t<s;++t){const s=r+t*i;for(let t=0;t<i;++t)n[s+t]-=e[a+t]}}}return{input_features:t}}}class Jz extends Oz{constructor(e){super(e),this.config.mel_filters??=Uz(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney"),this.window=Wz(this.config.n_fft,"hann")}async _extract_fbank_features(e){const t=await Vz(e,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:this.config.nb_max_frames}),n=t.data,r=X(n)[0];for(let e=0;e<n.length;++e)n[e]=(Math.max(n[e],r-8)+4)/4;return t}async _call(e){let t;Bz(e,"WhisperFeatureExtractor"),e.length>this.config.n_samples?(console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),t=e.slice(0,this.config.n_samples)):(t=new Float32Array(this.config.n_samples),t.set(e));return{input_features:(await this._extract_fbank_features(t)).unsqueeze_(0)}}}class eC{static async from_pretrained(e,t={}){const r=await W(e,m_,!0,t),s=r.feature_extractor_type,i=n[s];if(!i)throw new Error(`Unknown feature_extractor_type: \'${s}\'. Please report this at ${f_}.`);return new i(r)}}class tC extends fS{static tokenizer_class=s_;static feature_extractor_class=eC;async _call(e){return await this.feature_extractor(e)}}function nC(e,t,n,r,s,i){return 0===e&&0===t?function a(e,t,n,r){return`${t}${r}`+n.repeat(e)+`${t}`}(n,r,s,i):function o(e,t,n,r,s,i){let a="";for(let i=0;i<t;++i){for(let t=0;t<n;++t)a+=r+`<row_${i+1}_col_${t+1}>`+s.repeat(e);a+="\\n"}return a+=`\\n${r}${i}`+s.repeat(e)+`${r}`,a}(n,e,t,r,s,i)}class rC extends fS{static image_processor_class=Tz;static tokenizer_class=s_;static uses_processor_config=!0;fake_image_token="<fake_token_around_image>";image_token="<image>";global_img_token="<global-img>";async _call(e,t=null,n={}){let r;n.return_row_col_info??=!0,t&&(r=await this.image_processor(t,n)),Array.isArray(e)||(e=[e]);const s=r.rows??[new Array(e.length).fill(0)],i=r.cols??[new Array(e.length).fill(0)],a=this.config.image_seq_len,o=[],l=[];for(let t=0;t<e.length;++t){const n=e[t],r=s[t],u=i[t];o.push(B(n,this.image_token));const d=r.map(((e,t)=>nC(e,u[t],a,this.fake_image_token,this.image_token,this.global_img_token))),c=n.split(this.image_token);if(0===c.length)throw new Error("The image token should be present in the text.");let p=c[0];for(let e=0;e<d.length;++e)p+=d[e]+c[e+1];l.push(p)}return{...this.tokenizer(l),...r}}}class sC extends fS{static image_processor_class=Tz;static tokenizer_class=s_;static uses_processor_config=!0;constructor(e,t){super(e,t),this.image_tag=this.config.image_tag,this.image_start_tag=this.config.image_start_tag,this.image_end_tag=this.config.image_end_tag,this.num_image_tokens=this.config.num_image_tokens}async _call(e,{images:t=null,chat_template:n="default"}={}){t?Array.isArray(t)||(t=[t]):t=await Promise.all(e.filter((e=>e.images)).flatMap((e=>e.images)).map((e=>U_.read(e))));const r=this.tokenizer,s=e=>r.encode(e,{add_special_tokens:!1}),i=r.apply_chat_template(e,{tokenize:!1,add_generation_prompt:!0,chat_template:n}).split(this.image_tag),a=i.length-1;if(t.length!==a)throw new Error(`Number of images provided (${t.length}) does not match number of "${this.image_tag}" image tags (${a})`);const[o,l,u]=r.model.convert_tokens_to_ids([this.image_tag,this.image_start_tag,this.image_end_tag]);let d=s(i[0]),c=new Array(d.length).fill(!1);for(let e=1;e<i.length;++e){const t=new Array(this.num_image_tokens).fill(o),n=s(i[e]);d=T(d,[l],t,[u],n);c=T(c,[!1],new Array(this.num_image_tokens).fill(!0),[!1],new Array(n.length).fill(!1))}const p=[1,d.length],h={input_ids:new Cp("int64",d,p),attention_mask:new Cp("int64",new Array(d.length).fill(1),p),images_seq_mask:new Cp("bool",c,p),images_emb_mask:new Cp("bool",new Array(a*this.num_image_tokens).fill(!0),[1,a,this.num_image_tokens])};if(t&&t.length>0){const e=await this.image_processor(t);return e.pixel_values.unsqueeze_(0),{...h,...e}}return h}}class iC extends fS{static tokenizer_class=s_;static image_processor_class=Tz;async _call(e=null,t=null,n={}){if(!e&&!t)throw new Error("Either text or images must be provided");return{...e?this.tokenizer(e,n):{},...t?await this.image_processor(t,n):{}}}}class aC extends fS{static tokenizer_class=s_;static image_processor_class=Tz}const oC="<|image|>",lC=/<\\|image_\\d+\\|>/g;class uC extends fS{static image_processor_class=Tz;static tokenizer_class=s_;async _call(e,t=null,{padding:n=!0,truncation:r=!0,num_crops:s=null}={}){let i,a;if(Array.isArray(e)||(e=[e]),t){a=await this.image_processor(t,{num_crops:s});const{num_img_tokens:o}=a,l=e.map(((e,t)=>e.split(lC).join(oC.repeat(o[t]))));i=this.tokenizer(l,{padding:n,truncation:r});const u=this.tokenizer.model.convert_tokens_to_ids([oC])[0];i.input_ids.map_((e=>e==u?-e:e))}else i=this.tokenizer(e);return{...i,...a}}}const dC="<image>";class cC extends fS{static tokenizer_class=s_;static image_processor_class=Tz;static uses_processor_config=!1;async _call(e,t=null,n={}){t||(console.warn("You are using PaliGemma without a text prefix. It will perform as a picture-captioning model."),t=""),Array.isArray(e)||(e=[e]),Array.isArray(t)||(t=[t]);const r=this.tokenizer.bos_token,s=this.image_processor.config.image_seq_length;let i;t.some((e=>e.includes(dC)))?i=t.map((e=>{const t=e.replaceAll(dC,dC.repeat(s)),n=t.lastIndexOf(dC),i=-1===n?0:n+7;return t.slice(0,i)+r+t.slice(i)+"\\n"})):(console.warn("You are passing both `text` and `images` to `PaliGemmaProcessor`. The processor expects special image tokens in the text, as many tokens as there are images per each text. It is recommended to add `<image>` tokens in the very beginning of your text. For this call, we will infer how many images each text has and add special tokens."),i=t.map((t=>function n(e,t,r,s,i){return`${s.repeat(r*i)}${t}${e}\\n`}(t,r,s,dC,e.length))));const a=this.tokenizer(i,n);return{...await this.image_processor(e,n),...a}}}class pC extends fS{static feature_extractor_class=Kz;async _call(e){return await this.feature_extractor(e)}post_process_speaker_diarization(...e){return this.feature_extractor.post_process_speaker_diarization(...e)}get sampling_rate(){return this.feature_extractor.config.sampling_rate}}class hC extends fS{static image_processor_class=Tz;static tokenizer_class=s_;async _call(e,t=null,...n){let r,s;if(Array.isArray(e)||(e=[e]),t&&(r=await this.image_processor(t),s=r.image_grid_thw),s){let t=this.image_processor.config.merge_size**2,n=0;const r=s.tolist();e=e.map((e=>{for(;e.includes("<|image_pad|>");){const s=Number(r[n++].reduce(((e,t)=>e*t),1n));e=e.replace("<|image_pad|>","<|placeholder|>".repeat(Math.floor(s/t)))}return e.replaceAll("<|placeholder|>","<|image_pad|>")}))}return{...this.tokenizer(e),...r}}}class fC extends fS{static image_processor_class=Tz;async _call(...e){return await this.image_processor(...e)}post_process_masks(...e){return this.image_processor.post_process_masks(...e)}reshape_input_points(...e){return this.image_processor.reshape_input_points(...e)}}class mC extends fS{static tokenizer_class=s_;static feature_extractor_class=eC;async _call(e){return await this.feature_extractor(e)}}class _C extends fS{static feature_extractor_class=eC;async _call(e){return await this.feature_extractor(e)}}class gC extends fS{static tokenizer_class=s_;static feature_extractor_class=eC;async _call(e){return await this.feature_extractor(e)}}class wC{static async from_pretrained(e,s={}){const i=await W(e,__,!0,s),{image_processor_type:a,feature_extractor_type:o,processor_class:l}=i;if(l&&r[l])return r[l].from_pretrained(e,s);if(!a&&!o)throw new Error("No `image_processor_type` or `feature_extractor_type` found in the config.");const u={};if(a){const e=t[a];if(!e)throw new Error(`Unknown image_processor_type: \'${a}\'.`);u.image_processor=new e(i)}if(o){const e=t[o];if(e)u.image_processor=new e(i);else{const e=n[o];if(!e)throw new Error(`Unknown feature_extractor_type: \'${o}\'.`);u.feature_extractor=new e(i)}}return new fS({},u)}}async function yC(e){return Array.isArray(e)||(e=[e]),await Promise.all(e.map((e=>U_.read(e))))}async function bC(e,t){return Array.isArray(e)||(e=[e]),await Promise.all(e.map((e=>"string"==typeof e||e instanceof URL?async function n(e,t){if("undefined"==typeof AudioContext)throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const n=await(await F(e)).arrayBuffer(),r=new AudioContext({sampleRate:t});"undefined"==typeof t&&console.warn(`No sampling rate provided, using default of ${r.sampleRate}Hz.`);const s=await r.decodeAudioData(n);let i;if(2===s.numberOfChannels){const e=Math.sqrt(2),t=s.getChannelData(0),n=s.getChannelData(1);i=new Float32Array(t.length);for(let r=0;r<s.length;++r)i[r]=e*(t[r]+n[r])/2}else i=s.getChannelData(0);return i}(e,t):e instanceof Float64Array?new Float32Array(e):e)))}function xC(e,t){t&&(e=e.map((e=>0|e)));const[n,r,s,i]=e;return{xmin:n,ymin:r,xmax:s,ymax:i}}class vC extends k{constructor({task:e,model:t,tokenizer:n=null,processor:r=null}){super(),this.task=e,this.model=t,this.tokenizer=n,this.processor=r}async dispose(){await this.model.dispose()}}class $C extends vC{_key="generated_text";constructor(e){super(e)}async _call(e,t={}){Array.isArray(e)||(e=[e]),this.model.config.prefix&&(e=e.map((e=>this.model.config.prefix+e)));const n=this.model.config.task_specific_params;n&&n[this.task]&&n[this.task].prefix&&(e=e.map((e=>n[this.task].prefix+e)));const r=this.tokenizer,s={padding:!0,truncation:!0};let i;i=this instanceof kC&&"_build_translation_inputs"in r?r._build_translation_inputs(e,s,t):r(e,s);const a=await this.model.generate({...i,...t});return r.batch_decode(a,{skip_special_tokens:!0}).map((e=>({[this._key]:e})))}}class kC extends $C{_key="translation_text";constructor(e){super(e)}}function EC(e){return Array.isArray(e)&&e.every((e=>"role"in e&&"content"in e))}const SC=Object.freeze({"text-classification":{tokenizer:s_,pipeline:class zC extends vC{constructor(e){super(e)}async _call(e,{top_k:t=1}={}){const n=this.tokenizer(e,{padding:!0,truncation:!0}),r=await this.model(n),s="multi_label_classification"===this.model.config.problem_type?e=>e.sigmoid():e=>new Cp("float32",G(e.data),e.dims),i=this.model.config.id2label,a=[];for(const e of r.logits){const n=s(e),r=await Ip(n,t),o=r[0].tolist(),l=r[1].tolist().map(((e,t)=>({label:i?i[e]:`LABEL_${e}`,score:o[t]})));1===t?a.push(...l):a.push(l)}return Array.isArray(e)||1===t?a:a[0]}},model:sS,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:s_,pipeline:class CC extends vC{constructor(e){super(e)}async _call(e,{ignore_labels:t=["O"]}={}){const n=Array.isArray(e),r=this.tokenizer(n?e:[e],{padding:!0,truncation:!0}),s=(await this.model(r)).logits,i=this.model.config.id2label,a=[];for(let e=0;e<s.dims[0];++e){const n=r.input_ids[e],o=s[e],l=[];for(let e=0;e<o.dims[0];++e){const r=o[e],s=X(r.data)[1],a=i?i[s]:`LABEL_${s}`;if(t.includes(a))continue;const u=this.tokenizer.decode([n[e].item()],{skip_special_tokens:!0});if(""===u)continue;const d=G(r.data);l.push({entity:a,score:d[s],index:e,word:u})}a.push(l)}return n?a:a[0]}},model:class TC extends sb{static MODEL_CLASS_MAPPINGS=[Ov]},default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:s_,pipeline:class AC extends vC{constructor(e){super(e)}async _call(e,t,{top_k:n=1}={}){const r=this.tokenizer(e,{text_pair:t,padding:!0,truncation:!0}),{start_logits:s,end_logits:i}=await this.model(r),a=r.input_ids.tolist(),o=r.attention_mask.tolist(),l=this.tokenizer.all_special_ids,u=[];for(let e=0;e<s.dims[0];++e){const t=a[e],r=t.findIndex((e=>e==this.tokenizer.sep_token_id)),d=(o[e].map(((e,n)=>1==e&&(0===n||n>r&&-1===l.findIndex((e=>e==t[n]))))),s[e].tolist()),c=i[e].tolist();for(let n=1;n<d.length;++n)(0==o[e]||n<=r||-1!==l.findIndex((e=>e==t[n])))&&(d[n]=-Infinity,c[n]=-Infinity);const p=G(d).map(((e,t)=>[e,t])),h=G(c).map(((e,t)=>[e,t]));p[0][0]=0,h[0][0]=0;const f=A(p,h).filter((e=>e[0][1]<=e[1][1])).map((e=>[e[0][1],e[1][1],e[0][0]*e[1][0]])).sort(((e,t)=>t[2]-e[2]));for(let e=0;e<Math.min(f.length,n);++e){const[n,r,s]=f[e],i=t.slice(n,r+1),a=this.tokenizer.decode(i,{skip_special_tokens:!0});u.push({answer:a,score:s})}}return 1===n?u[0]:u}},model:class IC extends sb{static MODEL_CLASS_MAPPINGS=[Z$]},default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:s_,pipeline:class MC extends vC{constructor(e){super(e)}async _call(e,{top_k:t=5}={}){const n=this.tokenizer(e,{padding:!0,truncation:!0}),{logits:r}=await this.model(n),s=[],i=n.input_ids.tolist();for(let e=0;e<i.length;++e){const n=i[e],a=n.findIndex((e=>e==this.tokenizer.mask_token_id));if(-1===a)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const o=r[e][a],l=await Ip(new Cp("float32",G(o.data),o.dims),t),u=l[0].tolist(),d=l[1].tolist();s.push(d.map(((e,t)=>{const r=n.slice();return r[a]=e,{score:u[t],token:Number(e),token_str:this.tokenizer.model.vocab[e],sequence:this.tokenizer.decode(r,{skip_special_tokens:!0})}})))}return Array.isArray(e)?s:s[0]}},model:class OC extends sb{static MODEL_CLASS_MAPPINGS=[N$]},default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:s_,pipeline:class BC extends $C{_key="summary_text";constructor(e){super(e)}},model:iS,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:s_,pipeline:kC,model:iS,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:s_,pipeline:$C,model:iS,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:s_,pipeline:class NC extends vC{constructor(e){super(e)}async _call(e,t={}){let n,r=!1,s=!1;if("string"==typeof e)n=e=[e];else if(Array.isArray(e)&&e.every((e=>"string"==typeof e)))r=!0,n=e;else{if(EC(e))e=[e];else{if(!Array.isArray(e)||!e.every(EC))throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");r=!0}s=!0,n=e.map((e=>this.tokenizer.apply_chat_template(e,{tokenize:!1,add_generation_prompt:!0})))}const i=t.add_special_tokens??!1,a=!s&&(t.return_full_text??!0);this.tokenizer.padding_side="left";const o=this.tokenizer(n,{add_special_tokens:i,padding:!0,truncation:!0}),l=await this.model.generate({...o,...t}),u=this.tokenizer.batch_decode(l,{skip_special_tokens:!0});let d;!a&&o.input_ids.dims.at(-1)>0&&(d=this.tokenizer.batch_decode(o.input_ids,{skip_special_tokens:!0}).map((e=>e.length)));const c=Array.from({length:e.length},(e=>[]));for(let t=0;t<u.length;++t){const n=Math.floor(t/l.dims[0]*e.length);d&&(u[t]=u[t].slice(d[n])),c[n].push({generated_text:s?[...e[n],{role:"assistant",content:u[t]}]:u[t]})}return r||1!==c.length?c:c[0]}},model:class PC extends sb{static MODEL_CLASS_MAPPINGS=[r$]},default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:s_,pipeline:class RC extends vC{constructor(e){super(e),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map((([e,t])=>[e.toLowerCase(),t]))),this.entailment_id=this.label2id.entailment,void 0===this.entailment_id&&(console.warn("Could not find \'entailment\' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,void 0===this.contradiction_id&&(console.warn("Could not find \'contradiction\' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(e,t,{hypothesis_template:n="This example is {}.",multi_label:r=!1}={}){const s=Array.isArray(e);s||(e=[e]),Array.isArray(t)||(t=[t]);const i=t.map((e=>n.replace("{}",e))),a=r||1===t.length,o=[];for(const n of e){const e=[];for(const t of i){const r=this.tokenizer(n,{text_pair:t,padding:!0,truncation:!0}),s=await this.model(r);a?e.push([s.logits.data[this.contradiction_id],s.logits.data[this.entailment_id]]):e.push(s.logits.data[this.entailment_id])}const r=(a?e.map((e=>G(e)[1])):G(e)).map(((e,t)=>[e,t])).sort(((e,t)=>t[0]-e[0]));o.push({sequence:n,labels:r.map((e=>t[e[1]])),scores:r.map((e=>e[0]))})}return s?o:o[0]}},model:sS,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:class DC extends vC{constructor(e){super(e)}async _call(e,{top_k:t=5}={}){const n=this.processor.feature_extractor.config.sampling_rate,r=await bC(e,n),s=this.model.config.id2label,i=[];for(const e of r){const n=await this.processor(e),r=(await this.model(n)).logits[0],a=await Ip(new Cp("float32",G(r.data),r.dims),t),o=a[0].tolist(),l=a[1].tolist().map(((e,t)=>({label:s?s[e]:`LABEL_${e}`,score:o[t]})));i.push(l)}return Array.isArray(e)?i:i[0]}},model:class LC extends sb{static MODEL_CLASS_MAPPINGS=[fE]},processor:wC,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:s_,pipeline:class FC extends vC{constructor(e){super(e)}async _call(e,t,{hypothesis_template:n="This is a sound of {}."}={}){const r=!Array.isArray(e);r&&(e=[e]);const s=t.map((e=>n.replace("{}",e))),i=this.tokenizer(s,{padding:!0,truncation:!0}),a=this.processor.feature_extractor.config.sampling_rate,o=await bC(e,a),l=[];for(const e of o){const n=await this.processor(e),r=G((await this.model({...i,...n})).logits_per_audio.data);l.push([...r].map(((e,n)=>({score:e,label:t[n]}))))}return r?l[0]:l}},model:rS,processor:wC,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:s_,pipeline:class UC extends vC{constructor(e){super(e)}async _call(e,t={}){switch(this.model.config.model_type){case"whisper":return this._call_whisper(e,t);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":return this._call_wav2vec2(e,t);case"moonshine":return this._call_moonshine(e,t);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type \'${this.model.config.model_type}\'.`)}}async _call_wav2vec2(e,t){t.language&&console.warn(\'`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".\'),t.task&&console.warn(\'`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".\');const n=!Array.isArray(e);n&&(e=[e]);const r=this.processor.feature_extractor.config.sampling_rate,s=await bC(e,r),i=[];for(const e of s){const t=await this.processor(e),n=(await this.model(t)).logits[0],r=[];for(const e of n)r.push(X(e.data)[1]);const s=this.tokenizer.decode(r);i.push({text:s})}return n?i[0]:i}async _call_whisper(e,t){const n=t.return_timestamps??!1,r=t.chunk_length_s??0,s=t.force_full_sequences??!1;let i=t.stride_length_s??null;const a={...t};"word"===n&&(a.return_token_timestamps=!0,a.return_timestamps=!1);const o=!Array.isArray(e);o&&(e=[e]);const l=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,u=this.processor.feature_extractor.config.hop_length,d=this.processor.feature_extractor.config.sampling_rate,c=await bC(e,d),p=[];for(const e of c){let t=[];if(r>0){if(null===i)i=r/6;else if(r<=i)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const n=d*r,s=d*i,a=n-2*s;let o=0;for(;;){const r=o+n,i=e.subarray(o,r),l=await this.processor(i),u=0===o,d=r>=e.length;if(t.push({stride:[i.length,u?0:s,d?0:s],input_features:l.input_features,is_last:d}),d)break;o+=a}}else t=[{stride:[e.length,0,0],input_features:(await this.processor(e)).input_features,is_last:!0}];for(const e of t){a.num_frames=Math.floor(e.stride[0]/u);const t=await this.model.generate({inputs:e.input_features,...a});"word"===n?(e.tokens=t.sequences.tolist()[0],e.token_timestamps=t.token_timestamps.tolist()[0].map((e=>te(e,2)))):e.tokens=t[0].tolist(),e.stride=e.stride.map((e=>e/d))}const[o,c]=this.tokenizer._decode_asr(t,{time_precision:l,return_timestamps:n,force_full_sequences:s});p.push({text:o,...c})}return o?p[0]:p}async _call_moonshine(e,t){const n=!Array.isArray(e);n&&(e=[e]);const r=this.processor.feature_extractor.config.sampling_rate,s=await bC(e,r),i=[];for(const e of s){const n=await this.processor(e),s=6*Math.floor(e.length/r),a=await this.model.generate({max_new_tokens:s,...t,...n}),o=this.processor.batch_decode(a,{skip_special_tokens:!0})[0];i.push({text:o})}return n?i[0]:i}},model:[class qC extends sb{static MODEL_CLASS_MAPPINGS=[ov]},class VC extends sb{static MODEL_CLASS_MAPPINGS=[oE]}],processor:wC,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:s_,pipeline:class WC extends vC{DEFAULT_VOCODER_ID="Xenova/speecht5_hifigan";constructor(e){super(e),this.vocoder=e.vocoder??null}async _call(e,{speaker_embeddings:t=null}={}){return this.processor?this._call_text_to_spectrogram(e,{speaker_embeddings:t}):this._call_text_to_waveform(e)}async _call_text_to_waveform(e){const t=this.tokenizer(e,{padding:!0,truncation:!0}),{waveform:n}=await this.model(t),r=this.model.config.sampling_rate;return{audio:n.data,sampling_rate:r}}async _call_text_to_spectrogram(e,{speaker_embeddings:t}){if(this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await rS.from_pretrained(this.DEFAULT_VOCODER_ID,{dtype:"fp32"})),("string"==typeof t||t instanceof URL)&&(t=new Float32Array(await(await fetch(t)).arrayBuffer())),t instanceof Float32Array)t=new Cp("float32",t,[1,t.length]);else if(!(t instanceof Cp))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");const{input_ids:n}=this.tokenizer(e,{padding:!0,truncation:!0}),{waveform:r}=await this.model.generate_speech(n,t,{vocoder:this.vocoder}),s=this.processor.feature_extractor.config.sampling_rate;return{audio:r.data,sampling_rate:s}}},model:[class jC extends sb{static MODEL_CLASS_MAPPINGS=[hv]},class GC extends sb{static MODEL_CLASS_MAPPINGS=[cv]}],processor:[wC,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:s_,pipeline:class HC extends vC{constructor(e){super(e)}async _call(e,t={}){const n=Array.isArray(e),r=await yC(e),{pixel_values:s}=await this.processor(r),i=[];for(const e of s){e.dims=[1,...e.dims];const n=await this.model.generate({inputs:e,...t}),r=this.tokenizer.batch_decode(n,{skip_special_tokens:!0}).map((e=>({generated_text:e.trim()})));i.push(r)}return n?i:i[0]}},model:class KC extends sb{static MODEL_CLASS_MAPPINGS=[fk]},processor:wC,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:class XC extends vC{constructor(e){super(e)}async _call(e,{top_k:t=5}={}){const n=await yC(e),{pixel_values:r}=await this.processor(n),s=await this.model({pixel_values:r}),i=this.model.config.id2label,a=[];for(const e of s.logits){const n=await Ip(new Cp("float32",G(e.data),e.dims),t),r=n[0].tolist(),s=n[1].tolist().map(((e,t)=>({label:i?i[e]:`LABEL_${e}`,score:r[t]})));a.push(s)}return Array.isArray(e)?a:a[0]}},model:class QC extends sb{static MODEL_CLASS_MAPPINGS=[vk]},processor:wC,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:class YC extends vC{constructor(e){super(e),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(e,{threshold:t=.5,mask_threshold:n=.5,overlap_mask_area_threshold:r=.8,label_ids_to_fuse:s=null,target_sizes:i=null,subtask:a=null}={}){if(Array.isArray(e)&&1!==e.length)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const o=await yC(e),l=o.map((e=>[e.height,e.width])),{pixel_values:u,pixel_mask:d}=await this.processor(o),c=await this.model({pixel_values:u,pixel_mask:d});let p=null;if(null!==a)p=this.subtasks_mapping[a];else for(let[e,t]of Object.entries(this.subtasks_mapping))if(t in this.processor.image_processor){p=this.processor.image_processor[t].bind(this.processor.image_processor),a=e;break}const h=this.model.config.id2label,f=[];if("panoptic"===a||"instance"===a){const e=p(c,t,n,r,s,i??l)[0],a=e.segmentation;for(const t of e.segments_info){const e=new Uint8ClampedArray(a.data.length);for(let n=0;n<a.data.length;++n)a.data[n]===t.id&&(e[n]=255);const n=new U_(e,a.dims[1],a.dims[0],1);f.push({score:t.score,label:h[t.label_id],mask:n})}}else{if("semantic"!==a)throw Error(`Subtask ${a} not supported.`);{const{segmentation:e,labels:t}=p(c,i??l)[0];for(const n of t){const t=new Uint8ClampedArray(e.data.length);for(let r=0;r<e.data.length;++r)e.data[r]===n&&(t[r]=255);const r=new U_(t,e.dims[1],e.dims[0],1);f.push({score:null,label:h[n],mask:r})}}}return f}},model:[class ZC extends sb{static MODEL_CLASS_MAPPINGS=[Zk]},class JC extends sb{static MODEL_CLASS_MAPPINGS=[eE]},class eT extends sb{static MODEL_CLASS_MAPPINGS=[rE]}],processor:wC,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"zero-shot-image-classification":{tokenizer:s_,pipeline:class tT extends vC{constructor(e){super(e)}async _call(e,t,{hypothesis_template:n="This is a photo of {}"}={}){const r=Array.isArray(e),s=await yC(e),i=t.map((e=>n.replace("{}",e))),a=this.tokenizer(i,{padding:"siglip"!==this.model.config.model_type||"max_length",truncation:!0}),{pixel_values:o}=await this.processor(s),l=await this.model({...a,pixel_values:o}),u="siglip"===this.model.config.model_type?e=>e.sigmoid().data:e=>G(e.data),d=[];for(const e of l.logits_per_image){const n=[...u(e)].map(((e,n)=>({score:e,label:t[n]})));n.sort(((e,t)=>t.score-e.score)),d.push(n)}return r?d:d[0]}},model:rS,processor:wC,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:class nT extends vC{constructor(e){super(e)}async _call(e,{threshold:t=.9,percentage:n=!1}={}){const r=Array.isArray(e);if(r&&1!==e.length)throw Error("Object detection pipeline currently only supports a batch size of 1.");const s=await yC(e),i=n?null:s.map((e=>[e.height,e.width])),{pixel_values:a,pixel_mask:o}=await this.processor(s),l=await this.model({pixel_values:a,pixel_mask:o}),u=this.processor.image_processor.post_process_object_detection(l,t,i),d=this.model.config.id2label,c=u.map((e=>e.boxes.map(((t,r)=>({score:e.scores[r],label:d[e.classes[r]],box:xC(t,!n)})))));return r?c:c[0]}},model:class rT extends sb{static MODEL_CLASS_MAPPINGS=[Wk]},processor:wC,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:s_,pipeline:class sT extends vC{constructor(e){super(e)}async _call(e,t,{threshold:n=.1,top_k:r=null,percentage:s=!1}={}){const i=Array.isArray(e),a=await yC(e),o=this.tokenizer(t,{padding:!0,truncation:!0}),l=await this.processor(a),u=[];for(let e=0;e<a.length;++e){const i=a[e],d=s?null:[[i.height,i.width]],c=l.pixel_values[e].unsqueeze_(0),p=await this.model({...o,pixel_values:c}),h=this.processor.image_processor.post_process_object_detection(p,n,d,!0)[0];let f=h.boxes.map(((e,n)=>({score:h.scores[n],label:t[h.classes[n]],box:xC(e,!s)}))).sort(((e,t)=>t.score-e.score));null!==r&&(f=f.slice(0,r)),u.push(f)}return i?u:u[0]}},model:class iT extends sb{static MODEL_CLASS_MAPPINGS=[Xk]},processor:wC,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:s_,pipeline:class aT extends vC{constructor(e){super(e)}async _call(e,t,n={}){const r=(await yC(e))[0],{pixel_values:s}=await this.processor(r),i=`<s_docvqa><s_question>${t}</s_question><s_answer>`,a=this.tokenizer(i,{add_special_tokens:!1,padding:!0,truncation:!0}).input_ids,o=await this.model.generate({inputs:s,max_length:this.model.config.decoder.max_position_embeddings,decoder_input_ids:a,...n}),l=this.tokenizer.batch_decode(o)[0].match(/<s_answer>(.*?)<\\/s_answer>/);let u=null;return l&&l.length>=2&&(u=l[1].trim()),[{answer:u}]}},model:class oT extends sb{static MODEL_CLASS_MAPPINGS=[xk]},processor:wC,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:class lT extends vC{constructor(e){super(e)}async _call(e){const t=await yC(e),n=await this.processor(t),r=await this.model(n),s=[];for(const e of r.reconstruction){const t=e.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");s.push(U_.fromTensor(t))}return s.length>1?s:s[0]}},model:class uT extends sb{static MODEL_CLASS_MAPPINGS=[BE]},processor:wC,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:class dT extends vC{constructor(e){super(e)}async _call(e){const t=await yC(e),n=await this.processor(t),{predicted_depth:r}=await this.model(n),s=[];for(let e=0;e<t.length;++e){const n=Tp(r[e],t[e].size.reverse(),"bilinear",!1),i=n.mul_(255/X(n.data)[0]).to("uint8");s.push({predicted_depth:r[e],depth:U_.fromTensor(i)})}return s.length>1?s:s[0]}},model:class cT extends sb{static MODEL_CLASS_MAPPINGS=[PE]},processor:wC,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:s_,pipeline:class pT extends vC{constructor(e){super(e)}async _call(e,{pooling:t="none",normalize:n=!1,quantize:r=!1,precision:s="binary"}={}){const i=this.tokenizer(e,{padding:!0,truncation:!0}),a=await this.model(i);let o=a.last_hidden_state??a.logits??a.token_embeddings;if("none"===t);else if("mean"===t)o=function l(e,t){const n=e.data,r=t.data,s=[e.dims[0],e.dims[2]],i=new n.constructor(s[0]*s[1]),[a,o,l]=e.dims;let u=0;for(let e=0;e<a;++e){const t=e*l*o;for(let s=0;s<l;++s){let a=0,d=0;const c=e*o,p=t+s;for(let e=0;e<o;++e){const t=Number(r[c+e]);d+=t,a+=n[p+e*l]*t}const h=a/d;i[u++]=h}}return new Cp(e.type,i,s)}(o,i.attention_mask);else{if("cls"!==t)throw Error(`Pooling method \'${t}\' not supported.`);o=o.slice(null,0)}return n&&(o=o.normalize(2,-1)),r&&(o=function u(e,t){if(2!==e.dims.length)throw new Error("The tensor must have 2 dimensions");if(e.dims.at(-1)%8!=0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(t))throw new Error("The precision must be either \'binary\' or \'ubinary\'");const n="binary"===t,r=n?"int8":"uint8",s=n?Int8Array:Uint8Array,i=e.data,a=new s(i.length/8);for(let e=0;e<i.length;++e){const t=i[e]>0?1:0,r=Math.floor(e/8),s=e%8;a[r]|=t<<7-s,n&&0===s&&(a[r]-=128)}return new Cp(r,a,[e.dims[0],e.dims[1]/8])}(o,s)),o}},model:rS,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:wC,pipeline:class hT extends vC{constructor(e){super(e)}async _call(e,{pool:t=null}={}){const n=await yC(e),{pixel_values:r}=await this.processor(n),s=await this.model({pixel_values:r});let i;if(t){if(!("pooler_output"in s))throw Error("No pooled output was returned. Make sure the model has a \'pooler\' layer when using the \'pool\' option.");i=s.pooler_output}else i=s.last_hidden_state??s.logits??s.image_embeds;return i}},model:[class fT extends sb{static MODEL_CLASS_MAPPINGS=[GE]},rS],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),mT=Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});async function _T(e,t=null,{progress_callback:n=null,config:r=null,cache_dir:s=null,local_files_only:i=!1,revision:a="main",device:o=null,dtype:l=null,model_file_name:u=null,session_options:d={}}={}){e=mT[e]??e;const c=SC[e.split("_",1)[0]];if(!c)throw Error(`Unsupported pipeline: ${e}. Must be one of [${Object.keys(SC)}]`);t||(t=c.default.model,console.log(`No model specified. Using default model: "${t}".`));const p={progress_callback:n,config:r,cache_dir:s,local_files_only:i,revision:a,device:o,dtype:l,model_file_name:u,session_options:d},h=new Map([["tokenizer",c.tokenizer],["model",c.model],["processor",c.processor]]),f=await async function m(e,t,n){const r=Object.create(null),s=[];for(const[i,a]of e.entries()){if(!a)continue;let e;e=Array.isArray(a)?new Promise((async(e,r)=>{let s;for(const i of a){if(null===i)return void e(null);try{return void e(await i.from_pretrained(t,n))}catch(e){if(e.message?.includes("Unsupported model type"))s=e;else{if(!e.message?.includes("Could not locate file"))return void r(e);s=e}}}r(s)})):a.from_pretrained(t,n),r[i]=e,s.push(e)}await Promise.all(s);for(const[e,t]of Object.entries(r))r[e]=await t;return r}(h,t,p);f.task=e,E(n,{status:"ready",task:e,model:t});return new(0,c.pipeline)(f)}g.IS_PROCESS_AVAILABLE;["upload","listen","summarize","telehealth"].map((e=>`finished-${e}-transcriptions`));var gT,wT;globalThis.requestIdleCallback||(globalThis.requestIdleCallback=e=>+setTimeout((()=>e({didTimeout:!1,timeRemaining:()=>1})))),globalThis.cancelIdleCallback||(globalThis.cancelIdleCallback=clearTimeout);null!==(gT=(wT=Set.prototype).union)&&void 0!==gT||(wT.union=function(e){const t=new Set(this);for(const n of e.keys())t.add(n);return t});\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst yT=Symbol("Comlink.proxy"),bT=Symbol("Comlink.endpoint"),xT=Symbol("Comlink.releaseProxy"),vT=Symbol("Comlink.finalizer"),$T=Symbol("Comlink.thrown"),kT=e=>"object"==typeof e&&null!==e||"function"==typeof e,ET=new Map([["proxy",{canHandle:e=>kT(e)&&e[yT],serialize(e){const{port1:t,port2:n}=new MessageChannel;return ST(e,t),[n,[n]]},deserialize:e=>(e.start(),function t(e,n){return MT(e,[],n)}(e))}],["throw",{canHandle:e=>kT(e)&&$T in e,serialize({value:e}){let t;return t=e instanceof Error?{isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:{isError:!1,value:e},[t,[]]},deserialize(e){if(e.isError)throw Object.assign(new Error(e.value.message),e.value);throw e.value}}]]);function ST(e,t=globalThis,n=["*"]){t.addEventListener("message",(function r(s){if(!s||!s.data)return;if(!function i(e,t){for(const n of e){if(t===n||"*"===n)return!0;if(n instanceof RegExp&&n.test(t))return!0}return!1}(n,s.origin))return void console.warn(`Invalid origin \'${s.origin}\' for comlink proxy`);const{id:a,type:o,path:l}=Object.assign({path:[]},s.data),u=(s.data.argumentList||[]).map(PT);let d;try{const t=l.slice(0,-1).reduce(((e,t)=>e[t]),e),n=l.reduce(((e,t)=>e[t]),e);switch(o){case"GET":d=n;break;case"SET":t[l.slice(-1)[0]]=PT(s.data.value),d=!0;break;case"APPLY":d=n.apply(t,u);break;case"CONSTRUCT":d=function r(e){return Object.assign(e,{[yT]:!0})}(new n(...u));break;case"ENDPOINT":{const{port1:t,port2:n}=new MessageChannel;ST(e,n),d=function r(e,t){return BT.set(e,t),e}(t,[t])}break;case"RELEASE":d=void 0;break;default:return}}catch(e){d={value:e,[$T]:0}}Promise.resolve(d).catch((e=>({value:e,[$T]:0}))).then((n=>{const[s,i]=NT(n);t.postMessage(Object.assign(Object.assign({},s),{id:a}),i),"RELEASE"===o&&(t.removeEventListener("message",r),zT(t),vT in e&&"function"==typeof e[vT]&&e[vT]())})).catch((e=>{const[n,r]=NT({value:new TypeError("Unserializable return value"),[$T]:0});t.postMessage(Object.assign(Object.assign({},n),{id:a}),r)}))})),t.start&&t.start()}function zT(e){(function t(e){return"MessagePort"===e.constructor.name})(e)&&e.close()}function CT(e){if(e)throw new Error("Proxy has been released and is not useable")}function TT(e){return RT(e,{type:"RELEASE"}).then((()=>{zT(e)}))}const AT=new WeakMap,IT="FinalizationRegistry"in globalThis&&new FinalizationRegistry((e=>{const t=(AT.get(e)||0)-1;AT.set(e,t),0===t&&TT(e)}));function MT(e,t=[],n=function(){}){let r=!1;const s=new Proxy(n,{get(n,i){if(CT(r),i===xT)return()=>{!function t(e){IT&&IT.unregister(e)}(s),TT(e),r=!0};if("then"===i){if(0===t.length)return{then:()=>s};const n=RT(e,{type:"GET",path:t.map((e=>e.toString()))}).then(PT);return n.then.bind(n)}return MT(e,[...t,i])},set(n,s,i){CT(r);const[a,o]=NT(i);return RT(e,{type:"SET",path:[...t,s].map((e=>e.toString())),value:a},o).then(PT)},apply(n,s,i){CT(r);const a=t[t.length-1];if(a===bT)return RT(e,{type:"ENDPOINT"}).then(PT);if("bind"===a)return MT(e,t.slice(0,-1));const[o,l]=OT(i);return RT(e,{type:"APPLY",path:t.map((e=>e.toString())),argumentList:o},l).then(PT)},construct(n,s){CT(r);const[i,a]=OT(s);return RT(e,{type:"CONSTRUCT",path:t.map((e=>e.toString())),argumentList:i},a).then(PT)}});return function i(e,t){const n=(AT.get(t)||0)+1;AT.set(t,n),IT&&IT.register(e,t,e)}(s,e),s}function OT(e){const t=e.map(NT);return[t.map((e=>e[0])),(n=t.map((e=>e[1])),Array.prototype.concat.apply([],n))];var n}const BT=new WeakMap;function NT(e){for(const[t,n]of ET)if(n.canHandle(e)){const[r,s]=n.serialize(e);return[{type:"HANDLER",name:t,value:r},s]}return[{type:"RAW",value:e},BT.get(e)||[]]}function PT(e){switch(e.type){case"HANDLER":return ET.get(e.name).deserialize(e.value);case"RAW":return e.value}}function RT(e,t,n){return new Promise((r=>{const s=function i(){return new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-")}();e.addEventListener("message",(function t(n){n.data&&n.data.id&&n.data.id===s&&(e.removeEventListener("message",t),r(n.data))})),e.start&&e.start(),e.postMessage(Object.assign({id:s},t),n)}))}"undefined"!=typeof navigator&&navigator.userAgent.includes("Firefox");let DT=48e3;if("undefined"!=typeof AudioContext){const e=new AudioContext;DT=e.sampleRate,e.close()}!!globalThis.navigator&&/Mobi|Android/i.test(navigator.userAgent);const LT="undefined"==typeof location?"":location.search,FT="undefined"!=typeof process,UT=(!FT&&"undefined"!=typeof location&&location.pathname.includes("/dashboard"),"undefined"!=typeof AudioWorkletProcessor),qT="undefined"!=typeof DedicatedWorkerGlobalScope||UT,VT=!FT&&(qT||UT||"undefined"!=typeof navigator),WT="undefined"!=typeof location&&("localhost"===location.hostname||location.href.startsWith("blob:http://localhost"));VT&&"undefined"!=typeof location&&(location.host.includes("nuiq.com")||location.href.startsWith("blob:https://nuiq.com")||WT&&location.port),"undefined"!=typeof location&&(location.host.includes("stage.nuiq.com")||location.href.startsWith("blob:https://stage.nuiq.com")),WT||/debug(\\=true)?($|&)/.test(LT),"undefined"!=typeof navigator&&/Safari/i.test(navigator.userAgent)&&navigator.userAgent.includes("Chrome"),LT.includes("useDevServer=true"),Math.PI;qT&&self.addEventListener("unhandledrejection",(e=>{e.preventDefault(),postMessage({status:"error",args:[e.reason]}),console.error("error in worker",e)}));class jT{async init(e,t){qT&&postMessage({status:"ready"})}async process(e,t){return e}constructor(){qT&&(ST(this),postMessage({status:"listening"}))}}v.allowLocalModels=!1,v.backends.onnx&&v.backends.onnx.wasm&&(v.backends.onnx.wasm.numThreads=1);class GT{static dispose(){var e;null===(e=this.instance)||void 0===e||e.dispose(),this.instance=null}static get isDistil(){return this.model.includes("distil")}static async getInstance(){var e;const t=(e=>e.includes("distil")?(e=>e.includes("distil-whisper")?e:`distil-whisper/distil-${e.split("-")[1]}.en`)(e):(e=>e.startsWith("Xenova")?e:`onnx-community/whisper-${e}.en`)(e))(this.model),n=this.isDistil||this.quantized;return console.log(`loading ASRPipeline with params model: ${t}, quantized: ${n}`),null!==(e=this.instance)&&void 0!==e?e:this.instance=await _T("automatic-speech-recognition",t,{quantized:n,device:"wasm",dtype:{encoder_model:t.includes("turbo")?"fp16":"fp32",decoder_model_merged:"q4"},revision:"medium"===this.model?"no_attentions":"main"})}}let HT;GT.model="tiny",GT.quantized=!0,GT.instance=null;const KT=(e,t,n)=>{var r,s,i,a,o,l;if(!(null==(null===(r=e.timestamp)||void 0===r?void 0:r[1])))return e;const{[t+1]:u=e}=n;if(u!==e){const t=n.map((({timestamp:[e,t=e]=[0,0]})=>t-e)).reduce(((e,t)=>e+t),0)/n.length,r=n.map((({text:e})=>{var t;return null!==(t=null==e?void 0:e.split(/\\s+/g).length)&&void 0!==t?t:0})).reduce(((e,t)=>e+t),0)/n.length,d=r/t,c=(null!==(i=null===(s=u.timestamp)||void 0===s?void 0:s[0])&&void 0!==i?i:0)-(null!==(o=null===(a=e.timestamp)||void 0===a?void 0:a[0])&&void 0!==o?o:0),p=null===(l=e.text)||void 0===l?void 0:l.split(/\\s+/g).slice(0,Math.round(d*c)).join(" ");return e.timestamp&&(e.timestamp[1]=e.timestamp[0]+c),e.text=p,e}return e.timestamp&&(e.timestamp[1]=e.timestamp[0]),e.text="",e},XT=e=>{var t,n;return{...e,start:null===(t=e.timestamp)||void 0===t?void 0:t[0],end:null===(n=e.timestamp)||void 0===n?void 0:n[1]}},QT=e=>e.text&&e.end-e.start>0,YT=e=>{var t;return e.text=(null!==(t=e.text)&&void 0!==t?t:"").replaceAll("[BLANK_AUDIO]","").replaceAll("[MUSIC_PLAYING]","").replaceAll(/\\>{2,}/g,"").replaceAll(/[\\[\\]]/g,"").replaceAll(/\\({2,}/g,"").replaceAll(/^\\s+\\-\\s+/g,"").replaceAll(/((?:\\.\\s+|^)[a-z])/g,(e=>e.toUpperCase())).replaceAll(/^no audio$/gi,"").replaceAll(/^silence$/gi,"").trim(),e},ZT=((e,{mode:t="chain"}={})=>{let n,r=!1;const s=async(...i)=>r?"chain"===t?n.then((()=>s(...i))):n:(r=!0,n=new Promise((async(t,n)=>{try{t(await e(...i))}catch(e){console.error(e),n(e)}finally{r=!1}})),n);return s})((async({audio:e})=>{const{chunk_length:t}=HT.processor.feature_extractor.config,{max_source_positions:n}=HT.model.config,r=t/n,s=[{tokens:[],finalised:!1}];try{const t=await HT(e,{top_k:0,do_sample:!1,chunk_length_s:30,stride_length_s:5,language:null,task:null,return_timestamps:"words",force_full_sequences:!1,callback_function:function n(e){s[s.length-1].tokens=[...e[0].output_token_ids],HT.tokenizer._decode_asr(s,{time_precision:r,return_timestamps:!0,force_full_sequences:!1})},chunk_callback:function i(e){const t=s[s.length-1];Object.assign(t,e),t.finalised=!0,e.is_last||s.push({tokens:[],finalised:!1})}}),{text:a,chunks:o}=t;return{segments:o.map(YT).map(KT).map(XT).filter(QT),text:a.trim()}}catch(e){return{segments:[],text:""}}}));new class JT extends jT{async metrics(){return{}}progress(){}async init({model:e,quantized:t}){HT=await(async({model:e="tiny",quantized:t=!0}={})=>{const{instance:n,model:r,quantized:s}=GT;return(r!==e||s!==t)&&(n&&console.warn(`transcribe worker rebuilding model (model: ${e}, quantized: ${t})`),GT.model=e,GT.quantized=t,GT.dispose()),HT=await GT.getInstance()})({model:e,quantized:t}),console.log(`loaded model ${GT.model}`),await super.init()}async process({audio:e}){return await ZT({audio:e})}}})()})();',"Worker",void 0,void 0)}function u(){return a()('(()=>{var e,t,n={98:(e,t,n)=>{"use strict";e.exports=n.p+"9784243b0cabe768d594.wasm"},193:()=>{},160:()=>{},448:()=>{},655:()=>{},626:()=>{},674:()=>{},666:()=>{}},r={};function s(e){var t=r[e];if(void 0!==t)return t.exports;var i=r[e]={exports:{}};return n[e](i,i.exports,s),i.exports}s.m=n,t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,s.t=function(n,r){if(1&r&&(n=this(n)),8&r)return n;if("object"==typeof n&&n){if(4&r&&n.__esModule)return n;if(16&r&&"function"==typeof n.then)return n}var i=Object.create(null);s.r(i);var a={};e=e||[null,t({}),t([]),t(t)];for(var o=2&r&&n;"object"==typeof o&&!~e.indexOf(o);o=t(o))Object.getOwnPropertyNames(o).forEach((e=>a[e]=()=>n[e]));return a.default=()=>n,s.d(i,a),i},s.d=(e,t)=>{for(var n in t)s.o(t,n)&&!s.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},s.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),s.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),s.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{var e;s.g.importScripts&&(e=s.g.location+"");var t=s.g.document;if(!e&&t&&(t.currentScript&&(e=t.currentScript.src),!e)){var n=t.getElementsByTagName("script");if(n.length)for(var r=n.length-1;r>-1&&(!e||!/^http(s?):/.test(e));)e=n[r--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\\?.*$/,"").replace(/\\/[^\\/]+$/,"/"),s.p=e})(),s.b=self.location+"",(()=>{"use strict";var e={};s.r(e),s.d(e,{InferenceSession:()=>tt,TRACE:()=>Qe,TRACE_FUNC_BEGIN:()=>Ze,TRACE_FUNC_END:()=>Je,Tensor:()=>Xe,default:()=>Sp,env:()=>Oe,registerBackend:()=>ze});var t={};s.r(t),s.d(t,{BeitFeatureExtractor:()=>GS,BitImageProcessor:()=>HS,CLIPFeatureExtractor:()=>QS,CLIPImageProcessor:()=>XS,ChineseCLIPFeatureExtractor:()=>KS,ConvNextFeatureExtractor:()=>ZS,ConvNextImageProcessor:()=>YS,DPTFeatureExtractor:()=>az,DPTImageProcessor:()=>iz,DeiTFeatureExtractor:()=>ez,DeiTImageProcessor:()=>JS,DetrFeatureExtractor:()=>nz,DetrImageProcessor:()=>tz,DonutFeatureExtractor:()=>sz,DonutImageProcessor:()=>rz,EfficientNetImageProcessor:()=>oz,GLPNFeatureExtractor:()=>lz,Idefics3ImageProcessor:()=>uz,JinaCLIPImageProcessor:()=>cz,LlavaOnevisionImageProcessor:()=>pz,Mask2FormerImageProcessor:()=>mz,MaskFormerFeatureExtractor:()=>fz,MaskFormerImageProcessor:()=>hz,MobileNetV1FeatureExtractor:()=>gz,MobileNetV1ImageProcessor:()=>_z,MobileNetV2FeatureExtractor:()=>yz,MobileNetV2ImageProcessor:()=>wz,MobileNetV3FeatureExtractor:()=>xz,MobileNetV3ImageProcessor:()=>bz,MobileNetV4FeatureExtractor:()=>$z,MobileNetV4ImageProcessor:()=>vz,MobileViTFeatureExtractor:()=>Ez,MobileViTImageProcessor:()=>kz,NougatImageProcessor:()=>Sz,OwlViTFeatureExtractor:()=>Cz,OwlViTImageProcessor:()=>zz,Owlv2ImageProcessor:()=>Tz,Phi3VImageProcessor:()=>Nz,PvtImageProcessor:()=>Pz,Qwen2VLImageProcessor:()=>Rz,RTDetrImageProcessor:()=>Dz,SamImageProcessor:()=>Fz,SegformerFeatureExtractor:()=>Uz,SegformerImageProcessor:()=>Lz,SiglipImageProcessor:()=>qz,Swin2SRImageProcessor:()=>Vz,VLMImageProcessor:()=>dz,ViTFeatureExtractor:()=>jz,ViTImageProcessor:()=>Wz,VitMatteImageProcessor:()=>Gz,VitPoseImageProcessor:()=>Hz,YolosFeatureExtractor:()=>Xz,YolosImageProcessor:()=>Kz});var n={};s.r(n),s.d(n,{ASTFeatureExtractor:()=>pC,ClapFeatureExtractor:()=>hC,ImageFeatureExtractor:()=>jS,MoonshineFeatureExtractor:()=>fC,PyAnnoteFeatureExtractor:()=>mC,SeamlessM4TFeatureExtractor:()=>_C,SpeechT5FeatureExtractor:()=>gC,Wav2Vec2FeatureExtractor:()=>wC,WeSpeakerFeatureExtractor:()=>yC,WhisperFeatureExtractor:()=>bC});var r={};s.r(r),s.d(r,{Florence2Processor:()=>Yz,Idefics3Processor:()=>kC,JinaCLIPProcessor:()=>SC,MgpstrProcessor:()=>Jz,MoonshineProcessor:()=>vC,OwlViTProcessor:()=>zC,PaliGemmaProcessor:()=>MC,Phi3VProcessor:()=>IC,PyAnnoteProcessor:()=>OC,Qwen2VLProcessor:()=>BC,SamProcessor:()=>NC,SpeechT5Processor:()=>PC,VLChatProcessor:()=>EC,Wav2Vec2ProcessorWithLM:()=>RC,WhisperProcessor:()=>DC});\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst i=Symbol("Comlink.proxy"),a=Symbol("Comlink.endpoint"),o=Symbol("Comlink.releaseProxy"),l=Symbol("Comlink.finalizer"),u=Symbol("Comlink.thrown"),d=e=>"object"==typeof e&&null!==e||"function"==typeof e,c=new Map([["proxy",{canHandle:e=>d(e)&&e[i],serialize(e){const{port1:t,port2:n}=new MessageChannel;return p(e,t),[n,[n]]},deserialize:e=>(e.start(),function t(e,n){return w(e,[],n)}(e))}],["throw",{canHandle:e=>d(e)&&u in e,serialize({value:e}){let t;return t=e instanceof Error?{isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:{isError:!1,value:e},[t,[]]},deserialize(e){if(e.isError)throw Object.assign(new Error(e.value.message),e.value);throw e.value}}]]);function p(e,t=globalThis,n=["*"]){t.addEventListener("message",(function r(s){if(!s||!s.data)return;if(!function a(e,t){for(const n of e){if(t===n||"*"===n)return!0;if(n instanceof RegExp&&n.test(t))return!0}return!1}(n,s.origin))return void console.warn(`Invalid origin \'${s.origin}\' for comlink proxy`);const{id:o,type:d,path:c}=Object.assign({path:[]},s.data),f=(s.data.argumentList||[]).map(k);let m;try{const t=c.slice(0,-1).reduce(((e,t)=>e[t]),e),n=c.reduce(((e,t)=>e[t]),e);switch(d){case"GET":m=n;break;case"SET":t[c.slice(-1)[0]]=k(s.data.value),m=!0;break;case"APPLY":m=n.apply(t,f);break;case"CONSTRUCT":m=function r(e){return Object.assign(e,{[i]:!0})}(new n(...f));break;case"ENDPOINT":{const{port1:t,port2:n}=new MessageChannel;p(e,n),m=v(t,[t])}break;case"RELEASE":m=void 0;break;default:return}}catch(e){m={value:e,[u]:0}}Promise.resolve(m).catch((e=>({value:e,[u]:0}))).then((n=>{const[s,i]=$(n);t.postMessage(Object.assign(Object.assign({},s),{id:o}),i),"RELEASE"===d&&(t.removeEventListener("message",r),h(t),l in e&&"function"==typeof e[l]&&e[l]())})).catch((e=>{const[n,r]=$({value:new TypeError("Unserializable return value"),[u]:0});t.postMessage(Object.assign(Object.assign({},n),{id:o}),r)}))})),t.start&&t.start()}function h(e){(function t(e){return"MessagePort"===e.constructor.name})(e)&&e.close()}function f(e){if(e)throw new Error("Proxy has been released and is not useable")}function m(e){return E(e,{type:"RELEASE"}).then((()=>{h(e)}))}const _=new WeakMap,g="FinalizationRegistry"in globalThis&&new FinalizationRegistry((e=>{const t=(_.get(e)||0)-1;_.set(e,t),0===t&&m(e)}));function w(e,t=[],n=function(){}){let r=!1;const s=new Proxy(n,{get(n,i){if(f(r),i===o)return()=>{!function t(e){g&&g.unregister(e)}(s),m(e),r=!0};if("then"===i){if(0===t.length)return{then:()=>s};const n=E(e,{type:"GET",path:t.map((e=>e.toString()))}).then(k);return n.then.bind(n)}return w(e,[...t,i])},set(n,s,i){f(r);const[a,o]=$(i);return E(e,{type:"SET",path:[...t,s].map((e=>e.toString())),value:a},o).then(k)},apply(n,s,i){f(r);const o=t[t.length-1];if(o===a)return E(e,{type:"ENDPOINT"}).then(k);if("bind"===o)return w(e,t.slice(0,-1));const[l,u]=b(i);return E(e,{type:"APPLY",path:t.map((e=>e.toString())),argumentList:l},u).then(k)},construct(n,s){f(r);const[i,a]=b(s);return E(e,{type:"CONSTRUCT",path:t.map((e=>e.toString())),argumentList:i},a).then(k)}});return function i(e,t){const n=(_.get(t)||0)+1;_.set(t,n),g&&g.register(e,t,e)}(s,e),s}function y(e){return Array.prototype.concat.apply([],e)}function b(e){const t=e.map($);return[t.map((e=>e[0])),y(t.map((e=>e[1])))]}const x=new WeakMap;function v(e,t){return x.set(e,t),e}function $(e){for(const[t,n]of c)if(n.canHandle(e)){const[r,s]=n.serialize(e);return[{type:"HANDLER",name:t,value:r},s]}return[{type:"RAW",value:e},x.get(e)||[]]}function k(e){switch(e.type){case"HANDLER":return c.get(e.name).deserialize(e.value);case"RAW":return e.value}}function E(e,t,n){return new Promise((r=>{const s=function i(){return new Array(4).fill(0).map((()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16))).join("-")}();e.addEventListener("message",(function t(n){n.data&&n.data.id&&n.data.id===s&&(e.removeEventListener("message",t),r(n.data))})),e.start&&e.start(),e.postMessage(Object.assign({id:s},t),n)}))}var S=s(626),z=s(674),C=s(666);const T="undefined"!=typeof window&&"undefined"!=typeof window.document,I="undefined"!=typeof self&&"DedicatedWorkerGlobalScope"===self.constructor?.name,A="undefined"!=typeof self&&"caches"in self,M="undefined"!=typeof navigator&&"gpu"in navigator,O="undefined"!=typeof navigator&&"ml"in navigator,B="undefined"!=typeof process,N=B&&"node"===process?.release?.name,P=!W(S),R=!W(z),D=Object.freeze({IS_BROWSER_ENV:T,IS_WEBWORKER_ENV:I,IS_WEB_CACHE_AVAILABLE:A,IS_WEBGPU_AVAILABLE:M,IS_WEBNN_AVAILABLE:O,IS_PROCESS_AVAILABLE:B,IS_NODE_ENV:N,IS_FS_AVAILABLE:P,IS_PATH_AVAILABLE:R}),F=P&&R;let L="./";if(F){const e=Object({}).url;e?L=z.dirname(z.dirname(C.fileURLToPath(e))):"undefined"!=typeof __dirname&&(L=z.dirname(__dirname))}const U=F?z.join(L,"/.cache/"):null,q="/models/",V={version:"3.2.0",backends:{onnx:{}},allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!(T||I),localModelPath:F?z.join(L,q):q,useFS:P,useBrowserCache:A,useFSCache:P,cacheDir:U,useCustomCache:!1,customCache:null};function W(e){return 0===Object.keys(e).length}const j=class{constructor(){let e=function(...t){return e._call(...t)};return Object.setPrototypeOf(e,new.target.prototype)}_call(...e){throw Error("Must implement _call method in subclass")}};function G(e,t){e&&e(t)}function H(e){return e.replace(/[.*+?^${}()|[\\]\\\\]/g,"\\\\$&")}function K(e){return null==e||-1===e}function X(e){const t=[];let n=e;for(;Array.isArray(n);)t.push(n.length),n=n[0];return t}function Q(...e){return Array.prototype.concat.apply([],e)}function Y(...e){return e.reduce(((e,t)=>e.flatMap((e=>t.map((t=>[e,t]))))))}function Z(e,t){return Math.abs((e+t)%(2*t)-t)}function J(e,t){return Object.assign({},...t.map((t=>{if(void 0!==e[t])return{[t]:e[t]}})))}function ee(e){let t=0;for(const n of e)++t;return t}function te(e,t){let n=0;for(const r of e)r===t&&++n;return n}var ne=s(160),re=s(448);const se={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};class ie{constructor(e){if(this.filePath=e,this.headers=new Headers,this.exists=ne.existsSync(e),this.exists){this.status=200,this.statusText="OK";let t=ne.statSync(e);this.headers.set("content-length",t.size.toString()),this.updateContentType();let n=this;this.body=new ReadableStream({start(e){n.arrayBuffer().then((t=>{e.enqueue(new Uint8Array(t)),e.close()}))}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const e=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",se[e]??"application/octet-stream")}clone(){let e=new ie(this.filePath);return e.exists=this.exists,e.status=this.status,e.statusText=this.statusText,e.headers=new Headers(this.headers),e}async arrayBuffer(){return(await ne.promises.readFile(this.filePath)).buffer}async blob(){const e=await ne.promises.readFile(this.filePath);return new Blob([e],{type:this.headers.get("content-type")})}async text(){return await ne.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function ae(e,t=null,n=null){let r;try{r=new URL(e)}catch(e){return!1}return!(t&&!t.includes(r.protocol))&&!(n&&!n.includes(r.hostname))}async function oe(e){if(V.useFS&&!ae(e,["http:","https:","blob:"]))return new ie(e);if("undefined"!=typeof process&&"node"===process?.release?.name){const t=!!process.env?.TESTING_REMOTELY,n=V.version,r=new Headers;r.set("User-Agent",`transformers.js/${n}; is_ci/${t};`);if(ae(e,["http:","https:"],["huggingface.co","hf.co"])){const e=process.env?.HF_TOKEN??process.env?.HF_ACCESS_TOKEN;e&&r.set("Authorization",`Bearer ${e}`)}return fetch(e,{headers:r})}return fetch(e)}const le={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};class ue{constructor(e){this.path=e}async match(e){let t=re.join(this.path,e),n=new ie(t);return n.exists?n:void 0}async put(e,t){const n=Buffer.from(await t.arrayBuffer());let r=re.join(this.path,e);try{await ne.promises.mkdir(re.dirname(r),{recursive:!0}),await ne.promises.writeFile(r,n)}catch(e){console.warn("An error occurred while writing the file to cache:",e)}}}async function de(e,t,n=!0,r={}){if(!V.allowLocalModels){if(r.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!V.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}let s;if(G(r.progress_callback,{status:"initiate",name:e,file:t}),!s&&V.useBrowserCache){if("undefined"==typeof caches)throw Error("Browser cache is not available in this environment.");try{s=await caches.open("transformers-cache")}catch(e){console.warn("An error occurred while opening the browser cache:",e)}}if(!s&&V.useFSCache&&(s=new ue(r.cache_dir??V.cacheDir)),!s&&V.useCustomCache){if(!V.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");if(!V.customCache.match||!V.customCache.put)throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");s=V.customCache}const i=r.revision??"main";let a,o,l=pe(e,t),u=pe(V.localModelPath,l),d=pe(V.remoteHost,V.remotePathTemplate.replaceAll("{model}",e).replaceAll("{revision}",encodeURIComponent(i)),t),c="main"===i?l:pe(e,i,t),p=s instanceof ue?c:d,h=!1;s&&(o=await async function f(e,...t){for(let n of t)try{let t=await e.match(n);if(t)return t}catch(e){continue}}(s,u,p));const m=void 0!==o;if(void 0===o){if(V.allowLocalModels){if(ae(l,["http:","https:"])){if(r.local_files_only)throw new Error(`\\`local_files_only=true\\`, but attempted to load a remote file from: ${l}.`);if(!V.allowRemoteModels)throw new Error(`\\`env.allowRemoteModels=false\\`, but attempted to load a remote file from: ${l}.`)}else try{o=await oe(u),a=u}catch(e){console.warn(`Unable to load from local path "${u}": "${e}"`)}}if(void 0===o||404===o.status){if(r.local_files_only||!V.allowRemoteModels){if(n)throw Error(`\\`local_files_only=true\\` or \\`env.allowRemoteModels=false\\` and file was not found locally at "${u}".`);return null}if(o=await oe(d),200!==o.status)return function e(t,n,r){if(!r)return null;const s=le[t]??`Error (${t}) occurred while trying to load file`;throw Error(`${s}: "${n}".`)}(o.status,d,n);a=p}h=s&&"undefined"!=typeof Response&&o instanceof Response&&200===o.status}let _;return G(r.progress_callback,{status:"download",name:e,file:t}),r.progress_callback?m&&"undefined"!=typeof navigator&&/firefox/i.test(navigator.userAgent)?(_=new Uint8Array(await o.arrayBuffer()),G(r.progress_callback,{status:"progress",name:e,file:t,progress:100,loaded:_.length,total:_.length})):_=await async function g(e,t){const n=e.headers.get("Content-Length");null===n&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let r=parseInt(n??"0"),s=new Uint8Array(r),i=0;const a=e.body.getReader();async function o(){const{done:e,value:n}=await a.read();if(e)return;let l=i+n.length;if(l>r){r=l;let e=new Uint8Array(r);e.set(s),s=e}s.set(n,i),i=l;return t({progress:i/r*100,loaded:i,total:r}),o()}return await o(),s}(o,(n=>{G(r.progress_callback,{status:"progress",name:e,file:t,...n})})):_=new Uint8Array(await o.arrayBuffer()),h&&a&&void 0===await s.match(a)&&await s.put(a,new Response(_,{headers:o.headers})).catch((e=>{console.warn(`Unable to add response to browser cache: ${e}.`)})),G(r.progress_callback,{status:"done",name:e,file:t}),_}async function ce(e,t,n=!0,r={}){let s=await de(e,t,n,r);if(null===s)return{};let i=new TextDecoder("utf-8").decode(s);return JSON.parse(i)}function pe(...e){return e=e.map(((t,n)=>(n&&(t=t.replace(new RegExp("^/"),"")),n!==e.length-1&&(t=t.replace(new RegExp("/$"),"")),t))),e.join("/")}function he(e){const t=_e(e)[0],n=e.map((e=>Math.exp(e-t))),r=n.reduce(((e,t)=>e+t),0);return n.map((e=>e/r))}function fe(e){const t=_e(e)[0];let n=0;for(let r=0;r<e.length;++r)n+=Math.exp(e[r]-t);const r=Math.log(n);return e.map((e=>e-t-r))}function me(e){if(0===e.length)throw Error("Array must not be empty");let t=e[0],n=0;for(let r=1;r<e.length;++r)e[r]<t&&(t=e[r],n=r);return[t,n]}function _e(e){if(0===e.length)throw Error("Array must not be empty");let t=e[0],n=0;for(let r=1;r<e.length;++r)e[r]>t&&(t=e[r],n=r);return[Number(t),n]}function ge(e){return e>0&&!(e&e-1)}class we{constructor(e){if(this.size=0|e,this.size<=1||!ge(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=e<<1,this.table=new Float64Array(2*this.size);for(let e=0;e<this.table.length;e+=2){const t=Math.PI*e/this.size;this.table[e]=Math.cos(t),this.table[e+1]=-Math.sin(t)}let t=0;for(let e=1;this.size>e;e<<=1)++t;this._width=t%2==0?t-1:t,this._bitrev=new Int32Array(1<<this._width);for(let e=0;e<this._bitrev.length;++e){this._bitrev[e]=0;for(let t=0;t<this._width;t+=2){const n=this._width-t-2;this._bitrev[e]|=(e>>>t&3)<<n}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(e,t){const n=t||new Array(e.length>>>1);for(let t=0;t<e.length;t+=2)n[t>>>1]=e[t];return n}toComplexArray(e,t){const n=t||this.createComplexArray();for(let t=0;t<n.length;t+=2)n[t]=e[t>>>1],n[t+1]=0;return n}transform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._transform4(e,t,1)}realTransform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._realTransform4(e,t,1)}inverseTransform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._transform4(e,t,-1);for(let t=0;t<e.length;++t)e[t]/=this.size}_transform4(e,t,n){const r=this._csize;let s,i,a=1<<this._width,o=r/a<<1;const l=this._bitrev;if(4===o)for(s=0,i=0;s<r;s+=o,++i){const n=l[i];this._singleTransform2(t,e,s,n,a)}else for(s=0,i=0;s<r;s+=o,++i){const r=l[i];this._singleTransform4(t,e,s,r,a,n)}const u=this.table;for(a>>=2;a>=2;a>>=2){o=r/a<<1;const t=o>>>2;for(s=0;s<r;s+=o){const r=s+t-1;for(let i=s,o=0;i<r;i+=2,o+=a){const r=i,s=r+t,a=s+t,l=a+t,d=e[r],c=e[r+1],p=e[s],h=e[s+1],f=e[a],m=e[a+1],_=e[l],g=e[l+1],w=u[o],y=n*u[o+1],b=p*w-h*y,x=p*y+h*w,v=u[2*o],$=n*u[2*o+1],k=f*v-m*$,E=f*$+m*v,S=u[3*o],z=n*u[3*o+1],C=_*S-g*z,T=_*z+g*S,I=d+k,A=c+E,M=d-k,O=c-E,B=b+C,N=x+T,P=n*(b-C),R=n*(x-T);e[r]=I+B,e[r+1]=A+N,e[s]=M+R,e[s+1]=O-P,e[a]=I-B,e[a+1]=A-N,e[l]=M-R,e[l+1]=O+P}}}}_singleTransform2(e,t,n,r,s){const i=e[r],a=e[r+1],o=e[r+s],l=e[r+s+1];t[n]=i+o,t[n+1]=a+l,t[n+2]=i-o,t[n+3]=a-l}_singleTransform4(e,t,n,r,s,i){const a=2*s,o=3*s,l=e[r],u=e[r+1],d=e[r+s],c=e[r+s+1],p=e[r+a],h=e[r+a+1],f=e[r+o],m=e[r+o+1],_=l+p,g=u+h,w=l-p,y=u-h,b=d+f,x=c+m,v=i*(d-f),$=i*(c-m);t[n]=_+b,t[n+1]=g+x,t[n+2]=w+$,t[n+3]=y-v,t[n+4]=_-b,t[n+5]=g-x,t[n+6]=w-$,t[n+7]=y+v}_realTransform4(e,t,n){const r=this._csize;let s,i,a=1<<this._width,o=r/a<<1;const l=this._bitrev;if(4===o)for(s=0,i=0;s<r;s+=o,++i){const n=l[i];this._singleRealTransform2(t,e,s,n>>>1,a>>>1)}else for(s=0,i=0;s<r;s+=o,++i){const r=l[i];this._singleRealTransform4(t,e,s,r>>>1,a>>>1,n)}const u=this.table;for(a>>=2;a>=2;a>>=2){o=r/a<<1;const t=o>>>1,i=t>>>1,l=i>>>1;for(s=0;s<r;s+=o)for(let r=0,o=0;r<=l;r+=2,o+=a){const a=s+r,d=a+i,c=d+i,p=c+i,h=e[a],f=e[a+1],m=e[d],_=e[d+1],g=e[c],w=e[c+1],y=e[p],b=e[p+1],x=h,v=f,$=u[o],k=n*u[o+1],E=m*$-_*k,S=m*k+_*$,z=u[2*o],C=n*u[2*o+1],T=g*z-w*C,I=g*C+w*z,A=u[3*o],M=n*u[3*o+1],O=y*A-b*M,B=y*M+b*A,N=x+T,P=v+I,R=x-T,D=v-I,F=E+O,L=S+B,U=n*(E-O),q=n*(S-B);if(e[a]=N+F,e[a+1]=P+L,e[d]=R+q,e[d+1]=D-U,0===r){e[c]=N-F,e[c+1]=P-L;continue}if(r===l)continue;const V=s+i-r,W=s+t-r;e[V]=R-n*q,e[V+1]=-D-n*U,e[W]=N-n*F,e[W+1]=n*L-P}}const d=r>>>1;for(let t=2;t<d;t+=2)e[r-t]=e[t],e[r-t+1]=-e[t+1]}_singleRealTransform2(e,t,n,r,s){const i=e[r],a=e[r+s];t[n]=i+a,t[n+1]=0,t[n+2]=i-a,t[n+3]=0}_singleRealTransform4(e,t,n,r,s,i){const a=2*s,o=3*s,l=e[r],u=e[r+s],d=e[r+a],c=e[r+o],p=l+d,h=l-d,f=u+c,m=i*(u-c);t[n]=p+f,t[n+1]=0,t[n+2]=h,t[n+3]=-m,t[n+4]=p-f,t[n+5]=0,t[n+6]=h,t[n+7]=m}}class ye{constructor(e){const t=2*(e-1),n=2*(2*e-1),r=2**Math.ceil(Math.log2(n));this.bufferSize=r,this._a=t;const s=new Float64Array(n),i=new Float64Array(r);this._chirpBuffer=new Float64Array(r),this._buffer1=new Float64Array(r),this._buffer2=new Float64Array(r),this._outBuffer1=new Float64Array(r),this._outBuffer2=new Float64Array(r);const a=-2*Math.PI/e,o=Math.cos(a),l=Math.sin(a);for(let t=0;t<n>>1;++t){const n=(t+1-e)**2/2,r=Math.sqrt(o**2+l**2)**n,a=n*Math.atan2(l,o),u=2*t;s[u]=r*Math.cos(a),s[u+1]=r*Math.sin(a),i[u]=s[u],i[u+1]=-s[u+1]}this._slicedChirpBuffer=s.subarray(t,n),this._f=new we(r>>1),this._f.transform(this._chirpBuffer,i)}_transform(e,t,n){const r=this._buffer1,s=this._buffer2,i=this._outBuffer1,a=this._outBuffer2,o=this._chirpBuffer,l=this._slicedChirpBuffer,u=this._a;if(n)for(let e=0;e<l.length;e+=2){const n=e+1,s=t[e>>1];r[e]=s*l[e],r[n]=s*l[n]}else for(let e=0;e<l.length;e+=2){const n=e+1;r[e]=t[e]*l[e]-t[n]*l[n],r[n]=t[e]*l[n]+t[n]*l[e]}this._f.transform(i,r);for(let e=0;e<o.length;e+=2){const t=e+1;s[e]=i[e]*o[e]-i[t]*o[t],s[t]=i[e]*o[t]+i[t]*o[e]}this._f.inverseTransform(a,s);for(let t=0;t<a.length;t+=2){const n=a[t+u],r=a[t+u+1],s=l[t],i=l[t+1];e[t]=n*s-r*i,e[t+1]=n*i+r*s}}transform(e,t){this._transform(e,t,!1)}realTransform(e,t){this._transform(e,t,!0)}}class be{constructor(e){this.fft_length=e,this.isPowerOfTwo=ge(e),this.isPowerOfTwo?(this.fft=new we(e),this.outputBufferSize=2*e):(this.fft=new ye(e),this.outputBufferSize=this.fft.bufferSize)}realTransform(e,t){this.fft.realTransform(e,t)}transform(e,t){this.fft.transform(e,t)}}function xe(e,t){if(t%2==0||t<=0)throw new Error("Window size must be a positive odd number");const n=new e.constructor(e.length),r=new e.constructor(t),s=Math.floor(t/2);for(let t=0;t<e.length;++t){let i=0;for(let n=-s;n<=s;++n){let s=t+n;s<0?s=Math.abs(s):s>=e.length&&(s=2*(e.length-1)-s),r[i++]=e[s]}r.sort(),n[t]=r[s]}return n}function ve(e,t){const n=Math.pow(10,t);return Math.round(e*n)/n}function $e(e){const t=e.length,n=e[0].length,r=[t+1,n+1],s=Array.from({length:r[0]},(()=>Array(r[1]).fill(Infinity)));s[0][0]=0;const i=Array.from({length:r[0]},(()=>Array(r[1]).fill(-1)));for(let t=1;t<r[1];++t)for(let n=1;n<r[0];++n){const r=s[n-1][t-1],a=s[n-1][t],o=s[n][t-1];let l,u;r<a&&r<o?(l=r,u=0):a<r&&a<o?(l=a,u=1):(l=o,u=2),s[n][t]=e[n-1][t-1]+l,i[n][t]=u}for(let e=0;e<r[1];++e)i[0][e]=2;for(let e=0;e<r[0];++e)i[e][0]=1;let a=t,o=n,l=[],u=[];for(;a>0||o>0;)switch(l.push(a-1),u.push(o-1),i[a][o]){case 0:--a,--o;break;case 1:--a;break;case 2:--o;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${a}, ${o}]. Please file a bug report.`)}return l.reverse(),u.reverse(),[l,u]}var ke,Ee,Se,ze,Ce,Te,Ie,Ae,Me,Oe,Be,Ne,Pe,Re,De,Fe,Le,Ue,qe,Ve,We,je,Ge,He,Ke,Xe,Qe,Ye,Ze,Je,et,tt,nt=s(193),rt=s.t(nt,2),st=Object.defineProperty,it=Object.getOwnPropertyDescriptor,at=Object.getOwnPropertyNames,ot=Object.prototype.hasOwnProperty,lt=(ke=function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error(\'Dynamic require of "\'+e+\'" is not supported\')},typeof require<"u"?require:typeof Proxy<"u"?new Proxy(ke,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):ke),ut=(e,t)=>()=>(e&&(t=e(e=0)),t),dt=(e,t)=>{for(var n in t)st(e,n,{get:t[n],enumerable:!0})},ct=e=>((e,t,n,r)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let s of at(t))!ot.call(e,s)&&s!==n&&st(e,s,{get:()=>t[s],enumerable:!(r=it(t,s))||r.enumerable});return e})(st({},"__esModule",{value:!0}),e),pt=ut((()=>{Ee=new Map,Se=[],ze=(e,t,n)=>{if(!t||"function"!=typeof t.init||"function"!=typeof t.createInferenceSessionHandler)throw new TypeError("not a valid backend");{let r=Ee.get(e);if(void 0===r)Ee.set(e,{backend:t,priority:n});else{if(r.priority>n)return;if(r.priority===n&&r.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){let t=Se.indexOf(e);-1!==t&&Se.splice(t,1);for(let t=0;t<Se.length;t++)if(Ee.get(Se[t]).priority<=n)return void Se.splice(t,0,e);Se.push(e)}}},Ce=async e=>{let t=Ee.get(e);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let n=!!t.initPromise;try{return n||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(e){return n||(t.error=`${e}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},Te=async e=>{let t,n=e.executionProviders||[],r=n.map((e=>"string"==typeof e?e:e.name)),s=0===r.length?Se:r,i=[],a=new Set;for(let e of s){let n=await Ce(e);"string"==typeof n?i.push({name:e,err:n}):(t||(t=n),t===n&&a.add(e))}if(!t)throw new Error(`no available backend found. ERR: ${i.map((e=>`[${e.name}] ${e.err}`)).join(", ")}`);for(let{name:e,err:t}of i)r.includes(e)&&console.warn(`removing requested execution provider "${e}" from session options because it is not available: ${t}`);let o=n.filter((e=>a.has("string"==typeof e?e:e.name)));return[t,new Proxy(e,{get:(e,t)=>"executionProviders"===t?o:Reflect.get(e,t)})]}})),ht=ut((()=>{pt()})),ft=ut((()=>{Ie="1.21.0-dev.20241205-6ed77cc374"})),mt=ut((()=>{ft(),Ae="warning",Me={wasm:{},webgl:{},webgpu:{},versions:{common:Ie},set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);Ae=e}},get logLevel(){return Ae}},Object.defineProperty(Me,"logLevel",{enumerable:!0})})),_t=ut((()=>{mt(),Oe=Me})),gt=ut((()=>{Be=(e,t)=>{let n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];let r=n.getContext("2d");if(null!=r){let s,i;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(s=e.dims[2],i=e.dims[3]):(s=e.dims[3],i=e.dims[2]);let a,o,l=void 0!==t?.format?t.format:"RGB",u=t?.norm;void 0===u||void 0===u.mean?a=[255,255,255,255]:"number"==typeof u.mean?a=[u.mean,u.mean,u.mean,u.mean]:(a=[u.mean[0],u.mean[1],u.mean[2],0],void 0!==u.mean[3]&&(a[3]=u.mean[3])),void 0===u||void 0===u.bias?o=[0,0,0,0]:"number"==typeof u.bias?o=[u.bias,u.bias,u.bias,u.bias]:(o=[u.bias[0],u.bias[1],u.bias[2],0],void 0!==u.bias[3]&&(o[3]=u.bias[3]));let d=i*s,c=0,p=d,h=2*d,f=-1;"RGBA"===l?(c=0,p=d,h=2*d,f=3*d):"RGB"===l?(c=0,p=d,h=2*d):"RBG"===l&&(c=0,h=d,p=2*d);for(let t=0;t<i;t++)for(let n=0;n<s;n++){let s=(e.data[c++]-o[0])*a[0],i=(e.data[p++]-o[1])*a[1],l=(e.data[h++]-o[2])*a[2],u=-1===f?255:(e.data[f++]-o[3])*a[3];r.fillStyle="rgba("+s+","+i+","+l+","+u+")",r.fillRect(n,t,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}throw new Error("Can not access image data")},Ne=(e,t)=>{let n,r=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");if(null==r)throw new Error("Can not access image data");{let s,i,a;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(s=e.dims[2],i=e.dims[1],a=e.dims[3]):(s=e.dims[3],i=e.dims[2],a=e.dims[1]);let o,l,u=void 0!==t&&void 0!==t.format?t.format:"RGB",d=t?.norm;void 0===d||void 0===d.mean?o=[255,255,255,255]:"number"==typeof d.mean?o=[d.mean,d.mean,d.mean,d.mean]:(o=[d.mean[0],d.mean[1],d.mean[2],255],void 0!==d.mean[3]&&(o[3]=d.mean[3])),void 0===d||void 0===d.bias?l=[0,0,0,0]:"number"==typeof d.bias?l=[d.bias,d.bias,d.bias,d.bias]:(l=[d.bias[0],d.bias[1],d.bias[2],0],void 0!==d.bias[3]&&(l[3]=d.bias[3]));let c=i*s;if(void 0!==t&&(void 0!==t.format&&4===a&&"RGBA"!==t.format||3===a&&"RGB"!==t.format&&"BGR"!==t.format))throw new Error("Tensor format doesn\'t match input tensor dims");let p=4,h=0,f=1,m=2,_=3,g=0,w=c,y=2*c,b=-1;"RGBA"===u?(g=0,w=c,y=2*c,b=3*c):"RGB"===u?(g=0,w=c,y=2*c):"RBG"===u&&(g=0,y=c,w=2*c),n=r.createImageData(s,i);for(let t=0;t<i*s;h+=p,f+=p,m+=p,_+=p,t++)n.data[h]=(e.data[g++]-l[0])*o[0],n.data[f]=(e.data[w++]-l[1])*o[1],n.data[m]=(e.data[y++]-l[2])*o[2],n.data[_]=-1===b?255:(e.data[b++]-l[3])*o[3]}return n}})),wt=ut((()=>{xt(),Pe=(e,t)=>{if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");let n,r,{height:s,width:i}=t,a=t.norm??{mean:255,bias:0};n="number"==typeof a.mean?[a.mean,a.mean,a.mean,a.mean]:[a.mean[0],a.mean[1],a.mean[2],a.mean[3]??255],r="number"==typeof a.bias?[a.bias,a.bias,a.bias,a.bias]:[a.bias[0],a.bias[1],a.bias[2],a.bias[3]??0];let o=void 0!==t.format?t.format:"RGBA",l=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",u=s*i,d="RGBA"===l?new Float32Array(4*u):new Float32Array(3*u),c=4,p=0,h=1,f=2,m=3,_=0,g=u,w=2*u,y=-1;"RGB"===o&&(c=3,p=0,h=1,f=2,m=-1),"RGBA"===l?y=3*u:"RBG"===l?(_=0,w=u,g=2*u):"BGR"===l&&(w=0,g=u,_=2*u);for(let t=0;t<u;t++,p+=c,f+=c,h+=c,m+=c)d[_++]=(e[p]+r[0])/n[0],d[g++]=(e[h]+r[1])/n[1],d[w++]=(e[f]+r[2])/n[2],-1!==y&&-1!==m&&(d[y++]=(e[m]+r[3])/n[3]);return new Ke("float32",d,"RGBA"===l?[1,4,s,i]:[1,3,s,i])},Re=async(e,t)=>{let n,r=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,s=typeof ImageData<"u"&&e instanceof ImageData,i=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,a="string"==typeof e,o=t??{},l=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},u=e=>typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas?e.getContext("2d"):null;if(r){let r=l();r.width=e.width,r.height=e.height;let s=u(r);if(null==s)throw new Error("Can not access image data");{let r=e.height,i=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(r=t.resizedHeight,i=t.resizedWidth),void 0!==t){if(o=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");o.tensorFormat="RGBA",o.height=r,o.width=i}else o.tensorFormat="RGBA",o.height=r,o.width=i;s.drawImage(e,0,0),n=s.getImageData(0,0,i,r).data}}else{if(!s){if(i){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");let r=l();r.width=e.width,r.height=e.height;let s=u(r);if(null!=s){let t=e.height,r=e.width;return s.drawImage(e,0,0,r,t),n=s.getImageData(0,0,r,t).data,o.height=t,o.width=r,Pe(n,o)}throw new Error("Can not access image data")}if(a)return new Promise(((t,n)=>{let r=l(),s=u(r);if(!e||!s)return n();let i=new Image;i.crossOrigin="Anonymous",i.src=e,i.onload=()=>{r.width=i.width,r.height=i.height,s.drawImage(i,0,0,r.width,r.height);let e=s.getImageData(0,0,r.width,r.height);o.height=r.height,o.width=r.width,t(Pe(e.data,o))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{let r,s;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(r=t.resizedHeight,s=t.resizedWidth):(r=e.height,s=e.width),void 0!==t&&(o=t),o.format="RGBA",o.height=r,o.width=s,void 0!==t){let t=l();t.width=s,t.height=r;let i=u(t);if(null==i)throw new Error("Can not access image data");i.putImageData(e,0,0),n=i.getImageData(0,0,s,r).data}else n=e.data}}if(void 0!==n)return Pe(n,o);throw new Error("Input data provided is not supported - aborted tensor creation")},De=(e,t)=>{let{width:n,height:r,download:s,dispose:i}=t;return new Ke({location:"texture",type:"float32",texture:e,dims:[1,r,n,4],download:s,dispose:i})},Fe=(e,t)=>{let{dataType:n,dims:r,download:s,dispose:i}=t;return new Ke({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:r,download:s,dispose:i})},Le=(e,t)=>{let{dataType:n,dims:r,download:s,dispose:i}=t;return new Ke({location:"ml-tensor",type:n??"float32",mlTensor:e,dims:r,download:s,dispose:i})},Ue=(e,t,n)=>new Ke({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]})})),yt=ut((()=>{qe=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Ve=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),We=!1,je=()=>{if(!We){We=!0;let e=typeof BigInt64Array<"u"&&BigInt64Array.from,t=typeof BigUint64Array<"u"&&BigUint64Array.from,n=typeof Float16Array<"u"&&Float16Array.from;e&&(qe.set("int64",BigInt64Array),Ve.set(BigInt64Array,"int64")),t&&(qe.set("uint64",BigUint64Array),Ve.set(BigUint64Array,"uint64")),n?(qe.set("float16",Float16Array),Ve.set(Float16Array,"float16")):qe.set("float16",Uint16Array)}}})),bt=ut((()=>{xt(),Ge=e=>{let t=1;for(let n=0;n<e.length;n++){let r=e[n];if("number"!=typeof r||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t},He=(e,t)=>{switch(e.location){case"cpu":return new Ke(e.type,e.data,t);case"cpu-pinned":return new Ke({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new Ke({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new Ke({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new Ke({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}})),xt=ut((()=>{gt(),wt(),yt(),bt(),Ke=class{constructor(e,t,n){let r,s;if(je(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,r=e.type,s=e.dims,e.location){case"cpu-pinned":{let t=qe.get(r);if(!t)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw new TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"uint8"!==r&&"bool"!==r&&"uint4"!==r&&"int4"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;case"ml-tensor":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"uint64"!==r&&"int8"!==r&&"uint8"!==r&&"bool"!==r&&"uint4"!==r&&"int4"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break;default:throw new Error(`Tensor constructor: unsupported location \'${this.dataLocation}\'`)}else{let i,a;if("string"==typeof e)if(r=e,a=n,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor\'s data must be a string array.");i=t}else{let n=qe.get(e);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e&&n===Uint16Array||"uint4"===e||"int4"===e)throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${n.name} as data.`);i="uint64"===e||"int64"===e?n.from(t,BigInt):n.from(t)}else if(t instanceof n)i=t;else{if(!(t instanceof Uint8ClampedArray))throw new TypeError(`A ${r} tensor\'s data must be type of ${n}`);if("uint8"!==e)throw new TypeError("A Uint8ClampedArray tensor\'s data must be type of uint8");i=Uint8Array.from(t)}}else if(a=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");let t=typeof e[0];if("string"===t)r="string",i=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);r="bool",i=Uint8Array.from(e)}}else if(e instanceof Uint8ClampedArray)r="uint8",i=Uint8Array.from(e);else{let t=Ve.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=t,i=e}if(void 0===a)a=[i.length];else if(!Array.isArray(a))throw new TypeError("A tensor\'s dims must be a number array");s=a,this.cpuData=i,this.dataLocation="cpu"}let i=Ge(s);if(this.cpuData&&i!==this.cpuData.length&&("uint4"!==r&&"int4"!==r||Math.ceil(i/2)!==this.cpuData.length))throw new Error(`Tensor\'s size(${i}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=s,this.size=i}static async fromImage(e,t){return Re(e,t)}static fromTexture(e,t){return De(e,t)}static fromGpuBuffer(e,t){return Fe(e,t)}static fromMLTensor(e,t){return Le(e,t)}static fromPinnedBuffer(e,t,n){return Ue(e,t,n)}toDataURL(e){return Be(this,e)}toImageData(e){return Ne(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return He(this,e)}}})),vt=ut((()=>{xt(),Xe=Ke})),$t=ut((()=>{mt(),Qe=(e,t)=>{(typeof Me.trace>"u"?!Me.wasm.trace:!Me.trace)||console.timeStamp(`${e}::ORT::${t}`)},Ye=(e,t)=>{let n=(new Error).stack?.split(/\\r\\n|\\r|\\n/g)||[],r=!1;for(let s=0;s<n.length;s++){if(r&&!n[s].includes("TRACE_FUNC")){let r=`FUNC_${e}::${n[s].trim().split(" ")[1]}`;return t&&(r+=`::${t}`),void Qe("CPU",r)}n[s].includes("TRACE_FUNC")&&(r=!0)}},Ze=e=>{(typeof Me.trace>"u"?!Me.wasm.trace:!Me.trace)||Ye("BEGIN",e)},Je=e=>{(typeof Me.trace>"u"?!Me.wasm.trace:!Me.trace)||Ye("END",e)}})),kt=ut((()=>{pt(),vt(),$t(),et=class e{constructor(e){this.handler=e}async run(e,t,n){Ze();let r={},s={};if("object"!=typeof e||null===e||e instanceof Xe||Array.isArray(e))throw new TypeError("\'feeds\' must be an object that use input names as keys and OnnxValue as corresponding values.");let i=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof Xe)throw new TypeError("\'fetches\' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("\'fetches\' cannot be an empty array.");i=!1;for(let e of t){if("string"!=typeof e)throw new TypeError("\'fetches\' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`\'fetches\' contains invalid output name: ${e}.`);r[e]=null}if("object"==typeof n&&null!==n)s=n;else if(typeof n<"u")throw new TypeError("\'options\' must be an object.")}else{let e=!1,a=Object.getOwnPropertyNames(t);for(let n of this.outputNames)if(-1!==a.indexOf(n)){let s=t[n];(null===s||s instanceof Xe)&&(e=!0,i=!1,r[n]=s)}if(e){if("object"==typeof n&&null!==n)s=n;else if(typeof n<"u")throw new TypeError("\'options\' must be an object.")}else s=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be \'fetches\' or \'options\'.");for(let t of this.inputNames)if(typeof e[t]>"u")throw new Error(`input \'${t}\' is missing in \'feeds\'.`);if(i)for(let e of this.outputNames)r[e]=null;let a=await this.handler.run(e,r,s),o={};for(let e in a)if(Object.hasOwnProperty.call(a,e)){let t=a[e];o[e]=t instanceof Xe?t:new Xe(t.type,t.data,t.dims)}return Je(),o}async release(){return this.handler.dispose()}static async create(t,n,r,s){Ze();let i,a={};if("string"==typeof t){if(i=t,"object"==typeof n&&null!==n)a=n;else if(typeof n<"u")throw new TypeError("\'options\' must be an object.")}else if(t instanceof Uint8Array){if(i=t,"object"==typeof n&&null!==n)a=n;else if(typeof n<"u")throw new TypeError("\'options\' must be an object.")}else{if(!(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be \'path\' or \'buffer\'.");{let e=t,o=0,l=t.byteLength;if("object"==typeof n&&null!==n)a=n;else if("number"==typeof n){if(o=n,!Number.isSafeInteger(o))throw new RangeError("\'byteOffset\' must be an integer.");if(o<0||o>=e.byteLength)throw new RangeError(`\'byteOffset\' is out of range [0, ${e.byteLength}).`);if(l=t.byteLength-o,"number"==typeof r){if(l=r,!Number.isSafeInteger(l))throw new RangeError("\'byteLength\' must be an integer.");if(l<=0||o+l>e.byteLength)throw new RangeError(`\'byteLength\' is out of range (0, ${e.byteLength-o}].`);if("object"==typeof s&&null!==s)a=s;else if(typeof s<"u")throw new TypeError("\'options\' must be an object.")}else if(typeof r<"u")throw new TypeError("\'byteLength\' must be a number.")}else if(typeof n<"u")throw new TypeError("\'options\' must be an object.");i=new Uint8Array(e,o,l)}}let[o,l]=await Te(a),u=await o.createInferenceSessionHandler(i,l);return Je(),new e(u)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}})),Et=ut((()=>{kt(),tt=et})),St=ut((()=>{})),zt=ut((()=>{})),Ct=ut((()=>{})),Tt=ut((()=>{})),It={};dt(It,{InferenceSession:()=>tt,TRACE:()=>Qe,TRACE_FUNC_BEGIN:()=>Ze,TRACE_FUNC_END:()=>Je,Tensor:()=>Xe,env:()=>Oe,registerBackend:()=>ze});var At=ut((()=>{ht(),_t(),Et(),vt(),St(),zt(),$t(),Ct(),Tt()})),Mt=ut((()=>{})),Ot={};dt(Ot,{default:()=>Pt});var Bt,Nt,Pt,Rt=ut((()=>{wp(),wd(),gd(),Bt="ort-wasm-proxy-worker",(Nt=globalThis.self?.name===Bt)&&(self.onmessage=e=>{let{type:t,in:n}=e.data;try{switch(t){case"init-wasm":nn(n.wasm).then((()=>{Fc(n).then((()=>{postMessage({type:t})}),(e=>{postMessage({type:t,err:e})}))}),(e=>{postMessage({type:t,err:e})}));break;case"init-ep":{let{epName:e,env:r}=n;Lc(r,e).then((()=>{postMessage({type:t})}),(e=>{postMessage({type:t,err:e})}));break}case"copy-from":{let{buffer:e}=n,r=Vc(e);postMessage({type:t,out:r});break}case"create":{let{model:e,options:r}=n;Wc(e,r).then((e=>{postMessage({type:t,out:e})}),(e=>{postMessage({type:t,err:e})}));break}case"release":jc(n),postMessage({type:t});break;case"run":{let{sessionId:e,inputIndices:r,inputs:s,outputIndices:i,options:a}=n;Hc(e,r,s,i,new Array(i.length).fill(null),a).then((e=>{e.some((e=>"cpu"!==e[3]))?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:e},Xc([...s,...e]))}),(e=>{postMessage({type:t,err:e})}));break}case"end-profiling":Kc(n),postMessage({type:t})}}catch(e){postMessage({type:t,err:e})}}),Pt=Nt?null:e=>new Worker(e??qt,{type:"module",name:Bt})})),Dt={};dt(Dt,{default:()=>Ut});var Ft,Lt,Ut,qt,Vt,Wt,jt,Gt,Ht,Kt,Xt,Qt,Yt,Zt,Jt,en,tn,nn,rn,sn,an,on,ln,un,dn,cn,pn,hn,fn,mn,_n,gn,wn,yn,bn,xn,vn,$n,kn,En,Sn,zn,Cn,Tn,In,An,Mn,On,Bn,Nn,Pn,Rn,Dn,Fn,Ln,Un,qn,Vn,Wn,jn,Gn,Hn,Kn,Xn,Qn,Yn,Zn,Jn,er,tr,nr,rr,sr,ir,ar,or,lr,ur,dr,cr,pr,hr,fr,mr,_r,gr,wr,yr,br,xr,vr,$r,kr,Er,Sr,zr,Cr,Tr,Ir,Ar,Mr,Or,Br,Nr,Pr,Rr,Dr,Fr,Lr,Ur,qr,Vr,Wr,jr,Gr,Hr,Kr,Xr,Qr,Yr,Zr,Jr,es,ts,ns,rs,ss,is,as,os,ls,us,ds,cs,ps,hs,fs,ms,_s,gs,ws,ys,bs,xs,vs,$s,ks,Es,Ss,zs,Cs,Ts,Is,As,Ms,Os,Bs,Ns,Ps,Rs,Ds,Fs,Ls,Us,qs,Vs,Ws,js,Gs,Hs,Ks,Xs,Qs,Ys,Zs,Js,ei,ti,ni,ri,si,ii,ai,oi,li,ui,di,ci,pi,hi,fi,mi,_i,gi,wi,yi,bi,xi,vi,$i,ki,Ei,Si,zi,Ci,Ti,Ii,Ai,Mi,Oi,Bi,Ni,Pi,Ri,Di,Fi,Li,Ui,qi,Vi,Wi,ji,Gi,Hi,Ki,Xi,Qi,Yi,Zi,Ji,ea,ta,na,ra,sa,ia,aa,oa,la,ua,da,ca,pa,ha,fa,ma,_a,ga,wa,ya,ba,xa,va,$a,ka,Ea,Sa,za,Ca,Ta,Ia,Aa,Ma,Oa,Ba,Na,Pa,Ra,Da,Fa,La,Ua,qa,Va,Wa,ja,Ga,Ha,Ka,Xa,Qa,Ya,Za,Ja,eo,to,no,ro,so,io,ao,oo,lo,uo,co,po,ho,fo,mo,_o,go,wo,yo,bo,xo,vo,$o,ko,Eo,So,zo,Co,To,Io,Ao,Mo,Oo,Bo,No,Po,Ro,Do,Fo,Lo,Uo,qo,Vo,Wo,jo,Go,Ho,Ko,Xo,Qo,Yo,Zo,Jo,el,tl,nl,rl,sl,il,al,ol,ll,ul,dl,cl,pl,hl,fl,ml,_l,gl,wl,yl,bl,xl,vl,$l,kl,El,Sl,zl,Cl,Tl,Il,Al,Ml,Ol,Bl,Nl,Pl,Rl,Dl,Fl,Ll,Ul,ql,Vl,Wl,jl,Gl,Hl,Kl,Xl,Ql,Yl,Zl,Jl,eu,tu,nu,ru,su,iu,au,ou,lu,uu,du,cu,pu,hu,fu,mu,_u,gu,wu,yu,bu,xu,vu,$u,ku,Eu,Su,zu,Cu,Tu,Iu,Au,Mu,Ou,Bu,Nu,Pu,Ru,Du,Fu,Lu,Uu,qu,Vu,Wu,ju,Gu,Hu,Ku,Xu,Qu,Yu,Zu,Ju,ed,td,nd,rd,sd,id,ad,od,ld,ud,dd,cd,pd,hd,fd,md,_d=ut((()=>{Ft="file:///Users/sam-schaack/gamp/nuiq-asr/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs",Lt=async function(e={}){function t(){return A.buffer!=B.buffer&&j(),B}function n(){return A.buffer!=B.buffer&&j(),N}function r(){return A.buffer!=B.buffer&&j(),P}function i(){return A.buffer!=B.buffer&&j(),R}function a(){return A.buffer!=B.buffer&&j(),D}function o(){return A.buffer!=B.buffer&&j(),F}function l(){return A.buffer!=B.buffer&&j(),L}function u(){return A.buffer!=B.buffer&&j(),V}var d,c,p=Object.assign({},e),h=new Promise(((e,t)=>{d=e,c=t})),f="object"==typeof window,m="function"==typeof importScripts,_=m&&"em-pthread"==self.name;p.mountExternalData=(e,t)=>{e.startsWith("./")&&(e=e.substring(2)),(p.Fb||(p.Fb=new Map)).set(e,t)},p.unmountExternalData=()=>{delete p.Fb};var g=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor;let w=()=>{let e=(e,t,n)=>(...r)=>{let s=Kt,i=t?.();r=e(...r);let a=t?.();return i!==a&&(e=a,n(i),t=n=null),Kt!=s?new Promise(((e,t)=>{en={resolve:e,reject:t}})):r},t=e=>async(...t)=>{try{if(p.Gb)throw Error("Session already started");let n=p.Gb={hc:t[0],errors:[]},r=await e(...t);if(p.Gb!==n)throw Error("Session mismatch");p.Hb?.flush();let s=n.errors;if(0<s.length){let e=await Promise.all(s);if(e=e.filter((e=>e)),0<e.length)throw Error(e.join("\\n"))}return r}finally{p.Gb=null}};p._OrtCreateSession=e(p._OrtCreateSession,(()=>p._OrtCreateSession),(e=>p._OrtCreateSession=e)),p._OrtRun=t(e(p._OrtRun,(()=>p._OrtRun),(e=>p._OrtRun=e))),p._OrtRunWithBinding=t(e(p._OrtRunWithBinding,(()=>p._OrtRunWithBinding),(e=>p._OrtRunWithBinding=e))),p._OrtBindInput=e(p._OrtBindInput,(()=>p._OrtBindInput),(e=>p._OrtBindInput=e)),w=void 0};p.jsepInit=(e,t)=>{if(w?.(),"webgpu"===e){[p.Hb,p.Vb,p.Zb,p.Ob,p.Yb,p.kb,p.$b,p.cc,p.Wb,p.Xb,p.ac]=t;let e=p.Hb;p.jsepRegisterBuffer=(t,n,r,s)=>e.registerBuffer(t,n,r,s),p.jsepGetBuffer=t=>e.getBuffer(t),p.jsepCreateDownloader=(t,n,r)=>e.createDownloader(t,n,r),p.jsepOnCreateSession=t=>{e.onCreateSession(t)},p.jsepOnReleaseSession=t=>{e.onReleaseSession(t)},p.jsepOnRunStart=t=>e.onRunStart(t),p.dc=(t,n)=>{e.upload(t,n)}}else if("webnn"===e){[p.Hb,p.bc,p.Pb,p.jsepEnsureTensor,p.ec,p.jsepDownloadTensor]=t,p.jsepReleaseTensorId=p.Pb;let e=p.Hb;p.jsepOnRunStart=t=>e.onRunStart(t),p.jsepRegisterMLContext=(t,n)=>{e.registerMLContext(t,n)},p.jsepOnReleaseSession=t=>{e.onReleaseSession(t)},p.jsepCreateMLTensorDownloader=(t,n)=>e.createMLTensorDownloader(t,n),p.jsepRegisterMLTensor=(t,n,r)=>e.registerMLTensor(t,n,r),p.jsepCreateMLContext=t=>e.createMLContext(t),p.jsepRegisterMLConstant=(t,n,r,s,i)=>e.registerMLConstant(t,n,r,s,i,p.Fb)}};var y,b,x=Object.assign({},p),v=(e,t)=>{throw t},$="";(f||m)&&(m?$=self.location.href:typeof document<"u"&&document.currentScript&&($=document.currentScript.src),Ft&&($=Ft),$=$.startsWith("blob:")?"":$.substr(0,$.replace(/[?#].*/,"").lastIndexOf("/")+1),m&&(b=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),y=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var k,E=console.log.bind(console),S=console.error.bind(console),z=E,C=S;if(Object.assign(p,x),x=null,_){let e=function(t){try{var n=t.data,r=n.cmd;if("load"===r){let t=[];self.onmessage=e=>t.push(e),self.startWorker=()=>{postMessage({cmd:"loaded"});for(let n of t)e(n);self.onmessage=e};for(let e of n.handlers)p[e]&&!p[e].proxy||(p[e]=(...t)=>{postMessage({Nb:"callHandler",pc:e,args:t})},"print"==e&&(z=p[e]),"printErr"==e&&(C=p[e]));A=n.wasmMemory,j(),T(n.wasmModule)}else if("run"===r){kr(n.pthread_ptr,0,0,1,0,0),Bt(n.pthread_ptr),Se(),ve(),I||(yr(),I=!0);try{ze(n.start_routine,n.arg)}catch(e){if("unwind"!=e)throw e}}else"cancel"===r?xr()&&Cr(-1):"setimmediate"!==n.target&&("checkMailbox"===r?I&&Nt():r&&(C(`worker: received unknown command ${r}`),C(n)))}catch(e){throw Er(),e}};var T,I=!1;C=function(...e){e=e.join(" "),console.error(e)},self.alert=function(...e){postMessage({Nb:"alert",text:e.join(" "),rc:xr()})},p.instantiateWasm=(e,t)=>new Promise((e=>{T=n=>{n=new WebAssembly.Instance(n,ie()),t(n),e()}})),self.onunhandledrejection=e=>{throw e.reason||e},self.onmessage=e}p.wasmBinary&&(k=p.wasmBinary);var A,M,O,B,N,P,R,D,F,L,U,q,V,W=!1;function j(){var e=A.buffer;p.HEAP8=B=new Int8Array(e),p.HEAP16=P=new Int16Array(e),p.HEAPU8=N=new Uint8Array(e),p.HEAPU16=R=new Uint16Array(e),p.HEAP32=D=new Int32Array(e),p.HEAPU32=F=new Uint32Array(e),p.HEAPF32=L=new Float32Array(e),p.HEAPF64=V=new Float64Array(e),p.HEAP64=U=new BigInt64Array(e),p.HEAPU64=q=new BigUint64Array(e)}if(!_){if(!((A=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0})).buffer instanceof g))throw C("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),Error("bad memory");j()}var G=[],H=[],K=[],X=0,Q=null,Y=null;function Z(){if(0==--X&&(null!==Q&&(clearInterval(Q),Q=null),Y)){var e=Y;Y=null,e()}}function J(e){throw C(e="Aborted("+e+")"),W=!0,O=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),c(e),e}var ee,te=e=>e.startsWith("data:application/octet-stream;base64,"),ne=e=>e.startsWith("file://");function re(e){if(e==ee&&k)return new Uint8Array(k);if(b)return b(e);throw"both async and sync fetching of the wasm failed"}function se(e,t,n){return function(e){if(!k&&(f||m)){if("function"==typeof fetch&&!ne(e))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw`failed to load wasm binary file at \'${e}\'`;return t.arrayBuffer()})).catch((()=>re(e)));if(y)return new Promise(((t,n)=>{y(e,(e=>t(new Uint8Array(e))),n)}))}return Promise.resolve().then((()=>re(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then(n,(e=>{C(`failed to asynchronously prepare wasm: ${e}`),J(e)}))}function ie(){return{a:{O:le,Aa:oe,b:Te,aa:Ae,B:Ne,qa:Pe,Y:Le,_:Ue,ra:qe,oa:Ve,ha:We,na:je,L:Ge,Z:He,W:Ke,pa:Xe,X:Qe,va:Je,F:at,Q:lt,P:_t,E:wt,u:yt,q:bt,G:xt,A:Tt,R:It,ua:At,ka:Mt,U:Pt,ba:Dt,H:Lt,ja:Bt,ta:Ut,t:Wt,Ba:jt,x:rn,n:an,l:un,c:ct,o:cn,j:mn,w:_n,p:gn,f:wn,s:yn,m:bn,e:xn,k:vn,i:$n,h:kn,d:En,ea:Sn,fa:In,ga:An,ca:Mn,da:On,T:Bn,g:Rn,D:Dn,I:Fn,M:Ln,y:Un,sa:Vn,V:Wn,v:qn,z:jn,N:Gn,S:Hn,za:Yn,ya:Zn,la:nr,ma:rr,$:_e,C:sr,K:ir,ia:ar,J:lr,a:A,xa:fe,wa:pr,r:hr}}}var ae={874308:(e,t,r,s,i)=>{if(void 0===p||!p.Fb)return 1;if((e=Be(Number(e>>>0))).startsWith("./")&&(e=e.substring(2)),!(e=p.Fb.get(e)))return 2;if(t=Number(t>>>0),r=Number(r>>>0),s=Number(s>>>0),t+r>e.byteLength)return 3;try{let a=e.subarray(t,t+r);switch(i){case 0:n().set(a,s>>>0);break;case 1:p.dc(s,a);break;default:return 4}return 0}catch{return 4}},875023:(e,t,r)=>{p.ec(e,n().subarray(t>>>0,t+r>>>0))},875086:()=>p.bc(),875127:e=>{p.Pb(e)},875163:()=>{p.Wb()},875194:()=>{p.Xb()},875223:()=>{p.ac()},875248:e=>p.Vb(e),875281:e=>p.Zb(e),875313:(e,t,n)=>{p.Ob(Number(e),Number(t),Number(n),!0)},875376:(e,t,n)=>{p.Ob(Number(e),Number(t),Number(n))},875433:()=>typeof wasmOffsetConverter<"u",875490:e=>{p.kb("Abs",e,void 0)},875541:e=>{p.kb("Neg",e,void 0)},875592:e=>{p.kb("Floor",e,void 0)},875645:e=>{p.kb("Ceil",e,void 0)},875697:e=>{p.kb("Reciprocal",e,void 0)},875755:e=>{p.kb("Sqrt",e,void 0)},875807:e=>{p.kb("Exp",e,void 0)},875858:e=>{p.kb("Erf",e,void 0)},875909:e=>{p.kb("Sigmoid",e,void 0)},875964:(e,t,n)=>{p.kb("HardSigmoid",e,{alpha:t,beta:n})},876043:e=>{p.kb("Log",e,void 0)},876094:e=>{p.kb("Sin",e,void 0)},876145:e=>{p.kb("Cos",e,void 0)},876196:e=>{p.kb("Tan",e,void 0)},876247:e=>{p.kb("Asin",e,void 0)},876299:e=>{p.kb("Acos",e,void 0)},876351:e=>{p.kb("Atan",e,void 0)},876403:e=>{p.kb("Sinh",e,void 0)},876455:e=>{p.kb("Cosh",e,void 0)},876507:e=>{p.kb("Asinh",e,void 0)},876560:e=>{p.kb("Acosh",e,void 0)},876613:e=>{p.kb("Atanh",e,void 0)},876666:e=>{p.kb("Tanh",e,void 0)},876718:e=>{p.kb("Not",e,void 0)},876769:(e,t,n)=>{p.kb("Clip",e,{min:t,max:n})},876838:e=>{p.kb("Clip",e,void 0)},876890:(e,t)=>{p.kb("Elu",e,{alpha:t})},876948:e=>{p.kb("Gelu",e,void 0)},877e3:e=>{p.kb("Relu",e,void 0)},877052:(e,t)=>{p.kb("LeakyRelu",e,{alpha:t})},877116:(e,t)=>{p.kb("ThresholdedRelu",e,{alpha:t})},877186:(e,t)=>{p.kb("Cast",e,{to:t})},877244:e=>{p.kb("Add",e,void 0)},877295:e=>{p.kb("Sub",e,void 0)},877346:e=>{p.kb("Mul",e,void 0)},877397:e=>{p.kb("Div",e,void 0)},877448:e=>{p.kb("Pow",e,void 0)},877499:e=>{p.kb("Equal",e,void 0)},877552:e=>{p.kb("Greater",e,void 0)},877607:e=>{p.kb("GreaterOrEqual",e,void 0)},877669:e=>{p.kb("Less",e,void 0)},877721:e=>{p.kb("LessOrEqual",e,void 0)},877780:(e,t,n,r,s)=>{p.kb("ReduceMean",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},877955:(e,t,n,r,s)=>{p.kb("ReduceMax",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},878129:(e,t,n,r,s)=>{p.kb("ReduceMin",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},878303:(e,t,n,r,s)=>{p.kb("ReduceProd",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},878478:(e,t,n,r,s)=>{p.kb("ReduceSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},878652:(e,t,n,r,s)=>{p.kb("ReduceL1",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},878825:(e,t,n,r,s)=>{p.kb("ReduceL2",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},878998:(e,t,n,r,s)=>{p.kb("ReduceLogSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},879175:(e,t,n,r,s)=>{p.kb("ReduceSumSquare",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},879355:(e,t,n,r,s)=>{p.kb("ReduceLogSumExp",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},879535:e=>{p.kb("Where",e,void 0)},879588:(e,t,n)=>{p.kb("Transpose",e,{perm:t?Array.from(a().subarray(Number(t)>>>0,Number(n)>>>0)):[]})},879712:(e,t,n,r)=>{p.kb("DepthToSpace",e,{blocksize:t,mode:Be(n),format:r?"NHWC":"NCHW"})},879845:(e,t,n,r)=>{p.kb("DepthToSpace",e,{blocksize:t,mode:Be(n),format:r?"NHWC":"NCHW"})},879978:(e,n,r,s,i,o,l,u,d,c,h,f,m,_,g)=>{p.kb("ConvTranspose",e,{format:d?"NHWC":"NCHW",autoPad:n,dilations:[r],group:s,kernelShape:[i],pads:[o,l],strides:[u],wIsConst:()=>!!t()[c>>>0],outputPadding:h?Array.from(a().subarray(Number(h)>>>0,Number(f)>>>0)):[],outputShape:m?Array.from(a().subarray(Number(m)>>>0,Number(_)>>>0)):[],activation:Be(g)})},880411:(e,n,r,s,i,o,l,u,d,c,h,f,m,_)=>{p.kb("ConvTranspose",e,{format:u?"NHWC":"NCHW",autoPad:n,dilations:Array.from(a().subarray(Number(r)>>>0,2+(Number(r)>>>0)>>>0)),group:s,kernelShape:Array.from(a().subarray(Number(i)>>>0,2+(Number(i)>>>0)>>>0)),pads:Array.from(a().subarray(Number(o)>>>0,4+(Number(o)>>>0)>>>0)),strides:Array.from(a().subarray(Number(l)>>>0,2+(Number(l)>>>0)>>>0)),wIsConst:()=>!!t()[d>>>0],outputPadding:c?Array.from(a().subarray(Number(c)>>>0,Number(h)>>>0)):[],outputShape:f?Array.from(a().subarray(Number(f)>>>0,Number(m)>>>0)):[],activation:Be(_)})},881072:(e,n,r,s,i,o,l,u,d,c,h,f,m,_,g)=>{p.kb("ConvTranspose",e,{format:d?"NHWC":"NCHW",autoPad:n,dilations:[r],group:s,kernelShape:[i],pads:[o,l],strides:[u],wIsConst:()=>!!t()[c>>>0],outputPadding:h?Array.from(a().subarray(Number(h)>>>0,Number(f)>>>0)):[],outputShape:m?Array.from(a().subarray(Number(m)>>>0,Number(_)>>>0)):[],activation:Be(g)})},881505:(e,n,r,s,i,o,l,u,d,c,h,f,m,_)=>{p.kb("ConvTranspose",e,{format:u?"NHWC":"NCHW",autoPad:n,dilations:Array.from(a().subarray(Number(r)>>>0,2+(Number(r)>>>0)>>>0)),group:s,kernelShape:Array.from(a().subarray(Number(i)>>>0,2+(Number(i)>>>0)>>>0)),pads:Array.from(a().subarray(Number(o)>>>0,4+(Number(o)>>>0)>>>0)),strides:Array.from(a().subarray(Number(l)>>>0,2+(Number(l)>>>0)>>>0)),wIsConst:()=>!!t()[d>>>0],outputPadding:c?Array.from(a().subarray(Number(c)>>>0,Number(h)>>>0)):[],outputShape:f?Array.from(a().subarray(Number(f)>>>0,Number(m)>>>0)):[],activation:Be(_)})},882166:(e,t)=>{p.kb("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},882257:(e,t,n,r,s,i,o,l,u,d,c,h,f,m)=>{p.kb("AveragePool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:s,dilations:i?Array.from(a().subarray(Number(i)>>>0,Number(o)>>>0)):[],kernel_shape:l?Array.from(a().subarray(Number(l)>>>0,Number(u)>>>0)):[],pads:d?Array.from(a().subarray(Number(d)>>>0,Number(c)>>>0)):[],strides:h?Array.from(a().subarray(Number(h)>>>0,Number(f)>>>0)):[]})},882736:(e,t)=>{p.kb("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},882827:(e,t,n,r,s,i,o,l,u,d,c,h,f,m)=>{p.kb("AveragePool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:s,dilations:i?Array.from(a().subarray(Number(i)>>>0,Number(o)>>>0)):[],kernel_shape:l?Array.from(a().subarray(Number(l)>>>0,Number(u)>>>0)):[],pads:d?Array.from(a().subarray(Number(d)>>>0,Number(c)>>>0)):[],strides:h?Array.from(a().subarray(Number(h)>>>0,Number(f)>>>0)):[]})},883306:(e,t)=>{p.kb("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},883393:(e,t,n,r,s,i,o,l,u,d,c,h,f,m)=>{p.kb("MaxPool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:s,dilations:i?Array.from(a().subarray(Number(i)>>>0,Number(o)>>>0)):[],kernel_shape:l?Array.from(a().subarray(Number(l)>>>0,Number(u)>>>0)):[],pads:d?Array.from(a().subarray(Number(d)>>>0,Number(c)>>>0)):[],strides:h?Array.from(a().subarray(Number(h)>>>0,Number(f)>>>0)):[]})},883868:(e,t)=>{p.kb("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},883955:(e,t,n,r,s,i,o,l,u,d,c,h,f,m)=>{p.kb("MaxPool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:s,dilations:i?Array.from(a().subarray(Number(i)>>>0,Number(o)>>>0)):[],kernel_shape:l?Array.from(a().subarray(Number(l)>>>0,Number(u)>>>0)):[],pads:d?Array.from(a().subarray(Number(d)>>>0,Number(c)>>>0)):[],strides:h?Array.from(a().subarray(Number(h)>>>0,Number(f)>>>0)):[]})},884430:(e,t,n,r,s)=>{p.kb("Gemm",e,{alpha:t,beta:n,transA:r,transB:s})},884534:e=>{p.kb("MatMul",e,void 0)},884588:(e,t,n,r)=>{p.kb("ArgMax",e,{keepDims:!!t,selectLastIndex:!!n,axis:r})},884696:(e,t,n,r)=>{p.kb("ArgMin",e,{keepDims:!!t,selectLastIndex:!!n,axis:r})},884804:(e,t)=>{p.kb("Softmax",e,{axis:t})},884867:(e,t)=>{p.kb("Concat",e,{axis:t})},884927:(e,t,n,r,s)=>{p.kb("Split",e,{axis:t,numOutputs:n,splitSizes:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},885083:e=>{p.kb("Expand",e,void 0)},885137:(e,t)=>{p.kb("Gather",e,{axis:Number(t)})},885208:(e,t)=>{p.kb("GatherElements",e,{axis:Number(t)})},885287:(e,t)=>{p.kb("GatherND",e,{batch_dims:Number(t)})},885366:(e,t,n,r,s,i,o,l,u,d,c)=>{p.kb("Resize",e,{antialias:t,axes:n?Array.from(a().subarray(Number(n)>>>0,Number(r)>>>0)):[],coordinateTransformMode:Be(s),cubicCoeffA:i,excludeOutside:o,extrapolationValue:l,keepAspectRatioPolicy:Be(u),mode:Be(d),nearestMode:Be(c)})},885728:(e,t,n,r,s,i,o)=>{p.kb("Slice",e,{starts:t?Array.from(a().subarray(Number(t)>>>0,Number(n)>>>0)):[],ends:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[],axes:i?Array.from(a().subarray(Number(i)>>>0,Number(o)>>>0)):[]})},885992:e=>{p.kb("Tile",e,void 0)},886044:(e,t,n)=>{p.kb("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},886158:(e,t,n)=>{p.kb("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},886272:e=>{p.kb("Range",e,void 0)},886325:(e,t)=>{p.kb("Einsum",e,{equation:Be(t)})},886406:(e,t,n,r,s)=>{p.kb("Pad",e,{mode:t,value:n,pads:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[]})},886549:(e,t,n,r,s,i)=>{p.kb("BatchNormalization",e,{epsilon:t,momentum:n,spatial:!!s,trainingMode:!!r,format:i?"NHWC":"NCHW"})},886718:(e,t,n,r,s,i)=>{p.kb("BatchNormalization",e,{epsilon:t,momentum:n,spatial:!!s,trainingMode:!!r,format:i?"NHWC":"NCHW"})},886887:(e,t,n)=>{p.kb("CumSum",e,{exclusive:Number(t),reverse:Number(n)})},886984:(e,t,n)=>{p.kb("DequantizeLinear",e,{axis:t,blockSize:n})},887074:(e,t,n,r,s)=>{p.kb("GridSample",e,{align_corners:t,mode:Be(n),padding_mode:Be(r),format:s?"NHWC":"NCHW"})},887244:(e,t,n,r,s)=>{p.kb("GridSample",e,{align_corners:t,mode:Be(n),padding_mode:Be(r),format:s?"NHWC":"NCHW"})},887414:(e,t)=>{p.kb("ScatterND",e,{reduction:Be(t)})},887499:(e,t,n,r,s,i,o,l,u)=>{p.kb("Attention",e,{numHeads:t,isUnidirectional:n,maskFilterValue:r,scale:s,doRotary:i,qkvHiddenSizes:o?Array.from(a().subarray(Number(l)>>>0,Number(l)+o>>>0)):[],pastPresentShareBuffer:!!u})},887771:e=>{p.kb("BiasAdd",e,void 0)},887826:e=>{p.kb("BiasSplitGelu",e,void 0)},887887:e=>{p.kb("FastGelu",e,void 0)},887943:(e,n,r,s,i,o,u,d,c,h,f,m,_,g,w,y)=>{p.kb("Conv",e,{format:m?"NHWC":"NCHW",auto_pad:n,dilations:r?Array.from(a().subarray(Number(r)>>>0,Number(s)>>>0)):[],group:i,kernel_shape:o?Array.from(a().subarray(Number(o)>>>0,Number(u)>>>0)):[],pads:d?Array.from(a().subarray(Number(d)>>>0,Number(c)>>>0)):[],strides:h?Array.from(a().subarray(Number(h)>>>0,Number(f)>>>0)):[],w_is_const:()=>!!t()[Number(_)>>>0],activation:Be(g),activation_params:w?Array.from(l().subarray(Number(w)>>>0,Number(y)>>>0)):[]})},888527:e=>{p.kb("Gelu",e,void 0)},888579:(e,t,n,r,s,i,a,o,l)=>{p.kb("GroupQueryAttention",e,{numHeads:t,kvNumHeads:n,scale:r,softcap:s,doRotary:i,rotaryInterleaved:a,smoothSoftmax:o,localWindowSize:l})},888796:(e,t,n,r)=>{p.kb("LayerNormalization",e,{axis:t,epsilon:n,simplified:!!r})},888907:(e,t,n,r)=>{p.kb("LayerNormalization",e,{axis:t,epsilon:n,simplified:!!r})},889018:(e,t,n,r,s,i)=>{p.kb("MatMulNBits",e,{k:t,n,accuracyLevel:r,bits:s,blockSize:i})},889145:(e,t,n,r,s,i)=>{p.kb("MultiHeadAttention",e,{numHeads:t,isUnidirectional:n,maskFilterValue:r,scale:s,doRotary:i})},889304:(e,t)=>{p.kb("QuickGelu",e,{alpha:t})},889368:(e,t,n,r,s)=>{p.kb("RotaryEmbedding",e,{interleaved:!!t,numHeads:n,rotaryEmbeddingDim:r,scale:s})},889507:(e,t,n)=>{p.kb("SkipLayerNormalization",e,{epsilon:t,simplified:!!n})},889609:(e,t,n)=>{p.kb("SkipLayerNormalization",e,{epsilon:t,simplified:!!n})},889711:(e,t,n,r)=>{p.kb("GatherBlockQuantized",e,{gatherAxis:t,quantizeAxis:n,blockSize:r})},889832:e=>{p.$b(e)},889866:(e,t)=>p.cc(Number(e),Number(t),p.Gb.hc,p.Gb.errors)};function oe(e,t,n){return nn((async()=>{await p.Yb(Number(e),Number(t),Number(n))}))}function le(){return typeof wasmOffsetConverter<"u"}function ue(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}var de=e=>{e.terminate(),e.onmessage=()=>{}},ce=e=>{0==ge.length&&(ke(),$e(ge[0]));var t=ge.pop();if(!t)return 6;we.push(t),be[e.Bb]=t,t.Bb=e.Bb;var n={cmd:"run",start_routine:e.ic,arg:e.Rb,pthread_ptr:e.Bb};return t.postMessage(n,e.nc),0},pe=0,he=(e,t,...n)=>{for(var r=2*n.length,s=Or(),i=Mr(8*r),a=i>>>3,o=0;o<n.length;o++){var l=n[o];"bigint"==typeof l?(U[a+2*o]=1n,U[a+2*o+1]=l):(U[a+2*o]=0n,u()[a+2*o+1>>>0]=l)}return e=Sr(e,0,r,i,t),Ar(s),e};function fe(e){if(_)return he(0,1,e);if(O=e,!(0<pe)){for(var t of we)de(t);for(t of ge)de(t);ge=[],we=[],be=[],W=!0}v(e,new ue(e))}function me(e){if(_)return he(1,0,e);_e(e)}var _e=e=>{if(O=e,_)throw me(e),"unwind";fe(e)},ge=[],we=[],ye=[],be={},xe=e=>{var t=e.Bb;delete be[t],ge.push(e),we.splice(we.indexOf(e),1),e.Bb=0,zr(t)};function ve(){ye.forEach((e=>e()))}var $e=e=>new Promise((t=>{e.onmessage=n=>{var r=(n=n.data).cmd;if(n.targetThread&&n.targetThread!=xr()){var s=be[n.targetThread];s?s.postMessage(n,n.transferList):C(`Internal error! Worker sent a message "${r}" to target pthread ${n.targetThread}, but that thread no longer exists!`)}else"checkMailbox"===r?Nt():"spawnThread"===r?ce(n):"cleanupThread"===r?xe(be[n.thread]):"killThread"===r?(n=n.thread,r=be[n],delete be[n],de(r),zr(n),we.splice(we.indexOf(r),1),r.Bb=0):"cancelThread"===r?be[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,t(e)):"alert"===r?alert(`Thread ${n.threadId}: ${n.text}`):"setimmediate"===n.target?e.postMessage(n):"callHandler"===r?p[n.handler](...n.args):r&&C(`worker sent an unknown command ${r}`)},e.onerror=e=>{throw C(`worker sent an error! ${e.filename}:${e.lineno}: ${e.message}`),e};var n,r=[];for(n of[])p.hasOwnProperty(n)&&r.push(n);e.postMessage({cmd:"load",handlers:r,wasmMemory:A,wasmModule:M})}));function ke(){var e=new Worker(new URL("file:///Users/sam-schaack/gamp/nuiq-asr/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs"),{type:"module",workerData:"em-pthread",name:"em-pthread"});ge.push(e)}var Ee=e=>{for(;0<e.length;)e.shift()(p)},Se=()=>{var e=xr(),t=o()[e+52>>>2>>>0];e=o()[e+56>>>2>>>0],Ir(t,t-e),Ar(t)},ze=(e,t)=>{pe=0,e=Br(e,t),0<pe?O=e:Cr(e)};class Ce{constructor(e){this.Kb=e-24}}function Te(e,t,n){var r=new Ce(e>>>=0);throw t>>>=0,n>>>=0,o()[r.Kb+16>>>2>>>0]=0,o()[r.Kb+4>>>2>>>0]=t,o()[r.Kb+8>>>2>>>0]=n,e}function Ie(e,t,n,r){return _?he(2,1,e,t,n,r):Ae(e,t,n,r)}function Ae(e,t,n,r){if(e>>>=0,t>>>=0,n>>>=0,r>>>=0,void 0===g)return C("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var s=[];return _&&0===s.length?Ie(e,t,n,r):(e={ic:n,Bb:e,Rb:r,nc:s},_?(e.Nb="spawnThread",postMessage(e,s),0):ce(e))}var Me=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Oe=(e,t,n)=>{var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&Me)return Me.decode(e.buffer instanceof g?e.slice(t,n):e.subarray(t,n));for(r="";t<n;){var s=e[t++];if(128&s){var i=63&e[t++];if(192==(224&s))r+=String.fromCharCode((31&s)<<6|i);else{var a=63&e[t++];65536>(s=224==(240&s)?(15&s)<<12|i<<6|a:(7&s)<<18|i<<12|a<<6|63&e[t++])?r+=String.fromCharCode(s):(s-=65536,r+=String.fromCharCode(55296|s>>10,56320|1023&s))}}else r+=String.fromCharCode(s)}return r},Be=(e,t)=>(e>>>=0)?Oe(n(),e,t):"";function Ne(e,t,n){return _?he(3,1,e,t,n):0}function Pe(e,t){if(_)return he(4,1,e,t)}var Re=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t},De=(e,t,n,r)=>{if(!(0<r))return 0;var s=n>>>=0;r=n+r-1;for(var i=0;i<e.length;++i){var a=e.charCodeAt(i);if(55296<=a&&57343>=a&&(a=65536+((1023&a)<<10)|1023&e.charCodeAt(++i)),127>=a){if(n>=r)break;t[n++>>>0]=a}else{if(2047>=a){if(n+1>=r)break;t[n++>>>0]=192|a>>6}else{if(65535>=a){if(n+2>=r)break;t[n++>>>0]=224|a>>12}else{if(n+3>=r)break;t[n++>>>0]=240|a>>18,t[n++>>>0]=128|a>>12&63}t[n++>>>0]=128|a>>6&63}t[n++>>>0]=128|63&a}}return t[n>>>0]=0,n-s},Fe=(e,t,r)=>De(e,n(),t,r);function Le(e,t){if(_)return he(5,1,e,t)}function Ue(e,t,n){if(_)return he(6,1,e,t,n)}function qe(e,t,n){return _?he(7,1,e,t,n):0}function Ve(e,t){if(_)return he(8,1,e,t)}function We(e,t,n){if(_)return he(9,1,e,t,n)}function je(e,t,n,r){if(_)return he(10,1,e,t,n,r)}function Ge(e,t,n,r){if(_)return he(11,1,e,t,n,r)}function He(e,t,n,r){if(_)return he(12,1,e,t,n,r)}function Ke(e){if(_)return he(13,1,e)}function Xe(e,t){if(_)return he(14,1,e,t)}function Qe(e,t,n){if(_)return he(15,1,e,t,n)}var Ye,Ze,Je=()=>{J("")},et=e=>{for(var t="";n()[e>>>0];)t+=Ye[n()[e++>>>0]];return t},tt={},nt={},rt={};function st(e,t,n={}){if(!("argPackAdvance"in t))throw new TypeError("registerType registeredInstance requires argPackAdvance");return function(e,t,n={}){var r=t.name;if(!e)throw new Ze(`type "${r}" must have a positive integer typeid pointer`);if(nt.hasOwnProperty(e)){if(n.Tb)return;throw new Ze(`Cannot register type \'${r}\' twice`)}nt[e]=t,delete rt[e],tt.hasOwnProperty(e)&&(t=tt[e],delete tt[e],t.forEach((e=>e())))}(e,t,n)}var it=(e,s,l)=>{switch(s){case 1:return l?e=>t()[e>>>0]:e=>n()[e>>>0];case 2:return l?e=>r()[e>>>1>>>0]:e=>i()[e>>>1>>>0];case 4:return l?e=>a()[e>>>2>>>0]:e=>o()[e>>>2>>>0];case 8:return l?e=>U[e>>>3]:e=>q[e>>>3];default:throw new TypeError(`invalid integer width (${s}): ${e}`)}};function at(e,t,n){n>>>=0,st(e>>>=0,{name:t=et(t>>>0),fromWireType:e=>e,toWireType:function(e,t){if("bigint"!=typeof t&&"number"!=typeof t)throw t=null===t?"null":"object"==(e=typeof t)||"array"===e||"function"===e?t.toString():""+t,new TypeError(`Cannot convert "${t}" to ${this.name}`);return"number"==typeof t&&(t=BigInt(t)),t},argPackAdvance:ot,readValueFromPointer:it(t,n,-1==t.indexOf("u")),Eb:null})}var ot=8;function lt(e,t,r,s){st(e>>>=0,{name:t=et(t>>>0),fromWireType:function(e){return!!e},toWireType:function(e,t){return t?r:s},argPackAdvance:ot,readValueFromPointer:function(e){return this.fromWireType(n()[e>>>0])},Eb:null})}var ut=[],dt=[];function ct(e){9<(e>>>=0)&&0==--dt[e+1]&&(dt[e]=void 0,ut.push(e))}var pt=e=>{if(!e)throw new Ze("Cannot use deleted val. handle = "+e);return dt[e]},ht=e=>{switch(e){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let t=ut.pop()||dt.length;return dt[t]=e,dt[t+1]=1,t}};function ft(e){return this.fromWireType(o()[e>>>2>>>0])}var mt={name:"emscripten::val",fromWireType:e=>{var t=pt(e);return ct(e),t},toWireType:(e,t)=>ht(t),argPackAdvance:ot,readValueFromPointer:ft,Eb:null};function _t(e){return st(e>>>0,mt)}var gt=(e,t)=>{switch(t){case 4:return function(e){return this.fromWireType(l()[e>>>2>>>0])};case 8:return function(e){return this.fromWireType(u()[e>>>3>>>0])};default:throw new TypeError(`invalid float width (${t}): ${e}`)}};function wt(e,t,n){n>>>=0,st(e>>>=0,{name:t=et(t>>>0),fromWireType:e=>e,toWireType:(e,t)=>t,argPackAdvance:ot,readValueFromPointer:gt(t,n),Eb:null})}function yt(e,t,n,r,s){if(e>>>=0,n>>>=0,t=et(t>>>0),-1===s&&(s=4294967295),s=e=>e,0===r){var i=32-8*n;s=e=>e<<i>>>i}var a=t.includes("unsigned")?function(e,t){return t>>>0}:function(e,t){return t};st(e,{name:t,fromWireType:s,toWireType:a,argPackAdvance:ot,readValueFromPointer:it(t,n,0!==r),Eb:null})}function bt(e,n,r){function s(e){var n=o()[e>>>2>>>0];return e=o()[e+4>>>2>>>0],new i(t().buffer,e,n)}var i=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][n];st(e>>>=0,{name:r=et(r>>>0),fromWireType:s,argPackAdvance:ot,readValueFromPointer:s},{Tb:!0})}function xt(e,t){e>>>=0;var r="std::string"===(t=et(t>>>0));st(e,{name:t,fromWireType:function(e){var t=o()[e>>>2>>>0],s=e+4;if(r)for(var i=s,a=0;a<=t;++a){var l=s+a;if(a==t||0==n()[l>>>0]){if(i=Be(i,l-i),void 0===u)var u=i;else u+=String.fromCharCode(0),u+=i;i=l+1}}else{for(u=Array(t),a=0;a<t;++a)u[a]=String.fromCharCode(n()[s+a>>>0]);u=u.join("")}return vr(e),u},toWireType:function(e,t){t instanceof ArrayBuffer&&(t=new Uint8Array(t));var s="string"==typeof t;if(!(s||t instanceof Uint8Array||t instanceof Uint8ClampedArray||t instanceof Int8Array))throw new Ze("Cannot pass non-string to std::string");var i=r&&s?Re(t):t.length,a=$r(4+i+1),l=a+4;if(o()[a>>>2>>>0]=i,r&&s)Fe(t,l,i+1);else if(s)for(s=0;s<i;++s){var u=t.charCodeAt(s);if(255<u)throw vr(l),new Ze("String has UTF-16 code units that do not fit in 8 bits");n()[l+s>>>0]=u}else for(s=0;s<i;++s)n()[l+s>>>0]=t[s];return null!==e&&e.push(vr,a),a},argPackAdvance:ot,readValueFromPointer:ft,Eb(e){vr(e)}})}var vt=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,$t=(e,t)=>{for(var s=e>>1,a=s+t/2;!(s>=a)&&i()[s>>>0];)++s;if(32<(s<<=1)-e&&vt)return vt.decode(n().slice(e,s));for(s="",a=0;!(a>=t/2);++a){var o=r()[e+2*a>>>1>>>0];if(0==o)break;s+=String.fromCharCode(o)}return s},kt=(e,t,n)=>{if(n??=2147483647,2>n)return 0;var s=t;n=(n-=2)<2*e.length?n/2:e.length;for(var i=0;i<n;++i){var a=e.charCodeAt(i);r()[t>>>1>>>0]=a,t+=2}return r()[t>>>1>>>0]=0,t-s},Et=e=>2*e.length,St=(e,t)=>{for(var n=0,r="";!(n>=t/4);){var s=a()[e+4*n>>>2>>>0];if(0==s)break;++n,65536<=s?(s-=65536,r+=String.fromCharCode(55296|s>>10,56320|1023&s)):r+=String.fromCharCode(s)}return r},zt=(e,t,n)=>{if(t>>>=0,n??=2147483647,4>n)return 0;var r=t;n=r+n-4;for(var s=0;s<e.length;++s){var i=e.charCodeAt(s);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++s)),a()[t>>>2>>>0]=i,(t+=4)+4>n)break}return a()[t>>>2>>>0]=0,t-r},Ct=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);55296<=r&&57343>=r&&++n,t+=4}return t};function Tt(e,t,n){if(e>>>=0,t>>>=0,n=et(n>>>=0),2===t)var r=$t,s=kt,a=Et,l=e=>i()[e>>>1>>>0];else 4===t&&(r=St,s=zt,a=Ct,l=e=>o()[e>>>2>>>0]);st(e,{name:n,fromWireType:e=>{for(var n,s=o()[e>>>2>>>0],i=e+4,a=0;a<=s;++a){var u=e+4+a*t;a!=s&&0!=l(u)||(i=r(i,u-i),void 0===n?n=i:(n+=String.fromCharCode(0),n+=i),i=u+t)}return vr(e),n},toWireType:(e,r)=>{if("string"!=typeof r)throw new Ze(`Cannot pass non-string to C++ string type ${n}`);var i=a(r),l=$r(4+i+t);return o()[l>>>2>>>0]=i/t,s(r,l+4,i+t),null!==e&&e.push(vr,l),l},argPackAdvance:ot,readValueFromPointer:ft,Eb(e){vr(e)}})}function It(e,t){st(e>>>=0,{Ub:!0,name:t=et(t>>>0),argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})}var At=()=>1;function Mt(e){kr(e>>>0,!m,1,!f,131072,!1),ve()}var Ot=e=>{if(!W)try{if(e(),!(0<pe))try{_?Cr(O):_e(O)}catch(e){e instanceof ue||"unwind"==e||v(1,e)}}catch(e){e instanceof ue||"unwind"==e||v(1,e)}};function Bt(e){e>>>=0,"function"==typeof Atomics.oc&&(Atomics.oc(a(),e>>>2,e).value.then(Nt),e+=128,Atomics.store(a(),e>>>2,1))}var Nt=()=>{var e=xr();e&&(Bt(e),Ot(Tr))};function Pt(e,t){(e>>>=0)==t>>>0?setTimeout(Nt):_?postMessage({targetThread:e,cmd:"checkMailbox"}):(e=be[e])&&e.postMessage({cmd:"checkMailbox"})}var Rt=[];function Dt(e,t,n,r,s){for(t>>>=0,r/=2,Rt.length=r,n=s>>>0>>>3,s=0;s<r;s++)Rt[s]=U[n+2*s]?U[n+2*s+1]:u()[n+2*s+1>>>0];return(t?ae[t]:_r[e])(...Rt)}function Lt(e){e>>>=0,_?postMessage({cmd:"cleanupThread",thread:e}):xe(be[e])}function Ut(e){}var qt=(e,t)=>{var n=nt[e];if(void 0===n)throw e=wr(e),n=et(e),vr(e),new Ze(`${t} has unknown type ${n}`);return n},Vt=(e,t,n)=>{var r=[];return e=e.toWireType(r,n),r.length&&(o()[t>>>2>>>0]=ht(r)),e};function Wt(e,t,n){return t>>>=0,n>>>=0,e=pt(e>>>0),t=qt(t,"emval::as"),Vt(t,n,e)}function jt(e,t){return t>>>=0,e=pt(e>>>0),(t=qt(t,"emval::as")).toWireType(null,e)}var Gt=e=>{try{e()}catch(e){J(e)}},Ht=0,Kt=null,Xt=0,Qt=[],Yt={},Zt={},Jt=0,en=null,tn=[];function nn(e){return function(t){if(!W){if(0===Ht){var n=!1,r=!1;(t=>{e().then(t)})(((e=0)=>{if(!W&&(Xt=e,n=!0,r)){Ht=2,Gt((()=>Rr(Kt))),typeof Browser<"u"&&Browser.Lb.Sb&&Browser.Lb.resume(),e=!1;try{var t=(o=a()[Kt+8>>>2>>>0],o=gr[Zt[o]],--pe,o())}catch(o){t=o,e=!0}var s=!1;if(!Kt){var i=en;i&&(en=null,(e?i.reject:i.resolve)(t),s=!0)}if(e&&!s)throw t}var o})),r=!0,n||(Ht=1,Kt=function(){var e=$r(65548),t=e+12;o()[e>>>2>>>0]=t,o()[e+4>>>2>>>0]=t+65536,t=Qt[0];var n=Yt[t];return void 0===n&&(n=Jt++,Yt[t]=n,Zt[n]=t),t=n,a()[e+8>>>2>>>0]=t,e}(),typeof Browser<"u"&&Browser.Lb.Sb&&Browser.Lb.pause(),Gt((()=>Nr(Kt))))}else 2===Ht?(Ht=0,Gt(Dr),vr(Kt),Kt=null,tn.forEach(Ot)):J(`invalid state: ${Ht}`);return Xt}}()}function rn(e){return e>>>=0,nn((()=>(e=pt(e)).then(ht)))}var sn=[];function an(e,t,n,r){return n>>>=0,r>>>=0,(e=sn[e>>>0])(null,t=pt(t>>>0),n,r)}var on={},ln=e=>{var t=on[e];return void 0===t?et(e):t};function un(e,t,n,r,s){return n>>>=0,r>>>=0,s>>>=0,(e=sn[e>>>0])(t=pt(t>>>0),t[n=ln(n)],r,s)}var dn=()=>"object"==typeof globalThis?globalThis:Function("return this")();function cn(e){return 0==(e>>>=0)?ht(dn()):(e=ln(e),ht(dn()[e]))}var pn=e=>{var t=sn.length;return sn.push(e),t},hn=(e,t)=>{for(var n=Array(e),r=0;r<e;++r)n[r]=qt(o()[t+4*r>>>2>>>0],"parameter "+r);return n},fn=(e,t)=>Object.defineProperty(t,"name",{value:e});function mn(e,t,n){var r=(t=hn(e,t>>>0)).shift();e--;var s="return function (obj, func, destructorsRef, args) {\\n",i=0,a=[];0===n&&a.push("obj");for(var o=["retType"],l=[r],u=0;u<e;++u)a.push("arg"+u),o.push("argType"+u),l.push(t[u]),s+=`  var arg${u} = argType${u}.readValueFromPointer(args${i?"+"+i:""});\\n`,i+=t[u].argPackAdvance;return s+=`  var rv = ${1===n?"new func":"func.call"}(${a.join(", ")});\\n`,r.Ub||(o.push("emval_returnValue"),l.push(Vt),s+="  return emval_returnValue(retType, destructorsRef, rv);\\n"),o.push(s+"};\\n"),e=function(e){var t=Function;if(!(t instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof t} which is not a function`);var n=fn(t.name||"unknownFunctionName",(function(){}));return n.prototype=t.prototype,n=new n,(e=t.apply(n,e))instanceof Object?e:n}(o)(...l),n=`methodCaller<(${t.map((e=>e.name)).join(", ")}) => ${r.name}>`,pn(fn(n,e))}function _n(e){return e=ln(e>>>0),ht(p[e])}function gn(e,t){return t>>>=0,e=pt(e>>>0),t=pt(t),ht(e[t])}function wn(e){9<(e>>>=0)&&(dt[e+1]+=1)}function yn(){return ht([])}function bn(e){e=pt(e>>>0);for(var t=Array(e.length),n=0;n<e.length;n++)t[n]=e[n];return ht(t)}function xn(e){return ht(ln(e>>>0))}function vn(){return ht({})}function $n(e){for(var t=pt(e>>>=0);t.length;){var n=t.pop();t.pop()(n)}ct(e)}function kn(e,t,n){t>>>=0,n>>>=0,e=pt(e>>>0),t=pt(t),n=pt(n),e[t]=n}function En(e,t){return t>>>=0,e=(e=qt(e>>>0,"_emval_take_value")).readValueFromPointer(t),ht(e)}function Sn(e,t){e=-9007199254740992>e||9007199254740992<e?NaN:Number(e),t>>>=0,e=new Date(1e3*e),a()[t>>>2>>>0]=e.getUTCSeconds(),a()[t+4>>>2>>>0]=e.getUTCMinutes(),a()[t+8>>>2>>>0]=e.getUTCHours(),a()[t+12>>>2>>>0]=e.getUTCDate(),a()[t+16>>>2>>>0]=e.getUTCMonth(),a()[t+20>>>2>>>0]=e.getUTCFullYear()-1900,a()[t+24>>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[t+28>>>2>>>0]=e}var zn=e=>e%4==0&&(e%100!=0||e%400==0),Cn=[0,31,60,91,121,152,182,213,244,274,305,335],Tn=[0,31,59,90,120,151,181,212,243,273,304,334];function In(e,t){e=-9007199254740992>e||9007199254740992<e?NaN:Number(e),t>>>=0,e=new Date(1e3*e),a()[t>>>2>>>0]=e.getSeconds(),a()[t+4>>>2>>>0]=e.getMinutes(),a()[t+8>>>2>>>0]=e.getHours(),a()[t+12>>>2>>>0]=e.getDate(),a()[t+16>>>2>>>0]=e.getMonth(),a()[t+20>>>2>>>0]=e.getFullYear()-1900,a()[t+24>>>2>>>0]=e.getDay();var n=(zn(e.getFullYear())?Cn:Tn)[e.getMonth()]+e.getDate()-1|0;a()[t+28>>>2>>>0]=n,a()[t+36>>>2>>>0]=-60*e.getTimezoneOffset(),n=new Date(e.getFullYear(),6,1).getTimezoneOffset();var r=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(n!=r&&e.getTimezoneOffset()==Math.min(r,n)),a()[t+32>>>2>>>0]=e}function An(e){e>>>=0;var t=new Date(a()[e+20>>>2>>>0]+1900,a()[e+16>>>2>>>0],a()[e+12>>>2>>>0],a()[e+8>>>2>>>0],a()[e+4>>>2>>>0],a()[e>>>2>>>0],0),n=a()[e+32>>>2>>>0],r=t.getTimezoneOffset(),s=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=new Date(t.getFullYear(),0,1).getTimezoneOffset(),o=Math.min(i,s);return 0>n?a()[e+32>>>2>>>0]=+(s!=i&&o==r):0<n!=(o==r)&&(s=Math.max(i,s),t.setTime(t.getTime()+6e4*((0<n?o:s)-r))),a()[e+24>>>2>>>0]=t.getDay(),n=(zn(t.getFullYear())?Cn:Tn)[t.getMonth()]+t.getDate()-1|0,a()[e+28>>>2>>>0]=n,a()[e>>>2>>>0]=t.getSeconds(),a()[e+4>>>2>>>0]=t.getMinutes(),a()[e+8>>>2>>>0]=t.getHours(),a()[e+12>>>2>>>0]=t.getDate(),a()[e+16>>>2>>>0]=t.getMonth(),a()[e+20>>>2>>>0]=t.getYear(),e=t.getTime(),BigInt(isNaN(e)?-1:e/1e3)}function Mn(e,t,n,r,s,i,a){return _?he(16,1,e,t,n,r,s,i,a):-52}function On(e,t,n,r,s,i){if(_)return he(17,1,e,t,n,r,s,i)}function Bn(e,t,n,r){e>>>=0,t>>>=0,n>>>=0,r>>>=0;var s=(new Date).getFullYear(),i=new Date(s,0,1),l=new Date(s,6,1);s=i.getTimezoneOffset();var u=l.getTimezoneOffset(),d=Math.max(s,u);o()[e>>>2>>>0]=60*d,a()[t>>>2>>>0]=+(s!=u),i=(e=e=>e.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1])(i),l=e(l),u<s?(Fe(i,n,17),Fe(l,r,17)):(Fe(i,r,17),Fe(l,n,17))}var Nn=[],Pn=(e,t)=>{Nn.length=0;for(var r;r=n()[e++>>>0];){var s=105!=r;t+=(s&=112!=r)&&t%8?4:0,Nn.push(112==r?o()[t>>>2>>>0]:106==r?U[t>>>3]:105==r?a()[t>>>2>>>0]:u()[t>>>3>>>0]),t+=s?8:4}return Nn};function Rn(e,t,n){return e>>>=0,t=Pn(t>>>0,n>>>0),ae[e](...t)}function Dn(e,t,n){return e>>>=0,t=Pn(t>>>0,n>>>0),ae[e](...t)}var Fn=()=>{},Ln=()=>Date.now();function Un(e,t){return C(Be(e>>>0,t>>>0))}var qn,Vn=()=>{throw pe+=1,"unwind"};function Wn(){return 4294901760}qn=()=>performance.timeOrigin+performance.now();var jn=()=>navigator.hardwareConcurrency;function Gn(){return J("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function Hn(e){e>>>=0;var t=n().length;if(e<=t||4294901760<e)return!1;for(var r=1;4>=r;r*=2){var s=t*(1+.2/r);s=Math.min(s,e+100663296);var i=Math;s=Math.max(e,s);e:{i=(i.min.call(i,4294901760,s+(65536-s%65536)%65536)-A.buffer.byteLength+65535)/65536;try{A.grow(i),j();var a=1;break e}catch{}a=void 0}if(a)return!0}return!1}var Kn=()=>(J("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),Xn={},Qn=e=>{e.forEach((e=>{var t=Kn();t&&(Xn[t]=e)}))};function Yn(){var e=Error().stack.toString().split("\\n");return"Error"==e[0]&&e.shift(),Qn(e),Xn.Qb=Kn(),Xn.fc=e,Xn.Qb}function Zn(e,t,n){if(e>>>=0,t>>>=0,Xn.Qb==e)var r=Xn.fc;else"Error"==(r=Error().stack.toString().split("\\n"))[0]&&r.shift(),Qn(r);for(var s=3;r[s]&&Kn()!=e;)++s;for(e=0;e<n&&r[e+s];++e)a()[t+4*e>>>2>>>0]=Kn();return e}var Jn,er={},tr=()=>{if(!Jn){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:"./this.program"};for(e in er)void 0===er[e]?delete t[e]:t[e]=er[e];var n=[];for(e in t)n.push(`${e}=${t[e]}`);Jn=n}return Jn};function nr(e,n){if(_)return he(18,1,e,n);e>>>=0,n>>>=0;var r=0;return tr().forEach(((s,i)=>{var a=n+r;for(i=o()[e+4*i>>>2>>>0]=a,a=0;a<s.length;++a)t()[i++>>>0]=s.charCodeAt(a);t()[i>>>0]=0,r+=s.length+1})),0}function rr(e,t){if(_)return he(19,1,e,t);e>>>=0,t>>>=0;var n=tr();o()[e>>>2>>>0]=n.length;var r=0;return n.forEach((e=>r+=e.length+1)),o()[t>>>2>>>0]=r,0}function sr(e){return _?he(20,1,e):52}function ir(e,t,n,r){return _?he(21,1,e,t,n,r):52}function ar(e,t,n,r){return _?he(22,1,e,t,n,r):70}var or=[null,[],[]];function lr(e,t,r,s){if(_)return he(23,1,e,t,r,s);t>>>=0,r>>>=0,s>>>=0;for(var i=0,a=0;a<r;a++){var l=o()[t>>>2>>>0],u=o()[t+4>>>2>>>0];t+=8;for(var d=0;d<u;d++){var c=n()[l+d>>>0],p=or[e];0===c||10===c?((1===e?z:C)(Oe(p,0)),p.length=0):p.push(c)}i+=u}return o()[s>>>2>>>0]=i,0}var ur=[31,29,31,30,31,30,31,31,30,31,30,31],dr=[31,28,31,30,31,30,31,31,30,31,30,31],cr=(e,n)=>{t().set(e,n>>>0)};function pr(e,t,n,r){function s(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function i(e,t){return s(e,t,"0")}function l(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function u(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function d(e){var t=e.Cb;for(e=new Date(new Date(e.Db+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(zn(e.getFullYear())?ur:dr)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=u(new Date(e.getFullYear(),0,4)),n=u(n),0>=l(t,e)?0>=l(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,n>>>=0,r>>>=0;var c=o()[r+40>>>2>>>0];for(var p in r={lc:a()[r>>>2>>>0],kc:a()[r+4>>>2>>>0],Ib:a()[r+8>>>2>>>0],Mb:a()[r+12>>>2>>>0],Jb:a()[r+16>>>2>>>0],Db:a()[r+20>>>2>>>0],vb:a()[r+24>>>2>>>0],Cb:a()[r+28>>>2>>>0],sc:a()[r+32>>>2>>>0],jc:a()[r+36>>>2>>>0],mc:c?Be(c):""},n=Be(n),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(p,"g"),c[p]);var h,f,m="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),_="January February March April May June July August September October November December".split(" ");for(p in c={"%a":e=>m[e.vb].substring(0,3),"%A":e=>m[e.vb],"%b":e=>_[e.Jb].substring(0,3),"%B":e=>_[e.Jb],"%C":e=>i((e.Db+1900)/100|0,2),"%d":e=>i(e.Mb,2),"%e":e=>s(e.Mb,2," "),"%g":e=>d(e).toString().substring(2),"%G":d,"%H":e=>i(e.Ib,2),"%I":e=>(0==(e=e.Ib)?e=12:12<e&&(e-=12),i(e,2)),"%j":e=>{for(var t=0,n=0;n<=e.Jb-1;t+=(zn(e.Db+1900)?ur:dr)[n++]);return i(e.Mb+t,3)},"%m":e=>i(e.Jb+1,2),"%M":e=>i(e.kc,2),"%n":()=>"\\n","%p":e=>0<=e.Ib&&12>e.Ib?"AM":"PM","%S":e=>i(e.lc,2),"%t":()=>"\\t","%u":e=>e.vb||7,"%U":e=>i(Math.floor((e.Cb+7-e.vb)/7),2),"%V":e=>{var t=Math.floor((e.Cb+7-(e.vb+6)%7)/7);if(2>=(e.vb+371-e.Cb-2)%7&&t++,t)53==t&&(4==(n=(e.vb+371-e.Cb)%7)||3==n&&zn(e.Db)||(t=1));else{t=52;var n=(e.vb+7-e.Cb-1)%7;(4==n||5==n&&zn(e.Db%400-1))&&t++}return i(t,2)},"%w":e=>e.vb,"%W":e=>i(Math.floor((e.Cb+7-(e.vb+6)%7)/7),2),"%y":e=>(e.Db+1900).toString().substring(2),"%Y":e=>e.Db+1900,"%z":e=>(0<=(e=e.jc)?"+":"-")+("0000"+((e=Math.abs(e)/60)/60*100+e%60)).slice(-4),"%Z":e=>e.mc,"%%":()=>"%"},n=n.replace(/%%/g,"\\0\\0"),c)n.includes(p)&&(n=n.replace(new RegExp(p,"g"),c[p](r)));return h=n=n.replace(/\\0\\0/g,"%"),f=Array(Re(h)+1),De(h,f,0,f.length),(p=f).length>t?0:(cr(p,e),p.length-1)}function hr(e,t,n,r){return pr(e>>>0,t>>>0,n>>>0,r>>>0)}_||function(){for(var e=p.numThreads-1;e--;)ke();G.unshift((()=>{var e;X++,e=()=>Z(),_?e():Promise.all(ge.map($e)).then(e)}))}();for(var fr=Array(256),mr=0;256>mr;++mr)fr[mr]=String.fromCharCode(mr);Ye=fr,Ze=p.BindingError=class extends Error{constructor(e){super(e),this.name="BindingError"}},p.InternalError=class extends Error{constructor(e){super(e),this.name="InternalError"}},dt.push(0,1,void 0,1,null,1,!0,1,!1,1),p.count_emval_handles=()=>dt.length/2-5-ut.length;var _r=[fe,me,Ie,Ne,Pe,Le,Ue,qe,Ve,We,je,Ge,He,Ke,Xe,Qe,Mn,On,nr,rr,sr,ir,ar,lr],gr=function(){function e(e,t){return gr=e.exports,gr=function(){var e=gr,t={};for(let[n,r]of Object.entries(e))t[n]="function"==typeof r?(...e)=>{Qt.push(n);try{return r(...e)}finally{W||(Qt.pop(),Kt&&1===Ht&&0===Qt.length&&(Ht=0,pe+=1,Gt(Pr),typeof Fibers<"u"&&Fibers.tc()))}}:r;return t}(),n=gr,r=e=>t=>e(t)>>>0,s=e=>()=>e()>>>0,(n=Object.assign({},n)).Da=r(n.Da),n.gb=s(n.gb),n.ib=r(n.ib),n.emscripten_main_runtime_thread_id=s(n.emscripten_main_runtime_thread_id),n.tb=r(n.tb),n.ub=s(n.ub),gr=n,ye.push(gr.jb),H.unshift(gr.Ca),M=t,Z(),gr;var n,r,s}var t,n,r,i=ie();if(X++,p.instantiateWasm)try{return p.instantiateWasm(i,e)}catch(t){C(`Module.instantiateWasm callback failed with error: ${t}`),c(t)}return ee||=p.locateFile?te("ort-wasm-simd-threaded.jsep.wasm")?"ort-wasm-simd-threaded.jsep.wasm":p.locateFile?p.locateFile("ort-wasm-simd-threaded.jsep.wasm",$):$+"ort-wasm-simd-threaded.jsep.wasm":new URL(s(98),s.b).href,(t=i,n=function(t){e(t.instance,t.module)},r=ee,k||"function"!=typeof WebAssembly.instantiateStreaming||te(r)||ne(r)||"function"!=typeof fetch?se(r,t,n):fetch(r,{credentials:"same-origin"}).then((e=>WebAssembly.instantiateStreaming(e,t).then(n,(function(e){return C(`wasm streaming compile failed: ${e}`),C("falling back to ArrayBuffer instantiation"),se(r,t,n)}))))).catch(c),{}}(),wr=e=>(wr=gr.Da)(e),yr=()=>(yr=gr.Ea)();p._OrtInit=(e,t)=>(p._OrtInit=gr.Fa)(e,t),p._OrtGetLastError=(e,t)=>(p._OrtGetLastError=gr.Ga)(e,t),p._OrtCreateSessionOptions=(e,t,n,r,s,i,a,o,l,u)=>(p._OrtCreateSessionOptions=gr.Ha)(e,t,n,r,s,i,a,o,l,u),p._OrtAppendExecutionProvider=(e,t)=>(p._OrtAppendExecutionProvider=gr.Ia)(e,t),p._OrtAddFreeDimensionOverride=(e,t,n)=>(p._OrtAddFreeDimensionOverride=gr.Ja)(e,t,n),p._OrtAddSessionConfigEntry=(e,t,n)=>(p._OrtAddSessionConfigEntry=gr.Ka)(e,t,n),p._OrtReleaseSessionOptions=e=>(p._OrtReleaseSessionOptions=gr.La)(e),p._OrtCreateSession=(e,t,n)=>(p._OrtCreateSession=gr.Ma)(e,t,n),p._OrtReleaseSession=e=>(p._OrtReleaseSession=gr.Na)(e),p._OrtGetInputOutputCount=(e,t,n)=>(p._OrtGetInputOutputCount=gr.Oa)(e,t,n),p._OrtGetInputName=(e,t)=>(p._OrtGetInputName=gr.Pa)(e,t),p._OrtGetOutputName=(e,t)=>(p._OrtGetOutputName=gr.Qa)(e,t),p._OrtFree=e=>(p._OrtFree=gr.Ra)(e),p._OrtCreateTensor=(e,t,n,r,s,i)=>(p._OrtCreateTensor=gr.Sa)(e,t,n,r,s,i),p._OrtGetTensorData=(e,t,n,r,s)=>(p._OrtGetTensorData=gr.Ta)(e,t,n,r,s),p._OrtReleaseTensor=e=>(p._OrtReleaseTensor=gr.Ua)(e),p._OrtCreateRunOptions=(e,t,n,r)=>(p._OrtCreateRunOptions=gr.Va)(e,t,n,r),p._OrtAddRunConfigEntry=(e,t,n)=>(p._OrtAddRunConfigEntry=gr.Wa)(e,t,n),p._OrtReleaseRunOptions=e=>(p._OrtReleaseRunOptions=gr.Xa)(e),p._OrtCreateBinding=e=>(p._OrtCreateBinding=gr.Ya)(e),p._OrtBindInput=(e,t,n)=>(p._OrtBindInput=gr.Za)(e,t,n),p._OrtBindOutput=(e,t,n,r)=>(p._OrtBindOutput=gr._a)(e,t,n,r),p._OrtClearBoundOutputs=e=>(p._OrtClearBoundOutputs=gr.$a)(e),p._OrtReleaseBinding=e=>(p._OrtReleaseBinding=gr.ab)(e),p._OrtRunWithBinding=(e,t,n,r,s)=>(p._OrtRunWithBinding=gr.bb)(e,t,n,r,s),p._OrtRun=(e,t,n,r,s,i,a,o)=>(p._OrtRun=gr.cb)(e,t,n,r,s,i,a,o),p._OrtEndProfiling=e=>(p._OrtEndProfiling=gr.db)(e),p._JsepOutput=(e,t,n)=>(p._JsepOutput=gr.eb)(e,t,n),p._JsepGetNodeName=e=>(p._JsepGetNodeName=gr.fb)(e);var br,xr=()=>(xr=gr.gb)(),vr=p._free=e=>(vr=p._free=gr.hb)(e),$r=p._malloc=e=>($r=p._malloc=gr.ib)(e),kr=(e,t,n,r,s,i)=>(kr=gr.lb)(e,t,n,r,s,i),Er=()=>(Er=gr.mb)(),Sr=(e,t,n,r,s)=>(Sr=gr.nb)(e,t,n,r,s),zr=e=>(zr=gr.ob)(e),Cr=e=>(Cr=gr.pb)(e),Tr=()=>(Tr=gr.qb)(),Ir=(e,t)=>(Ir=gr.rb)(e,t),Ar=e=>(Ar=gr.sb)(e),Mr=e=>(Mr=gr.tb)(e),Or=()=>(Or=gr.ub)(),Br=p.dynCall_ii=(e,t)=>(Br=p.dynCall_ii=gr.wb)(e,t),Nr=e=>(Nr=gr.xb)(e),Pr=()=>(Pr=gr.yb)(),Rr=e=>(Rr=gr.zb)(e),Dr=()=>(Dr=gr.Ab)();function Fr(){0<X||(_?(d(p),_||Ee(H),startWorker(p)):(Ee(G),0<X||br||(br=!0,p.calledRun=!0,W||(_||Ee(H),d(p),_||Ee(K)))))}return p.___start_em_js=889994,p.___stop_em_js=890240,p.stackSave=()=>Or(),p.stackRestore=e=>Ar(e),p.stackAlloc=e=>Mr(e),p.setValue=function(e,n,s="i8"){switch(s.endsWith("*")&&(s="*"),s){case"i1":case"i8":t()[e>>>0]=n;break;case"i16":r()[e>>>1>>>0]=n;break;case"i32":a()[e>>>2>>>0]=n;break;case"i64":U[e>>>3]=BigInt(n);break;case"float":l()[e>>>2>>>0]=n;break;case"double":u()[e>>>3>>>0]=n;break;case"*":o()[e>>>2>>>0]=n;break;default:J(`invalid type for setValue: ${s}`)}},p.getValue=function(e,n="i8"){switch(n.endsWith("*")&&(n="*"),n){case"i1":case"i8":return t()[e>>>0];case"i16":return r()[e>>>1>>>0];case"i32":return a()[e>>>2>>>0];case"i64":return U[e>>>3];case"float":return l()[e>>>2>>>0];case"double":return u()[e>>>3>>>0];case"*":return o()[e>>>2>>>0];default:J(`invalid type for getValue: ${n}`)}},p.UTF8ToString=Be,p.stringToUTF8=Fe,p.lengthBytesUTF8=Re,Y=function e(){br||Fr(),br||(Y=e)},Fr(),p.PTR_SIZE=4,h},Ut=Lt,"em-pthread"===globalThis.self?.name&&Lt()})),gd=ut((()=>{Mt(),qt="file:///Users/sam-schaack/gamp/nuiq-asr/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs",Vt=typeof location>"u"?void 0:location.origin,Wt=(e,t)=>{try{let n=t??qt;return(n?new URL(e,n):new URL(e)).origin===Vt}catch{return!1}},jt=async e=>{let t=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(t)},Gt=(Rt(),ct(Ot)).default,Ht=async()=>{if(!qt)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(Wt(qt))return[void 0,Gt()];let e=await jt(qt);return[e,Gt(e)]},Kt=(_d(),ct(Dt)).default,Xt=async(e,t,n)=>[void 0,Kt]})),wd=ut((()=>{gd(),Yt=!1,Zt=!1,Jt=!1,en=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},tn=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},nn=async e=>{if(Yt)return Promise.resolve();if(Zt)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(Jt)throw new Error("previous call to \'initializeWebAssembly()\' failed.");Zt=!0;let t=e.initTimeout,n=e.numThreads;if(!tn())throw new Error("WebAssembly SIMD is not supported in the current environment.");let r=en();n>1&&!r&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=n=1);let s=e.wasmPaths,i="string"==typeof s?s:void 0,a=s?.mjs,o=a?.href??a,l=s?.wasm,u=l?.href??l,d=e.wasmBinary,[c,p]=await Xt(o,i,n>1),h=!1,f=[];if(t>0&&f.push(new Promise((e=>{setTimeout((()=>{h=!0,e()}),t)}))),f.push(new Promise(((e,t)=>{let r={numThreads:n};d?r.wasmBinary=d:(u||i)&&(r.locateFile=(e,t)=>u??(i??t)+e),p(r).then((t=>{Zt=!1,Yt=!0,Qt=t,e(),c&&URL.revokeObjectURL(c)}),(e=>{Zt=!1,Jt=!0,t(e)}))}))),await Promise.race(f),h)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},rn=()=>{if(Yt&&Qt)return Qt;throw new Error("WebAssembly is not initialized yet.")}})),yd=ut((()=>{wd(),sn=(e,t)=>{let n=rn(),r=n.lengthBytesUTF8(e)+1,s=n._malloc(r);return n.stringToUTF8(e,s,r),t.push(s),s},an=(e,t,n,r)=>{if("object"==typeof e&&null!==e){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach((([e,s])=>{let i=t?t+e:e;if("object"==typeof s)an(s,i+".",n,r);else if("string"==typeof s||"number"==typeof s)r(i,s.toString());else{if("boolean"!=typeof s)throw new Error("Can\'t handle extra config type: "+typeof s);r(i,s?"1":"0")}}))},on=e=>{let t=rn(),n=t.stackSave();try{let n=t.PTR_SIZE,r=t.stackAlloc(2*n);t._OrtGetLastError(r,r+n);let s=Number(t.getValue(r,4===n?"i32":"i64")),i=t.getValue(r+n,"*"),a=i?t.UTF8ToString(i):"";throw new Error(`${e} ERROR_CODE: ${s}, ERROR_MESSAGE: ${a}`)}finally{t.stackRestore(n)}}})),bd=ut((()=>{wd(),yd(),ln=e=>{let t=rn(),n=0,r=[],s=e||{};try{if(void 0===e?.logSeverityLevel)s.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===e?.logVerbosityLevel)s.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===e?.terminate&&(s.terminate=!1);let i=0;return void 0!==e?.tag&&(i=sn(e.tag,r)),n=t._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,i),0===n&&on("Can\'t create run options."),void 0!==e?.extra&&an(e.extra,"",new WeakSet,((e,s)=>{let i=sn(e,r),a=sn(s,r);0!==t._OrtAddRunConfigEntry(n,i,a)&&on(`Can\'t set a run config entry: ${e} - ${s}.`)})),[n,r]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),r.forEach((e=>t._free(e))),e}}})),xd=ut((()=>{wd(),yd(),un=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},dn=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},cn=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)},pn=(e,t,n)=>{for(let r of t){let t="string"==typeof r?r:r.name;switch(t){case"webnn":if(t="WEBNN","string"!=typeof r){let t=r?.deviceType;if(t){let r=sn("deviceType",n),s=sn(t,n);0!==rn()._OrtAddSessionConfigEntry(e,r,s)&&on(`Can\'t set a session config entry: \'deviceType\' - ${t}.`)}}break;case"webgpu":if(t="JS","string"!=typeof r){let t=r;if(t?.preferredLayout){if("NCHW"!==t.preferredLayout&&"NHWC"!==t.preferredLayout)throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${t.preferredLayout}`);let r=sn("preferredLayout",n),s=sn(t.preferredLayout,n);0!==rn()._OrtAddSessionConfigEntry(e,r,s)&&on(`Can\'t set a session config entry: \'preferredLayout\' - ${t.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${t}`)}let s=sn(t,n);0!==rn()._OrtAppendExecutionProvider(e,s)&&on(`Can\'t append execution provider: ${t}.`)}},hn=e=>{let t=rn(),n=0,r=[],s=e||{};cn(s);try{let e=un(s.graphOptimizationLevel??"all"),i=dn(s.executionMode??"sequential"),a="string"==typeof s.logId?sn(s.logId,r):0,o=s.logSeverityLevel??2;if(!Number.isInteger(o)||o<0||o>4)throw new Error(`log serverity level is not valid: ${o}`);let l=s.logVerbosityLevel??0;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log verbosity level is not valid: ${l}`);let u="string"==typeof s.optimizedModelFilePath?sn(s.optimizedModelFilePath,r):0;if(n=t._OrtCreateSessionOptions(e,!!s.enableCpuMemArena,!!s.enableMemPattern,i,!!s.enableProfiling,0,a,o,l,u),0===n&&on("Can\'t create session options."),s.executionProviders&&pn(n,s.executionProviders,r),void 0!==s.enableGraphCapture){if("boolean"!=typeof s.enableGraphCapture)throw new Error(`enableGraphCapture must be a boolean value: ${s.enableGraphCapture}`);let e=sn("enableGraphCapture",r),i=sn(s.enableGraphCapture.toString(),r);0!==t._OrtAddSessionConfigEntry(n,e,i)&&on(`Can\'t set a session config entry: \'enableGraphCapture\' - ${s.enableGraphCapture}.`)}if(s.freeDimensionOverrides)for(let[e,i]of Object.entries(s.freeDimensionOverrides)){if("string"!=typeof e)throw new Error(`free dimension override name must be a string: ${e}`);if("number"!=typeof i||!Number.isInteger(i)||i<0)throw new Error(`free dimension override value must be a non-negative integer: ${i}`);let s=sn(e,r);0!==t._OrtAddFreeDimensionOverride(n,s,i)&&on(`Can\'t set a free dimension override: ${e} - ${i}.`)}return void 0!==s.extra&&an(s.extra,"",new WeakSet,((e,s)=>{let i=sn(e,r),a=sn(s,r);0!==t._OrtAddSessionConfigEntry(n,i,a)&&on(`Can\'t set a session config entry: ${e} - ${s}.`)})),[n,r]}catch(e){throw 0!==n&&0!==t._OrtReleaseSessionOptions(n)&&on("Can\'t release session options."),r.forEach((e=>t._free(e))),e}}})),vd=ut((()=>{fn=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},mn=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},_n=(e,t)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],r="number"==typeof t?t:t.reduce(((e,t)=>e*t),1);return n>0?Math.ceil(r*n):void 0},gn=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},wn=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},yn=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,bn=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint64"===e||"int8"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,xn=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}})),$d=ut((()=>{Mt(),vn=async e=>{if("string"==typeof e){{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let n=t.headers.get("Content-Length"),r=n?parseInt(n,10):0;if(r<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let n,s=t.body.getReader();try{n=new ArrayBuffer(r)}catch(e){if(!(e instanceof RangeError))throw e;{let e=Math.ceil(r/65536);n=new WebAssembly.Memory({initial:e,maximum:e}).buffer}}let i=0;for(;;){let{done:e,value:t}=await s.read();if(e)break;let r=t.byteLength;new Uint8Array(n,i,r).set(t),i+=r}return new Uint8Array(n,0,r)}}}return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}})),kd=ut((()=>{vd(),$n=["V","I","W","E","F"],kn=(e,t)=>{console.log(`[${$n[e]},${(new Date).toISOString()}]${t}`)},zn=(e,t)=>{En=e,Sn=t},Cn=(e,t)=>{let n=wn(e);n>=wn(En)&&kn(n,"function"==typeof t?t():t)},Tn=(...e)=>{Sn&&Cn(...e)}})),Ed=ut((()=>{vd(),In=(e,t)=>new(gn(t))(e)})),Sd=ut((()=>{})),zd=ut((()=>{kd(),Sd(),An=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),Mn=[],On=e=>16*Math.ceil(Number(e)/16),Bn=e=>{for(let t=0;t<Mn.length;t++){let n=Mn[t];if(e<=n)return n}return 16*Math.ceil(e/16)},Nn=1,Pn=()=>Nn++,Rn=async(e,t,n,r)=>{let s=On(n),i=e.device.createBuffer({size:s,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let a=e.getCommandEncoder();e.endComputePass(),a.copyBufferToBuffer(t,0,i,0,s),e.flush(),await i.mapAsync(GPUMapMode.READ);let o=i.getMappedRange();if(r){let e=r();return e.set(new Uint8Array(o,0,n)),e}return new Uint8Array(o.slice(0,n))}finally{i.destroy()}},Dn=class{constructor(e){this.backend=e,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[e]of An)Mn.push(e),this.freeBuffers.set(e,[]),this.freeUniformBuffers.set(e,[]);this.sessionCount=0}upload(e,t){let n=t.buffer,r=t.byteOffset,s=t.byteLength,i=On(s),a=this.storageCache.get(e);if(!a)throw new Error("gpu data for uploading does not exist");if(Number(a.originalSize)!==s)throw new Error(`inconsistent data size. gpu data size=${a.originalSize}, data size=${s}`);let o=this.backend.device.createBuffer({mappedAtCreation:!0,size:i,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),l=o.getMappedRange();new Uint8Array(l).set(new Uint8Array(n,r,s)),o.unmap();let u=this.backend.device.createCommandEncoder();u.copyBufferToBuffer(o,0,a.gpuData.buffer,0,i),this.backend.device.queue.submit([u.finish()]),o.destroy(),Tn("verbose",(()=>`[WebGPU] GpuDataManager.upload(id=${e})`))}memcpy(e,t){let n=this.storageCache.get(e);if(!n)throw new Error("source gpu data for memcpy does not exist");let r=this.storageCache.get(t);if(!r)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==r.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=On(n.originalSize),i=this.backend.getCommandEncoder();this.backend.endComputePass(),i.copyBufferToBuffer(n.gpuData.buffer,0,r.gpuData.buffer,0,s)}registerExternalBuffer(e,t,n){let r;if(n){if(r=n[0],e===n[1])return Tn("verbose",(()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${r}, buffer is the same, skip.`)),r;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error("Registering a different external buffer under graph capture mode is not supported yet.\\n             Please use the previous external buffer!")}else r=Pn();return this.storageCache.set(r,{gpuData:{id:r,type:0,buffer:e},originalSize:t}),Tn("verbose",(()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${r}, registered.`)),r}unregisterExternalBuffer(e){void 0!==e&&(this.storageCache.delete(e),Tn("verbose",(()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`)))}create(e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n,r=Bn(e),s=(t&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,i=(t&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||i){let e=(s?this.freeBuffers:this.freeUniformBuffers).get(r);n=e&&e.length>0?e.pop():this.backend.device.createBuffer({size:r,usage:t})}else n=this.backend.device.createBuffer({size:r,usage:t});let a={id:Pn(),type:0,buffer:n};return this.storageCache.set(a.id,{gpuData:a,originalSize:Number(e)}),Tn("verbose",(()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${a.id}`)),a}get(e){return this.storageCache.get(e)?.gpuData}release(e){let t="bigint"==typeof e?Number(e):e,n=this.storageCache.get(t);if(!n){if(0===this.storageCache.size)return 0;throw new Error("releasing data does not exist")}return Tn("verbose",(()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${n.gpuData.id}`)),this.storageCache.delete(t),this.buffersPending.push(n.gpuData.buffer),n.originalSize}async download(e,t){let n=this.storageCache.get(Number(e));if(!n)throw new Error("data does not exist");await Rn(this.backend,n.gpuData.buffer,n.originalSize,t)}refreshPendingBuffers(){if(0!==this.buffersPending.length)if("default"===this.backend.sessionStatus){for(let e of this.buffersPending){let t=An.get(e.size);if((e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let n=this.freeBuffers.get(e.size)||[];void 0===t||n.length>=t?e.destroy():n.push(e)}else if((e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let n=this.freeUniformBuffers.get(e.size)||[];void 0===t||n.length>=t?e.destroy():n.push(e)}else e.destroy()}this.buffersPending=[]}else{let e=this.capturedPendingBuffers.get(this.backend.currentSessionId);e||(e=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,e));for(let t of this.buffersPending)e.push(t);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.freeUniformBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.storageCache.forEach((e=>{e.gpuData.buffer.destroy()})),this.capturedPendingBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(e){let t=this.capturedPendingBuffers.get(e);t&&(t.forEach((e=>{e.destroy()})),this.capturedPendingBuffers.delete(e)),this.sessionCount-=1,0===this.sessionCount&&(Tn("warning",(()=>"[WebGPU] Clearing webgpu buffer cache")),this.storageCache.forEach((e=>{e.gpuData.buffer.destroy()})),this.storageCache=new Map)}},Fn=(...e)=>new Dn(...e)})),Cd=ut((()=>{Ln=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map((e=>`${this[e]}`)).join(";")),this.key}},Un=e=>new Ln(e)})),Td=ut((()=>{qn=class{static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}},Vn=class{static calcShape(e,t,n=!1){let r=e.length,s=t.length;if(0===r)return t;if(0===s)return e;let i=Math.max(e.length,t.length),a=new Array(i);if(n){if(r<2||s<2)return;let n=qn.calcMatMulShape([e[r-2],e[r-1]],[t[s-2],t[s-1]]);if(void 0===n)return;[a[i-2],a[i-1]]=n}for(let o=n?3:1;o<=i;o++){let n=r-o<0?1:e[r-o],l=s-o<0?1:t[s-o];if(n!==l&&n>1&&l>1)return;let u=Math.max(n,l);if(n&&l)a[i-o]=Math.max(n,l);else{if(u>1)return;a[i-o]=0}}return a}static isValidBroadcast(e,t){let n=e.length,r=t.length;if(n>r)return!1;for(let s=1;s<=n;s++)if(1!==e[n-s]&&e[n-s]!==t[r-s])return!1;return!0}},Wn=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static convertShape(e,t=4){let n=e.length;if(0===n)return[];let r=new Array(n),s=n-1;for(;s>=0;){if(e[s]%t==0){r[s]=e[s]/t;break}if(t%e[s]!=0)throw new Error("cannot convert shape");r[s]=1,t/=e[s],s--}for(s--;s>=0;s--)r[s]=e[s];return r}static sizeFromDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,n,t.length)}static sizeToDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,n)}static getSizeFromDimensionRange(e,t,n){let r=1;for(let s=t;s<n;s++){if(e[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");r*=Number(e[s])}return r}static computeStrides(e){let t=e.length;if(0===t)return[];if(1===t)return[1];let n=new Array(t);n[t-1]=1,n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map((n=>this.normalizeAxis(n,t??e.length)))}static sortBasedOnPerm(e,t){return t?t.map((t=>e[t])):e.slice().reverse()}static padShape(e,t){let n=e.length;return e.map(((e,r)=>e+t[r]+t[r+n]))}static areEqual(e,t){return e.length===t.length&&e.every(((e,n)=>e===t[n]))}},jn=class e{static adjustPoolAttributes(e,t,n,r,s,i){if(!e&&n.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let e=0;e<t.length-2;e++)e>=n.length?n.push(t[e+2]):n[e]=t[e+2];for(let e=0;e<n.length;e++)if(e<r.length){if(r[e]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let e=0;e<n.length;e++)if(e<s.length){if(s[e]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let e=0;e<2*n.length;e++)if(e<i.length){if(i[e]<0)throw new Error("pad should be greater than or equal to 1")}else i.push(0);for(let e=0;e<n.length;e++){if(n[e]<=0)throw new Error("kernel shapes need to be greater than 0");if(i[e]>=n[e]||i[e+n.length]>=n[e])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,n,r,s,i,a,o){if(o){if(i.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(s.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let l=0;l<t.length-2;l++)e.adjustPadAndReturnShape(t[l+(a?1:2)],n[l],r[l],s[l],i,l,l+t.length-2,o)}}static computePoolOutputShape(t,n,r,s,i,a,o){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let l=[n[0],n[1]];return e.computeShapeHelper(t,n,l,r,s,i,a,o),l}static computeConvOutputShape(t,n,r,s,i,a,o){if(t.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let l=[t[0],n[0]];return e.computeShapeHelper(!1,t,l,r,s,i,a,o),l}static computeShapeHelper(t,n,r,s,i,a,o,l){if(t)for(let e=0;e<n.length-2;e++)r.push(1);else for(let t=0;t<n.length-2;t++)r.push(e.adjustPadAndReturnShape(n[t+2],s[t],i[t],a[t],o,t,t+n.length-2,l))}static adjustPadAndReturnShape(e,t,n,r,s,i,a,o){let l=n*(r-1)+1;if(!o||"NOTSET"===o)return Math.floor((e+s[i]+s[a]-l)/t+1);switch(o){case"VALID":return s[i]=0,s[a]=0,Math.floor((e-l)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let n=((e+t-1)/t-1)*t+r-e;return s[i]=Math.floor("SAME_LOWER"===o?(n+1)/2:n/2),s[a]=n-s[i],Math.floor((e+n-r)/t+1)}default:throw new Error("Unsupported AutoPad type")}}},Gn=class{static getShapeOfGemmResult(e,t,n,r,s){if(2!==e.length||2!==n.length)throw new Error("shape need to be of size 2");let i,a,o;t?(i=e[1],a=e[0]):(i=e[0],a=e[1]);let l=-1;if(r?(o=n[0],l=1):(o=n[1],l=0),n[l]!==a)throw new Error("dimension mismatch");if(i<=0||o<=0||a<=0)throw new Error("invalid shape specified");if(s&&!Vn.isValidBroadcast(s,[i,o]))throw new Error("gemm: invalid bias shape for broadcast");return[i,o,a]}},Hn=-34028234663852886e22,Kn=34028234663852886e22})),Id=ut((()=>{vd(),Td(),Xn=64,Qn=(e,t)=>{if(3===t)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(e)){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(4!==t)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${e}`)}},Yn=(e,t=1)=>{let n=Qn(e,t);return"string"==typeof n?n:n[0]},Zn=(e,t=1)=>{let n=Qn(e,t);return"string"==typeof n?n:n[1]},Jn=(...e)=>{let t=[];return e.forEach((e=>{0!==e.length&&t.push({type:12,data:e},{type:12,data:Wn.computeStrides(e)})})),t},er=e=>e%4==0?4:e%2==0?2:1,tr=(e="f32",t,n="0")=>t&&1!==t?`vec${t}<${e}>(${n})`:`${e}(${n})`,nr=(e,t,n)=>"f32"===e?n:1===t?`f32(${n})`:`vec${t}<f32>(${n})`,rr=(e,t)=>4===t?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:2===t?`(${e}.x + ${e}.y)`:3===t?`(${e}.x + ${e}.y + ${e}.z)`:e,sr=(e,t,n,r)=>e.startsWith("uniforms.")&&n>4?"string"==typeof t?"f16"===r?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:"f16"===r?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:n>1?`${e}[${t}]`:e,ir=(e,t,n,r,s)=>{let i="number"==typeof n,a=i?n:n.length,o=[...new Array(a).keys()],l=a<2?"u32":a<=4?`vec${a}<u32>`:`array<u32, ${a}>`,u=Qn(t,s),d="string"==typeof u?u:u[1],c="string"==typeof u?u:u[0],p={indices:l,value:d,storage:c,tensor:t},h=e=>"string"==typeof e?e:`${e}u`,f={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},m=i?"uniforms.":"",_=`${m}${e}_shape`,g=`${m}${e}_strides`,w="";for(let e=0;e<a-1;e++)w+=`\\n    let dim${e} = current / ${sr(g,e,a)};\\n    let rest${e} = current % ${sr(g,e,a)};\\n    indices[${e}] = dim${e};\\n    current = rest${e};\\n    `;w+=`indices[${a-1}] = current;`;let y=a<2?"":`\\n  fn o2i_${e}(offset: u32) -> ${p.indices} {\\n    var indices: ${p.indices};\\n    var current = offset;\\n    ${w}\\n    return indices;\\n  }`,b=[];if(a>=2)for(let e=a-1;e>=0;e--)b.push(`${sr(g,e,a)} * (indices[${e}])`);let x=a<2?"":`\\n  fn i2o_${e}(indices: ${p.indices}) -> u32 {\\n    return ${b.join("+")};\\n  }`,v=(...e)=>0===a?"0u":`${p.indices}(${e.map(h).join(",")})`,$=(e,t)=>a<2?`${e}`:`${sr(e,t,a)}`,k={},E=(t,n)=>(()=>{if(p.storage===p.value)return`${e}[${t}]=${n};`;if("vec2<u32>"===p.storage&&"i32"===p.value)return`${e}[${t}]=vec2<u32>(u32(${n}), select(0u, 0xFFFFFFFFu, ${n} < 0));`;if("vec2<u32>"===p.storage&&"u32"===p.value)return`${e}[${t}]=vec2<u32>(u32(${n}), 0u);`;if("u32"===p.storage&&"vec4<bool>"===p.value)return`${e}[${t}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${n}));`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),S=t=>(()=>{if(p.storage===p.value)return`${e}[${t}]`;if("vec2<u32>"===p.storage&&"i32"===p.value)return`i32(${e}[${t}].x)`;if("vec2<u32>"===p.storage&&"u32"===p.value)return`u32(${e}[${t}].x)`;if("u32"===p.storage&&"vec4<bool>"===p.value)return`vec4<bool>(bool(${e}[${t}] & 0xFFu), bool(${e}[${t}] & 0xFF00u), bool(${e}[${t}] & 0xFF0000u), bool(${e}[${t}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),z=a<2?"":`\\n  fn get_${e}ByIndices(indices: ${p.indices}) -> ${d} {\\n    return ${S(`i2o_${e}(indices)`)};\\n  }`,C=a<2?"":(()=>{let t=o.map((e=>`d${e}: u32`)).join(", "),n=o.map((e=>`d${e}`)).join(", ");return`\\n  fn get_${e}(${t}) -> ${d} {\\n    return get_${e}ByIndices(${v(n)});\\n  }`})(),T=a<2?"":`\\n  fn set_${e}ByIndices(indices: ${p.indices}, value: ${d}) {\\n    ${E(`i2o_${e}(indices)`,"value")}\\n  }`,I=a<2?"":(()=>{let t=o.map((e=>`d${e}: u32`)).join(", "),n=o.map((e=>`d${e}`)).join(", ");return`\\n  fn set_${e}(${t}, value: ${d}) {\\n    set_${e}ByIndices(${v(n)}, value);\\n  }`})();return{impl:()=>{let e=[],t=!1;return f.offsetToIndices&&(e.push(y),t=!0),f.indicesToOffset&&(e.push(x),t=!0),f.broadcastedIndicesToOffset&&(Object.values(k).forEach((t=>e.push(t))),t=!0),f.set&&(e.push(I),t=!0),f.setByIndices&&(e.push(T),t=!0),f.get&&(e.push(C),t=!0),f.getByIndices&&(e.push(z),t=!0),!i&&t&&e.unshift(`const ${_} = ${p.indices}(${n.join(",")});`,`const ${g} = ${p.indices}(${Wn.computeStrides(n).join(",")});`),e.join("\\n")},type:p,offsetToIndices:t=>(f.offsetToIndices=!0,a<2?t:`o2i_${e}(${t})`),indicesToOffset:t=>(f.indicesToOffset=!0,a<2?t:`i2o_${e}(${t})`),broadcastedIndicesToOffset:(t,n)=>{f.broadcastedIndicesToOffset=!0;let r=`${n.name}broadcastedIndicesTo${e}Offset`;if(r in k)return`${r}(${t})`;let s=[];for(let e=a-1;e>=0;e--){let t=n.indicesGet("outputIndices",e+n.rank-a);s.push(`${$(g,e)} * (${t} % ${$(_,e)})`)}return k[r]=`fn ${r}(outputIndices: ${n.type.indices}) -> u32 {\\n             return ${s.length>0?s.join("+"):"0u"};\\n           }`,`${r}(${t})`},indices:v,indicesGet:$,indicesSet:(e,t,n)=>a<2?`${e}=${n};`:`${sr(e,t,a)}=${n};`,set:(...t)=>{if(t.length!==a+1)throw new Error(`indices length must be ${a}`);let n=t[a];if("string"!=typeof n)throw new Error("value must be string");let r=t.slice(0,a).map(h).join(",");return 0===a?E("0u",n):1===a?E(r[0],n):(f.set=!0,f.setByIndices=!0,f.indicesToOffset=!0,`set_${e}(${r}, ${n})`)},setByOffset:E,setByIndices:(t,n)=>a<2?E(t,n):(f.setByIndices=!0,f.indicesToOffset=!0,`set_${e}ByIndices(${t}, ${n});`),get:(...t)=>{if(t.length!==a)throw new Error(`indices length must be ${a}`);let n=t.map(h).join(",");return 0===a?S("0u"):1===a?S(n[0]):(f.get=!0,f.getByIndices=!0,f.indicesToOffset=!0,`get_${e}(${n})`)},getByOffset:S,getByIndices:t=>a<2?S(t):(f.getByIndices=!0,f.indicesToOffset=!0,`get_${e}ByIndices(${t})`),usage:r,name:e,strides:g,shape:_,rank:a}},ar=(e,t,n,r=1)=>ir(e,t,n,"input",r),or=(e,t,n,r=1)=>ir(e,t,n,"output",r),lr=(e,t,n)=>ir(e,t,n,"atomicOutput",1),ur=(e,t,n,r=1)=>ir(e,t,n,"internal",r),dr=class{constructor(e,t){this.normalizedDispatchGroup=e,this.limits=t,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${"number"==typeof e?`${e}u`:e}) { return; }`}mainStart(e=Xn){let t="number"==typeof e?e:e[0],n="number"==typeof e?1:e[1],r="number"==typeof e?1:e[2];if(t>this.limits.maxComputeWorkgroupSizeX||n>this.limits.maxComputeWorkgroupSizeY||r>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${t}, ${n}, ${r}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(t*n*r>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${t}, ${n}, ${r}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let s=1===this.normalizedDispatchGroup[1]&&1===this.normalizedDispatchGroup[2];return`@compute @workgroup_size(${t}, ${n}, ${r})\\n  fn main(${s?"@builtin(global_invocation_id) global_id : vec3<u32>,\\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\\n    @builtin(local_invocation_index) local_idx : u32,\\n    @builtin(local_invocation_id) local_id : vec3<u32>":"@builtin(global_invocation_id) global_id : vec3<u32>,\\n                                             @builtin(local_invocation_id) local_id : vec3<u32>,\\n    @builtin(local_invocation_index) local_idx : u32,\\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\\n    @builtin(num_workgroups) num_workgroups : vec3<u32>"}) {\\n    ${s?"let global_idx = global_id.x;\\n         let workgroup_index = workgroup_id.x;":`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\\n             workgroup_id.y * num_workgroups[0] + workgroup_id.x;\\n         let global_idx = workgroup_index * ${t*n*r}u + local_idx;`}\\n  `}appendVariableUniforms(e){0!==e.rank&&(e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:"u32",length:e.rank}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:"u32",length:e.rank}))}declareVariable(e,t){if("internal"===e.usage)throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(e),this.appendVariableUniforms(e);let n="input"===e.usage?"read":"read_write",r="atomicOutput"===e.usage?"atomic<i32>":e.type.storage;return`@group(0) @binding(${t}) var<storage, ${n}> ${e.name}: array<${r}>;`}declareVariables(...e){return e.map((e=>this.declareVariable(e,this.variableIndex++))).join("\\n")}registerInternalVariable(e){if("internal"!==e.usage)throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(e),this.appendVariableUniforms(e)}registerInternalVariables(...e){return e.forEach((e=>this.registerInternalVariable(e))),this}registerUniform(e,t,n=1){return this.uniforms.push({name:e,type:t,length:n}),this}registerUniforms(e){return this.uniforms=this.uniforms.concat(e),this}uniformDeclaration(){if(0===this.uniforms.length)return"";let e=[];for(let{name:t,type:n,length:r}of this.uniforms)if(r&&r>4)"f16"===n?e.push(`@align(16) ${t}:array<mat2x4<${n}>, ${Math.ceil(r/8)}>`):e.push(`${t}:array<vec4<${n}>, ${Math.ceil(r/4)}>`);else{let s=null==r||1===r?n:`vec${r}<${n}>`;e.push(`${t}:${s}`)}return`\\n      struct Uniforms { ${e.join(", ")} };\\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map((e=>e.impl())).join("\\n")+this.internalVariables.map((e=>e.impl())).join("\\n")}get variablesInfo(){if(0===this.uniforms.length)return;let e=e=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(e)];return this.uniforms.map((t=>[e(t.type),t.length??1]))}},cr=(e,t)=>new dr(e,t)})),Ad=ut((()=>{vd(),Td(),Cd(),Id(),pr=e=>{if(!e||1!==e.length)throw new Error("Transpose requires 1 input.")},hr=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,fr=(e,t)=>Wn.sortBasedOnPerm(e,hr(e.length,t)),mr=(e,t,n,r)=>{let s=`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {\\n    var a: ${n.type.indices};`;for(let n=0;n<t;++n)s+=`a[${e[n]}]=i[${n}];`;return s+"return a;}"},_r=(e,t)=>{let n=[],r=[];for(let s=0;s<e.length;++s)1!==e[s]&&n.push(e[s]),1!==e[t[s]]&&r.push(t[s]);return{newShape:n,newPerm:r}},gr=(e,t)=>{let n=0;for(let r=0;r<e.length;++r)if(1!==t[e[r]]){if(e[r]<n)return!1;n=e[r]}return!0},wr=(e,t)=>{let n,r=e.dataType,s=e.dims.length,i=hr(s,t),a=fr(e.dims,i),o=e.dims,l=a;if(s<2||gr(i,e.dims))return n=e=>{let t=ar("input",r,o,4),n=or("output",r,l,4);return`\\n  ${e.registerUniform("output_size","u32").declareVariables(t,n)}\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n    output[global_idx] = input[global_idx];\\n  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let t=Wn.size(a);return{outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(t/64/4)},programUniforms:[{type:12,data:Math.ceil(t/4)}]}},getShaderSource:n};let{newShape:u,newPerm:d}=_r(e.dims,i),c=Wn.areEqual(d,[2,3,1]),p=Wn.areEqual(d,[3,1,2]);if(2===u.length||c||p){o=c?[u[0],u[1]*u[2]]:p?[u[0]*u[1],u[2]]:u,l=[o[1],o[0]];let t=16;return n=e=>{let n=ar("a",r,o.length),s=or("output",r,l.length);return`\\n  ${e.registerUniform("output_size","u32").declareVariables(n,s)}\\n  var<workgroup> tile : array<array<${s.type.value}, ${t+1}>, ${t}>;\\n  ${e.mainStart([t,t,1])}\\n    let stride = (uniforms.output_shape[1] - 1) / ${t} + 1;\\n    let workgroup_id_x = workgroup_index % stride;\\n    let workgroup_id_y = workgroup_index / stride;\\n    let input_col = workgroup_id_y * ${t}u + local_id.x;\\n    let input_row = workgroup_id_x * ${t}u + local_id.y;\\n    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {\\n      tile[local_id.y][local_id.x] = ${n.getByIndices(`${n.type.indices}(input_row, input_col)`)};\\n    }\\n    workgroupBarrier();\\n\\n    let output_col = workgroup_id_x * ${t}u + local_id.x;\\n    let output_row = workgroup_id_y * ${t}u + local_id.y;\\n    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {\\n      ${s.setByIndices(`${s.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}\\n    }\\n  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let n=Wn.size(a);return{outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(l[1]/t),y:Math.ceil(l[0]/t)},programUniforms:[{type:12,data:n},...Jn(o,l)]}},getShaderSource:n}}return n=e=>{let t=ar("a",r,o.length),n=or("output",r,l.length);return`\\n  ${e.registerUniform("output_size","u32").declareVariables(t,n)}\\n\\n  ${mr(i,s,t,n)}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n\\n    let indices = ${n.offsetToIndices("global_idx")};\\n    let aIndices = perm(indices);\\n\\n    ${n.setByOffset("global_idx",t.getByIndices("aIndices"))}\\n  }`},{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:["rank"]},getRunData:()=>{let t=Wn.size(a);return{outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(t/64)},programUniforms:[{type:12,data:t},...Jn(o,l)]}},getShaderSource:n}},yr=(e,t)=>{pr(e.inputs),e.compute(wr(e.inputs[0],t.perm))},br=e=>Un({perm:e.perm})})),Md=ut((()=>{vd(),Td(),Id(),Od(),Ad(),xr={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},vr={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},$r={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},kr={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Er=(e,t)=>{let n=[];for(let r=t-e;r<t;++r)n.push(r);return n},Sr=(e,t)=>{let n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);return[n,t.map((t=>e[t]))]},zr=(e,t)=>{let n=e.length+t.length,r=[],s=0;for(let i=0;i<n;i++)-1===t.indexOf(i)?r.push(e[s++]):r.push(1);return r},Cr=(e,t)=>{for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0},Tr=(e,t)=>{let n=[];if(!Cr(e,t)){for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);e.forEach((e=>n.push(e)))}return n},Ir=(e,t,n,r,s,i,a)=>{let o=n[0].dims,l=Wn.size(i),u=Wn.size(a),d=ar("_A",n[0].dataType,o),c=or("output",s,i),p=64;1===l&&(p=256);let h=`\\n          var<workgroup> aBestValues : array<f32, ${p}>;\\n       `;return{name:e,shaderCache:{hint:`${t};${p}`,inputDependencies:["type"]},getShaderSource:e=>`\\n        ${e.registerUniform("reduceSize","u32").declareVariables(d,c)}\\n        ${h}\\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\\n          return ((a - 1u) / b + 1u);\\n         }\\n         ${e.mainStart(p)}\\n\\n          let outputIndex = global_idx / ${p};\\n          let offset = outputIndex * uniforms.reduceSize;\\n\\n          var bestValue = f32(${$r[r]});\\n          let Length = uniforms.reduceSize;\\n          for (var k = local_idx; k < Length; k = k + ${p}) {\\n           let candidate = f32(${d.getByOffset("offset + k")});\\n           bestValue = ${xr[r]};\\n          }\\n          aBestValues[local_idx] = bestValue;\\n          workgroupBarrier();\\n\\n         var reduceSize = min(Length, ${p}u);\\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\\n             currentSize = reduceSize / 2u) {\\n           let interval = DIV_CEIL(reduceSize, 2u);\\n           if (local_idx < currentSize) {\\n            let candidate = aBestValues[local_idx + interval];\\n            bestValue = ${vr[r]};\\n            aBestValues[local_idx] = bestValue;\\n           }\\n           reduceSize = interval;\\n           workgroupBarrier();\\n         }\\n\\n         if (local_idx == 0u) {\\n          ${c.setByOffset("outputIndex",""+("mean"===r?`${c.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${c.type.storage}(${kr[r]})`))};\\n         }\\n        }`,getRunData:()=>({outputs:[{dims:i,dataType:s}],dispatchGroup:{x:l},programUniforms:[{type:12,data:u}]})}},Ar=(e,t,n,r)=>{let s=1===e.inputs.length?n:jr(e.inputs,n),i=s.axes;0===i.length&&!s.noopWithEmptyAxes&&(i=e.inputs[0].dims.map(((e,t)=>t)));let a=Wn.normalizeAxes(i,e.inputs[0].dims.length),o=a,l=e.inputs[0],u=Tr(o,e.inputs[0].dims.length);u.length>0&&(l=e.compute(wr(e.inputs[0],u),{inputs:[0],outputs:[-1]})[0],o=Er(o.length,l.dims.length));let[d,c]=Sr(l.dims,o),p=d;s.keepDims&&(p=zr(d,a)),e.compute(Ir(t,s.cacheKey,[l],r,e.inputs[0].dataType,p,c),{inputs:[l]})},Mr=(e,t)=>{Ar(e,"ReduceMeanShared",t,"mean")},Or=(e,t)=>{Ar(e,"ReduceL1Shared",t,"l1")},Br=(e,t)=>{Ar(e,"ReduceL2Shared",t,"l2")},Nr=(e,t)=>{Ar(e,"ReduceLogSumExpShared",t,"logSumExp")},Pr=(e,t)=>{Ar(e,"ReduceMaxShared",t,"max")},Rr=(e,t)=>{Ar(e,"ReduceMinShared",t,"min")},Dr=(e,t)=>{Ar(e,"ReduceProdShared",t,"prod")},Fr=(e,t)=>{Ar(e,"ReduceSumShared",t,"sum")},Lr=(e,t)=>{Ar(e,"ReduceSumSquareShared",t,"sumSquare")},Ur=(e,t)=>{Ar(e,"ReduceLogSumShared",t,"logSum")}})),Od=ut((()=>{vd(),Td(),Cd(),Id(),Md(),qr=e=>{if(!e||0===e.length||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(2===e.length&&1!==e[1].dims.length)throw new Error("Invalid axes input dims.")},Vr=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],Wr=(e,t,n,r,s,i,a=!1,o=!1)=>{let l=[],u=n[0].dims,d=u.length,c=Wn.normalizeAxes(s,d),p=!o&&0===c.length;u.forEach(((e,t)=>{p||c.indexOf(t)>=0?a&&l.push(1):l.push(e)}));let h=l.length,f=Wn.size(l);return{name:e,shaderCache:t,getShaderSource:e=>{let t=[],s=ar("_A",n[0].dataType,d),o=or("output",i,h),l=r(s,o,c),f=l[2];for(let e=0,n=0;e<d;e++)p||c.indexOf(e)>=0?(a&&n++,f=`for(var j${e}: u32 = 0; j${e} < ${u[e]}; j${e}++) {\\n                  ${l[2].includes("last_index")?`let last_index = j${e};`:""}\\n                  ${s.indicesSet("input_indices",e,`j${e}`)}\\n                  ${f}\\n                }`):(t.push(`${s.indicesSet("input_indices",e,o.indicesGet("output_indices",n))};`),n++);return`\\n\\n        ${e.registerUniform("output_size","u32").declareVariables(s,o)}\\n\\n        ${e.mainStart()}\\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n          var input_indices: ${s.type.indices};\\n          let output_indices = ${o.offsetToIndices("global_idx")};\\n\\n          ${t.join("\\n")}\\n          ${l[0]}       // init ops for reduce max/min\\n          ${l[1]}\\n          ${f}\\n          ${l[3]}\\n          ${4===l.length?o.setByOffset("global_idx","value"):l.slice(4).join("\\n")}\\n        }`},getRunData:()=>({outputs:[{dims:l,dataType:i}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:[{type:12,data:f},...Jn(u,l)]})}},jr=(e,t)=>{let n=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach((e=>n.push(Number(e)))),Un({axes:n,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},Gr=(e,t,n,r)=>{let s=e.inputs,i=1===s.length?n:jr(s,n);e.compute(Wr(t,{hint:i.cacheKey,inputDependencies:["rank"]},[s[0]],i.noopWithEmptyAxes&&0===i.axes.length?Vr:r,i.axes,s[0].dataType,i.keepDims,i.noopWithEmptyAxes),{inputs:[0]})},Hr=(e,t)=>{qr(e.inputs),Gr(e,"ReduceLogSum",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByIndices("input_indices")};`,"value = log(value);"]))},Kr=(e,t)=>{qr(e.inputs),Gr(e,"ReduceL1",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += abs(${e.getByIndices("input_indices")});`,""]))},Xr=(e,t)=>{qr(e.inputs),Gr(e,"ReduceL2",t,((e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"]))},Qr=(e,t)=>{qr(e.inputs),Gr(e,"ReduceLogSumExp",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += exp(${e.getByIndices("input_indices")});`,"value = log(value);"]))},Yr=(e,t)=>{qr(e.inputs),Gr(e,"ReduceMax",t,((e,t,n)=>{let r=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&r.push(e.indicesSet("input_indices",t,0));return[`${r.join("\\n")}`,`var value = ${e.getByIndices("input_indices")};`,`value = max(value, ${e.getByIndices("input_indices")});`,""]}))},Zr=(e,t)=>{qr(e.inputs),Gr(e,"ReduceMean",t,((t,n,r)=>{let s=1;for(let n=0;n<t.rank;n++)(r.indexOf(n)>=0||0===r.length)&&(s*=e.inputs[0].dims[n]);return["var sum = f32(0);","",`sum += f32(${t.getByIndices("input_indices")});`,`let value = ${n.type.value}(sum / ${s});`]}))},Jr=(e,t)=>{qr(e.inputs),Gr(e,"ReduceMin",t,((e,t,n)=>{let r=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&r.push(`input_indices[${t}] = 0;`);return[`${r.join("\\n")}`,`var value = ${e.getByIndices("input_indices")};`,`value = min(value, ${e.getByIndices("input_indices")});`,""]}))},es=(e,t)=>{qr(e.inputs),Gr(e,"ReduceProd",t,((e,t)=>[`var value = ${t.type.storage}(1);`,"",`value *= ${e.getByIndices("input_indices")};`,""]))},ts=(e,t)=>{qr(e.inputs),Gr(e,"ReduceSum",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByIndices("input_indices")};`,""]))},ns=(e,t)=>{qr(e.inputs),Gr(e,"ReduceSumSquare",t,((e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByIndices("input_indices")}; value += t * t;`,""]))},rs=(e,t,n)=>{if(0===t.length)return n;let r=1,s=1;for(let n=0;n<t.length;n++)-1===t.indexOf(n)?r*=e[n]:s*=e[n];return s<32&&r>1024},ss=(e,t)=>{rs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Zr(e,t):Mr(e,t)},is=(e,t)=>{rs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Kr(e,t):Or(e,t)},as=(e,t)=>{rs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Xr(e,t):Br(e,t)},os=(e,t)=>{rs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Qr(e,t):Nr(e,t)},ls=(e,t)=>{rs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Yr(e,t):Pr(e,t)},us=(e,t)=>{rs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Jr(e,t):Rr(e,t)},ds=(e,t)=>{rs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?es(e,t):Dr(e,t)},cs=(e,t)=>{rs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ts(e,t):Fr(e,t)},ps=(e,t)=>{rs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ns(e,t):Lr(e,t)},hs=(e,t)=>{rs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Hr(e,t):Ur(e,t)}})),Bd=ut((()=>{vd(),Cd(),Od(),fs=e=>{if(!e||0===e.length||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(1!==e[0].dataType)throw new Error("Invalid input type.")},ms=(e,t)=>{fs(e.inputs);e.compute(Wr("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],((e,n,r)=>{let s=[];for(let t=0;t<e.rank;t++)(r.indexOf(t)>=0||0===r.length)&&s.push(`input_indices[${t}] = 0;`);return[`${s.join("\\n")}`,`var value = ${e.getByIndices("input_indices")};\\nvar best_index : i32 = 0;`,`if (${e.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {\\n         value = ${e.getByIndices("input_indices")};\\n         best_index = i32(last_index);\\n       }`,"",n.setByOffset("global_idx","best_index")]}),[t.axis],7,t.keepDims),{inputs:[0]})},_s=(e,t)=>{fs(e.inputs);e.compute(Wr("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],((e,n,r)=>{let s=[];for(let t=0;t<e.rank;t++)(r.indexOf(t)>=0||0===r.length)&&s.push(`input_indices[${t}] = 0;`);return[`${s.join("\\n")}`,`var value = ${e.getByIndices("input_indices")};\\nvar best_index : i32 = 0;`,`if (${e.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {\\n         value = ${e.getByIndices("input_indices")};\\n         best_index = i32(last_index);\\n       }`,"",n.setByOffset("global_idx","best_index")]}),[t.axis],7,t.keepDims),{inputs:[0]})},gs=e=>Un(e)})),Nd=ut((()=>{vd(),Td(),Sd(),Id(),ws=(e,t)=>{let n=e[0],r=e[1],s=e[2],i=e[3],a=e[4],o=e[5];if(a&&o)throw new Error("Attention cannot have both past and attention_bias");if(3!==n.dims.length)throw new Error(\'Input "input" must have 3 dimensions\');let l=n.dims[0],u=n.dims[1],d=n.dims[2];if(1!==s.dims.length)throw new Error(\'Input "bias" is expected to have 1 dimensions\');if(2!==r.dims.length)throw new Error(\'Input "weights" is expected to have 2 dimensions\');if(r.dims[0]!==d)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(s.dims[0]!==r.dims[1])throw new Error(\'Input "bias" dimension 0 should have same length as dimension 1 of input "weights"\');let c=s.dims[0]/3,p=c,h=p;if(t.qkvHiddenSizes.length>0){if(3!==t.qkvHiddenSizes.length)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let e of t.qkvHiddenSizes)if(e%t.numHeads!=0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");c=t.qkvHiddenSizes[0],p=t.qkvHiddenSizes[1],h=t.qkvHiddenSizes[2]}let f=u;if(c!==p)throw new Error("qkv_hidden_sizes first element should be same as the second");if(s.dims[0]!==c+p+h)throw new Error(\'Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes\');let m=0;if(a){if(p!==h)throw new Error(\'Input "past" expect k_hidden_size == v_hidden_size\');if(5!==a.dims.length)throw new Error(\'Input "past" must have 5 dimensions\');if(2!==a.dims[0])throw new Error(\'Input "past" first dimension must be 2\');if(a.dims[1]!==l)throw new Error(\'Input "past" second dimension must be batch_size\');if(a.dims[2]!==t.numHeads)throw new Error(\'Input "past" third dimension must be num_heads\');if(a.dims[4]!==p/t.numHeads)throw new Error(\'Input "past" fifth dimension must be k_hidden_size / num_heads\');t.pastPresentShareBuffer||(m=a.dims[3])}let _=f+m;if(i)throw new Error("Mask not supported");if(a)throw new Error("past is not supported");if(o){if(4!==o.dims.length)throw new Error(\'Input "attention_bias" must have 4 dimensions\');if(o.dims[0]!==l||o.dims[1]!==t.numHeads||o.dims[2]!==u||o.dims[3]!==_)throw new Error(\'Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)\')}return{batchSize:l,sequenceLength:u,pastSequenceLength:m,kvSequenceLength:f,totalSequenceLength:_,maxSequenceLength:-1,inputHiddenSize:d,hiddenSize:c,vHiddenSize:h,headSize:Math.floor(c/t.numHeads),vHeadSize:Math.floor(h/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:0,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},ys=(e,t,n)=>t&&e?`\\n      let total_sequence_length_input = u32(${t.getByOffset("0")});\\n      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);\\n      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;\\n      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;\\n      total_sequence_length = u32(${e?.getByOffset("batchIdx")}) + 1;\\n      var past_sequence_length: u32 = 0;\\n      if (is_first_prompt == false) {\\n        past_sequence_length = total_sequence_length - sequence_length;\\n      }\\n       `:`\\n    ${n?"let past_sequence_length = uniforms.past_sequence_length":""};\\n    let present_sequence_length = total_sequence_length;\\n    `,bs=(e,t,n,r,s,i,a,o)=>{let l=er(a?1:i),u=64,d=i/l;d<u&&(u=32);let c=Math.ceil(i/l/u),p=[{type:12,data:t},{type:12,data:n},{type:12,data:r},{type:12,data:s},{type:12,data:d},{type:12,data:c}],h=Yn(e.dataType,l),f=Zn(1,l),m=["type"];a&&m.push("type"),o&&m.push("type");return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${u};${h};${l}`,inputDependencies:m},getShaderSource:t=>{let n=or("x",e.dataType,e.dims,l),r=[n],s=a?ar("seq_lens",a.dataType,a.dims):void 0;s&&r.push(s);let i=o?ar("total_sequence_length_input",o.dataType,o.dims):void 0;i&&r.push(i);let d=Zn(e.dataType);return`\\n  var<workgroup> thread_max: array<f32, ${u}>;\\n  var<workgroup> thread_sum: array<f32, ${u}>;\\n  ${t.registerUniforms([{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}]).declareVariables(...r)}\\n  ${t.mainStart([u,1,1])}\\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\\n    let headIdx = workgroup_id.z % uniforms.num_heads;\\n    let sequence_length = uniforms.sequence_length;\\n    var total_sequence_length = uniforms.total_sequence_length;\\n    ${ys(s,i,!1)}\\n    let local_offset = local_idx * uniforms.elements_per_thread;\\n    let offset = (global_idx / ${u}) * uniforms.total_sequence_length + local_offset;\\n    let seq_causal_length = ${a?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};\\n    var thread_max_vector = ${f}(-3.402823e+38f);\\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\\n      thread_max_vector = max(${f}(x[offset + i]), thread_max_vector);\\n    }\\n    thread_max[local_idx] = ${(()=>{switch(l){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${l}`)}})()};\\n    workgroupBarrier();\\n\\n    var max_value =  f32(-3.402823e+38f);\\n    for (var i = 0u; i < ${u}; i++) {\\n      max_value = max(thread_max[i], max_value);\\n    }\\n\\n    var sum_vector = ${f}(0);\\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\\n      sum_vector += exp(${f}(x[offset + i]) - max_value);\\n    }\\n    thread_sum[local_idx] = ${(()=>{switch(l){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${l}`)}})()};\\n    workgroupBarrier();\\n\\n    var sum: f32 = 0;\\n    for (var i = 0u; i < ${u}; i++) {\\n      sum += thread_sum[i];\\n    }\\n\\n    if (sum == 0) {\\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\\n        x[offset + i] = ${n.type.value}(${d}(1.0) / ${d}(seq_causal_length));\\n      }\\n    } else {\\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\\n        var f32input = ${f}(x[offset + i]);\\n        x[offset + i] = ${n.type.value}(exp(f32input - max_value) / sum);\\n      }\\n    }\\n      ${a?`\\n        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {\\n          x[offset + total_seq_id] = ${n.type.value}(${d}(0));\\n        }`:""};\\n  }`},getRunData:()=>({outputs:[],dispatchGroup:{x:Math.ceil(i/u),y:s,z:t*n},programUniforms:p})}},xs=(e,t,n,r,s,i,a,o,l)=>{let u=a+i.kvSequenceLength,d=[i.batchSize,i.numHeads,i.sequenceLength,u],c=e>1&&r,p=i.kvNumHeads?i.kvNumHeads:i.numHeads,h=c?[i.batchSize,p,u,i.headSize]:void 0,f=i.nReps?i.nReps:1,m=0===i.scale?1/Math.sqrt(i.headSize):i.scale,_=er(i.headSize),g=i.headSize/_,w=12,y={x:Math.ceil(u/w),y:Math.ceil(i.sequenceLength/w),z:i.batchSize*i.numHeads},b=[{type:12,data:i.sequenceLength},{type:12,data:g},{type:12,data:u},{type:12,data:i.numHeads},{type:12,data:i.headSize},{type:1,data:m},{type:12,data:a},{type:12,data:i.kvSequenceLength},{type:12,data:f}],x=c&&r&&Wn.size(r.dims)>0,v=["type","type"];x&&v.push("type"),s&&v.push("type"),o&&v.push("type"),l&&v.push("type");let $=[{dims:d,dataType:t.dataType,gpuDataType:0}];c&&$.push({dims:h,dataType:t.dataType,gpuDataType:0});return{name:"AttentionProbs",shaderCache:{hint:`${_};${void 0!==s};${void 0!==r};${e}`,inputDependencies:v},getRunData:()=>({outputs:$,dispatchGroup:y,programUniforms:b}),getShaderSource:e=>{let i=ar("q",t.dataType,t.dims,_),a=[i,ar("key",n.dataType,n.dims,_)];if(x){let e=ar("past_key",r.dataType,r.dims,_);a.push(e)}s&&a.push(ar("attention_bias",s.dataType,s.dims));let u=o?ar("seq_lens",o.dataType,o.dims):void 0;u&&a.push(u);let p=l?ar("total_sequence_length_input",l.dataType,l.dims):void 0;p&&a.push(p);let m=or("output",t.dataType,d),g=[m];c&&g.push(or("present_key",t.dataType,h,_));let y=Zn(1,_);return`\\n  const TILE_SIZE = 12u;\\n\\n  var<workgroup> tileQ: array<${i.type.storage}, 144>;\\n  var<workgroup> tileK: array<${i.type.storage}, 144>;\\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}]).declareVariables(...a,...g)}\\n  ${e.mainStart([w,w,1])}\\n    // x holds the N and y holds the M\\n    let headIdx = workgroup_id.z % uniforms.num_heads;\\n    let kvHeadIdx = ${1===f?"headIdx":"headIdx / uniforms.n_reps"};\\n    let kv_num_heads = ${1===f?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};\\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\\n    let m = workgroup_id.y * TILE_SIZE;\\n    let n = workgroup_id.x * TILE_SIZE;\\n    let sequence_length = uniforms.M;\\n    var total_sequence_length = uniforms.N;\\n    ${ys(u,p,!0)}\\n    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;\\n    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\\n    ${x&&c?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};\\n    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;\\n    ${c?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}\\n    var value = ${y}(0);\\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\\n      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {\\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\\n      }\\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\\n        var idx = TILE_SIZE * local_id.y + local_id.x;\\n      ${x&&c?"\\n              if (n + local_id.y < past_sequence_length) {\\n                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\\n              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\\n                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];\\n              }":"\\n          if (n + local_id.y < uniforms.kv_sequence_length) {\\n            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\\n          }"}\\n      ${c?"if (n + local_id.y < present_sequence_length) {\\n        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];\\n      }":""}\\n      }\\n      workgroupBarrier();\\n\\n      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\\n          value += ${y}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);\\n      }\\n\\n      workgroupBarrier();\\n    }\\n\\n    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {\\n      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;\\n      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;\\n      var sum: f32 = ${(()=>{switch(_){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${_}`)}})()};\\n        output[outputIdx] = ${m.type.value} (sum * uniforms.alpha) + ${s?"attention_bias[outputIdx]":"0.0"};\\n    }\\n  }`}}},vs=(e,t,n,r,s,i,a=void 0,o=void 0)=>{let l=i+s.kvSequenceLength,u=s.nReps?s.nReps:1,d=s.vHiddenSize*u,c=e>1&&r,p=s.kvNumHeads?s.kvNumHeads:s.numHeads,h=c?[s.batchSize,p,l,s.headSize]:void 0,f=[s.batchSize,s.sequenceLength,d],m=12,_={x:Math.ceil(s.vHeadSize/m),y:Math.ceil(s.sequenceLength/m),z:s.batchSize*s.numHeads},g=[{type:12,data:s.sequenceLength},{type:12,data:l},{type:12,data:s.vHeadSize},{type:12,data:s.numHeads},{type:12,data:s.headSize},{type:12,data:d},{type:12,data:i},{type:12,data:s.kvSequenceLength},{type:12,data:u}],w=c&&r&&Wn.size(r.dims)>0,y=["type","type"];w&&y.push("type"),a&&y.push("type"),o&&y.push("type");let b=[{dims:f,dataType:t.dataType,gpuDataType:0}];c&&b.push({dims:h,dataType:t.dataType,gpuDataType:0});return{name:"AttentionScore",shaderCache:{hint:`${void 0!==r};${e}`,inputDependencies:y},getRunData:()=>({outputs:b,dispatchGroup:_,programUniforms:g}),getShaderSource:e=>{let s=ar("probs",t.dataType,t.dims),i=[s,ar("v",n.dataType,n.dims)];w&&i.push(ar("past_value",r.dataType,r.dims));let l=a?ar("seq_lens",a.dataType,a.dims):void 0;a&&i.push(l);let d=o?ar("total_sequence_length_input",o.dataType,o.dims):void 0;o&&i.push(d);let p=[or("output",t.dataType,f)];c&&p.push(or("present_value",t.dataType,h));return`\\n  const TILE_SIZE = 12u;\\n  var<workgroup> tileQ: array<${s.type.value}, 144>;\\n  var<workgroup> tileV: array<${s.type.value}, 144>;\\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}]).declareVariables(...i,...p)}\\n  ${e.mainStart([m,m,1])}\\n   let headIdx = workgroup_id.z % uniforms.num_heads;\\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\\n   let kvHeadIdx = ${1===u?"headIdx":"headIdx / uniforms.n_reps"};\\n   let kv_num_heads = ${1===u?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};\\n   let m = global_id.y;\\n   let n = global_id.x;\\n   let sequence_length = uniforms.M;\\n   var total_sequence_length = uniforms.K;\\n   ${ys(l,d,!0)}\\n   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\\n   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch\\n   ${w&&c?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};\\n   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;\\n   ${c?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}\\n   var value = ${s.type.storage}(0);\\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\\n      }\\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\\n        var idx = TILE_SIZE * local_id.y + local_id.x;\\n        ${w&&c?"\\n        if (w + local_id.y < past_sequence_length) {\\n          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];\\n        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\\n          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];\\n        }\\n      ":"\\n            if (w + local_id.y < uniforms.kv_sequence_length) {\\n              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];\\n            }"}\\n        ${c?"\\n            if (w + local_id.y < present_sequence_length) {\\n          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];\\n        }":""}\\n      }\\n     workgroupBarrier();\\n     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {\\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];\\n     }\\n     workgroupBarrier();\\n   }\\n\\n   // we need to transpose output from BNSH_v to BSND_v\\n   if (m < uniforms.M && n < uniforms.N) {\\n     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size\\n       + headIdx * uniforms.N + n;\\n     output[outputIdx] = value;\\n   }\\n  }`}}},$s=(e,t,n,r,s,i,a,o,l,u,d=void 0,c=void 0)=>{let p=Math.min(e.outputCount,1+(a?1:0)+(o?1:0)),h=p>1?u.pastSequenceLength:0,f=h+u.kvSequenceLength,m=l&&Wn.size(l.dims)>0?l:void 0,_=[t,n];p>1&&a&&Wn.size(a.dims)>0&&_.push(a),m&&_.push(m),d&&_.push(d),c&&_.push(c);let g=e.compute(xs(p,t,n,a,m,u,h,d,c),{inputs:_,outputs:p>1?[-1,1]:[-1]})[0];e.compute(bs(g,u.batchSize,u.numHeads,h,u.sequenceLength,f,d,c),{inputs:d&&c?[g,d,c]:[g],outputs:[]});let w=[g,r];p>1&&o&&Wn.size(o.dims)>0&&w.push(o),d&&w.push(d),c&&w.push(c),e.compute(vs(p,g,r,o,u,h,d,c),{inputs:w,outputs:p>1?[0,2]:[0]})},ks=(e,t)=>{let n=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],r=t.sequenceLength,s=t.inputHiddenSize,i=t.headSize,a=12,o={x:Math.ceil(t.headSize/a),y:Math.ceil(t.sequenceLength/a),z:t.batchSize*t.numHeads},l=[e.inputs[0],e.inputs[1],e.inputs[2]],u=[{type:12,data:r},{type:12,data:s},{type:12,data:i},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}];return e.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:o,programUniforms:u}),getShaderSource:e=>{let t=or("output_q",l[0].dataType,n),r=or("output_k",l[0].dataType,n),s=or("output_v",l[0].dataType,n),i=ar("input",l[0].dataType,l[0].dims),o=ar("weight",l[1].dataType,l[1].dims),u=ar("bias",l[2].dataType,l[2].dims),d=i.type.storage;return`\\n  const TILE_SIZE = 12u;\\n  var<workgroup> tileInput: array<${d}, 144>;\\n  var<workgroup> tileWeightQ: array<${d}, 144>;\\n  var<workgroup> tileWeightK: array<${d}, 144>;\\n  var<workgroup> tileWeightV: array<${d}, 144>;\\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}]).declareVariables(i,o,u,t,r,s)}\\n  ${e.mainStart([a,a,1])}\\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\\n    let headNumber = workgroup_id.z % uniforms.num_heads;\\n    let m = global_id.y;\\n    let n = global_id.x;\\n\\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\\n    let biasOffsetQ = headNumber * uniforms.head_size;\\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\\n\\n    var valueQ = ${d}(0);\\n    var valueK = ${d}(0);\\n    var valueV = ${d}(0);\\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\\n      }\\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\\n        let offset = n + (w + local_id.y) * uniforms.ldb;\\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\\n      }\\n      workgroupBarrier();\\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\\n      }\\n\\n      workgroupBarrier();\\n    }\\n\\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\\n    valueQ += bias[headOffset + biasOffsetQ];\\n    valueK += bias[headOffset + biasOffsetK];\\n    valueV += bias[headOffset + biasOffsetV];\\n\\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\\n    if (m < uniforms.M && n < uniforms.N) {\\n      let outputIdx = offset + m * uniforms.N + n;\\n      output_q[outputIdx] = valueQ;\\n      output_k[outputIdx] = valueK;\\n      output_v[outputIdx] = valueV;\\n    }\\n  }`}},{inputs:l,outputs:[-1,-1,-1]})},Es=(e,t)=>{let n=ws(e.inputs,t),[r,s,i]=ks(e,n);return $s(e,r,s,i,e.inputs[4],void 0,void 0,void 0,e.inputs[5],n)}})),Pd=ut((()=>{At(),vd(),Td(),Cd(),Id(),Ss=(e,t)=>{if(!e||5!==e.length)throw new Error("BatchNormalization requires 5 inputs");let n=(e,t,n)=>{let r=t.length;if(r!==e.length)throw new Error(`${n}: num dimensions != ${r}`);t.forEach(((t,r)=>{if(t!==e[r])throw new Error(`${n}: dim[${r}] do not match`)}))};if(e[0].dims.length>1){let r="NHWC"===t.format?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);n(e[1].dims,r,"Invalid input scale"),n(e[2].dims,r,"Invalid input B"),n(e[3].dims,r,"Invalid input mean"),n(e[4].dims,r,"Invalid input var")}else n(e[1].dims,[1],"Invalid input scale"),n(e[2].dims,[1],"Invalid input B"),n(e[3].dims,[1],"Invalid input mean"),n(e[4].dims,[1],"Invalid input var")},zs=(e,t)=>{let{epsilon:n,spatial:r,format:s}=t,i=e[0].dims,a=r?er(i[i.length-1]):1,o="NHWC"===s&&i.length>1?a:1,l=Wn.size(i)/a,u=r,d=u?i.length:i,c=ar("x",e[0].dataType,e[0].dims,a),p=ar("scale",e[1].dataType,e[1].dims,o),h=ar("bias",e[2].dataType,e[2].dims,o),f=ar("inputMean",e[3].dataType,e[3].dims,o),m=ar("inputVar",e[4].dataType,e[4].dims,o),_=or("y",e[0].dataType,d,a);return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${r}_${a}`,inputDependencies:u?["rank","type","type","type","type"]:void 0},getShaderSource:e=>`\\n  const epsilon = ${n};\\n  ${e.registerUniform("outputSize","u32").declareVariables(c,p,h,f,m,_)}\\n  ${e.mainStart()}\\n  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n    var outputIndices = ${_.offsetToIndices(`global_idx * ${a}`)};\\n    ${(()=>{let e="";if(r)e=`let cOffset = ${1===i.length?"0u":"NHWC"===s?`outputIndices[${i.length-1}] / ${a}`:"outputIndices[1]"};`;else if("NCHW"===s)e=`\\n            ${_.indicesSet("outputIndices","0","0")}\\n            let cOffset = ${_.indicesToOffset("outputIndices")};`;else{e=`var cIndices = ${p.type.indices}(0);\\n                       cIndices[0] = outputIndices[${i.length-1}];`;for(let t=1;t<p.rank;t++)e+=`cIndices[${t}] = outputIndices[${t}];`;e+=`let cOffset = ${p.indicesToOffset("cIndices")};`}return e})()}\\n    let scale = ${p.getByOffset("cOffset")};\\n    let bias = ${h.getByOffset("cOffset")};\\n    let inputMean = ${f.getByOffset("cOffset")};\\n    let inputVar = ${m.getByOffset("cOffset")};\\n    let x = ${c.getByOffset("global_idx")};\\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\\n    ${_.setByOffset("global_idx","value")}\\n  }`,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u?[{type:12,data:l},...Jn(i)]:[{type:12,data:l}]})}},Cs=e=>Un(e),Ts=(e,t)=>{let{inputs:n,outputCount:r}=e,s=Cs({...t,outputCount:r});if(Oe.webgpu.validateInputContent&&Ss(n,s),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(zs(n,s))}})),Rd=ut((()=>{Td(),Id(),Is=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},As=e=>{let t=e[0].dims,n=e[0].dims[2],r=Wn.size(t)/4,s=e[0].dataType,i=ar("input",s,t,4),a=ar("bias",s,[n],4),o=ar("residual",s,t,4),l=or("output",s,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(r/64)}}),getShaderSource:e=>`\\n  const channels = ${n}u / 4;\\n  ${e.declareVariables(i,a,o,l)}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(r)}\\n    let value = ${i.getByOffset("global_idx")}\\n      + ${a.getByOffset("global_idx % channels")} + ${o.getByOffset("global_idx")};\\n    ${l.setByOffset("global_idx","value")}\\n  }`}},Ms=e=>{Is(e.inputs),e.compute(As(e.inputs))}})),Dd=ut((()=>{vd(),Td(),Cd(),Id(),Os=(e,t,n,r,s,i,a)=>{let o=Math.ceil(t/4),l="";l="string"==typeof s?`${s}(a)`:s("a");let u=ar("inputData",n,[o],4),d=or("outputData",r,[o],4),c=[{name:"vec_size",type:"u32"}];return a&&c.push(...a),`\\n      ${e.registerUniforms(c).declareVariables(u,d)}\\n\\n  ${i??""}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\\n\\n    let a = ${u.getByOffset("global_idx")};\\n    ${d.setByOffset("global_idx",l)}\\n  }`},Bs=(e,t,n,r,s,i=e.dataType,a,o)=>{let l=[{type:12,data:Math.ceil(Wn.size(e.dims)/4)}];return a&&l.push(...a),{name:t,shaderCache:{hint:s,inputDependencies:["type"]},getShaderSource:t=>Os(t,Wn.size(e.dims),e.dataType,i,n,r,o),getRunData:t=>({outputs:[{dims:e.dims,dataType:i}],dispatchGroup:{x:Math.ceil(Wn.size(t[0].dims)/64/4)},programUniforms:l})}},Ns=e=>{e.compute(Bs(e.inputs[0],"Abs","abs"))},Ps=e=>{e.compute(Bs(e.inputs[0],"Acos","acos"))},Rs=e=>{e.compute(Bs(e.inputs[0],"Acosh","acosh"))},Ds=e=>{e.compute(Bs(e.inputs[0],"Asin","asin"))},Fs=e=>{e.compute(Bs(e.inputs[0],"Asinh","asinh"))},Ls=e=>{e.compute(Bs(e.inputs[0],"Atan","atan"))},Us=e=>{e.compute(Bs(e.inputs[0],"Atanh","atanh"))},qs=e=>Un(e),Vs=(e,t)=>{let n;switch(t.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute(Bs(e.inputs[0],"Cast",n,void 0,t.cacheKey,t.to))},Ws=e=>{let t,n,r=e.length>=2&&0!==e[1].data,s=e.length>=3&&0!==e[2].data;switch(e[0].dataType){case 1:t=r?e[1].getFloat32Array()[0]:-34028234663852886e22,n=s?e[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:t=r?e[1].getUint16Array()[0]:64511,n=s?e[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return Un({min:t,max:n})},js=(e,t)=>{let n=t||Ws(e.inputs),r=Zn(e.inputs[0].dataType);e.compute(Bs(e.inputs[0],"Clip",(e=>`clamp(${e}, vec4<${r}>(uniforms.min), vec4<${r}>(uniforms.max))`),void 0,n.cacheKey,void 0,[{type:e.inputs[0].dataType,data:n.min},{type:e.inputs[0].dataType,data:n.max}],[{name:"min",type:r},{name:"max",type:r}]),{inputs:[0]})},Gs=e=>{e.compute(Bs(e.inputs[0],"Ceil","ceil"))},Hs=e=>{e.compute(Bs(e.inputs[0],"Cos","cos"))},Ks=e=>{e.compute(Bs(e.inputs[0],"Cosh","cosh"))},Xs=e=>Un(e),Qs=(e,t)=>{let n=Zn(e.inputs[0].dataType);e.compute(Bs(e.inputs[0],"Elu",(e=>`elu_vf32(${e})`),`\\n  const elu_alpha_ = ${n}(${t.alpha});\\n\\n  fn elu_f32(a: ${n}) -> ${n} {\\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\\n  }\\n\\n  fn elu_vf32(v: vec4<${n}>) -> vec4<${n}> {\\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\\n  }`,t.cacheKey))},Ys=(e="f32")=>`\\nconst r0: ${e} = 0.3275911;\\nconst r1: ${e} = 0.254829592;\\nconst r2: ${e} = -0.284496736;\\nconst r3: ${e} = 1.421413741;\\nconst r4: ${e} = -1.453152027;\\nconst r5: ${e} = 1.061405429;\\n\\nfn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {\\n  let absv = abs(v);\\n  let x = 1.0 / (1.0 + r0 * absv);\\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\\n}`,Zs=e=>{let t=Zn(e.inputs[0].dataType);e.compute(Bs(e.inputs[0],"Erf",(e=>`erf_vf32(${e})`),Ys(t)))},Js=e=>{e.compute(Bs(e.inputs[0],"Exp","exp"))},ei=e=>{e.compute(Bs(e.inputs[0],"Floor","floor"))},ti=e=>{let t=Zn(e.inputs[0].dataType);e.compute(Bs(e.inputs[0],"Gelu",(e=>`0.5 * ${e} * (1.0 + erf_vf32(${e} * 0.7071067811865475))`),Ys(t)))},ni=(e,t)=>{let n=Zn(e.inputs[0].dataType);e.compute(Bs(e.inputs[0],"LeakyRelu",(e=>`select(leaky_relu_alpha_ * ${e}, ${e}, ${e} >= vec4<${n}>(0.0))`),`const leaky_relu_alpha_ = ${n}(${t.alpha});`,t.cacheKey))},ri=e=>{e.compute(Bs(e.inputs[0],"Not",(e=>`!${e}`)))},si=e=>{e.compute(Bs(e.inputs[0],"Neg",(e=>`-${e}`)))},ii=e=>{e.compute(Bs(e.inputs[0],"Reciprocal",(e=>`1.0/${e}`)))},ai=e=>{let t=Zn(e.inputs[0].dataType);e.compute(Bs(e.inputs[0],"Relu",(e=>`select(vec4<${t}>(0.0), ${e}, ${e} > vec4<${t}>(0.0))`)))},oi=e=>{e.compute(Bs(e.inputs[0],"Sigmoid",(e=>`(1.0 / (1.0 + exp(-${e})))`)))},li=e=>Un(e),ui=(e,t)=>{let n=Zn(e.inputs[0].dataType);e.compute(Bs(e.inputs[0],"HardSigmoid",(e=>`max(vec4<${n}>(0.0), min(vec4<${n}>(1.0), ${t.alpha} * ${e} + vec4<${n}>(${t.beta})))`),void 0,t.cacheKey))},di=e=>{e.compute(Bs(e.inputs[0],"Sin","sin"))},ci=e=>{e.compute(Bs(e.inputs[0],"Sinh","sinh"))},pi=e=>{e.compute(Bs(e.inputs[0],"Sqrt","sqrt"))},hi=e=>{e.compute(Bs(e.inputs[0],"Tan","tan"))},fi=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,mi=e=>{e.compute(Bs(e.inputs[0],"Tanh",fi))},_i=(e="f32")=>`\\nconst fast_gelu_a: ${e} = 0.5;\\nconst fast_gelu_b: ${e} = 0.7978845608028654;\\nconst fast_gelu_c: ${e} = 0.035677408136300125;\\n\\nfn tanh_v(v: vec4<${e}>) -> vec4<${e}> {\\n  return ${fi("v")};\\n}\\n`,gi=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,wi=e=>{let t=Zn(e.inputs[0].dataType);e.compute(Bs(e.inputs[0],"FastGelu",gi,_i(t),void 0,e.inputs[0].dataType))},yi=(e,t)=>{let n=Zn(e.inputs[0].dataType);return e.compute(Bs(e.inputs[0],"ThresholdedRelu",(e=>`select(vec4<${n}>(0.0), ${e}, ${e} > thresholded_relu_alpha_)`),`const thresholded_relu_alpha_ = vec4<${n}>(${t.alpha});`,t.cacheKey)),0},bi=e=>{e.compute(Bs(e.inputs[0],"Log","log"))},xi=(e,t)=>`\\nconst alpha = vec4<${e}>(${t});\\nconst one = ${e}(1.0);\\nconst zero = ${e}(0.0);\\n\\nfn quick_gelu_impl(x: vec4<${e}>) -> vec4<${e}> {\\n  let v = x *alpha;\\n  var x1 : vec4<${e}>;\\n  for (var i = 0; i < 4; i = i + 1) {\\n    if (v[i] >= zero) {\\n      x1[i] = one / (one + exp(-v[i]));\\n    } else {\\n      x1[i] = one - one / (one + exp(v[i]));\\n    }\\n  }\\n  return x * x1;\\n}\\n`,vi=e=>`quick_gelu_impl(${e})`,$i=(e,t)=>{let n=Zn(e.inputs[0].dataType);e.compute(Bs(e.inputs[0],"QuickGelu",vi,xi(n,t.alpha),t.cacheKey,e.inputs[0].dataType))}})),Fd=ut((()=>{Td(),Id(),Dd(),ki=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Ei=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let n=ar("input",e[0].dataType,e[0].dims,4),r=ar("bias",e[0].dataType,[e[0].dims[2]],4),s=or("output",e[0].dataType,t,4),i=Wn.size(t)/4,a=Yn(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:t=>`\\n  const M_SQRT2 = sqrt(2.0);\\n  const halfChannels = ${e[0].dims[2]/4/2}u;\\n\\n  ${t.declareVariables(n,r,s)}\\n\\n  ${Ys(a)}\\n\\n  ${t.mainStart()}\\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes(i)}\\n    let biasIdx = global_idx % halfChannels;\\n    let batchIndex = global_idx / halfChannels;\\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\\n    let valueLeft = input[inputOffset] + bias[biasIdx];\\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\\n\\n    ${s.setByOffset("global_idx","valueLeft * geluRight")}\\n  }`}},Si=e=>{ki(e.inputs),e.compute(Ei(e.inputs))}})),Ld=ut((()=>{vd(),Td(),Id(),zi=(e,t,n,r,s,i,a,o,l,u,d,c)=>{let p,h;"string"==typeof o?p=h=(e,t)=>`${o}((${e}),(${t}))`:"function"==typeof o?p=h=o:(p=o.scalar,h=o.vector);let f,m=or("outputData",d,r.length,4),_=ar("aData",l,t.length,4),g=ar("bData",u,n.length,4);if(s)if(i){let e=1===Wn.size(t),r=1===Wn.size(n),s=t.length>0&&t[t.length-1]%4==0,i=n.length>0&&n[n.length-1]%4==0;f=e||r?m.setByOffset("global_idx",h(e?`${_.type.value}(${_.getByOffset("0")}.x)`:_.getByOffset("global_idx"),r?`${g.type.value}(${g.getByOffset("0")}.x)`:g.getByOffset("global_idx"))):`\\n            let outputIndices = ${m.offsetToIndices("global_idx * 4u")};\\n            let offsetA = ${_.broadcastedIndicesToOffset("outputIndices",m)};\\n            let offsetB = ${g.broadcastedIndicesToOffset("outputIndices",m)};\\n            ${m.setByOffset("global_idx",h(a||s?_.getByOffset("offsetA / 4u"):`${_.type.value}(${_.getByOffset("offsetA / 4u")}[offsetA % 4u])`,a||i?g.getByOffset("offsetB / 4u"):`${g.type.value}(${g.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}\\n          `}else f=m.setByOffset("global_idx",h(_.getByOffset("global_idx"),g.getByOffset("global_idx")));else{if(!i)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let e=(e,t,n="")=>{let r=`aData[indexA${t}][componentA${t}]`,s=`bData[indexB${t}][componentB${t}]`;return`\\n            let outputIndices${t} = ${m.offsetToIndices(`global_idx * 4u + ${t}u`)};\\n            let offsetA${t} = ${_.broadcastedIndicesToOffset(`outputIndices${t}`,m)};\\n            let offsetB${t} = ${g.broadcastedIndicesToOffset(`outputIndices${t}`,m)};\\n            let indexA${t} = offsetA${t} / 4u;\\n            let indexB${t} = offsetB${t} / 4u;\\n            let componentA${t} = offsetA${t} % 4u;\\n            let componentB${t} = offsetB${t} % 4u;\\n            ${e}[${t}] = ${n}(${p(r,s)});\\n          `};f=9===d?`\\n            var data = vec4<u32>(0);\\n            ${e("data",0,"u32")}\\n            ${e("data",1,"u32")}\\n            ${e("data",2,"u32")}\\n            ${e("data",3,"u32")}\\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\\n            ${e("outputData[global_idx]",0)}\\n            ${e("outputData[global_idx]",1)}\\n            ${e("outputData[global_idx]",2)}\\n            ${e("outputData[global_idx]",3)}\\n          `}return`\\n        ${e.registerUniform("vec_size","u32").declareVariables(_,g,m)}\\n\\n        ${c??""}\\n\\n        ${e.mainStart()}\\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\\n        ${f}\\n      }`},Ci=(e,t,n,r,s,i,a=n.dataType)=>{let o=n.dims.map((e=>Number(e)??1)),l=r.dims.map((e=>Number(e)??1)),u=!Wn.areEqual(o,l),d=o,c=Wn.size(o),p=!1,h=!1,f=[u];if(u){let e=Vn.calcShape(o,l,!1);if(!e)throw new Error("Can\'t perform binary op on the given tensors");d=e.slice(),c=Wn.size(d);let t=1===Wn.size(o),n=1===Wn.size(l),r=o.length>0&&o[o.length-1]%4==0,s=l.length>0&&l[l.length-1]%4==0;f.push(t),f.push(n),f.push(r),f.push(s);let i=1;for(let e=1;e<d.length;e++){let t=o[o.length-e];if(t!==l[l.length-e])break;i*=t}i%4==0?(h=!0,p=!0):(t||n||r||s)&&(p=!0)}else p=!0;return f.push(p),{name:e,shaderCache:{hint:t+f.map((e=>e.toString())).join("_"),inputDependencies:["rank","rank"]},getShaderSource:e=>zi(e,o,l,d,p,u,h,s,n.dataType,r.dataType,a,i),getRunData:()=>({outputs:[{dims:d,dataType:a}],dispatchGroup:{x:Math.ceil(c/64/4)},programUniforms:[{type:12,data:Math.ceil(Wn.size(d)/4)},...Jn(o,l,d)]})}},Ti=(e,t,n,r,s,i)=>{e.compute(Ci(t,s??"",e.inputs[0],e.inputs[1],n,r,i))},Ii=e=>{Ti(e,"Add",((e,t)=>`${e}+${t}`))},Ai=e=>{Ti(e,"Div",((e,t)=>`${e}/${t}`))},Mi=e=>{Ti(e,"Equal",{scalar:(e,t)=>`u32(${e}==${t})`,vector:(e,t)=>`vec4<u32>(${e}==${t})`},void 0,void 0,9)},Oi=e=>{Ti(e,"Mul",((e,t)=>`${e}*${t}`))},Bi=e=>{let t=ar("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;Ti(e,"Pow",{scalar:(e,t)=>`pow_custom(${e},${t})`,vector:(e,t)=>`pow_vector_custom(${e},${t})`},`\\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\\n      if (b == ${t}(0.0)) {\\n        return ${t}(1.0);\\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\\n        return ${t}(pow(f32(a), f32(b))); // NaN\\n      }\\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${"i32"===t?"round":""}(pow(f32(abs(a)), f32(b))));\\n    }\\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\\n      // TODO: implement vectorized pow\\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\\n    }\\n      `)},Ni=e=>{Ti(e,"Sub",((e,t)=>`${e}-${t}`))},Pi=e=>{Ti(e,"Greater",{scalar:(e,t)=>`u32(${e}>${t})`,vector:(e,t)=>`vec4<u32>(${e}>${t})`},void 0,void 0,9)},Ri=e=>{Ti(e,"Less",{scalar:(e,t)=>`u32(${e}<${t})`,vector:(e,t)=>`vec4<u32>(${e}<${t})`},void 0,void 0,9)},Di=e=>{Ti(e,"GreaterOrEqual",{scalar:(e,t)=>`u32(${e}>=${t})`,vector:(e,t)=>`vec4<u32>(${e}>=${t})`},void 0,void 0,9)},Fi=e=>{Ti(e,"LessOrEqual",{scalar:(e,t)=>`u32(${e}<=${t})`,vector:(e,t)=>`vec4<u32>(${e}<=${t})`},void 0,void 0,9)}})),Ud=ut((()=>{vd(),Td(),Cd(),Id(),Li=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");let n=e[0],r=n.dataType,s=n.dims.length;e.forEach(((e,i)=>{if(0!==i){if(e.dataType!==r)throw new Error("input tensors should be one type");if(e.dims.length!==s)throw new Error("input tensors should have the same shape");e.dims.forEach(((e,r)=>{if(r!==t&&e!==n.dims[r])throw new Error("non concat dimensions must match")}))}}))},Ui=(e,t)=>`\\n  fn calculateInputIndex(index: u32) -> u32 {\\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\\n      if (index < sizeInConcatAxis[i]) {\\n        return i;\\n      }\\n    }\\n    return ${e}u;\\n  }`,qi=(e,t)=>{let n=e.length,r=[];for(let s=0;s<n;++s){let i=t.setByOffset("global_idx",e[s].getByIndices("indices"));1===n?r.push(i):0===s?r.push(`if (inputIndex == ${s}u) { ${i} }`):s===n-1?r.push(`else { ${i} }`):r.push(`else if (inputIndex == ${s}) { ${i} }`)}return r.join("\\n")},Vi=(e,t,n,r)=>{let s=Wn.size(n),i=new Array(e.length),a=new Array(e.length),o=0,l=[],u=[],d=[{type:12,data:s}];for(let n=0;n<e.length;++n)o+=e[n].dims[t],i[n]=o,u.push(e[n].dims.length),a[n]=ar(`input${n}`,r,u[n]),l.push("rank"),d.push({type:12,data:i[n]});for(let t=0;t<e.length;++t)d.push(...Jn(e[t].dims));d.push(...Jn(n));let c=or("output",r,n.length),p=c.indicesGet("indices",t),h=Array.from(Array(i.length).keys()).map((e=>`uniforms.sizeInConcatAxis${e}`)).join(",");return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:n,dataType:r}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:d}),getShaderSource:t=>`\\n\\n  ${(()=>{t.registerUniform("outputSize","u32");for(let n=0;n<e.length;n++)t.registerUniform(`sizeInConcatAxis${n}`,"u32");return t.declareVariables(...a,c)})()}\\n\\n  ${Ui(i.length,h)}\\n\\n  ${t.mainStart()}\\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n\\n    var indices = ${c.offsetToIndices("global_idx")};\\n\\n    let inputIndex = calculateInputIndex(${p});\\n    if (inputIndex != 0u) {\\n      let sizeInConcatAxis = array<u32, ${i.length}u>(${h});\\n      ${p} -= sizeInConcatAxis[inputIndex - 1u];\\n    }\\n\\n    ${qi(a,c)}\\n  }`}},Wi=(e,t)=>{let n=e.inputs,r=n[0].dims,s=Wn.normalizeAxis(t.axis,r.length);Li(n,s);let i=r.slice();i[s]=n.reduce(((e,t)=>e+(t.dims.length>s?t.dims[s]:0)),0);let a=n.filter((e=>Wn.size(e.dims)>0));e.compute(Vi(a,s,i,n[0].dataType),{inputs:a})},ji=e=>Un({axis:e.axis})})),qd=ut((()=>{vd(),Td(),Gi=(e,t,n="f32")=>{switch(e.activation){case"Relu":return`value = max(value, ${t}(0.0));`;case"Sigmoid":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${t}(${n}(uniforms.clip_min)), ${t}(${n}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${t}(0.0), min(${t}(1.0), ${n}(uniforms.alpha) * value + ${n}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${n}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case"Tanh":return"let e2x = exp(-2.0 * abs(value));\\n              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);\\n        ";case"":return"";default:throw new Error(`Unsupported activation ${e.activation}`)}},Hi=(e,t)=>{"Clip"===e.activation?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):"HardSigmoid"===e.activation?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):"LeakyRelu"===e.activation&&t.push({type:1,data:e.alpha})},Ki=(e,t)=>{"Clip"===e.activation?t.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):"HardSigmoid"===e.activation?t.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):"LeakyRelu"===e.activation&&t.push({name:"alpha",type:"f32"})},Xi=e=>{let t=e?.activation||"";if("HardSigmoid"===t){let[n,r]=e?.activation_params||[.2,.5];return{activation:t,alpha:n,beta:r}}if("Clip"===t){let[n,r]=e?.activation_params||[Hn,Kn];return{activation:t,clipMax:r,clipMin:n}}if("LeakyRelu"===t){let[n]=e?.activation_params||[.01];return{activation:t,alpha:n}}return{activation:t}}})),Vd=ut((()=>{Qi=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Yi=e=>`\\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\\n      `})),Wd=ut((()=>{Zi=e=>`\\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\\n  return dot(coords, vec4<i32>(\\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\\n}\\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\\n  return dot(coords, vec4<i32>(\\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\\n}\\n`})),jd=ut((()=>{vd(),Td(),Id(),qd(),Ji=(e,t,n,r,s)=>{let i=r-n;return`\\n      ${Array.from({length:n}).map(((n,a)=>`\\n      if (${sr(t.shape,a,t.rank)} != 1) {\\n        ${t.indicesSet(e,a,sr(s,a+i,r))}\\n      } else {\\n        ${t.indicesSet(e,a,0)}\\n      }`)).join("")}\\n`},ea=(e,t,n,r,s=!1,i)=>{let a=e[0].dims,o=e[1].dims,l=a[a.length-2],u=o[o.length-1],d=a[a.length-1],c=er(u),p=er(d),h=er(l),f=Wn.size(n)/c/h,m=e.length>2,_=r?r.slice(0,-2):n.slice(0,-2),g=[Wn.size(_),l,u],w=[{type:12,data:f},{type:12,data:l},{type:12,data:u},{type:12,data:d}];Hi(t,w),w.push(...Jn(_,a,o)),m&&w.push(...Jn(e[2].dims)),w.push(...Jn(g));return{name:"MatMulNaive",shaderCache:{hint:`${t.activation};${c};${p};${h};${s}`,inputDependencies:m?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:i?i(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:w}),getShaderSource:r=>{let i=ur("batch_dims",e[0].dataType,_.length),l=ar("a",e[0].dataType,a.length,p),u=ar("b",e[1].dataType,o.length,c),d=or("output",e[0].dataType,g.length,c),f=Yn(d.type.tensor),w=Gi(t,d.type.value,f),y=[l,u],b="";if(m){let t=s?c:1;y.push(ar("bias",e[2].dataType,e[2].dims.length,t)),b=""+(s?`value += bias[col / ${t}];`:`value += ${d.type.value}(bias[row + i]);`)}let x=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];Ki(t,x);return`\\n  ${r.registerUniforms(x).registerInternalVariables(i).declareVariables(...y,d)}\\n  ${r.mainStart()}\\n    ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n    let col = (global_idx % (uniforms.N / ${c})) * ${c};\\n    var index1 = global_idx / (uniforms.N / ${c});\\n    let stride1 = uniforms.M / ${h};\\n    let row = (index1 % stride1) * ${h};\\n    let batch = index1 / stride1;\\n\\n    ${2===n.length?"":`let batch_indices = ${i.offsetToIndices("batch")};`}\\n\\n    var a_indices: ${l.type.indices};\\n    ${Ji("a_indices",l,l.rank-2,i.rank,"batch_indices")}\\n    ${l.indicesSet("a_indices",l.rank-2,0)}\\n    ${l.indicesSet("a_indices",l.rank-1,0)}\\n    let a_offset = ${l.indicesToOffset("a_indices")};\\n\\n    var b_indices: ${u.type.indices};\\n    ${Ji("b_indices",u,u.rank-2,i.rank,"batch_indices")}\\n    ${u.indicesSet("b_indices",u.rank-2,0)}\\n    ${u.indicesSet("b_indices",u.rank-1,0)}\\n    let b_offset = ${u.indicesToOffset("b_indices")};\\n    var values: array<${d.type.value}, ${h}>;\\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${p}) {\\n      ${(()=>{let e=`var a_data: ${l.type.value};`;for(let t=0;t<p;t++)e+=`\\n              let b_data${t} = b[(b_offset + (k + ${t}) * uniforms.N + col) / ${c}];`;for(let t=0;t<h;t++){e+=`a_data = a[(a_offset + (row + ${t}) * uniforms.K + k) / ${p}];`;for(let n=0;n<p;n++)e+=`\\n            values[${t}] = fma(${u.type.value}(a_data${1===p?"":`[${n}]`}), b_data${n}, values[${t}]);\\n`}return e})()}\\n    }\\n    for (var i = 0u; i < ${h}u; i++) {\\n      var value = values[i];\\n      ${b}\\n      ${w}\\n      let cur_indices = ${d.type.indices}(batch, row + i, col);\\n      let offset = ${d.indicesToOffset("cur_indices")};\\n      ${d.setByOffset(`offset / ${c}`,"value")};\\n    }\\n  }\\n  `}}}})),Gd=ut((()=>{vd(),Td(),Id(),qd(),jd(),Vd(),ta=(e,t)=>e?`\\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n          kStart + inputRow,\\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\\n        `:`\\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n          globalRow + innerRow,\\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\\n        `,na=(e,t)=>e?`\\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\\n        ${3===t?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\\n        for (var i = 0; i < rowPerThread; i = i + 1) {\\n          acc[i] = BCached0 * ACached0[i] + acc[i];\\n          acc[i] = BCached1 * ACached1[i] + acc[i];\\n          acc[i] = BCached2 * ACached2[i] + acc[i];\\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\\n        }`:`\\n        for (var i = 0; i < rowPerThread; i = i + 1) {\\n          let ACached = mm_Asub[tileRow + i][k];\\n          acc[i] = BCached0 * ACached.x + acc[i];\\n          acc[i] = BCached1 * ACached.y + acc[i];\\n          acc[i] = BCached2 * ACached.z + acc[i];\\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\\n        }`,ra=(e,t,n="f32",r,s=!1,i=32,a=!1,o=32)=>{let l=t[1]*e[1],u=t[0]*e[0],d=s?l:i,c=s?i:l,p=d/t[0],h=i/t[1];if((!s||4!==p||4!==e[1])&&(s||3!==p&&4!==p)||d%t[0]!=0||i%t[1]!=0||4!==e[0])throw new Error(`If transposeA ${s} is true, innerElementSize ${p} and workPerThread[1] ${e[1]} must be 4.\\n      Otherwise, innerElementSize ${p} must be 3 or 4.\\n  tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}. tileInner ${i} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\\nvar<workgroup> mm_Asub: array<array<vec${p}<${n}>, ${d/p}>, ${c}>;\\nvar<workgroup> mm_Bsub: array<array<vec4<${n}>, ${u/e[0]}>, ${i}>;\\n\\nconst rowPerThread = ${e[1]};\\nconst colPerThread = ${e[0]};\\nconst innerElementSize = ${p};\\nconst tileInner = ${i};\\n\\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\\n        @builtin(global_invocation_id) globalId : vec3<u32>,\\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\\n  let localRow = i32(localId.y);\\n  let tileRow = localRow * rowPerThread;\\n  let tileCol = i32(localId.x);\\n\\n  let globalRow =i32(globalId.y) * rowPerThread;\\n  let globalCol = i32(globalId.x);\\n  let batch = ${a?"0":"i32(globalId.z)"};\\n  ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}\\n  let globalRowStart = i32(workgroupId.y) * ${l};\\n\\n  let num_tiles = ${a?`${Math.ceil(o/i)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\\n  var kStart = ${a?`i32(globalId.z) * ${o}`:"0"};\\n\\n  var acc: array<vec4<${n}>, rowPerThread>;\\n\\n  // Loop over shared dimension.\\n  let tileRowB = localRow * ${h};\\n  for (var t = 0; t < num_tiles; t = t + 1) {\\n      // Load one tile of A into local memory.\\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n          let inputRow = tileRow + innerRow;\\n          let inputCol = tileCol;\\n          ${ta(s,r)}\\n      }\\n\\n      // Load one tile of B into local memory.\\n      for (var innerRow = 0; innerRow < ${h}; innerRow = innerRow + 1) {\\n          let inputRow = tileRowB + innerRow;\\n          let inputCol = tileCol;\\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${r?", batchIndices":""});\\n      }\\n      kStart = kStart + tileInner;\\n      workgroupBarrier();\\n\\n      // Compute acc values for a single thread.\\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\\n          ${3===p?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\\n\\n          ${na(s,p)}\\n      }\\n\\n      workgroupBarrier();\\n  }\\n\\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\\n  }\\n}`},sa=(e,t)=>e?`\\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n              kStart + inputRow,\\n              globalRowStart + inputCol${t?", batchIndices":""});\\n            `:`\\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n              globalRowStart + inputRow,\\n              kStart + inputCol${t?", batchIndices":""});\\n            `,ia=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",aa=(e,t,n="f32",r,s=!1,i=32,a=!1,o=32,l=!1)=>{let u=e[1]*t[1],d=e[0]*t[0],c=s?u:i,p=s?i:u;if(p%t[1]!=0||c%t[0]!=0||i%t[1]!=0)throw new Error(`tileAHight ${p} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}, tileInner ${i} must be divisible by workgroupSize[1]${t[1]}`);let h=p/t[1],f=c/t[0],m=i/t[1],_=l?`\\n    let localRow = i32(localId.y);\\n    let localCol = i32(localId.x);\\n    let globalRowStart = i32(workgroupId.y) * ${u};\\n    let globalColStart = i32(workgroupId.x) * ${d};\\n\\n    // Loop over shared dimension.\\n    for (var t = 0; t < num_tiles; t = t + 1) {\\n      // Load one tile of A into local memory.\\n      for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${t[1]}) {\\n        for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {\\n          ${sa(s,r)}\\n        }\\n      }\\n      // Load one tile of B into local memory.\\n      for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${t[1]}) {\\n            for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${t[0]}) {\\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\\n            kStart + inputRow,\\n            globalColStart + inputCol${r?", batchIndices":""});\\n        }\\n      }\\n      kStart = kStart + tileInner;\\n      workgroupBarrier();\\n\\n      // Compute acc values for a single thread.\\n      var BCached : array<${n}, colPerThread>;\\n      for (var k = 0; k < tileInner; k = k + 1) {\\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\\n        }\\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n          let ACached = ${s?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\\n                ACached * BCached[innerCol];\\n          }\\n        }\\n      }\\n      workgroupBarrier();\\n    }\\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\\n      }\\n    }\\n    `:`\\nlet tileRow = i32(localId.y) * rowPerThread;\\nlet tileCol = i32(localId.x) * colPerThread;\\n\\nlet globalRow = i32(globalId.y) * rowPerThread;\\nlet globalCol = i32(globalId.x) * colPerThread;\\nlet globalRowStart = i32(workgroupId.y) * ${u};\\n\\nlet tileRowA = i32(localId.y) * ${h};\\nlet tileColA = i32(localId.x) * ${f};\\nlet tileRowB = i32(localId.y) * ${m};\\n// Loop over shared dimension.\\nfor (var t = 0; t < num_tiles; t = t + 1) {\\n  // Load one tile of A into local memory.\\n  for (var innerRow = 0; innerRow < ${h}; innerRow = innerRow + 1) {\\n    for (var innerCol = 0; innerCol < ${f}; innerCol = innerCol + 1) {\\n      let inputRow = tileRowA + innerRow;\\n      let inputCol = tileColA + innerCol;\\n      ${sa(s,r)}\\n    }\\n  }\\n\\n  // Load one tile of B into local memory.\\n  for (var innerRow = 0; innerRow < ${m}; innerRow = innerRow + 1) {\\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n      let inputRow = tileRowB + innerRow;\\n      let inputCol = tileCol + innerCol;\\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\\n        kStart + inputRow,\\n        globalCol + innerCol${r?", batchIndices":""});\\n    }\\n  }\\n  kStart = kStart + tileInner;\\n  workgroupBarrier();\\n\\n  // Compute acc values for a single thread.\\n  var BCached : array<${n}, colPerThread>;\\n  for (var k = 0; k < tileInner; k = k + 1) {\\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\\n    }\\n\\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      ${ia(s)}\\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\\n      }\\n    }\\n  }\\n\\n  workgroupBarrier();\\n}\\n\\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\\n        acc[innerRow][innerCol]);\\n  }\\n}\\n`;return`\\n  var<workgroup> mm_Asub : array<array<${n}, ${c}>, ${p}>;\\n  var<workgroup> mm_Bsub : array<array<${n}, ${d}>, ${i}>;\\n  const rowPerThread = ${e[1]};\\n  const colPerThread = ${e[0]};\\n  const tileInner = ${i};\\n\\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\\n        @builtin(global_invocation_id) globalId : vec3<u32>,\\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\\n    let batch = ${a?"0":"i32(globalId.z)"};\\n    ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}\\n    let num_tiles = ${a?`${Math.ceil(o/i)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\\n    var kStart = ${a?`i32(globalId.z) * ${o}`:"0"};\\n\\n    var acc : array<array<${n}, colPerThread>, rowPerThread>;\\n    ${_}\\n  }\\n`},oa=(e,t,n,r,s=!1)=>{let[i,a,o,l]=r,u=Yn(r[0].type.tensor);return`\\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${i.type.indices}) -> ${Qi(e,u)} {\\n      var value = ${Qi(e,u)}(0.0);\\n      let col = colIn * ${e};\\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\\n      {\\n        var aIndices: ${a.type.indices};\\n        ${Ji("aIndices",a,a.rank-2,i.rank,"batchIndices")}\\n        ${a.indicesSet("aIndices",a.rank-2,"u32(row)")}\\n        ${a.indicesSet("aIndices",a.rank-1,"u32(colIn)")}\\n        value = ${a.getByIndices("aIndices")};\\n      }\\n      return value;\\n    }\\n\\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${i.type.indices}) -> ${Qi(e,u)} {\\n      var value = ${Qi(e,u)}(0.0);\\n      let col = colIn * ${e};\\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\\n      {\\n        var bIndices: ${o.type.indices};\\n        ${Ji("bIndices",o,o.rank-2,i.rank,"batchIndices")}\\n        ${o.indicesSet("bIndices",o.rank-2,"u32(row)")}\\n        ${o.indicesSet("bIndices",o.rank-1,"u32(colIn)")}\\n        value = ${o.getByIndices("bIndices")};\\n      }\\n      return value;\\n    }\\n\\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Qi(e,u)}) {\\n      let col = colIn * ${e};\\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\\n        var value = valueIn;\\n        let coords = vec3<i32>(batch, row, colIn);\\n        ${t?`value = value + ${s?"bias[colIn]":`${Qi(e,u)}(bias[row])`};`:""}\\n        ${n}\\n        ${l.setByIndices("vec3<u32>(coords)","value")}\\n      }\\n    }\\n    `},la=(e,t,n,r,s=!1,i)=>{let a=e[0].dims,o=e[1].dims,l=a.slice(0,-2),u=o.slice(0,-2),d=r?r.slice(0,-2):n.slice(0,-2),c=Wn.size(d),p=a[a.length-2],h=a[a.length-1],f=o[o.length-1],m=h%4==0&&f%4==0,_=p<=8?[4,1,1]:[4,4,1],g=[8,8,1],w=[Math.ceil(f/g[0]/_[0]),Math.ceil(p/g[1]/_[1]),Math.ceil(c/g[2]/_[2])],y=m?4:1,b=[...l,p,h/y],x=b.length,v=[...u,h,f/y],$=v.length,k=[c,p,f/y],E=[{type:6,data:p},{type:6,data:f},{type:6,data:h}];Hi(t,E),E.push(...Jn(d,b,v));let S=["rank","rank"],z=e.length>2;z&&(E.push(...Jn(e[2].dims)),S.push("rank")),E.push(...Jn(k));return{name:"MatMul",shaderCache:{hint:`${_};${t.activation};${m};${s}`,inputDependencies:S},getRunData:()=>({outputs:[{dims:i?i(n):n,dataType:e[0].dataType}],dispatchGroup:{x:w[0],y:w[1],z:w[2]},programUniforms:E}),getShaderSource:n=>{let r=d.length,i=ur("batchDims",e[0].dataType,r,1),a=Yn(e[0].dataType),o=ar("a",e[0].dataType,x,y),l=ar("b",e[1].dataType,$,y),u=or("result",e[0].dataType,k.length,y),c=[o,l];if(z){let t=s?y:1;c.push(ar("bias",e[2].dataType,e[2].dims.length,t))}let p=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];Ki(t,p);let h=Yn(u.type.tensor),f=Gi(t,u.type.value,h),w=oa(y,z,f,[i,o,l,u],s);return`\\n  ${n.registerUniforms(p).registerInternalVariables(i).declareVariables(...c,u)}\\n  ${w}\\n  ${m?ra(_,g,a,i):aa(_,g,a,i)}\\n                   `}}}})),Hd=ut((()=>{vd(),kd(),Id(),qd(),Vd(),Wd(),Gd(),ua=(e,t,n,r,s=!1,i,a=4,o=4,l=4,u="f32")=>{let d=e?"\\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\\n    ":"\\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\\n    ",c=e?"\\n    let coords = vec4<i32>(\\n      batch,\\n      row / outWidth,\\n      row % outWidth,\\n      col);\\n    ":"\\n    let coords = vec4<i32>(\\n      batch,\\n      row,\\n      col / outWidth,\\n      col % outWidth);\\n    ",p=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",h=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",f=e?"row":"col",m=e?"col":"row",_=`\\n    let inChannels = i32(uniforms.w_shape[2]);\\n    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\\n    let outRow = ${f} / outWidth;\\n    let outCol = ${f} % outWidth;\\n\\n    let WRow = ${m} / (i32(uniforms.w_shape[1]) * inChannels);\\n    let WCol = ${m} / inChannels % i32(uniforms.w_shape[1]);\\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\\n    let xCh = ${m} % inChannels;\\n    var resData = ${Qi(a,u)}(0.0);\\n    // The bounds checking is always needed since we use it to pad zero for\\n    // the \'same\' padding type.\\n    if (xRow >= 0 && xRow < ${p} && xCol >= 0 && xCol < ${h}) {\\n      ${d}\\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\\n      ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${u}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(a)}\\n    }\\n    return resData;`,g=e?t&&r?`\\n    let col = colIn * ${a};\\n    ${_}`:`\\n    let col = colIn * ${a};\\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\\n      ${_}\\n    }\\n    return ${Qi(a,u)}(0.0);`:r&&n?`\\n    let col = colIn * ${a};\\n    ${_}`:`\\n    let col = colIn * ${a};\\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\\n      ${_}\\n    }\\n    return ${Qi(a,u)}(0.0);`,w=`${(e=>{switch(e){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(o)}`,y=Qi(l,u),b=Qi(e?a:o,u),x=Qi(e?o:a,u),v=Gi(i,y,u);return`\\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${b} {\\n      ${e?g:w}\\n    }\\n\\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${x} {\\n      ${e?w:g}\\n    }\\n\\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${y}) {\\n      let col = colIn * ${l};\\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\\n      {\\n      var value = valueIn;\\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\\n      ${c}\\n      ${Yi(s)}\\n      ${v}\\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\\n      }\\n    }`},da=(e,t,n,r,s,i,a,o,l)=>{let u="NHWC"===t.format,d=u?e[0].dims[3]:e[0].dims[1],c=n[0],p=u?n[2]:n[3],h=u?n[1]:n[2],f=u?n[3]:n[1],m=u&&(d%4==0||d%3==0)&&f%4==0,_=u?f:p*h,g=u?p*h:f,w=[8,8,1],y=r<=8?[4,1,1]:[4,4,1],b=[Math.ceil(_/w[0]/y[0]),Math.ceil(g/w[1]/y[1]),Math.ceil(c/w[2]/y[2])];Tn("verbose",(()=>`[conv2d_mm_webgpu] dispatch = ${b}`));let x=m?u&&d%4!=0?3:4:1,v=w[1]*y[1],$=w[0]*y[0],k=Math.max(w[0]*x,w[1]),E=r%v==0,S=s%$==0,z=i%k==0,C=m?[x,4,4]:[1,1,1],T=[{type:6,data:r},{type:6,data:s},{type:6,data:i},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];Hi(t,T),T.push(...Jn(e[0].dims,e[1].dims));let I=["rank","rank"];a&&(T.push(...Jn(e[2].dims)),I.push("rank")),T.push(...Jn(n));return{name:"Conv2DMatMul",shaderCache:{hint:`${t.cacheKey};${x};${m};${E};${S};${z};${v};${$};${k}`,inputDependencies:I},getRunData:()=>({outputs:[{dims:l?l(n):n,dataType:e[0].dataType}],dispatchGroup:{x:b[0],y:b[1],z:b[2]},programUniforms:T}),getShaderSource:r=>{let s=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];Ki(t,s);let i=m?4:1,l=Yn(e[0].dataType),d=`\\n      fn setOutputAtIndex(flatIndex : i32, value : ${m?`vec4<${l}>`:l}) {\\n        result[flatIndex] = ${m?`vec4<${l}>`:l}(value);\\n      }\\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${m?`vec4<${l}>`:l}) {\\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\\n        setOutputAtIndex(flatIndex ${m?"/ 4":""}, value);\\n      }`,c=[ar("x",e[0].dataType,e[0].dims.length,3===x?1:x),ar("w",e[1].dataType,e[1].dims.length,i)],p=or("result",e[0].dataType,n.length,i);if(a){let t=ar("bias",e[2].dataType,e[2].dims.length,i);c.push(t),d+=`\\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${m?`vec4<${l}>`:l} {\\n          return bias[coords.${u?"w":"y"}${m?"/ 4":""}];\\n        }`}return`\\n        ${Zi("uniforms.result_strides")}\\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\\n        ${r.registerUniforms(s).declareVariables(...c,p)}\\n        ${d}\\n        ${ua(u,E,S,z,a,t,C[0],C[1],C[2],l)}\\n        ${m?ra(y,w,l,void 0,!u,k):aa(y,w,l,void 0,!u,k,!1,void 0,o)}`}}}})),Kd=ut((()=>{vd(),kd(),Td(),Id(),qd(),Vd(),ca=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t},pa=e=>"number"==typeof e?[e,e,e]:e,ha=(e,t)=>t<=1?e:e+(e-1)*(t-1),fa=(e,t,n,r=1)=>{let s=ha(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)},ma=(e,t,n,r,s)=>{null==s&&(s=fa(e,t[0],r[0]));let i=[0,0,0,n];for(let n=0;n<3;n++)e[n]+2*s>=t[n]&&(i[n]=Math.trunc((e[n]-t[n]+2*s)/r[n]+1));return i},_a=(e,t,n,r,s,i,a,o,l,u)=>{let d,c,p,h;if("VALID"===e&&(e=0),"number"==typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e};let f=ma([t,n,r,1],[o,l,u],1,[s,i,a],e);c=f[0],p=f[1],h=f[2]}else if(Array.isArray(e)){if(!e.every(((e,t,n)=>e===n[0])))throw Error(`Unsupported padding parameter: ${e}`);d={top:e[0],bottom:e[1],left:e[2],right:e[3],front:e[4],back:e[5]};let f=ma([t,n,r,1],[o,l,u],1,[s,i,a],e[0]);c=f[0],p=f[1],h=f[2]}else{if("SAME_UPPER"!==e)throw Error(`Unknown padding parameter: ${e}`);{c=Math.ceil(t/s),p=Math.ceil(n/i),h=Math.ceil(r/a);let e=(c-1)*s+o-t,f=(p-1)*i+l-n,m=(h-1)*a+u-r,_=Math.floor(e/2),g=e-_,w=Math.floor(f/2),y=f-w,b=Math.floor(m/2);d={top:w,bottom:y,left:b,right:m-b,front:_,back:g}}}return{padInfo:d,outDepth:c,outHeight:p,outWidth:h}},ga=(e,t,n,r,s,i=!1,a="channelsLast")=>{let o,l,u,d,c;if("channelsLast"===a)[o,l,u,d,c]=e;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[o,c,l,u,d]=e}let[p,,h,f,m]=t,[_,g,w]=pa(n),[y,b,x]=pa(r),v=ha(h,y),$=ha(f,b),k=ha(m,x),{padInfo:E,outDepth:S,outHeight:z,outWidth:C}=_a(s,l,u,d,_,g,w,v,$,k),T=i?p*c:p,I=[0,0,0,0,0];return"channelsFirst"===a?I=[o,T,S,z,C]:"channelsLast"===a&&(I=[o,S,z,C,T]),{batchSize:o,dataFormat:a,inDepth:l,inHeight:u,inWidth:d,inChannels:c,outDepth:S,outHeight:z,outWidth:C,outChannels:T,padInfo:E,strideDepth:_,strideHeight:g,strideWidth:w,filterDepth:h,filterHeight:f,filterWidth:m,effectiveFilterDepth:v,effectiveFilterHeight:$,effectiveFilterWidth:k,dilationDepth:y,dilationHeight:b,dilationWidth:x,inShape:e,outShape:I,filterShape:t}},wa=(e,t,n,r,s,i)=>{let a="channelsLast"===i,o=(a?e[0].dims[3]:e[0].dims[1],{x:n.map(((e,t)=>t))}),l=[Math.ceil(ca(o.x.map((e=>n[e])))/64),1,1];Tn("verbose",(()=>`[conv3d_naive_webgpu] dispatch = ${l}`));let u=[{type:12,data:Wn.size(n)},{type:12,data:r},{type:12,data:s},{type:12,data:t.strides},{type:12,data:t.dilations}];Hi(t,u),u.push(...Jn(e[0].dims,e[1].dims));let d=["rank","rank"],c=3===e.length;c&&(u.push(...Jn(e[2].dims)),d.push("rank")),u.push(...Jn(n));return{name:"Conv3DNaive",shaderCache:{hint:`${t.cacheKey};${a};1;${c}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:l[0],y:l[1],z:l[2]},programUniforms:u}),getShaderSource:i=>{let o=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:r.length},{name:"pads",type:"u32",length:s.length},{name:"strides",type:"u32",length:t.strides.length},{name:"dilations",type:"u32",length:t.dilations.length}];Ki(t,o);let l=Yn(e[0].dataType),u=ar("x",e[0].dataType,e[0].dims.length,1),d=ar("W",e[1].dataType,e[1].dims.length,1),p=[u,d],h=or("result",e[0].dataType,n.length,1),f="";if(c){let t=ar("bias",e[2].dataType,e[2].dims.length,1);p.push(t),f+=`\\n        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${l} {\\n          return bias[${sr("coords",a?4:1,5)}];\\n        }`}let m=Qi(1,l),_=Gi(t,m,l);return`\\n            ${f}\\n            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\\n              return ${u.getByIndices("aIndices")};\\n            }\\n            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\\n              return ${d.getByIndices("aIndices")};\\n            }\\n          ${i.registerUniforms(o).declareVariables(...p,h)}\\n          ${i.mainStart()}\\n          ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n              let coords = ${h.offsetToIndices("global_idx")};\\n              let batch = ${sr("coords",0,u.rank)};\\n              let d2 = ${sr("coords",a?u.rank-1:1,u.rank)};\\n              let xFRCCorner = vec3<u32>(${sr("coords",a?1:2,u.rank)},\\n              ${sr("coords",a?2:3,u.rank)},\\n              ${sr("coords",a?3:4,u.rank)}) * uniforms.strides - uniforms.pads;\\n              let xFCorner = xFRCCorner.x;\\n              let xRCorner = xFRCCorner.y;\\n              let xCCorner = xFRCCorner.z;\\n              let xShapeY = ${sr("uniforms.x_shape",a?1:2,u.rank)};\\n              let xShapeZ = ${sr("uniforms.x_shape",a?2:3,u.rank)};\\n              let xShapeW = ${sr("uniforms.x_shape",a?3:4,u.rank)};\\n              let xShapeU = ${sr("uniforms.x_shape",a?4:1,u.rank)};\\n              let inputDepthNearestVec4 = (xShapeU / 4) * 4;\\n              let inputDepthVec4Remainder = xShapeU % 4;\\n\\n              var value = 0.0;\\n              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {\\n                let xF = xFCorner + wF * uniforms.dilations[0];\\n                if (xF < 0 || xF >= xShapeY) {\\n                  continue;\\n                }\\n\\n                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {\\n                  let xR = xRCorner + wR * uniforms.dilations[1];\\n                  if (xR < 0 || xR >= xShapeZ) {\\n                    continue;\\n                  }\\n\\n                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {\\n                    let xC = xCCorner + wC * uniforms.dilations[2];\\n                    if (xC < 0 || xC >= xShapeW) {\\n                      continue;\\n                    }\\n\\n                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {\\n                      ${a?"let xValues = vec4<f32>(\\n                               getX(batch, xF, xR, xC, d1),\\n                               getX(batch, xF, xR, xC, d1 + 1),\\n                               getX(batch, xF, xR, xC, d1 + 2),\\n                               getX(batch, xF, xR, xC, d1 + 3));\\n                            ":"let xValues = vec4<f32>(\\n                               getX(batch, d1, xF, xR, xC),\\n                               getX(batch, d1 + 1, xF, xR, xC),\\n                               getX(batch, d1 + 2, xF, xR, xC),\\n                               getX(batch, d1 + 3, xF, xR, xC));\\n                            "}\\n                            let wValues = vec4<f32>(\\n                              getW(d2, d1, wF, wR, wC),\\n                              getW(d2, d1 + 1, wF, wR, wC),\\n                              getW(d2, d1 + 2, wF, wR, wC),\\n                              getW(d2, d1 + 3, wF, wR, wC));\\n                      value += dot(xValues, wValues);\\n                    }\\n                    if (inputDepthVec4Remainder == 1) {\\n                        ${a?"value += getX(batch, xF, xR, xC, inputDepthNearestVec4)\\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);":"value += getX(batch, inputDepthNearestVec4, xF, xR, xC)\\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);"}\\n                    } else if (inputDepthVec4Remainder == 2) {\\n                      ${a?"let xValues = vec2<f32>(\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));\\n                      ":"let xValues = vec2<f32>(\\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));\\n                    "}\\n                    let wValues = vec2<f32>(\\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));\\n                      value += dot(xValues, wValues);\\n                    } else if (inputDepthVec4Remainder == 3) {\\n                      ${a?"let xValues = vec3<f32>(\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));\\n                      ":"let xValues = vec3<f32>(\\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),\\n                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));\\n                    "}\\n                    let wValues = vec3<f32>(\\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),\\n                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));\\n                      value += dot(xValues, wValues);\\n                    }\\n                  }\\n                }\\n              }\\n              ${c?"value = value + getBiasByOutputCoords(coords)":""};\\n              ${_}\\n              result[global_idx] = f32(value);\\n          }`}}}})),Xd=ut((()=>{vd(),Td(),Id(),qd(),ya=(e,t,n,r)=>{let s=e.length>2,i=s?"value += b[output_channel];":"",a=e[0].dims,o=e[1].dims,l="NHWC"===t.format,u=l?n[3]:n[1],d=u/t.group,c=l&&d>=4?er(u):1,p=Wn.size(n)/c,h=[{type:12,data:p},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:d}];Hi(t,h),h.push(...Jn(a,[o[0],o[1],o[2],o[3]/c]));let f=s?["rank","rank","rank"]:["rank","rank"];h.push(...Jn([n[0],n[1],n[2],n[3]/c]));return{name:"GroupedConv",shaderCache:{hint:`${t.cacheKey}_${c}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:r?r(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:h}),getShaderSource:r=>{let u=or("output",e[0].dataType,n.length,c),d=Yn(u.type.tensor),p=Gi(t,u.type.value,d),h=ar("x",e[0].dataType,a.length),f=ar("w",e[1].dataType,o.length,c),m=[h,f];s&&m.push(ar("b",e[2].dataType,e[2].dims,c));let _=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:t.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];Ki(t,_);let g=l?`\\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {\\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\\n\\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {\\n          continue;\\n        }\\n\\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {\\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {\\n            continue;\\n          }\\n\\n          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {\\n            let input_channel = in_channel_offset + wInChannel;\\n            let xVal = ${h.get("batch","xHeight","xWidth","input_channel")};\\n            let wVal = ${f.get("wHeight","wWidth","wInChannel","output_channel")};\\n            value += xVal * wVal;\\n          }\\n        }\\n      }\\n      `:`\\n      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\\n        let input_channel = in_channel_offset + wInChannel;\\n        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\\n          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\\n\\n          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {\\n            continue;\\n          }\\n\\n          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\\n            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\\n            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {\\n              continue;\\n            }\\n\\n            let xVal = ${h.get("batch","input_channel","xHeight","xWidth")};\\n            let wVal = ${f.get("output_channel","wInChannel","wHeight","wWidth")};\\n            value += xVal * wVal;\\n          }\\n        }\\n      }\\n      `;return`\\n  ${r.registerUniforms(_).declareVariables(...m,u)}\\n\\n  ${r.mainStart()}\\n    ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n\\n    let outputIndices = ${u.offsetToIndices("global_idx")};\\n    let batch: u32 = outputIndices[0];\\n    let output_channel: u32 = outputIndices[${l?3:1}];\\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${l?1:2}], outputIndices[${l?2:3}]) * uniforms.strides - uniforms.pads;\\n    let group_id: u32 = output_channel * ${c} / uniforms.output_channels_per_group;\\n    var in_channel_offset = group_id * uniforms.w_shape[${l?2:1}];\\n\\n    var value: ${u.type.value} = ${u.type.value}(0);\\n    ${g}\\n    ${i}\\n    ${p}\\n    ${u.setByOffset("global_idx","value")}\\n  }`}}},ba=(e,t,n,r)=>{let s=e.length>2,i=er(n[3]),a=er(n[2]),o=Wn.size(n)/i/a,l=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/i],u=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/i],d=[n[0],n[1],n[2],n[3]/i],c=[{type:12,data:o},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];Hi(t,c),c.push(...Jn(l,u,d));let p=(a-1)*t.strides[1]+u[1];return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${t.cacheKey};${i};${a};${p};${u[0]};${u[1]}`,inputDependencies:s?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:r?r(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:c}),getShaderSource:n=>{let r=or("output",e[0].dataType,d.length,i),o=Yn(r.type.tensor),c=Gi(t,r.type.value,o),h=ar("x",e[0].dataType,l.length,i),f=ar("w",e[1].dataType,u.length,i),m=[h,f];s&&m.push(ar("b",e[2].dataType,e[2].dims,i));let _=s?"value += b[output_channel];":"",g=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return Ki(t,g),`\\n  ${n.registerUniforms(g).declareVariables(...m,r)}\\n  ${n.mainStart()}\\n    ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n    let width0 = uniforms.output_shape[3];\\n    let output_channel = global_idx % width0;\\n    var index1 = global_idx / width0;\\n    let width1 = uniforms.output_shape[2] / ${a}u;\\n    let col = (index1 % width1) * ${a}u;\\n    index1 = index1 / width1;\\n    let row = index1 % uniforms.output_shape[1];\\n    let batch = index1 / uniforms.output_shape[1];\\n\\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\\n\\n    var x_vals: array<${h.type.value}, ${p}>;\\n    var values: array<${r.type.value}, ${a}>;\\n    let input_channel = output_channel;\\n    // Use constant instead of uniform can give better performance for w\'s height/width.\\n    for (var w_height: u32 = 0u; w_height < ${u[0]}; w_height++) {\\n      let x_height = x_corner.x + i32(w_height);\\n      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {\\n        for (var i = 0; i < ${p}; i++) {\\n          let x_width = x_corner.y + i;\\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\\n            x_vals[i] = ${h.get("batch","u32(x_height)","u32(x_width)","input_channel")};\\n          } else {\\n            x_vals[i] = ${h.type.value}(0);\\n          }\\n        }\\n        for (var w_width: u32 = 0u; w_width < ${u[1]}; w_width++) {\\n          let w_val = ${f.get("w_height","w_width","0","output_channel")};\\n          for (var i = 0u; i < ${a}u; i++) {\\n            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);\\n          }\\n        }\\n      }\\n    }\\n\\n    for (var i = 0u; i < ${a}u; i++) {\\n      var value = values[i];\\n      ${_}\\n      ${c}\\n      ${r.set("batch","row","col + i","output_channel","value")};\\n    }\\n  }`}}}})),Qd=ut((()=>{Td(),Hd(),Kd(),Gd(),Xd(),qd(),jd(),Ad(),xa=(e,t,n,r,s,i)=>{let a=e[0],o=e.slice(i?1:2,i?3:4),l=o.length,u=t[0],d=t.slice(2).map(((e,t)=>e+(e-1)*(n[t]-1))),c=o.map(((e,t)=>e+r[t]+r[t+l])).map(((e,t)=>Math.floor((e-d[t]+s[t])/s[t])));return c.splice(0,0,a),c.splice(i?3:1,0,u),c},va=[2,3,1,0],$a=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length>5)throw new Error("greater than 5D is not supported");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[1]*t.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===e.length&&(1!==e[2].dims.length||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},ka=(e,t)=>{let n=e.kernelShape.slice();n.length<t[1].dims.length-2&&n.push(...Array(t[1].dims.length-2-n.length).fill(0));for(let e=2;e<t[1].dims.length;++e)0===n[e-2]&&(n[e-2]=t[1].dims[e]);let r=e.pads.slice();jn.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,r,"NHWC"===e.format,e.autoPad);let s=Object.assign({},e);return Object.assign(s,{kernelShape:n,pads:r}),s},Ea=e=>{let t=Xi(e),n=e.format;return{autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],format:n,dilations:e.dilations,group:e.group,kernelShape:e.kernel_shape,pads:e.pads,strides:e.strides,wIsConst:e.w_is_const(),...t,cacheKey:`${e.format};${t.activation};`}},Sa=(e,t,n,r)=>{let s="NHWC"===n.format,i=xa(t[0].dims,t[1].dims,n.dilations,n.pads,n.strides,s);if(1!==n.group){let a=[t[0]];if(s){let r=e.kernelCustomData.wT??e.compute(wr(t[1],va),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=r),a.push(r)}else a.push(t[1]);return 3===t.length&&a.push(t[2]),void(!e.adapterInfo.isArchitecture("ampere")&&s&&t[1].dims[0]===n.group&&1===t[1].dims[1]&&1===n.dilations[0]&&1===n.dilations[1]?e.compute(ba(a,n,i,r),{inputs:a}):e.compute(ya(a,n,i,r),{inputs:a}))}let a=3===t.length,o=t[0].dims[s?1:2],l=t[0].dims[s?2:3],u=t[0].dims[s?3:1],d=t[1].dims[2],c=t[1].dims[3],p=i[s?1:2],h=i[s?2:3],f=i[s?3:1],m=s&&d===o&&c===l&&0===n.pads[0]&&0===n.pads[1];if(m||1===d&&1===c&&1===n.dilations[0]&&1===n.dilations[1]&&1===n.strides[0]&&1===n.strides[1]&&0===n.pads[0]&&0===n.pads[1]){let d,c,_,g=i[0],w=[];if(s){let r=e.kernelCustomData.wT??e.compute(wr(t[1],va),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=r),m){let e=o*l*u;d=t[0].reshape([1,g,e]),c=r.reshape([1,e,f]),_=[1,g,f]}else d=t[0].reshape([g,o*l,u]),c=r.reshape([1,u,f]),_=[g,p*h,f];w.push(d),w.push(c)}else d=t[0].reshape([g,u,o*l]),c=t[1].reshape([1,f,u]),_=[g,f,p*h],w.push(c),w.push(d);a&&w.push(t[2]);let y=_[2],b=w[0].dims[w[0].dims.length-1];return void(y<8&&b<8?e.compute(ea(w,n,i,_,s,r),{inputs:w}):e.compute(la(w,n,i,_,s,r),{inputs:w}))}let _=e.kernelCustomData.wT??e.compute(wr(t[1],va),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=_);let g=[t[0],_];a&&g.push(t[2]);let w=s?p*h:f,y=s?f:p*h,b=d*c*u;e.compute(da(g,n,i,w,y,b,a,!0,r),{inputs:g})},za=(e,t)=>{let n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&r.push(e.inputs[2]);let s=[0,t.pads[0],0,t.pads[1]],i=[1].concat(t.strides),a=[1].concat(t.dilations),o=[1].concat(t.kernelShape),l=ka({...t,pads:s,strides:i,dilations:a,kernelShape:o},r);Sa(e,r,l,(e=>n?[e[0],e[2],e[3]]:[e[0],e[1],e[3]]))},Ca=(e,t,n)=>{let r="NHWC"===n.format?"channelsLast":"channelsFirst",s=ka(n,t),i="NOTSET"===n.autoPad?n.pads:n.autoPad,a=ga(t[0].dims,t[1].dims,n.strides,n.dilations,i,!1,r);e.compute(wa(t,s,a.outShape,[a.filterDepth,a.filterHeight,a.filterWidth],[a.padInfo.front,a.padInfo.top,a.padInfo.left],r))},Ta=(e,t)=>{if($a(e.inputs,t),3===e.inputs[0].dims.length)za(e,t);else if(5===e.inputs[0].dims.length)Ca(e,e.inputs,t);else{let n=ka(t,e.inputs);Sa(e,e.inputs,n)}}})),Yd=ut((()=>{vd(),kd(),Td(),Id(),Ia=(e,t,n)=>{let r=e.length>2,s=t.outputShape,i="NHWC"===t.format,a=t.group,o=e[1].dims,l=o[2]/a,u=o[3],d=i?er(u):1,c=Wn.size(s)/d,p=[Math.ceil(c/64),1,1];Tn("verbose",(()=>`[conv2d_backprop_webgpu] dispatch = ${p}`));let h=["rank","rank"],f=[t.strides[0],t.strides[1]],m=[t.kernelShape[i?1:2],t.kernelShape[i?2:3]],_=[t.dilations[0],t.dilations[1]],g=[m[0]+(t.dilations[0]<=1?0:(t.kernelShape[i?1:2]-1)*(t.dilations[0]-1)),m[1]+(t.dilations[1]<=1?0:(t.kernelShape[i?2:3]-1)*(t.dilations[1]-1))],w=[g[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),g[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],y=[{type:12,data:c},{type:12,data:f},{type:12,data:m},{type:12,data:_},{type:12,data:g},{type:6,data:w},{type:12,data:l},{type:12,data:u},...Jn(e[0].dims,e[1].dims)];r&&(y.push(...Jn(e[2].dims)),h.push("rank")),y.push(...Jn(s));return{name:"ConvTranspose2D",shaderCache:{hint:`${t.cacheKey};${d}`,inputDependencies:h},getRunData:()=>({dispatchGroup:{x:p[0],y:p[1],z:p[2]},outputs:[{dims:n?n(s):s,dataType:e[0].dataType}],programUniforms:y}),getShaderSource:t=>{let n=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:f.length},{name:"filter_dims",type:"u32",length:m.length},{name:"dilations",type:"u32",length:m.length},{name:"effective_filter_dims",type:"u32",length:g.length},{name:"pads",type:"i32",length:w.length},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],a=Yn(e[0].dataType),o=i?1:2,l=i?2:3,u=i?3:1,c=ar("W",e[1].dataType,e[1].dims.length,d),p=ar("Dy",e[0].dataType,e[0].dims.length),h=[p,c];r&&h.push(ar("bias",e[2].dataType,[s[u]].length,d));let _=or("result",e[0].dataType,s.length,d),y=`\\n            let outputIndices = ${_.offsetToIndices(`global_idx * ${d}`)};\\n            let batch = ${_.indicesGet("outputIndices",0)};\\n            let d1 = ${_.indicesGet("outputIndices",u)};\\n            let r = ${_.indicesGet("outputIndices",o)};\\n            let c = ${_.indicesGet("outputIndices",l)};\\n            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\\n            let dyRCorner = dyCorner.x;\\n            let dyCCorner = dyCorner.y;\\n            let groupId = d1 / uniforms.output_channels_per_group;\\n            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\\n            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\\n            // ? = to be determined. : = across all values in that axis.\\n            var dotProd = ${_.type.value}(0.0);\\n            for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\\n              if (wR % uniforms.dilations.x != 0) {\\n                continue;\\n              }\\n              let dyR = (${a}(dyRCorner) + ${a}(wR)) / ${a}(uniforms.strides[0]);\\n              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\\n              if (dyR < 0.0 || dyR >= ${a}(uniforms.Dy_shape[${o}]) || fract(dyR) > 0.0 ||\\n                  wRPerm < 0) {\\n                continue;\\n              }\\n              let idyR: u32 = u32(dyR);\\n\\n              for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\\n                if (wC % uniforms.dilations.y != 0) {\\n                  continue;\\n                }\\n                let dyC = (${a}(dyCCorner) + ${a}(wC)) / ${a}(uniforms.strides.y);\\n                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\\n                if (dyC < 0.0 || dyC >= ${a}(uniforms.Dy_shape[${l}]) ||\\n                    fract(dyC) > 0.0 || wCPerm < 0) {\\n                  continue;\\n                }\\n                let idyC: u32 = u32(dyC);\\n                var inputChannel = groupId * uniforms.input_channels_per_group;\\n                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {\\n                  let xValue = ${i?p.get("batch","idyR","idyC","inputChannel"):p.get("batch","inputChannel","idyR","idyC")};\\n                  let w_offset = ${c.indicesToOffset(`${c.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};\\n                  let wValue = ${c.getByOffset(`w_offset / ${d}`)};\\n                  dotProd = dotProd + xValue * wValue;\\n                  inputChannel = inputChannel + 1;\\n                }\\n              }\\n            }\\n            let value = dotProd${r?` + bias[d1 / ${d}]`:""};\\n            ${_.setByOffset("global_idx","value")};\\n          `;return`\\n    ${t.registerUniforms(n).declareVariables(...h,_)}\\n      ${t.mainStart()}\\n      ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};\\n    ${y}}`}}}})),Zd=ut((()=>{Yd(),qd(),Ad(),Aa=(e,t,n,r,s,i)=>(e-1)*t+n+(r-1)*s+1-i,Ma=(e,t,n,r,s)=>{let i=Math.floor(e/2);"SAME_UPPER"===t?(n[r]=i,n[s]=e-i):"SAME_LOWER"===t&&(n[r]=e-i,n[s]=i)},Oa=(e,t,n,r,s,i,a,o,l,u)=>{let d=e.length-2,c=0===u.length;l.length<d&&l.push(...Array(d-l.length).fill(0));let p=e[0],h=t[o?3:1]*s;for(let s=0,p=e.length-d-(o?1:0);s<d;++s,++p){let o=e[p],h=c?o*a[s]:u[s],f=Aa(o,a[s],i[s],t[p],n[s],h);Ma(f,r,i,s,s+d),c&&u.push(a[s]*(o-1)+l[s]+(t[p]-1)*n[s]+1-i[s]-i[s+d])}u.splice(0,0,p),u.splice(o?3:1,0,h)},Ba=(e,t)=>{let n=e.kernelShape.slice();if(0===e.kernelShape.length||0===e.kernelShape.reduce(((e,t)=>e*t),1)){n.length=0;for(let e=2;e<t[1].dims.length;++e)n.push(t[1].dims[e])}let r="NHWC"===e.format;n.splice(0,0,t[1].dims[0]),n.splice(r?3:1,0,t[1].dims[1]);let s=e.pads.slice(),i=e.outputShape.slice(),a=e.outputPadding.slice(),o=t[0].dims,l=e.dilations.slice();if(0===l.reduce(((e,t)=>e+t),0)){let e=t[0].dims.length-2;l=new Array(e).fill(1)}let u=e.strides.slice();if(0===u.reduce(((e,t)=>e+t),0)){let e=t[0].dims.length-2;u=new Array(e).fill(1)}Oa(o,n,l,e.autoPad,e.group,s,u,r,a,i);let d=Object.assign({},e);return Object.assign(d,{kernelShape:n,pads:s,outputPadding:a,outputShape:i,dilations:l,strides:u}),d},Na=e=>{let t=Xi(e),n=e.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],s=e.dilations,i=e.group,a=e.kernelShape,o=e.pads,l=e.strides,u=e.wIsConst();return{autoPad:r,format:n,dilations:s,group:i,kernelShape:a,outputPadding:e.outputPadding,outputShape:e.outputShape,pads:o,strides:l,wIsConst:u,...t,cacheKey:`${e.format};${t.activation};`}},Pa=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(3===e.length&&(1!==e[2].dims.length||e[2].dims[0]!==n))throw new Error("invalid bias");let r=e[0].dims.length-2;if(t.dilations.reduce(((e,t)=>e+t),0)>0&&t.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(t.strides.reduce(((e,t)=>e+t),0)>0&&t.strides.length!==r)throw new Error(`strides should be ${r}D`);if(t.pads.reduce(((e,t)=>e+t),0)>0&&t.pads.length!==2*r)throw new Error(`pads should be ${2*r}D`);if(t.outputPadding.length!==r&&0!==t.outputPadding.length)throw new Error(`output_padding should be ${r}D`);if(t.kernelShape.reduce(((e,t)=>e+t),0)>0&&0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==t.outputShape.length&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},Ra=(e,t,n,r)=>{let s=e.kernelCustomData.wT??e.compute(wr(t[1],[2,3,0,1]),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=s);let i=[t[0],s];3===t.length&&i.push(t[2]),e.compute(Ia(i,n,r),{inputs:i})},Da=(e,t)=>{let n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&r.push(e.inputs[2]);let s=t.kernelShape;(0===s.length||0===s[0])&&(s=[e.inputs[1].dims[2]]);let i=t.dilations;(0===i.length||0===i[0])&&(i=[1]);let a=t.strides;(0===a.length||0===a[0])&&(a=[1]);let o=t.pads;0===o.length&&(o=[0,0]),o=[0,o[0],0,o[1]],a=[1].concat(a),i=[1].concat(i),s=[1].concat(s);let l=Ba({...t,pads:o,strides:a,dilations:i,kernelShape:s},r);Ra(e,r,l,(e=>n?[e[0],e[2],e[3]]:[e[0],e[1],e[3]]))},Fa=(e,t)=>{if(Pa(e.inputs,t),3===e.inputs[0].dims.length)Da(e,t);else{let n=Ba(t,e.inputs);Ra(e,e.inputs,n)}}})),Jd=ut((()=>{vd(),Td(),Cd(),Id(),La=(e,t,n,r)=>{let s=Wn.size(t),i=t.length,a=ar("input",e,i),o=or("output",e,i),l=6===n.dataType?n.getInt32Array()[0]:Number(n.getBigInt64Array()[0]),u=Wn.normalizeAxis(l,i);return{name:"CumSum",shaderCache:{hint:r.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:[{type:12,data:s},{type:12,data:u},...Jn(t,t)]}),getShaderSource:e=>{let t=` i32(${a.indicesGet("inputIndices","uniforms.axis")}) `,n=sr("uniforms.input_shape","uniforms.axis",i),s=r.reverse?t+(r.exclusive?" + 1":""):"0",l=r.reverse?n:t+(r.exclusive?"":" + 1");return`\\n                ${e.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(a,o)}\\n                ${e.mainStart()}\\n                  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n                  var inputIndices = ${o.offsetToIndices("global_idx")};\\n                  var sum = ${o.type.value}(0);\\n                  let first : i32 = ${s};\\n                  let last : i32 = ${l};\\n                  for (var i : i32 = first; i < last; i++) {\\n                    ${a.indicesSet("inputIndices","uniforms.axis","u32(i)")};\\n                    sum = sum + ${a.getByIndices("inputIndices")};\\n                  }\\n                  ${o.setByOffset("global_idx","sum")};\\n                }`}}},Ua=(e,t)=>{let n=e.inputs[0].dims,r=e.inputs[0].dataType,s=e.inputs[1];e.compute(La(r,n,s,t),{inputs:[0]})},qa=e=>{let t=1===e.exclusive,n=1===e.reverse;return Un({exclusive:t,reverse:n})}})),ec=ut((()=>{vd(),Td(),Cd(),Id(),Va=e=>{if(!e||1!==e.length)throw new Error("DepthToSpace requires 1 input.");if(4!==e[0].dims.length)throw new Error("DepthToSpace requires 4D input.")},Wa=(e,t,n,r)=>{let s=[];s.push(`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {\\n    var a: ${n.type.indices};`);for(let r=0;r<t;++r)s.push(n.indicesSet("a",e[r],`i[${r}]`));return s.push("return a;}"),s.join("\\n")},ja=(e,t)=>{let n,r,s,i,a,o,l="NHWC"===t.format,u=t.blocksize,d="DCR"===t.mode;l?([n,r,s,i]=e.dims,a=d?[n,r,s,u,u,i/u**2]:[n,r,s,i/u**2,u,u],o=d?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([n,r,s,i]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],a=d?[n,u,u,i/u**2,r,s]:[n,i/u**2,u,u,r,s],o=d?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let c=e.reshape(a),p=c.dims.length,h=e.dataType,f=ar("a",h,p),m=or("output",h,p);return{name:"DepthToSpace",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:["rank"]},getRunData:e=>{let t=l?[n,r*u,s*u,i/u**2]:[n,i/u**2,r*u,s*u],a=Wn.size(t),d=c.dims,p=Wn.sortBasedOnPerm(d,o);return{outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:[{type:12,data:a},...Jn(d,p)]}},getShaderSource:e=>`\\n  ${e.registerUniform("output_size","u32").declareVariables(f,m)}\\n\\n  ${Wa(o,p,f,m)}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n\\n    let indices = ${m.offsetToIndices("global_idx")};\\n    let aIndices = perm(indices);\\n\\n    ${m.setByOffset("global_idx",f.getByIndices("aIndices"))}\\n  }`}},Ga=(e,t)=>{Va(e.inputs),e.compute(ja(e.inputs[0],t))},Ha=e=>Un({blocksize:e.blocksize,mode:e.mode,format:e.format})})),tc=ut((()=>{vd(),Td(),Cd(),Id(),Qa="^"+(Xa="("+(Ka="[a-zA-Z]|\\\\.\\\\.\\\\.")+")+")+"$",Ya="^"+("("+Xa+",)*"+Xa)+"$",Za=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,t){let n=this.symbolToIndices.get(e);void 0===n?n=[t]:n.push(t),this.symbolToIndices.set(e,n)}},Ja=class{constructor(e,t){this.equation=t,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,r]=t.includes("->")?t.split("->",2):[t,""];if(!n.match(RegExp(Ya)))throw new Error("Invalid LHS term");if(n.split(",").forEach(((t,n)=>{let r=e[n].dims.slice();if(!t.match(RegExp(Qa)))throw new Error("Invalid LHS term");let s=this.processTerm(t,!0,r,n);this.lhs.push(s)})),""===r)r+=[...this.symbolToInfo.entries()].filter((([e,t])=>1===t.count||"..."===e)).map((([e])=>e)).join("");else if(!r.match(RegExp(Xa)))throw new Error("Invalid RHS");r.match(RegExp(Ka,"g"))?.forEach((e=>{if("..."===e)this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let t=this.symbolToInfo.get(e);if(void 0===t)throw new Error("Invalid RHS symbol");this.outputDims.push(t.dimValue)}})),this.rhs=this.processTerm(r,!1,this.outputDims)}addSymbol(e,t,n){let r=this.symbolToInfo.get(e);if(void 0!==r){if(r.dimValue!==t&&1!==r.count)throw new Error("Dimension mismatch");r.count++,r.inputIndices.push(n)}else r={count:1,dimValue:t,inputIndices:[n]};this.symbolToInfo.set(e,r)}processTerm(e,t,n,r=-1){let s=n.length,i=!1,a=[],o=0;if(!e.match(RegExp(Qa))&&!t&&""!==e)throw new Error("Invalid LHS term");let l=e.match(RegExp(Ka,"g")),u=new Za(r);return l?.forEach(((e,d)=>{if("..."===e){if(i)throw new Error("Only one ellipsis is allowed per input term");i=!0;let e=s-l.length+1;if(e<0)throw new Error("Ellipsis out of bounds");if(a=n.slice(o,o+e),this.hasEllipsis){if(this.ellipsisDims.length!==a.length||this.ellipsisDims.toString()!==a.toString())throw new Error("Ellipsis dimensions mismatch")}else{if(!t)throw new Error("Ellipsis must be specified in the LHS");this.hasEllipsis=!0,this.ellipsisDims=a}for(let e=0;e<a.length;e++){let t=String.fromCharCode("0".charCodeAt(0)+e);u.addSymbol(t,d+e),this.addSymbol(t,n[o++],r)}}else u.addSymbol(e,d+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(e,n[o++],r)})),u}},eo=e=>e+"_max",to=(e,t,n,r)=>{let s=e.map((e=>e.length)).map(((e,n)=>ar(`input${n}`,t,e))),i=Wn.size(r),a=or("output",t,r.length),o=[...n.symbolToInfo.keys()].filter((e=>!n.rhs.symbolToIndices.has(e)));return{name:"Einsum",shaderCache:{hint:n.equation,inputDependencies:e.map((()=>"rank"))},getRunData:()=>{let s=o.filter((e=>n.symbolToInfo.has(e))).map((e=>({type:12,data:n.symbolToInfo.get(e)?.dimValue||0})));s.push({type:12,data:i});let a=e.map(((e,t)=>[...Jn(e)])).reduce(((e,t)=>e.concat(t)),s);return a.push(...Jn(r)),{outputs:[{dims:r,dataType:t}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:a}},getShaderSource:e=>{let t=[],r=[],i=[],l=[],u=[],d=n.symbolToInfo.size===n.rhs.symbolToIndices.size;n.symbolToInfo.forEach(((e,o)=>{if(n.rhs.symbolToIndices.has(o)){let r=n.rhs.symbolToIndices.get(o)?.[0];void 0!==r&&n.lhs.forEach(((n,i)=>{if(e.inputIndices.includes(i)){let e=n.symbolToIndices.get(o);if(void 0===e)throw new Error("Invalid symbol error");e.forEach((e=>{t.push(`${s[i].indicesSet(`input${i}Indices`,e,a.indicesGet("outputIndices",r))}`)}))}}))}else n.lhs.forEach(((t,n)=>{if(e.inputIndices.includes(n)){let e=t.symbolToIndices.get(o);if(void 0===e)throw new Error("Invalid symbol error");e.forEach((e=>{r.push(`${s[n].indicesSet(`input${n}Indices`,e,`${o}`)}`)})),u.push(`prod *= ${s[n].getByIndices(`input${n}Indices`)};`)}})),i.push(`for(var ${o}: u32 = 0; ${o} < uniforms.${eo(o)}; ${o}++) {`),l.push("}")}));let c=d?[...t,`let sum = ${s.map(((e,t)=>e.getByIndices(`input${t}Indices`))).join(" * ")};`]:[...t,"var sum = 0.0;",...i,...r,"var prod = 1.0;",...u,"sum += prod;",...l];return`\\n            ${e.registerUniforms(o.map((e=>({name:`${eo(e)}`,type:"u32"})))).registerUniform("outputSize","u32").declareVariables(...s,a)}\\n\\n            ${e.mainStart()}\\n            ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n            var outputIndices = ${a.offsetToIndices("global_idx")};\\n            ${s.map(((e,t)=>`var input${t}Indices: ${s[t].type.indices};`)).join("\\n")}\\n            ${c.join("\\n")};\\n            ${a.setByOffset("global_idx","sum")};\\n          }`}}},no=(e,t)=>{let n=new Ja(e.inputs,t.equation),r=n.outputDims,s=e.inputs.map(((e,t)=>e.dims));e.compute(to(s,e.inputs[0].dataType,n,r))},ro=e=>{let t=e.equation.replace(/\\s+/g,"");return Un({equation:t})}})),nc=ut((()=>{vd(),Td(),Id(),so=e=>{if(!e||2!==e.length)throw new Error("Expand requires 2 input.");let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=n.length<t.length?0:n.length-t.length,s=t.length<n.length?0:t.length-n.length;for(;r<n.length&&s<t.length;++r,++s)if(n[r]!==t[s]&&1!==n[r]&&1!==t[s])throw new Error("Expand requires shape to be broadcastable to input")},io=(e,t)=>{let n=e.length-t.length,r=[];for(let t=0;t<n;++t)r.push(e[t]);for(let s=0;s<t.length;++s)r.push(1===t[s]?e[s+n]:t[s]);return r},ao=(e,t)=>e.length>t.length?io(e,t):io(t,e),oo=e=>{let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=ao(t,n),s=e[0].dataType,i=9===s||1===Wn.size(t),a=9===s||t.length>0&&t[t.length-1]%4==0?4:1,o=i||r.length>0&&r[r.length-1]%4==0?4:1,l=Math.ceil(Wn.size(r)/o),u=[{type:12,data:l},...Jn(t,r)];return{name:"Expand",shaderCache:{hint:`${r.length};${a}${o}`,inputDependencies:["rank"]},getShaderSource:e=>{let n,i=ar("input",s,t.length,a),l=or("output",s,r.length,o);if(9===s){let e=(e,t,n="")=>`\\n          let outputIndices${t} = ${l.offsetToIndices(`outputOffset + ${t}u`)};\\n          let offset${t} = ${i.broadcastedIndicesToOffset(`outputIndices${t}`,l)};\\n          let index${t} = offset${t} / 4u;\\n          let component${t} = offset${t} % 4u;\\n          ${e}[${t}] = ${n}(${i.getByOffset(`index${t}`)}[component${t}]);\\n        `;n=`\\n        let outputOffset = global_idx * ${o};\\n        var data = vec4<u32>(0);\\n        ${e("data",0,"u32")}\\n        ${e("data",1,"u32")}\\n        ${e("data",2,"u32")}\\n        ${e("data",3,"u32")}\\n        ${l.setByOffset("global_idx","data")}\\n      }`}else n=`\\n        let outputIndices = ${l.offsetToIndices(`global_idx * ${o}`)};\\n        let inputOffset = ${i.broadcastedIndicesToOffset("outputIndices",l)};\\n        let data = ${l.type.value}(${i.getByOffset(`inputOffset / ${a}`)});\\n        ${l.setByOffset("global_idx","data")}\\n      }`;return`\\n    ${e.registerUniform("vec_size","u32").declareVariables(i,l)}\\n    ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\\n    ${n}`},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u})}},lo=e=>{so(e.inputs),e.compute(oo(e.inputs),{inputs:[0]})}})),rc=ut((()=>{vd(),Td(),Id(),Dd(),uo=e=>{let t=e[0].dataType,n=Wn.size(e[0].dims),r=Wn.size(e[1].dims),s=r%4==0;return{name:"FastGeluWithBias",shaderCache:{hint:`${s}`,inputDependencies:["type","type"]},getShaderSource:e=>{let n=ar("x",t,[1],4),r=ar("bias",t,[1],4),i=or("y",t,[1],4),a=e=>`\\n      let bias${e}_offset: u32 = (global_idx * 4 + ${e}) % uniforms.bias_size;\\n      let bias${e} = ${r.getByOffset(`bias${e}_offset / 4`)}[bias${e}_offset % 4];`,o=s?`\\n      let bias = ${r.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${a(0)}${a(1)}${a(2)}${a(3)}\\n      let bias = ${n.type.value}(bias0, bias1, bias2, bias3);`;return`${e.registerUniforms([{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}]).declareVariables(n,r,i)}\\n\\n    ${_i(Zn(t))}\\n\\n    ${e.mainStart(Xn)}\\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}\\n\\n      let x = ${n.getByOffset("global_idx")};\\n      ${o}\\n      let x_in = x + bias;\\n      ${i.setByOffset("global_idx",gi("x_in"))}\\n    }`},getRunData:e=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],programUniforms:[{type:12,data:Math.ceil(n/4)},{type:12,data:r}],dispatchGroup:{x:Math.ceil(n/Xn/4)}})}},co=e=>{e.inputs.length<2||0===Wn.size(e.inputs[1].dims)?wi(e):e.compute(uo(e.inputs))}})),sc=ut((()=>{vd(),Td(),Cd(),Id(),po=e=>{if(!e||2!==e.length)throw new Error("Gather requires 2 inputs.")},ho=(e,t)=>{let n=e[0].dims,r=e[1].dims,s=n.length,i=Wn.normalizeAxis(t.axis,s),a=n.slice(0);a.splice(i,1,...r);let o=n[i],l=9===e[0].dataType?4:1,u=Math.ceil(Wn.size(a)/l),d=[{type:12,data:u},{type:6,data:o},{type:12,data:i},...Jn(e[0].dims,e[1].dims,a)];return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:d}),getShaderSource:t=>{let n,o=ar("data",e[0].dataType,e[0].dims.length,l),u=ar("inputIndices",e[1].dataType,e[1].dims.length),d=or("output",e[0].dataType,a.length,l),c=e=>{let t=r.length,n=`var indicesIndices${e}  = ${u.type.indices}(0);`;for(let r=0;r<t;r++)n+=`${t>1?`indicesIndices${e}[${r}]`:`indicesIndices${e}`} = ${a.length>1?`outputIndices${e}[uniforms.axis + ${r}]`:`outputIndices${e}`};`;n+=`\\n          var idx${e} = ${u.getByIndices(`indicesIndices${e}`)};\\n          if (idx${e} < 0) {\\n            idx${e} = idx${e} + uniforms.axisDimLimit;\\n          }\\n          var dataIndices${e} : ${o.type.indices};\\n        `;for(let r=0,o=0;r<s;r++)r===i?(n+=`${s>1?`dataIndices${e}[${r}]`:`dataIndices${e}`} = u32(idx${e});`,o+=t):(n+=`${s>1?`dataIndices${e}[${r}]`:`dataIndices${e}`} = ${a.length>1?`outputIndices${e}[${o}]`:`outputIndices${e}`};`,o++);return n};if(9===e[0].dataType){let e=(e,t,n="")=>`\\n          let outputIndices${t} = ${d.offsetToIndices(`outputOffset + ${t}u`)};\\n          ${c(t)};\\n          let offset${t} = ${o.indicesToOffset(`dataIndices${t}`)};\\n          let index${t} = offset${t} / 4u;\\n          let component${t} = offset${t} % 4u;\\n          ${e}[${t}] = ${n}(${o.getByOffset(`index${t}`)}[component${t}]);\\n        `;n=`\\n        let outputOffset = global_idx * ${l};\\n        var value = vec4<u32>(0);\\n        ${e("value",0,"u32")}\\n        ${e("value",1,"u32")}\\n        ${e("value",2,"u32")}\\n        ${e("value",3,"u32")}\\n        ${d.setByOffset("global_idx","value")}\\n      `}else n=`\\n      let outputIndices = ${d.offsetToIndices("global_idx")};\\n      ${c("")};\\n      let value = ${o.getByIndices("dataIndices")};\\n      ${d.setByOffset("global_idx","value")};\\n      `;return`\\n      ${t.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(o,u,d)}\\n      ${t.mainStart()}\\n        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n        ${n}\\n      }`}}},fo=e=>Un({axis:e.axis}),mo=(e,t)=>{let n=e.inputs;po(n),e.compute(ho(e.inputs,t))}})),ic=ut((()=>{vd(),Td(),Id(),_o=(e,t,n,r,s,i,a,o,l)=>{let u=[{type:12,data:i},{type:12,data:r},{type:12,data:s},{type:12,data:n},{type:12,data:a},{type:12,data:o},{type:12,data:l}],d=[i];u.push(...Jn(t.dims,d));return e.compute({name:"computeSliceOffsets",shaderCache:{hint:`${s.length}_${n.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:d,dataType:e.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:u}),getShaderSource:e=>{let r=[ar("indices_data",t.dataType,t.dims.length),or("input_slice_offsets_data",12,1,1)],i=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:s.length},{name:"sizes_from_slice_dims_data",type:"u32",length:n.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`\\n  ${e.registerUniforms(i).declareVariables(...r)}\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n    let batch_idx = global_idx / uniforms.num_slices_per_batch;\\n    let base_offset = batch_idx * uniforms.input_batch_stride;\\n\\n    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;\\n    var relative_slice_offset = 0;\\n    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {\\n      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);\\n      let input_dim_idx = uniforms.batch_dims + dim_idx;\\n      if (index < 0) {\\n        ${1===s.length?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}\\n      }\\n      ${1===n.length?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}\\n    }\\n\\n    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);\\n  }`}},{inputs:[t],outputs:[-1]})[0]},go=(e,t)=>{let n=e.inputs,r=n[0].dims,s=n[0].dataType,i=n[1].dims,a=i[i.length-1],o=Wn.sizeToDimension(i,i.length-1),l=Wn.sizeFromDimension(r,t.batchDims+a),u=Wn.sizeToDimension(r,t.batchDims),d=Wn.sizeFromDimension(r,t.batchDims),c=o/u,p=new Array(a),h=l;for(let e=0;e<a;++e)p[a-1-e]=h,h*=r[t.batchDims+a-1-e];let f=_o(e,n[1],p,t.batchDims,r,o,c,d,a),m=t.batchDims+a;if(m>r.length)throw new Error("last dimension of indices must not be larger than rank of input tensor");let _=i.slice(0,-1).concat(r.slice(m)),g=Wn.size(_),w=[{type:12,data:g},{type:12,data:l},...Jn(n[0].dims,f.dims,_)];e.compute({name:"GatherND",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:_,dataType:s}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:w}),getShaderSource:e=>{let t=ar("data",n[0].dataType,n[0].dims.length),r=ar("slice_offsets",12,f.dims.length),s=or("output",n[0].dataType,_.length);return`\\n          ${e.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(t,r,s)}\\n            ${e.mainStart()}\\n            ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];\\n          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];\\n        }`}},{inputs:[n[0],f]})},wo=e=>({batchDims:e.batch_dims,cacheKey:""})})),ac=ut((()=>{vd(),Td(),Cd(),Id(),yo=(e,t)=>{if(e.length<3||e.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let n=Wn.normalizeAxis(t.quantizeAxis,e[0].dims.length),r=t.blockSize,s=e[0],i=e[2],a=4===e.length?e[3]:void 0;if(i.dims.length!==s.dims.length||!s.dims.map(((e,t)=>t===n?Math.ceil(e/r)===i.dims[t]:e===i.dims[t])).reduce(((e,t)=>e&&t),!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(a){if(a.dataType!==s.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(a.dims.length!==i.dims.length||!a.dims.map(((e,t)=>e===i.dims[t])).reduce(((e,t)=>e&&t),!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},bo=(e,t)=>{let n=e[0].dims,r=e[1].dims,s=n.length,i=Wn.normalizeAxis(t.gatherAxis,s),a=Wn.normalizeAxis(t.quantizeAxis,s),o=n.slice(0);o.splice(i,1,...r);let l=Wn.size(o),u=e[2].dataType,d=22===e[0].dataType,c=[{type:12,data:l},{type:12,data:a},{type:12,data:i},{type:12,data:t.blockSize},...Jn(...e.map(((e,t)=>e.dims)),o)];return{name:"GatherBlockQuantized",shaderCache:{hint:`${t.cacheKey};${e.filter(((e,t)=>1!==t)).map((e=>e.dims.join("_"))).join(";")}`,inputDependencies:Array.from({length:e.length},((e,t)=>"rank"))},getRunData:()=>({outputs:[{dims:o,dataType:u}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:c}),getShaderSource:t=>{let s=ar("data",e[0].dataType,e[0].dims.length),a=ar("inputIndices",e[1].dataType,e[1].dims.length),l=ar("scales",e[2].dataType,e[2].dims.length),c=e.length>3?ar("zeroPoint",e[3].dataType,e[3].dims.length):void 0,p=or("output",u,o.length),h=[s,a,l];c&&h.push(c);return`\\n        ${t.registerUniforms([{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}]).declareVariables(...h,p)}\\n        ${t.mainStart()}\\n        let output_indices = ${p.offsetToIndices("global_idx")};\\n        var indices_indices = ${a.type.indices}(0);\\n        ${r.length>1?`\\n          for (var i: u32 = 0; i < ${r.length}; i++) {\\n            let index = ${p.indicesGet("output_indices","uniforms.gather_axis + i")};\\n            ${a.indicesSet("indices_indices","i","index")};\\n          }`:`indices_indices = ${p.indicesGet("output_indices","uniforms.gather_axis")};`};\\n        var data_indices = ${s.type.indices}(0);\\n        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {\\n          let index = ${p.indicesGet("output_indices","i")};\\n          ${s.indicesSet("data_indices","i","index")};\\n        }\\n        var index_from_indices = ${a.getByIndices("indices_indices")};\\n        if (index_from_indices < 0) {\\n          index_from_indices += ${n[i]};\\n        }\\n        ${s.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};\\n        for (var i = uniforms.gather_axis + 1; i < ${o.length}; i++) {\\n          let index = ${p.indicesGet("output_indices",`i + ${r.length} - 1`)};\\n          ${s.indicesSet("data_indices","i","index")};\\n        }\\n        let data_offset = ${s.indicesToOffset("data_indices")};\\n        let data_index = data_offset % 8;\\n        // Convert 4-bit packed data to 8-bit packed data.\\n        let packed_4bit_quantized_data = ${s.getByOffset("data_offset / 8")};\\n        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;\\n        let quantized_data_vec = ${d?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));\\n        let quantized_data = quantized_data_vec[data_index / 2];\\n        var scale_indices = data_indices;\\n        let quantize_axis_index = ${l.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;\\n        ${l.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};\\n        var scale = ${l.getByIndices("scale_indices")};\\n        ${c?`\\n              let zero_point_indices = scale_indices;\\n              let zero_point_offset = ${c.indicesToOffset("zero_point_indices")};\\n              let zero_point_index = zero_point_offset % 8;\\n              let packed_4bit_zero_points = ${c.getByOffset("zero_point_offset / 8")};\\n              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;\\n              let zero_point_vec = ${d?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));\\n              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};\\n        let dequantized_data = ${Zn(u)}(quantized_data - zero_point) * scale;\\n        ${p.setByOffset("global_idx","dequantized_data")};\\n    }`}}},xo=(e,t)=>{let n=e.inputs;yo(n,t),e.compute(bo(e.inputs,t))},vo=e=>Un({blockSize:e.blockSize,gatherAxis:e.gatherAxis,quantizeAxis:e.quantizeAxis})})),oc=ut((()=>{vd(),Td(),Cd(),Id(),$o=e=>{if(!e||2!==e.length)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error("GatherElements requires that the data input and\\n                     indices input tensors be of same rank.")},ko=(e,t)=>{let n=e[0].dims,r=e[0].dataType,s=n.length,i=e[1].dims,a=e[1].dataType,o=Wn.normalizeAxis(t.axis,s),l=n[o],u=i.slice(0),d=Wn.size(u),c=ar("input",r,s),p=ar("indicesInput",a,i.length),h=or("output",r,u.length),f=[{type:12,data:d},{type:6,data:l},{type:12,data:o}];return f.push(...Jn(n,i,u)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:f}),getShaderSource:e=>`\\n      ${e.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(c,p,h)}\\n      ${e.mainStart()}\\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n\\n      let outputIndices = ${h.offsetToIndices("global_idx")};\\n\\n      var idx = ${p.getByOffset("global_idx")};\\n      if (idx < 0) {\\n        idx = idx + uniforms.axisDimLimit;\\n      }\\n      var inputIndices = ${c.type.indices}(outputIndices);\\n      ${c.indicesSet("inputIndices","uniforms.axis","u32(idx)")};\\n      let value = ${c.getByIndices("inputIndices")};\\n\\n      ${h.setByOffset("global_idx","value")};\\n  }`}},Eo=e=>Un({axis:e.axis}),So=(e,t)=>{let n=e.inputs;$o(n),e.compute(ko(e.inputs,t))}})),lc=ut((()=>{vd(),Td(),Id(),zo=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(3===e.length&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Co=(e,t)=>{let n=e[0].dims.slice(),r=e[1].dims.slice(),[s,i,a]=Gn.getShapeOfGemmResult(n,t.transA,r,t.transB,3===e.length?e[2].dims:void 0),o=[s,i];if(!o)throw new Error("Can\'t use gemm on the given tensors");let l=16,u=Math.ceil(i/l),d=Math.ceil(s/l),c=(Wn.size(o),[{type:12,data:u},{type:12,data:s},{type:12,data:i},{type:12,data:a},{type:1,data:t.alpha},{type:1,data:t.beta}]),p=["type","type"];3===e.length&&(c.push(...Jn(e[2].dims)),p.push("rank")),c.push(...Jn(o));return{name:"GemmShared",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:u*d},programUniforms:c}),getShaderSource:n=>{let r=ar("a",e[0].dataType,e[0].dims),s=ar("b",e[1].dataType,e[1].dims),i=null,a=[r,s];3===e.length&&(i=ar("c",e[2].dataType,e[2].dims.length),a.push(i));let u=or("output",e[0].dataType,o.length);a.push(u);let d="",c="";t.transA&&t.transB?(c=`\\n      var col = tile_row_start + local_id.x;\\n      var row = k_start + local_id.y;\\n      if (col < uniforms.M && row < uniforms.K) {\\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\\n      } else {\\n        tile_a[local_id.y][local_id.x] = ${r.type.value}(0);\\n      }\\n\\n      col = k_start + local_id.x;\\n      row = tile_col_start + local_id.y;\\n      if (col < uniforms.K && row < uniforms.N) {\\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\\n      } else {\\n        tile_b[local_id.y][local_id.x] = ${s.type.value}(0);\\n      }\\n      `,d="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):t.transA&&!t.transB?(c=`\\n      var col = tile_row_start + local_id.x;\\n      var row = k_start + local_id.y;\\n      if (col < uniforms.M && row < uniforms.K) {\\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\\n      } else {\\n        tile_a[local_id.y][local_id.x] = ${r.type.value}(0);\\n      }\\n\\n      col = tile_col_start + local_id.x;\\n      row = k_start + local_id.y;\\n      if (col < uniforms.N && row < uniforms.K) {\\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\\n      } else {\\n        tile_b[local_id.y][local_id.x] = ${s.type.value}(0);\\n      }\\n      `,d="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!t.transA&&t.transB?(c=`\\n      var col = k_start + local_id.x;\\n      var row = tile_row_start + local_id.y;\\n      if (col < uniforms.K && row < uniforms.M) {\\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\\n      } else {\\n        tile_a[local_id.y][local_id.x] = ${r.type.value}(0);\\n      }\\n\\n      col = k_start + local_id.x;\\n      row = tile_col_start + local_id.y;\\n      if (col < uniforms.K && row < uniforms.N) {\\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\\n      } else {\\n        tile_b[local_id.y][local_id.x] = ${s.type.value}(0);\\n      }\\n      `,d="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!t.transA&&!t.transB&&(c=`\\n      var col = k_start + local_id.x;\\n      var row = tile_row_start + local_id.y;\\n      if (col < uniforms.K && row < uniforms.M) {\\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\\n      } else {\\n        tile_a[local_id.y][local_id.x] = ${r.type.value}(0);\\n      }\\n\\n      col = tile_col_start + local_id.x;\\n      row = k_start + local_id.y;\\n      if (col < uniforms.N && row < uniforms.K) {\\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\\n      } else {\\n        tile_b[local_id.y][local_id.x] = ${s.type.value}(0);\\n      }\\n      `,d="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let p=1===t.alpha?"":"value *= uniforms.alpha;";return`\\n  ${n.registerUniforms([{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}]).declareVariables(...a)}\\n  var<workgroup> tile_a: array<array<${r.type.storage}, 16>, 16>;\\n  var<workgroup> tile_b: array<array<${s.type.storage}, 16>, 16>;\\n  ${n.mainStart([l,l,1])}\\n    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * 16;\\n    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * 16;\\n    let num_tiles = (uniforms.K - 1) / 16 + 1;\\n    var k_start = 0u;\\n    var value = ${u.type.value}(0);\\n    for (var t: u32 = 0u; t < num_tiles; t++) {\\n      ${c}\\n      k_start = k_start + 16;\\n      workgroupBarrier();\\n\\n      for (var k: u32 = 0u; k < 16; k++) {\\n        ${d}\\n      }\\n      workgroupBarrier();\\n    }\\n\\n    ${p}\\n    let m = tile_row_start + local_id.y;\\n    let n = tile_col_start + local_id.x;\\n    ${null!=i?`let cOffset = ${i.broadcastedIndicesToOffset("vec2(m, n)",u)}; value += ${u.type.value}(uniforms.beta) * ${i.getByOffset("cOffset")};`:""}\\n    if (m < uniforms.M && n < uniforms.N) {\\n      output[m * uniforms.N + n] = value;\\n    }\\n  }`}}},To=e=>({transA:e.transA,transB:e.transB,alpha:e.alpha,beta:e.beta,cacheKey:`${e.transA};${e.transB};${1===e.alpha}`}),Io=(e,t)=>{zo(e.inputs),e.compute(Co(e.inputs,t))}})),uc=ut((()=>{vd(),Td(),Cd(),Id(),[Ao,Mo,Oo,Bo]=[0,1,2,3],No=e=>{if(4!==e[0].dims.length)throw new Error("only 4-D tensor is supported.");if(e[0].dims.length!==e[1].dims.length)throw new Error("input dimensions must be equal to grid dimensions");if(e[0].dims.length-2!==e[1].dims[e[1].dims.length-1])throw new Error("last dimension of grid must be equal to "+(e[0].dims.length-2));if(e[0].dims[0]!==e[1].dims[0])throw new Error("grid batch size must match input batch size")},Po=e=>`\\n  fn gs_bicubic_interpolate(p: mat4x4<${e}>, x: f32, y: f32) -> ${e} {\\n    var v: vec4<f32>;\\n    var coeffs = gs_get_cubic_coeffs(x);\\n    for (var i = 0; i < 4; i++) {\\n      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];\\n    }\\n    coeffs = gs_get_cubic_coeffs(y);\\n    let pixel = ${e}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);\\n    return pixel;\\n  }\\n`,Ro=e=>`\\n  fn gs_denormalize(n: f32, length: i32) -> f32 {\\n    ${0===e.alignCorners?"\\n    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]\\n    return ((n + 1.0) * f32(length) - 1.0) / 2.0;\\n    ":"\\n    // alignCorners: true => [-1, 1] to [0, length - 1]\\n    return (n + 1.0) / 2.0 * (f32(length - 1));\\n    "}\\n  }\\n`,Do=e=>`\\n  ${"reflection"===e.paddingMode?"\\n      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {\\n        var dx = 0.0;\\n        var fx = f32(x);\\n        let range = x_max - x_min;\\n        if (fx < x_min) {\\n          dx = x_min - fx;\\n          let n = u32(dx / range);\\n          let r = dx - f32(n) * range;\\n          if (n % 2 == 0) {\\n            fx = x_min + r;\\n          } else {\\n            fx = x_max - r;\\n          }\\n        } else if (fx > x_max) {\\n          dx = fx - x_max;\\n          let n = u32(dx / range);\\n          let r = dx - f32(n) * range;\\n          if (n % 2 == 0) {\\n            fx = x_max - r;\\n          } else {\\n            fx = x_min + r;\\n          }\\n        }\\n        return u32(fx);\\n      }":""}\\n`,Fo=(e,t,n)=>`\\n  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${t} {\\n     var pixel = ${t}(0);\\n     var indices = vec4<u32>(0);\\n     indices[${Ao}] = batch;\\n     indices[${Mo}] = channel;`+(()=>{switch(n.paddingMode){case"zeros":return`\\n          if (r >= 0 && r < H && c >=0 && c < W) {\\n            indices[${Oo}] = u32(r);\\n            indices[${Bo}] = u32(c);\\n          }\\n        `;case"border":return`\\n          indices[${Oo}] = u32(clamp(r, 0, H - 1));\\n          indices[${Bo}] = u32(clamp(c, 0, W - 1));\\n        `;case"reflection":return`\\n          indices[${Oo}] = gs_reflect(r, border[1], border[3]);\\n          indices[${Bo}] = gs_reflect(c, border[0], border[2]);\\n        `;default:throw new Error(`padding mode ${n.paddingMode} is not supported`)}})()+`\\n    return ${e.getByIndices("indices")};\\n  }\\n`,Lo=(e,t,n)=>(()=>{switch(n.mode){case"nearest":return`\\n          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${Ao}], indices[${Mo}], border);\\n        `;case"bilinear":return`\\n          let x1 = i32(floor(x));\\n          let y1 = i32(floor(y));\\n          let x2 = x1 + 1;\\n          let y2 = y1 + 1;\\n\\n          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${Ao}], indices[${Mo}], border);\\n          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${Ao}], indices[${Mo}], border);\\n          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${Ao}], indices[${Mo}], border);\\n          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${Ao}], indices[${Mo}], border);\\n\\n          let dx2 = ${t}(f32(x2) - x);\\n          let dx1 = ${t}(x - f32(x1));\\n          let dy2 = ${t}(f32(y2) - y);\\n          let dy1 = ${t}(y - f32(y1));\\n          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);\\n        `;case"bicubic":return`\\n          let x0 = i32(floor(x)) - 1;\\n          let y0 = i32(floor(y)) - 1;\\n          var p: mat4x4<${t}>;\\n          for (var h = 0; h < 4; h++) {\\n            for (var w = 0; w < 4; w++) {\\n              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${Ao}], indices[${Mo}], border);\\n            }\\n          }\\n\\n          let dx = x - f32(x0 + 1);\\n          let dy = y - f32(y0 + 1);\\n          let result = gs_bicubic_interpolate(p, dx, dy);\\n        `;default:throw new Error(`mode ${n.mode} is not supported`)}})()+`${e.setByOffset("global_idx","result")}`,Uo=(e,t)=>{let n=ar("x",e[0].dataType,e[0].dims.length),r=[e[1].dims[0],e[1].dims[1],e[1].dims[2]],s=ar("grid",e[1].dataType,r.length,2),i=[e[0].dims[0],e[0].dims[1],e[1].dims[1],e[1].dims[2]];"NHWC"===t.format&&(i=[e[0].dims[0],e[1].dims[1],e[1].dims[2],e[0].dims[3]],[Ao,Mo,Oo,Bo]=[0,3,1,2]);let a=or("output",e[0].dataType,i.length),o=n.type.value,l=[{type:12,data:Wn.size(i)},...Jn(e[0].dims,r,i)];return{name:"GridSample",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:["type","type"]},getRunData:e=>{let t=Wn.size(i);return{outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(t/64)},programUniforms:l}},getShaderSource:e=>`\\n  ${e.registerUniform("output_size","u32").declareVariables(n,s,a)}\\n  \\n  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {\\n    let cubic_alpha = -0.75f;\\n    let x_abs = abs(x);\\n    var coeffs: vec4<f32>;\\n    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);\\n    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);\\n    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);\\n    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);\\n    return coeffs;\\n  }\\n\\n  ${Po(o)}\\n  ${Ro(t)}\\n  ${Do(t)}\\n  ${Fo(n,o,t)}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n      let H_in = i32(uniforms.x_shape[${Oo}]);\\n      let W_in = i32(uniforms.x_shape[${Bo}]);\\n\\n      ${0===t.alignCorners?"\\n      let x_min = -0.5;\\n      let x_max = f32(W_in) - 0.5;\\n      let y_min = -0.5;\\n      let y_max = f32(H_in) - 0.5;\\n      ":"\\n      let x_min = 0.0;\\n      let x_max = f32(W_in) - 1.0;\\n      let y_min = 0.0;\\n      let y_max = f32(H_in) - 1.0;\\n      "};\\n      let border = vec4<f32>(x_min, y_min, x_max, y_max);\\n\\n      let indices = ${a.offsetToIndices("global_idx")};\\n      var grid_indices = vec3<u32>(indices[${Ao}], indices[${Oo}], indices[${Bo}]);\\n      let nxy = ${s.getByIndices("grid_indices")};\\n      var x = gs_denormalize(f32(nxy[0]), W_in);\\n      var y = gs_denormalize(f32(nxy[1]), H_in);\\n\\n      ${Lo(a,o,t)}\\n  }`}},qo=(e,t)=>{No(e.inputs),e.compute(Uo(e.inputs,t))},Vo=e=>Un({alignCorners:e.align_corners,mode:e.mode,paddingMode:e.padding_mode,format:e.format})})),dc=ut((()=>{vd(),Td(),Cd(),Sd(),Nd(),Id(),Ad(),Wo=(e,t)=>e.length>t&&e[t].dims.length>0?e[t]:void 0,jo=(e,t)=>{let n=e[0],r=Wo(e,1),s=Wo(e,2),i=Wo(e,3),a=Wo(e,4),o=Wo(e,5),l=Wo(e,6),u=Wo(e,7);if(3!==n.dims.length&&5!==n.dims.length)throw new Error("Input query is expected to have 3 or 5 dimensions");let d,c=n.dims[0],p=n.dims[1],h=3===n.dims.length?n.dims[2]:t.numHeads*n.dims[4],f=p,m=0,_=0,g=Math.floor(h/t.numHeads);if(l&&u&&Wn.size(l.dims)&&Wn.size(u.dims)){if(4!==l.dims.length)throw new Error(\'Input "past_key" is expected to have 4 dimensions\');if(l.dims[0]!==c||l.dims[1]!==t.numHeads||l.dims[3]!==g)throw new Error(\'Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)\');if(u.dims[0]!==c||u.dims[1]!==t.numHeads||u.dims[3]!==g)throw new Error(\'Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)\');if(l.dims[2]!==u.dims[2])throw new Error(\'Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)\');if(4!==u.dims.length)throw new Error(\'Input "past_value" is expected to have 4 dimensions\');m=l.dims[2],_=l.dims[2]}else if(l&&Wn.size(l.dims)||u&&Wn.size(u.dims))throw new Error(\'Input "past_key" and "past_value" shall be both present or both absent\');if(r&&Wn.size(r.dims)>0){if(3!==n.dims.length)throw new Error(\'Input "query" is expected to have 3 dimensions when key is given\');if(r.dims.length<3||r.dims.length>5)throw new Error(\'Input "key" is expected to have 3, 4, or 5 dimensions\');if(n.dims[0]!==r.dims[0])throw new Error(\'Input "query" and "key" shall have same dim 0 (batch size)\');if(3===r.dims.length){if(r.dims[2]!==n.dims[2])throw new Error(\'Input "query" and "key" shall have same dim 2 (hidden_size)\');d=2,f=r.dims[1]}else if(5===r.dims.length){if(r.dims[2]!==t.numHeads||2!==r.dims[3]||r.dims[4]!==g)throw new Error(\'Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv\');if(s)throw new Error(\'Expect "value" be none when "key" has packed kv format.\');d=5,f=r.dims[1]}else{if(r.dims[1]!==t.numHeads||r.dims[3]!==g)throw new Error(\'Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key\');d=0,f=r.dims[2]}}else{if(5!==n.dims.length)throw new Error(\'Input "query" is expected to have 5 dimensions when key is empty\');if(n.dims[2]!==t.numHeads||3!==n.dims[3])throw new Error(\'Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv\');d=3}if(i&&Wn.size(i.dims)>0){if(1!==i.dims.length)throw new Error(\'Input "bias" is expected to have 1 dimension\');if(r&&5===r.dims.length&&2===r.dims[3])throw new Error("bias is not allowed for packed kv.")}let w=m+f,y=0;if(a&&Wn.size(a.dims)>0){y=8;let e=a.dims;throw 1===e.length?e[0]===c?y=1:e[0]===3*c+2&&(y=3):2===e.length&&e[0]===c&&e[1]===w&&(y=5),8===y?new Error(\'Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)\'):new Error("Mask not supported")}let b=!1,x=h;if(s&&Wn.size(s.dims)>0){if(3!==s.dims.length&&4!==s.dims.length)throw new Error(\'Input "value" is expected to have 3 or 4 dimensions\');if(n.dims[0]!==s.dims[0])throw new Error(\'Input "query" and "value" shall have same dim 0 (batch_size)\');if(3===s.dims.length){if(f!==s.dims[1])throw new Error(\'Input "key" and "value" shall have the same dim 1 (kv_sequence_length)\');x=s.dims[2]}else{if(f!==s.dims[2])throw new Error(\'Input "key" and "value" shall have the same dim 2 (kv_sequence_length)\');x=s.dims[1]*s.dims[3],b=!0}}if(a&&Wn.size(a.dims)>0)throw new Error("Key padding mask is not supported");if(o&&Wn.size(o.dims)>0){if(4!==o.dims.length)throw new Error(\'Input "attention_bias" is expected to have 4 dimensions\');if(o.dims[0]!==c||o.dims[1]!==t.numHeads||o.dims[2]!==p||o.dims[3]!==w)throw new Error(\'Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)\')}return{batchSize:c,sequenceLength:p,pastSequenceLength:m,kvSequenceLength:f,totalSequenceLength:w,maxSequenceLength:_,inputHiddenSize:0,hiddenSize:h,vHiddenSize:x,headSize:g,vHeadSize:Math.floor(x/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:y,scale:t.scale,broadcastResPosBias:!1,passPastInKv:b,qkvFormat:d}},Go=e=>Un({...e}),Ho=Un({perm:[0,2,1,3]}),Ko=(e,t,n,r,s,i,a)=>{let o=[r,s,i],l=Wn.size(o),u=[{type:12,data:l},{type:12,data:a},{type:12,data:i}];return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:o,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u}),getShaderSource:e=>{let r=or("qkv_with_bias",t.dataType,o),s=ar("qkv",t.dataType,o),i=ar("bias",n.dataType,o);return`\\n  ${e.registerUniforms([{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}]).declareVariables(s,i,r)}\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\\n\\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\\n  }`}},{inputs:[t,n],outputs:[-1]})[0]},Xo=(e,t,n,r,s,i,a,o)=>{let l=i;if(a&&Wn.size(a.dims)>0){if(1===r)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return l=Ko(e,i,a,t,r,n*s,o),l=l.reshape([t,r,n,s]),1===n||1===r?l:e.compute(wr(l,Ho.perm),{inputs:[l],outputs:[-1]})[0]}return 3===i.dims.length&&(l=i.reshape([t,r,n,s])),1===n||1===r?l:e.compute(wr(l,Ho.perm),{inputs:[l],outputs:[-1]})[0]},Qo=(e,t)=>{let n=jo(e.inputs,t),r=e.inputs[0],s=Wo(e.inputs,1),i=Wo(e.inputs,2),a=Wo(e.inputs,3),o=Wo(e.inputs,4),l=Wo(e.inputs,5),u=Wo(e.inputs,6),d=Wo(e.inputs,7);if(5===r.dims.length)throw new Error("Packed QKV is not implemented");if(5===s?.dims.length)throw new Error("Packed KV is not implemented");let c=s&&i&&4===s.dims.length&&4===i.dims.length,p=Xo(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,r,a,0);if(c)return $s(e,p,s,i,o,void 0,u,d,l,n);if(!s||!i)throw new Error("key and value must be provided");let h=Xo(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.headSize,s,a,n.hiddenSize),f=Xo(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.vHeadSize,i,a,2*n.hiddenSize);$s(e,p,h,f,o,void 0,u,d,l,n)}})),cc=ut((()=>{vd(),Td(),Cd(),Id(),Yo=e=>{if(!e||e.length<1)throw new Error("too few inputs")},Zo=(e,t)=>{let n=[],r=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach((e=>n.push(Number(e)))),r=n.length),Un({numOutputs:r,axis:t.axis,splitSizes:n})},Jo=e=>`\\nfn calculateOutputIndex(index: u32) -> u32 {\\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\\n    if (index < ${sr("uniforms.size_in_split_axis","i",e)}) {\\n        return i;\\n    }\\n    }\\n    return ${e}u;\\n}`,el=e=>{let t=e.length,n=[];for(let r=0;r<t;++r){let s=e[r].setByIndices("indices","input[global_idx]");1===t?n.push(s):0===r?n.push(`if (output_number == ${r}u) { ${s} }`):r===t-1?n.push(`else { ${s} }`):n.push(`else if (output_number == ${r}) { ${s} }`)}return`\\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\\n        ${n.join("\\n")}\\n      }`},tl=(e,t)=>{let n=e[0].dims,r=Wn.size(n),s=e[0].dataType,i=Wn.normalizeAxis(t.axis,n.length),a=new Array(t.numOutputs),o=ar("input",s,n.length),l=new Array(t.numOutputs),u=[],d=[],c=0,p=[{type:12,data:r}];for(let r=0;r<t.numOutputs;r++){c+=t.splitSizes[r],l[r]=c;let o=n.slice();o[i]=t.splitSizes[r],d.push(o),a[r]=or(`output${r}`,s,o.length),u.push({dims:d[r],dataType:e[0].dataType})}p.push({type:12,data:l},...Jn(n,...d));return{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:e=>`\\n  ${e.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",l.length).declareVariables(o,...a)}\\n  ${Jo(l.length)}\\n  ${el(a)}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}\\n\\n    var indices = ${o.offsetToIndices("global_idx")};\\n    var index = ${o.indicesGet("indices",i)};\\n    let output_number = calculateOutputIndex(index);\\n    if (output_number != 0) {\\n      index -= ${sr("uniforms.size_in_split_axis","output_number - 1u",l.length)};\\n      ${o.indicesSet("indices",i,"index")};\\n    }\\n    writeBufferData(output_number, indices, global_idx);\\n  }`,getRunData:()=>({outputs:u,dispatchGroup:{x:Math.ceil(r/64)},programUniforms:p})}},nl=(e,t)=>{Yo(e.inputs);let n=1===e.inputs.length?t:Zo(e.inputs,t);e.compute(tl(e.inputs,n),{inputs:[0]})},rl=e=>{let t=e.axis,n=e.splitSizes,r=e.numOutputs<0?n.length:e.numOutputs;if(r!==n.length)throw new Error("numOutputs and splitSizes lengh must be equal");return Un({axis:t,numOutputs:r,splitSizes:n})}})),pc=ut((()=>{Cd(),Nd(),dc(),cc(),Ad(),sl=(e,t)=>{if(t.doRotary&&e.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let n=e[0],r=e[1],s=e[2],i=e[3],a=e[4];if(-1!==t.localWindowSize)throw new Error("Local attention is not supported");if(0!==t.softcap)throw new Error("Softcap is not supported");if(0!==t.rotaryInterleaved)throw new Error("Rotary interleaved is not supported");if(t.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(3!==n.dims.length&&5!==n.dims.length)throw new Error("Input query is expected to have 3 or 5 dimensions");let o=n.dims[0],l=n.dims[1],u=3===n.dims.length?n.dims[2]:t.numHeads*n.dims[4],d=l,c=0,p=!r||0===r.dims.length,h=Math.floor(p?u/(t.numHeads+2*t.kvNumHeads):u/t.numHeads);p&&(u=h*t.numHeads);let f=i&&0!==i.dims.length,m=a&&0!==a.dims.length;if(f&&4===i.dims.length&&i.dims[0]===o&&i.dims[1]!==t.kvNumHeads&&i.dims[2]===t.kvNumHeads&&i.dims[3]===h)throw new Error("BSNH pastKey/pastValue is not supported");if(f&&m){if(4!==i.dims.length)throw new Error(\'Input "past_key" is expected to have 4 dimensions\');if(4!==a.dims.length)throw new Error(\'Input "past_value" is expected to have 4 dimensions\');c=i.dims[2]}else if(f||m)throw new Error(\'Input "past_key" and "past_value" shall be both present or both absent\');let _=1;if(r&&r.dims.length>0){if(3!==n.dims.length)throw new Error(\'Input "query" is expected to have 3 dimensions when key is given\');if(r.dims.length<3||r.dims.length>5)throw new Error(\'Input "key" is expected to have 3, 4, or 5 dimensions\');if(n.dims[0]!==r.dims[0])throw new Error(\'Input "query" and "key" shall have same dim 0 (batch size)\');if(3===r.dims.length){if(n.dims[2]%r.dims[2]!=0)throw new Error(\'Dimension 2 of "query" should be a multiple of "key"\');d=r.dims[1]}else if(5===r.dims.length){if(r.dims[2]!==t.numHeads||2!==r.dims[3]||r.dims[4]!==h)throw new Error(\'Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv\');if(s)throw new Error(\'Expect "value" be none when "key" has packed kv format.\');d=r.dims[1]}else{if(r.dims[1]!==t.numHeads||r.dims[3]!==h)throw new Error(\'Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key\');d=r.dims[2]}}else{if(3!==n.dims.length&&5!==n.dims.length)throw new Error(\'Input "query" is expected to have 3 or 5 dimensions when key is empty\');if(5===n.dims.length&&(n.dims[2]!==t.numHeads||3!==n.dims[3]))throw new Error(\'Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv\');_=3}let g=!1,w=t.kvNumHeads?h*t.kvNumHeads:u;if(s&&s.dims.length>0){if(3!==s.dims.length&&4!==s.dims.length)throw new Error(\'Input "value" is expected to have 3 or 4 dimensions\');if(n.dims[0]!==s.dims[0])throw new Error(\'Input "query" and "value" shall have same dim 0 (batch_size)\');if(3===s.dims.length){if(d!==s.dims[1])throw new Error(\'Input "key" and "value" shall have the same dim 1 (kv_sequence_length)\');w=s.dims[2]}else{if(d!==s.dims[2])throw new Error(\'Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)\');w=s.dims[1]*s.dims[3],g=!0}}let y=e.length>4?e[5]:void 0;if(y&&1!==y.dims.length&&y.dims[0]!==o)throw new Error(\'Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size\');return{batchSize:o,sequenceLength:l,pastSequenceLength:c,kvSequenceLength:d,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:u,vHiddenSize:w,headSize:h,vHeadSize:Math.floor(w/t.kvNumHeads),numHeads:t.numHeads,kvNumHeads:t.kvNumHeads,nReps:t.numHeads/t.kvNumHeads,pastPresentShareBuffer:!1,maskType:0,scale:t.scale,broadcastResPosBias:!1,passPastInKv:g,qkvFormat:_}},il=Un({perm:[0,2,1,3]}),al=(e,t,n)=>{let r=t,s=n.kvNumHeads;return 3===t.dims.length&&0!==n.kvSequenceLength&&(r=t.reshape([n.batchSize,n.kvSequenceLength,s,n.headSize]),r=e.compute(wr(r,il.perm),{inputs:[r],outputs:[-1]})[0]),r},ol=(e,t)=>{let n=sl(e.inputs,t);if(5===e.inputs[0].dims.length)throw new Error("Packed QKV is not implemented");if(5===e.inputs[1]?.dims.length)throw new Error("Packed KV is not implemented");let r=e.inputs[0],s=e.inputs[1]&&e.inputs[1].dims.length>0?e.inputs[1]:void 0,i=e.inputs[2]&&e.inputs[2].dims.length>0?e.inputs[2]:void 0,a=e.inputs[3]&&0!==e.inputs[3].dims.length?e.inputs[3]:void 0,o=e.inputs[4]&&0!==e.inputs[4].dims.length?e.inputs[4]:void 0,l=e.inputs.length>4?e.inputs[5]:void 0,u=e.inputs.length>5?e.inputs[6]:void 0,d=n.kvNumHeads?n.kvNumHeads:n.numHeads,c=Un({axis:2,numOutputs:3,splitSizes:[n.numHeads*n.headSize,d*n.headSize,d*n.headSize]}),[p,h,f]=s||i?[r,s,i]:e.compute(tl([r],c),{inputs:[r],outputs:[-1,-1,-1]}),m=Xo(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,p,void 0,0);$s(e,m,al(e,h,n),al(e,f,n),void 0,void 0,a,o,void 0,n,l,u)}})),hc=ut((()=>{vd(),Td(),Ad(),Id(),ll=(e,t,n,r,s,i,a,o)=>{let l=er(i),u=1===l?"f32":`vec${l}f`,d=1===l?"vec2f":`mat2x${l}f`,c=s*a,p=64;1===c&&(p=256);let h=[s,a,i/l],f=[s,a,2],m=[];m.push(...Jn(h,f));return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${l};${o};${p}`,inputDependencies:["rank","type","type"]},getRunData:()=>({outputs:[{dims:f,dataType:1}],dispatchGroup:{x:c},programUniforms:m}),getShaderSource:e=>{let s=ar("x",t.dataType,3,l),i=[s,ar("scale",n.dataType,n.dims),ar("bias",r.dataType,r.dims),or("output",1,3,2)];return`\\n  var<workgroup> workgroup_shared : array<${d}, ${p}>;\\n  const workgroup_size = ${p}u;\\n  ${e.declareVariables(...i)}\\n  ${e.mainStart(p)}\\n    let batch = workgroup_index / uniforms.x_shape[1];\\n    let channel = workgroup_index % uniforms.x_shape[1];\\n    let hight = uniforms.x_shape[2];\\n    // initialize workgroup memory\\n    var sum = ${u}(0);\\n    var squared_sum = ${u}(0);\\n    for (var h = local_idx; h < hight; h += workgroup_size) {\\n      let value = ${u}(${s.get("batch","channel","h")});\\n      sum += value;\\n      squared_sum += value * value;\\n    }\\n    workgroup_shared[local_idx] = ${d}(sum, squared_sum);\\n    workgroupBarrier();\\n\\n    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {\\n      if (local_idx < currSize) {\\n        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];\\n      }\\n      workgroupBarrier();\\n    }\\n    if (local_idx == 0) {\\n      let sum_final = ${rr("workgroup_shared[0][0]",l)} / f32(hight * ${l});\\n      let squared_sum_final = ${rr("workgroup_shared[0][1]",l)} / f32(hight * ${l});\\n\\n      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${o}));\\n      let channel_scale = inv_std_dev * f32(scale[channel]);\\n      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;\\n      output[workgroup_index] = vec2f(channel_scale, channel_shift);\\n    }\\n  }`}},{inputs:[t,n,r],outputs:[-1]})[0]},ul=(e,t,n)=>{let r=t[0].dims,s=r,i=r[0],a=r[1],o=Wn.sizeFromDimension(r,2),l=er(o),u=Wn.size(s)/l,d=ll(e,t[0],t[1],t[2],i,o,a,n.epsilon),c=[i,a,o/l],p=[i,a];e.compute({name:"InstanceNormalization",shaderCache:{hint:`${l}`,inputDependencies:["type","none"]},getRunData:()=>({outputs:[{dims:s,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:[{type:12,data:u},...Jn(c,p,c)]}),getShaderSource:e=>{let n=ar("x",t[0].dataType,c.length,l),r=ar("scale_shift",1,p.length,2),s=or("output",t[0].dataType,c.length,l),i=[n,r,s];return`\\n  ${e.registerUniform("output_size","u32").declareVariables(...i)}\\n  ${e.mainStart()}\\n  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n      let outputIndices = ${s.offsetToIndices("global_idx")};\\n      let batch = outputIndices[0];\\n      let channel = outputIndices[1];\\n      let scale_shift = ${r.getByIndices("vec2<u32>(batch, channel)")};\\n      let value = ${n.getByOffset("global_idx")} * ${s.type.value}(scale_shift.x) + ${s.type.value}(scale_shift.y);\\n      ${s.setByOffset("global_idx","value")};\\n  }`}},{inputs:[t[0],d]})},dl=(e,t,n)=>{let r=t[0].dims,s=r,i=r[0],a=r[r.length-1],o=Wn.sizeFromDimension(r,1)/a,l=er(a),u=Wn.size(s)/l,d=[{type:12,data:o},{type:12,data:Math.floor(a/l)}],c=!1,p=[0,r.length-1];for(let e=0;e<r.length-2;e++)c=c||1!==r[e+1],p.push(e+1);c=c&&1!==r[r.length-1];let h=c?e.compute(wr(e.inputs[0],p),{inputs:[e.inputs[0]],outputs:[-1]})[0]:e.inputs[0].reshape(Array.from({length:r.length},((e,t)=>r[p[t]]))),f=ll(e,h,t[1],t[2],i,o,a,n.epsilon);e.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${l}`,inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:s,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:d}),getShaderSource:e=>{let n=Yn(t[0].dataType),r=1===l?"vec2f":`mat${l}x2f`,i=e=>{let t=0===e?"x":"y",r=1===l?"f32":`vec${l}f`;switch(l){case 1:return`${n}(${r}(scale.${t}))`;case 2:return`vec2<${n}>(${r}(scale[0].${t}, scale[1].${t}))`;case 4:return`vec4<${n}>(${r}(scale[0].${t}, scale[1].${t}, scale[2].${t}, scale[3].${t}))`;default:throw new Error(`Not supported compoents ${l}`)}},a=ar("input",t[0].dataType,t[0].dims,l),o=or("output",t[0].dataType,s,l);return`\\n  @group(0) @binding(0) var<storage, read> input : array<${a.type.storage}>;\\n  @group(0) @binding(1) var<storage, read> scale_input : array<${r}>;\\n  @group(0) @binding(2) var<storage, read_write> output : array<${o.type.storage}>;\\n  struct Uniforms {H: u32, C : u32};\\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\\n\\n  ${e.mainStart()}\\n    let current_image_number = global_idx / (uniforms.C * uniforms.H);\\n    let current_channel_number = global_idx % uniforms.C;\\n\\n    let scale_offset = current_image_number * uniforms.C + current_channel_number;\\n    let scale = scale_input[scale_offset];\\n    output[global_idx] = fma(input[global_idx], ${i(0)}, ${i(1)});\\n  }`}},{inputs:[t[0],f]})},cl=(e,t)=>{"NHWC"===t.format?dl(e,e.inputs,t):ul(e,e.inputs,t)}})),fc=ut((()=>{vd(),Td(),Id(),pl=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},hl=(e,t,n)=>{let r=t.simplified,s=e[0].dims,i=e[1],a=!r&&e[2],o=s,l=Wn.normalizeAxis(t.axis,s.length),u=Wn.sizeToDimension(s,l),d=Wn.sizeFromDimension(s,l),c=Wn.size(i.dims),p=a?Wn.size(a.dims):0;if(c!==d||a&&p!==d)throw new Error(`Size of X.shape()[axis:] == ${d}.\\n       Size of scale and bias (if provided) must match this.\\n       Got scale size of ${c} and bias size of ${p}`);let h=[];for(let e=0;e<s.length;++e)e<l?h.push(s[e]):h.push(1);let f=er(d),m=["type","type"],_=[{type:12,data:u},{type:1,data:d},{type:12,data:Math.floor(d/f)},{type:1,data:t.epsilon}];a&&m.push("type");let g=n>1,w=n>2,y=[{dims:o,dataType:e[0].dataType}];return g&&y.push({dims:h,dataType:1}),w&&y.push({dims:h,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${f};${n};${r}`,inputDependencies:m},getRunData:()=>({outputs:y,dispatchGroup:{x:Math.ceil(u/64)},programUniforms:_}),getShaderSource:t=>{let n=Yn(e[0].dataType),s=[ar("x",e[0].dataType,e[0].dims,f),ar("scale",i.dataType,i.dims,f)];a&&s.push(ar("bias",a.dataType,a.dims,f)),s.push(or("output",e[0].dataType,o,f)),g&&s.push(or("mean_data_output",1,h)),w&&s.push(or("inv_std_output",1,h));return`\\n  ${t.registerUniforms([{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}]).declareVariables(...s)}\\n  ${t.mainStart()}\\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}\\n    let offset = global_idx * uniforms.norm_size_vectorized;\\n    var mean_vector = ${tr("f32",f)};\\n    var mean_square_vector = ${tr("f32",f)};\\n\\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\\n      let value = ${nr(n,f,"x[h + offset]")};\\n      mean_vector += value;\\n      mean_square_vector += value * value;\\n    }\\n    let mean = ${rr("mean_vector",f)} / uniforms.norm_size;\\n    let inv_std_dev = inverseSqrt(${rr("mean_square_vector",f)} / uniforms.norm_size ${r?"":"- mean * mean"} + uniforms.epsilon);\\n\\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\\n      let f32input = ${nr(n,f,"x[j + offset]")};\\n      let f32scale = ${nr(n,f,"scale[j]")};\\n      output[j + offset] = ${s[0].type.value}((f32input ${r?"":"- mean"}) * inv_std_dev * f32scale\\n        ${a?`+ ${nr(n,f,"bias[j]")}`:""}\\n      );\\n    }\\n\\n    ${g?"mean_data_output[global_idx] = mean":""};\\n    ${w?"inv_std_output[global_idx] = inv_std_dev":""};\\n  }`}}},fl=(e,t)=>{pl(e.inputs),e.compute(hl(e.inputs,t,e.outputCount))}})),mc=ut((()=>{Td(),jd(),Gd(),ml=e=>{if(!e||2!==e.length)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},_l=e=>{ml(e.inputs);let t=Vn.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can\'t use matmul on the given tensors");let n=t[t.length-1],r=e.inputs[0].dims[e.inputs[0].dims.length-1];if(n<8&&r<8)e.compute(ea(e.inputs,{activation:""},t));else{let s=t[t.length-2],i=Wn.size(e.inputs[0].dims.slice(0,-2)),a=Wn.size(e.inputs[1].dims.slice(0,-2));if(1!==i&&1===s&&1===a){let s=[1,i,n],a=[e.inputs[0].reshape([1,i,r]),e.inputs[1].reshape([1,r,n])];e.compute(la(a,{activation:""},t,s),{inputs:a})}else e.compute(la(e.inputs,{activation:""},t))}}})),_c=ut((()=>{vd(),Td(),Cd(),Id(),gl=(e,t)=>{if(e.length<3||e.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let n=e[0],r=n.dims.length;if(n.dims[r-1]!==t.k)throw new Error("The last dim of input shape does not match the k value");let s=Math.floor((t.k+t.blockSize-1)/t.blockSize),i=t.blockSize/8*t.bits,a=e[1];if(!Wn.areEqual(a.dims,[t.n,s,i]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let o=e[2].dims;if(Wn.size(o)!==t.n*s)throw new Error("scales input size error.");if(4===e.length){let n=e[3].dims,r=t.bits>4?t.n*s:t.n*Math.floor((s+1)/2);if(Wn.size(n)!==r)throw new Error("zeroPoints input size error.")}},wl=(e,t)=>{let n=e[0].dims,r=n.length,s=n[r-2],i=t.k,a=t.n,o=n.slice(0,r-2),l=Wn.size(o),u=e[1].dims[2]/4,d=e[0].dataType,c=er(t.k),p=er(u),h=er(a),f=o.concat([s,a]),m=s>1&&a/h%2==0?2:1,_=Wn.size(f)/h/m,g=64,w=[],y=[l,s,i/c],b=Wn.convertShape(e[1].dims).slice();b.splice(-1,1,u/p),w.push(...Jn(y)),w.push(...Jn(b)),w.push(...Jn(e[2].dims)),4===e.length&&w.push(...Jn(Wn.convertShape(e[3].dims)));let x=[l,s,a/h];w.push(...Jn(x));return{name:"MatMulNBits",shaderCache:{hint:`${t.blockSize};${t.bits};${c};${p};${h};${m};64`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:f,dataType:d}],dispatchGroup:{x:_},programUniforms:w}),getShaderSource:n=>{let r=y.length,s=ar("a",e[0].dataType,r,c),i=ar("b",12,b.length,p),a=ar("scales",e[2].dataType,e[2].dims.length),o=[s,i,a],l=4===e.length?ar("zero_points",12,e[3].dims.length):void 0;l&&o.push(l);let d=x.length,f=or("output",e[0].dataType,d,h),_=Yn(e[0].dataType),w=(()=>{switch(c){case 1:return`array<${_}, 8>`;case 2:return`mat4x2<${_}>`;case 4:return`mat2x4<${_}>`;default:throw new Error(`${c}-component is not supported.`)}})();return`\\n        var<workgroup> workgroup_shared: array<${f.type.value}, ${m*g}>;\\n        ${n.declareVariables(...o,f)}\\n        ${n.mainStart([g,1,1])}\\n          let output_indices = ${f.offsetToIndices(`(global_idx / 64) * ${m}`)};\\n          let col = output_indices[2];\\n          let row = output_indices[1];\\n          let batch = output_indices[0];\\n          let nBlocksPerCol = uniforms.b_shape[1];\\n\\n          for (var block = local_id.x; block < nBlocksPerCol; block += 64) {\\n            //process one block\\n            var word_offset: u32 = block * ${t.blockSize/c};\\n            ${(()=>{let e=`\\n            var col_index = col * ${h};\\n            ${l?"\\n            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;\\n            var zero_point_byte_count: u32;\\n            var zero_point_word_index: u32;\\n            var zero_point_byte_offset: u32;\\n            let zero_point_nibble_offset: u32 = block & 0x1u;\\n            var zero_point_bits_offset: u32;\\n            var zero_point_word: u32;":`\\n            // The default zero point is 8 for unsigned 4-bit quantization.\\n            let zero_point = ${_}(8);`}\\n            `;for(let t=0;t<h*m;t++)e+=`\\n            let scale${t} = ${a.getByOffset("col_index * nBlocksPerCol + block")};\\n            ${l?`\\n            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);\\n            zero_point_word_index = zero_point_byte_count >> 0x2u;\\n            zero_point_byte_offset = zero_point_byte_count & 0x3u;\\n            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\\n            zero_point_word = ${l.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;\\n            let zero_point${t} = ${_}((zero_point_word) & 0xFu);`:""}\\n            col_index += 1;`;return e})()}\\n            for (var word: u32 = 0; word < ${u}; word += ${p}) {\\n              ${(()=>{let e=`col_index = col * ${h};`;for(let t=0;t<h*m;t++)e+=`\\n            let b${t}_data = ${i.getByIndices(`${i.type.indices}(col_index, block, word)`)};\\n            col_index += 1;`;return e+=`\\n            var b_value: u32;\\n            let b_mask: u32 = 0x0F0F0F0Fu;\\n            var b_value_lower: vec4<u32>;\\n            var b_value_upper: vec4<u32>;\\n            var b_quantized_values: ${w};\\n            var b_dequantized_values: ${w};`,e})()}\\n              for (var i: u32 = 0; i < ${p}; i++) {\\n                ${(()=>{let e=`\\n          // reuse a data\\n            var input_offset = ${s.indicesToOffset(`${s.type.indices}(batch, row, word_offset)`)};\\n            var a_data: ${w};\\n            for (var j: u32 = 0; j < ${8/c}; j++) {\\n              a_data[j] = ${s.getByOffset("input_offset")};\\n              input_offset++;\\n            }\\n          `;for(let t=0;t<h*m;t++)e+=`\\n            b_value = ${1===p?`b${t}_data`:`b${t}_data[i]`};\\n            b_value_lower = unpack4xU8(b_value & b_mask);\\n            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);\\n            b_quantized_values = ${w}(${Array.from({length:4},((e,t)=>`${_}(b_value_lower[${t}]), ${_}(b_value_upper[${t}])`)).join(", ")});\\n            b_dequantized_values = ${1===c?`${w}(${Array.from({length:8},((e,n)=>`(b_quantized_values[${n}] - ${l?`zero_point${t}`:"zero_point"}) * scale${t}`)).join(", ")});`:`(b_quantized_values - ${w}(${Array(8).fill(l?`zero_point${t}`:"zero_point").join(",")})) * scale${t};`};\\n            workgroup_shared[local_id.x * ${m} + ${Math.floor(t/h)}]${h>1?`[${t%h}]`:""} += ${Array.from({length:8/c},((e,t)=>""+(1===c?`a_data[${t}] * b_dequantized_values[${t}]`:`dot(a_data[${t}], b_dequantized_values[${t}])`))).join(" + ")};\\n          `;return e})()}\\n                word_offset += ${8/c};\\n              }\\n            }\\n          }\\n          workgroupBarrier();\\n\\n          if (local_id.x < ${m}) {\\n            var output_value: ${f.type.value} = ${f.type.value}(0);\\n            var workgroup_shared_offset: u32 = local_id.x;\\n            for (var b: u32 = 0u; b < 64u; b++) {\\n              output_value += workgroup_shared[workgroup_shared_offset];\\n              workgroup_shared_offset += ${m};\\n            }\\n            ${f.setByIndices(`${f.type.indices}(batch, row, col + local_id.x)`,"output_value")};\\n          }\\n        }`}}},yl=(e,t)=>{let n=e[0].dims,r=n.length,s=n[r-2],i=t.k,a=t.n,o=n.slice(0,r-2),l=Wn.size(o),u=e[1].dims[2]/4,d=e[0].dataType,c=er(t.k),p=er(u),h=o.concat([s,a]),f=a%8==0?8:a%4==0?4:1,m=128/f,_=m*p*8,g=_/c,w=_/t.blockSize,y=Wn.size(h)/f,b=[],x=[l,s,i/c],v=Wn.convertShape(e[1].dims).slice();v.splice(-1,1,u/p),b.push(...Jn(x)),b.push(...Jn(v)),b.push(...Jn(e[2].dims)),4===e.length&&b.push(...Jn(Wn.convertShape(e[3].dims)));let $=[l,s,a];b.push(...Jn($));return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${t.blockSize};${c};${p};${m};${f}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:h,dataType:d}],dispatchGroup:{x:y},programUniforms:b}),getShaderSource:n=>{let r=x.length,s=ar("a",e[0].dataType,r,c),i=ar("b",12,v.length,p),a=ar("scales",e[2].dataType,e[2].dims.length),o=[s,i,a],l=4===e.length?ar("zero_points",12,e[3].dims.length):void 0;l&&o.push(l);let u=$.length,d=or("output",e[0].dataType,u),h=Yn(e[0].dataType);return`\\n        var<workgroup> sub_a: array<${s.type.value}, ${g}>;\\n        var<workgroup> inter_results: array<array<${d.type.value}, ${m}>, ${f}>;\\n        ${n.declareVariables(...o,d)}\\n        ${n.mainStart([m,f,1])}\\n          let output_indices = ${d.offsetToIndices(`workgroup_index * ${f}`)};\\n          let col = output_indices[2];\\n          let row = output_indices[1];\\n          let batch = output_indices[0];\\n          let n_blocks_per_col = uniforms.b_shape[1];\\n          let num_tiles =  (n_blocks_per_col - 1) / ${w} + 1;\\n\\n          // Loop over shared dimension.\\n          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {\\n            let a_col_start = tile * ${g};\\n            // load one tile A data into shared memory.\\n            for (var a_offset = local_idx; a_offset < ${g}; a_offset += 128)\\n            {\\n              let a_col = a_col_start + a_offset;\\n              if (a_col < uniforms.a_shape[2])\\n              {\\n                sub_a[a_offset] = ${s.getByIndices(`${s.type.indices}(batch, row, a_col)`)};\\n              } else {\\n                sub_a[a_offset] = ${s.type.value}(0);\\n              }\\n            }\\n            workgroupBarrier();\\n\\n            // each thread process one block\\n            let b_row = col + local_id.y;\\n            let block = tile * ${w} + local_id.x;\\n            ${l?`\\n            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;\\n            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);\\n            let zero_point_word_index = zero_point_byte_count >> 0x2u;\\n            let zero_point_byte_offset = zero_point_byte_count & 0x3u;\\n            let zero_point_nibble_offset: u32 = block & 0x1u;\\n            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\\n            let zero_point_word = ${l.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;\\n            let zero_point = ${h}((zero_point_word) & 0xFu);`:`\\n            // The default zero point is 8 for unsigned 4-bit quantization.\\n            let zero_point = ${h}(8);`}\\n            let scale = ${a.getByOffset("b_row * n_blocks_per_col + block")};\\n            let b_data = ${i.getByIndices(`${i.type.indices}(b_row, block, 0)`)};\\n            var word_offset = local_id.x * ${t.blockSize/c};\\n            for (var i: u32 = 0; i < ${p}; i++) {\\n              ${(()=>{switch(c){case 1:return`\\n          let a_data0 = vec4<${h}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);\\n          let a_data1 = vec4<${h}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`\\n          let a_data0 = vec4<${h}>(sub_a[word_offset], sub_a[word_offset + 1]);\\n          let a_data1 = vec4<${h}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return"\\n          let a_data0 = sub_a[word_offset];\\n          let a_data1 = sub_a[word_offset + 1];";default:throw new Error(`${c}-component is not supported.`)}})()}\\n              let b_value = ${1===p?"b_data":"b_data[i]"};\\n              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);\\n              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);\\n              let b_quantized_values = mat2x4<${h}>(${Array.from({length:4},((e,t)=>`${h}(b_value_lower[${t}]), ${h}(b_value_upper[${t}])`)).join(", ")});\\n              let b_dequantized_values = (b_quantized_values - mat2x4<${h}>(${Array(8).fill("zero_point").join(",")})) * scale;\\n              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},((e,t)=>`dot(a_data${t}, b_dequantized_values[${t}])`)).join(" + ")};\\n              word_offset += ${8/c};\\n            }\\n            workgroupBarrier();\\n          }\\n\\n          if (local_idx < ${f}) {\\n            var output_value: ${d.type.value} = ${d.type.value}(0);\\n            for (var b = 0u; b < ${m}; b++) {\\n              output_value += inter_results[local_idx][b];\\n            }\\n            if (col + local_idx < uniforms.output_shape[2])\\n            {\\n              ${d.setByIndices(`${d.type.indices}(batch, row, col + local_idx)`,"output_value")}\\n            }\\n          }\\n        }`}}},bl=(e,t)=>{gl(e.inputs,t),32===t.blockSize&&e.adapterInfo.isVendor("intel")&&e.adapterInfo.isArchitecture("gen-12lp")?e.compute(yl(e.inputs,t)):e.compute(wl(e.inputs,t))},xl=e=>Un(e)})),gc=ut((()=>{vd(),Td(),Id(),vl=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(1!==e[0].dataType&&10!==e[0].dataType)throw new Error("Input type must be float or float16.");if(e.length>=2){let t=2*e[0].dims.length===e[1].dims[0];if(4===e.length&&(t=2*e[3].dims[0]===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},$l=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`\\n            k = i32(${e.indicesGet("indices",s)}) - ${sr("uniforms.pads",s,n)};\\n            if (k < 0) {\\n              break;\\n            }\\n            if (k >= i32(${sr("uniforms.x_shape",s,t)})) {\\n              break;\\n            }\\n            offset += k * i32(${sr("uniforms.x_strides",s,t)});\\n        `;return`\\n          value = ${e.type.value}(uniforms.constant_value);\\n          for (var i = 0; i < 1; i++) {\\n            var offset = 0;\\n            var k = 0;\\n            ${r}\\n            value = x[offset];\\n          }\\n      `},kl=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`\\n                k = i32(${e.indicesGet("indices",s)}) - ${sr("uniforms.pads",s,n)};\\n                if (k < 0) {\\n                  k = -k;\\n                }\\n                {\\n                  let _2n_1 = 2 * (i32(${sr("uniforms.x_shape",s,t)}) - 1);\\n                  k = k % _2n_1;\\n                  if(k >= i32(${sr("uniforms.x_shape",s,t)})) {\\n                    k = _2n_1 - k;\\n                  }\\n                }\\n                offset += k * i32(${sr("uniforms.x_strides",s,t)});\\n            `;return`\\n              var offset = 0;\\n              var k = 0;\\n              ${r}\\n              value = x[offset];\\n          `},El=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`\\n                k = i32(${e.indicesGet("indices",s)}) - ${sr("uniforms.pads",s,n)};\\n                if (k < 0) {\\n                  k = 0;\\n                }\\n                if (k >= i32(${sr("uniforms.x_shape",s,t)})) {\\n                  k = i32(${sr("uniforms.x_shape",s,t)}) - 1;\\n                }\\n                offset += k * i32(${sr("uniforms.x_strides",s,t)});\\n            `;return`\\n              var offset = 0;\\n              var k = 0;\\n              ${r}\\n              value = x[offset];\\n          `},Sl=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`\\n                k = i32(${e.indicesGet("indices",s)}) - ${sr("uniforms.pads",s,n)};\\n                if (k < 0)  {\\n                  k += i32(${sr("uniforms.x_shape",s,t)}]);\\n                }\\n                if (k >= i32(${sr("uniforms.x_shape",s,t)})) {\\n                  k -= i32(${sr("uniforms.x_shape",s,t)});\\n                }\\n                offset += k * i32(${sr("uniforms.x_strides",s,t)});\\n            `;return`\\n              var offset = 0;\\n              var k = 0;\\n              ${r}\\n              value = x[offset];\\n          `},zl=(e,t,n)=>{switch(n.mode){case 0:return $l(e,t,n.pads.length);case 1:return kl(e,t,n.pads.length);case 2:return El(e,t,n.pads.length);case 3:return Sl(e,t,n.pads.length);default:throw new Error("Invalid mode")}},Cl=(e,t)=>{let n=Wn.padShape(e[0].dims.slice(),t.pads),r=e[0].dims,s=[{type:12,data:Wn.size(n)},{type:6,data:t.pads}],i=e.length>=3&&e[2].data;0===t.mode&&s.push({type:i?e[2].dataType:1,data:t.value}),s.push(...Jn(e[0].dims,n));return{name:"Pad",shaderCache:{hint:`${t.mode}${i}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(Wn.size(n)/64)},programUniforms:s}),getShaderSource:s=>{let a=or("output",e[0].dataType,n.length),o=ar("x",e[0].dataType,r.length),l=o.type.value,u=zl(a,r.length,t),d=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:t.pads.length}];return 0===t.mode&&d.push({name:"constant_value",type:i?l:"f32"}),`\\n            ${s.registerUniforms(d).declareVariables(o,a)}\\n            ${s.mainStart()}\\n            ${s.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n\\n            let indices = ${a.offsetToIndices("global_idx")};\\n\\n            var value = ${l}(0);\\n            ${u}\\n            output[global_idx] = value;\\n        }`}}},Tl=(e,t)=>{if(e.length>1){let n=e[1].getBigInt64Array(),r=e.length>=3&&e[2].data?10===e[2].dataType?e[2].getUint16Array()[0]:e[2].getFloat32Array()[0]:0,s=e[0].dims.length,i=new Int32Array(2*s).fill(0);if(e.length>=4){let t=e[3].getBigInt64Array();for(let e=0;e<t.length;e++)i[Number(t[e])]=Number(n[e]),i[Number(t[e])+s]=Number(n[e+t.length])}else n.forEach(((e,t)=>i[Number(t)]=Number(e)));let a=[];return i.forEach((e=>a.push(e))),{mode:t.mode,value:r,pads:a}}return t},Il=(e,t)=>{vl(e.inputs);let n=Tl(e.inputs,t);e.compute(Cl(e.inputs,n),{inputs:[0]})}})),wc=ut((()=>{At(),vd(),Td(),Id(),Al=e=>{if(Oe.webgpu.validateInputContent&&(!e||1!==e.length))throw new Error("Pool ops requires 1 input.")},Ml=(e,t,n)=>{let r="NHWC"===t.format,s=e.dims.slice();r&&s.splice(1,0,s.pop());let i=Object.hasOwnProperty.call(t,"dilations"),a=t.kernelShape.slice(),o=t.strides.slice(),l=i?t.dilations.slice():[],u=t.pads.slice();jn.adjustPoolAttributes(n,s,a,o,l,u);let d=jn.computePoolOutputShape(n,s,o,l,a,u,t.autoPad),c=Object.assign({},t);i?Object.assign(c,{kernelShape:a,strides:o,pads:u,dilations:l,cacheKey:t.cacheKey}):Object.assign(c,{kernelShape:a,strides:o,pads:u,cacheKey:t.cacheKey});let p=d.slice();return p.push(p.splice(1,1)[0]),[c,r?p:d]},Ol=(e,t)=>{let n="NHWC"===t.format,r=[{type:12,data:Wn.size(e)},{type:12,data:Wn.size(t.kernelShape)}],s=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let e=t.kernelShape[t.kernelShape.length-1],n=t.strides[t.strides.length-1],i=t.pads[t.pads.length/2-1],a=t.pads[t.pads.length-1],o=!!(i+a);r.push({type:12,data:e},{type:12,data:n},{type:12,data:i},{type:12,data:a}),s.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let l=!1;if(2===t.kernelShape.length){let e=t.kernelShape[t.kernelShape.length-2],n=t.strides[t.strides.length-2],i=t.pads[t.pads.length/2-2],a=t.pads[t.pads.length-2];l=!!(i+a),r.push({type:12,data:e},{type:12,data:n},{type:12,data:i},{type:12,data:a}),s.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[r,s,!0,o,l]}{if(n)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let e=Wn.computeStrides(t.kernelShape);return r.push({type:12,data:e},{type:12,data:t.pads},{type:12,data:t.strides}),s.push({name:"kernelStrides",type:"u32",length:e.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length}),[r,s,!!t.pads.reduce(((e,t)=>e+t)),!1,!1]}},Bl=(e,t,n,r,s,i,a,o,l,u,d,c)=>{let p="NHWC"===s.format,h=t.type.value,f=or("output",t.type.tensor,r);if(s.kernelShape.length<=2){let r="",u="",m="",_=n-(p?2:1);if(r=d?`\\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\\n                  xIndices[${_}] = indices[${_}] * uniforms.sw - uniforms.pwStart + i;\\n                  if (xIndices[${_}] < 0 || xIndices[${_}]\\n                      >= uniforms.x_shape[${_}]) {\\n                    pad++;\\n                    continue;\\n                  }\\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\\n                  ${i}\\n                }`:`\\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\\n                  xIndices[${_}] = indices[${_}] * uniforms.sw - uniforms.pwStart + i;\\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\\n                  ${i}\\n                }`,2===s.kernelShape.length){let e=n-(p?3:2);u=c?`\\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\\n                  xIndices[${e}] = indices[${e}] * uniforms.sh - uniforms.phStart + j;\\n                  if (xIndices[${e}] < 0 || xIndices[${e}] >= uniforms.x_shape[${e}]) {\\n                    pad += i32(uniforms.kw);\\n                    continue;\\n                  }\\n              `:`\\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\\n                  xIndices[${e}] = indices[${e}] * uniforms.sh - uniforms.phStart + j;\\n                `,m="\\n              }\\n            "}return`\\n            ${e.registerUniforms(l).declareVariables(t,f)}\\n\\n            ${e.mainStart()}\\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n\\n              let indices = ${f.offsetToIndices("global_idx")};\\n              var xIndices = ${f.offsetToIndices("global_idx")};\\n\\n              var value = ${h}(${o});\\n              var pad = 0;\\n              ${u}\\n              ${r}\\n              ${m}\\n              ${a}\\n\\n              output[global_idx] = value;\\n            }`}{if(p)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let r=s.kernelShape.length,d=s.pads.length,c="";return c=u?`\\n                if (xIndices[j] >= uniforms.x_shape[j]) {\\n                  pad++;\\n                  isPad = true;\\n                  break;\\n                }\\n              }\\n              if (!isPad) {\\n                let x_val = x[${t.indicesToOffset("xIndices")}];\\n                ${i}\\n              }`:`\\n              }\\n              let x_val = x[${t.indicesToOffset("xIndices")}];\\n              ${i}\\n            `,`\\n            ${e.registerUniforms(l).declareVariables(t,f)}\\n\\n            ${e.mainStart()}\\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n              let indices = ${f.offsetToIndices("global_idx")};\\n              var xIndices = ${f.offsetToIndices("global_idx")};\\n\\n              var offsets: array<u32, ${r}>;\\n\\n              var value = ${h}(${o});\\n              var pad = 0;\\n              var isPad = false;\\n\\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\\n                var offset = i;\\n                for (var j = 0u; j < ${r-1}u; j++) {\\n                  offsets[j] = offset / ${sr("uniforms.kernelStrides","j",r)};\\n                  offset -= offsets[j] * ${sr("uniforms.kernelStrides","j",r)};\\n                }\\n                offsets[${r-1}] = offset;\\n\\n                isPad = false;\\n                for (var j = ${n-r}u; j < ${n}u; j++) {\\n                  xIndices[j] = indices[j] * ${sr("uniforms.strides",`j - ${n-r}u`,r)}\\n                    + offsets[j - ${n-r}u] - ${sr("uniforms.pads","j - 2u",d)};\\n                  ${c}\\n              }\\n              ${a}\\n\\n              output[global_idx] = value;\\n            }`}},Nl=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,Pl=e=>`${Nl(e)};${e.countIncludePad}`,Rl=e=>`${Nl(e)};${e.storageOrder};${e.dilations}`,Dl=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Fl=(e,t,n,r)=>{let[s,i]=Ml(t,r,n),a=ar("x",t.dataType,t.dims.length),o=a.type.value,l="";s.countIncludePad?l+=`value /= ${o}(uniforms.kernelSize);`:l+=`value /= ${o}(i32(uniforms.kernelSize) - pad);`;let[u,d,c,p,h]=Ol(i,s);u.push(...Jn(t.dims,i));return{name:e,shaderCache:{hint:`${r.cacheKey};${c};${p};${h}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(Wn.size(i)/64)},programUniforms:u}),getShaderSource:e=>Bl(e,a,t.dims.length,i.length,s,"value += x_val;",l,0,d,c,p,h)}},Ll=e=>{let t=0!==e.count_include_pad,n=Dl(e);if(0!==n.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let r={countIncludePad:t,...n,cacheKey:""};return{...r,cacheKey:Pl(r)}},Ul=(e,t)=>{Al(e.inputs),e.compute(Fl("AveragePool",e.inputs[0],!1,t))},ql={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},Vl=e=>{let t=e.format;return{format:t,...ql,cacheKey:t}},Wl=(e,t)=>{Al(e.inputs),e.compute(Fl("GlobalAveragePool",e.inputs[0],!0,t))},jl=(e,t,n,r)=>{let[s,i]=Ml(t,r,n),a=ar("x",t.dataType,t.dims.length),[o,l,u,d,c]=Ol(i,s);return o.push(...Jn(t.dims,i)),{name:e,shaderCache:{hint:`${r.cacheKey};${u};${d};${c}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(Wn.size(i)/64)},programUniforms:o}),getShaderSource:e=>Bl(e,a,t.dims.length,i.length,s,"\\n      value = max(x_val, value);\\n    ","",10===t.dataType?-65504:-1e5,l,u,d,c)}},Gl=(e,t)=>{Al(e.inputs),e.compute(jl("MaxPool",e.inputs[0],!1,t))},Hl=e=>{let t=e.storage_order,n=e.dilations,r=Dl(e);if(0!==t)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==r.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let s={storageOrder:t,dilations:n,...r,cacheKey:""};return{...s,cacheKey:Rl(s)}},Kl=e=>{let t=e.format;return{format:t,...ql,cacheKey:t}},Xl=(e,t)=>{Al(e.inputs),e.compute(jl("GlobalMaxPool",e.inputs[0],!0,t))}})),yc=ut((()=>{vd(),Td(),Cd(),Id(),Ql=(e,t)=>{if(e.length<2||e.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(3===e.length&&e[1].dims===e[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(6===e[0].dataType&&e.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(0!==e[1].dims.length&&1!==e[1].dims.length&&e[1].dims.length!==e[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(e.length>2){if(e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(e[1].dims.length!==e[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!e[1].dims.map(((t,n)=>t===e[2].dims[n])).reduce(((e,t)=>e&&t),!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(t.blockSize>0){if(0===e[1].dims.length||1===e[1].dims.length&&1===e[1].dims[0])throw new Error("blockSize must be set only for block quantization.");if(!e[1].dims.map(((n,r)=>r===t.axis||n===e[0].dims[r])).reduce(((e,t)=>e&&t),!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(e[1].dims.length!==e[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let n=e[0].dims[t.axis],r=e[1].dims[t.axis];if(t.blockSize<Math.ceil(n/r)||t.blockSize>Math.ceil(n/(r-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},Yl=(e,t)=>{let n=Wn.normalizeAxis(t.axis,e[0].dims.length),r=e[0].dataType,s=3===r,i=e[0].dims,a=e[1].dataType,o=Wn.size(i),l=3===r||2===r,u=l?[Math.ceil(Wn.size(e[0].dims)/4)]:e[0].dims,d=e[1].dims,c=e.length>2?e[2]:void 0,p=c?l?[Math.ceil(Wn.size(c.dims)/4)]:c.dims:void 0,h=0===d.length||1===d.length&&1===d[0],f=!1===h&&1===d.length,m=er(o),_=h&&(!l||4===m),g=_?m:1,w=_&&!l?m:1,y=ar("input",l?12:r,u.length,w),b=ar("scale",a,d.length),x=c?ar("zero_point",l?12:r,p.length):void 0,v=or("output",a,i.length,g),$=[y,b];x&&$.push(x);let k=[u,d];c&&k.push(p);let E=[{type:12,data:o/g},{type:12,data:n},{type:12,data:t.blockSize},...Jn(...k,i)];return{name:"DequantizeLinear",shaderCache:{hint:t.cacheKey,inputDependencies:x?["rank","rank","rank"]:["rank","rank"]},getShaderSource:e=>`\\n      ${e.registerUniforms([{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}]).declareVariables(...$,v)}\\n      ${e.mainStart()}\\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n          let output_indices = ${v.offsetToIndices("global_idx")};\\n\\n          // Set input x\\n          ${l?`\\n            let input = ${y.getByOffset("global_idx / 4")};\\n            let x_vec = ${s?"unpack4xI8(input)":"unpack4xU8(input)"};\\n            let x_value = ${1===g?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${y.getByOffset("global_idx")};`};\\n\\n          // Set scale input\\n          ${h?`let scale_value= ${b.getByOffset("0")}`:f?`\\n            let scale_index = ${v.indicesGet("output_indices","uniforms.axis")};\\n            let scale_value= ${b.getByOffset("scale_index")};`:`\\n            var scale_indices: ${b.type.indices} = output_indices;\\n            let index = ${b.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;\\n            ${b.indicesSet("scale_indices","uniforms.axis","index")};\\n            let scale_value= ${b.getByIndices("scale_indices")};`};\\n\\n          // Set zero-point input\\n          ${x?h?l?`\\n                let zero_point_input = ${x.getByOffset("0")};\\n                let zero_point_vec =  ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\\n                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${x.getByOffset("0")}`:f?l?`\\n                let zero_point_index = ${v.indicesGet("output_indices","uniforms.axis")};\\n                let zero_point_input = ${x.getByOffset("zero_point_index / 4")};\\n                let zero_point_vec =  ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\\n                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`\\n                let zero_point_index = ${v.indicesGet("output_indices","uniforms.axis")};\\n                let zero_point_value = ${x.getByOffset("zero_point_index")};`:l?`\\n                let zero_point_offset = ${b.indicesToOffset("scale_indices")};\\n                let zero_point_input = ${x.getByOffset("zero_point_offset / 4")};\\n                let zero_point_vec = ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\\n                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${x.getByIndices("scale_indices")};`:`let zero_point_value = ${l?s?"i32":"u32":y.type.value}(0);`};\\n      // Compute and write output\\n      ${v.setByOffset("global_idx",`${v.type.value}(x_value - zero_point_value) * scale_value`)};\\n      }`,getRunData:()=>({outputs:[{dims:i,dataType:a}],dispatchGroup:{x:Math.ceil(o/g/64),y:1,z:1},programUniforms:E})}},Zl=(e,t)=>{Ql(e.inputs,t),e.compute(Yl(e.inputs,t))},Jl=e=>Un({axis:e.axis,blockSize:e.blockSize})})),bc=ut((()=>{At(),vd(),Id(),eu=(e,t,n)=>{if(e===t||e<t&&n<0||e>t&&n>0)throw new Error("Range these inputs\' contents are invalid.")},tu=(e,t,n,r)=>{let s=Math.abs(Math.ceil((t-e)/n)),i=[s],a=s,o=[{type:12,data:a},{type:r,data:e},{type:r,data:n},...Jn(i)];return{name:"Range",shaderCache:{hint:`${r}`},getShaderSource:e=>{let t=or("output",r,i.length),n=t.type.value,s=[{name:"outputSize",type:"u32"},{name:"start",type:n},{name:"delta",type:n}];return`\\n        ${e.registerUniforms(s).declareVariables(t)}\\n        ${e.mainStart()}\\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n        output[global_idx] = uniforms.start + ${n}(global_idx) * uniforms.delta;\\n      }`},getRunData:()=>({outputs:[{dims:i,dataType:r}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:o})}},nu=e=>{let t=0,n=0,r=0;6===e.inputs[0].dataType?(t=e.inputs[0].getInt32Array()[0],n=e.inputs[1].getInt32Array()[0],r=e.inputs[2].getInt32Array()[0]):1===e.inputs[0].dataType&&(t=e.inputs[0].getFloat32Array()[0],n=e.inputs[1].getFloat32Array()[0],r=e.inputs[2].getFloat32Array()[0]),Oe.webgpu.validateInputContent&&eu(t,n,r),e.compute(tu(t,n,r,e.inputs[0].dataType),{inputs:[]})}})),xc=ut((()=>{vd(),Td(),Cd(),Id(),ru=(e,t,n,r)=>{if("none"!==e&&"i32"!==r&&"u32"!==r&&"f32"!==r)throw new Error(`Input ${r} is not supported with reduction ${e}.`);let s="{\\n                var oldValue = 0;\\n                loop {\\n                  let newValueF32 =",i=`;\\n                  let newValue = bitcast<i32>(newValueF32);\\n                  let res = atomicCompareExchangeWeak(&${t}, oldValue, newValue);\\n                  if res.exchanged {\\n                    break;\\n                  }\\n                  oldValue = res.old_value;\\n                }\\n              }`;switch(e){case"none":return`${t}=${n};`;case"add":return"i32"===r||"u32"===r?`atomicAdd(&${t}, bitcast<${r}>(${n}));`:`\\n              ${s}bitcast<${r}>(oldValue) + (${n})${i}`;case"max":return"i32"===r||"u32"===r?`atomicMax(&${t}, bitcast<${r}>(${n}));`:`\\n                ${s}max(bitcast<f32>(oldValue), (${n}))${i}`;case"min":return"i32"===r||"u32"===r?`atomicMin(&${t}, bitcast<${r}>(${n}));`:`${s}min(bitcast<${r}>(oldValue), (${n}))${i}`;case"mul":return`${s}(bitcast<${r}>(oldValue) * (${n}))${i}`;default:throw new Error(`Reduction ${e} is not supported.`)}},su=(e,t)=>{let n=e[0].dims,r=e[1].dims,s=n,i=Math.ceil(Wn.size(r)/1),a=r[r.length-1],o=Wn.sizeFromDimension(n,a),l=[{type:12,data:i},{type:12,data:a},{type:12,data:o},...Jn(e[1].dims,e[2].dims,s)];return{name:"ScatterND",shaderCache:{hint:`${t.cacheKey}_${t.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:l}),getShaderSource:n=>{let r=ar("indices",e[1].dataType,e[1].dims.length),i=ar("updates",e[2].dataType,e[2].dims.length,1),a="none"!==t.reduction&&""!==t.reduction?lr("output",e[0].dataType,s.length):or("output",e[0].dataType,s.length,1);return`\\n      ${n.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(r,i,a)}\\n      ${n.mainStart()}\\n        ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n  var data_offset = 0u;\\n  let indices_start = uniforms.last_index_dimension * global_idx;\\n  let indices_end = indices_start + uniforms.last_index_dimension;\\n  for (var i = indices_start; i < indices_end; i++) {\\n    var index = i32(indices[i].x);\\n    ${1===e[0].dims.length?"\\n    let element_count_dim = uniforms.output_strides;\\n    let dim_value = uniforms.output_shape;":"\\n    let element_count_dim = uniforms.output_strides[i - indices_start];\\n    let dim_value = uniforms.output_shape[i - indices_start + uniforms.last_index_dimension];"}\\n    if (index >= 0) {\\n      if (index >= i32(dim_value)) {\\n        index = i32(dim_value - 1);\\n      }\\n    } else {\\n      if (index < -i32(dim_value)) {\\n        index = 0;\\n      } else {\\n        index += i32(dim_value);\\n      }\\n    }\\n    data_offset += u32((u32(index) * element_count_dim));\\n  }\\n\\n  for (var i = 0u; i < uniforms.num_updates_elements; i++) {\\n    let value = updates[uniforms.num_updates_elements * global_idx + i];\\n    ${ru(t.reduction,"output[data_offset + i]","value",a.type.value)}\\n  }\\n\\n      }`}}},iu=e=>Un({reduction:e.reduction}),au=(e,t)=>{e.compute(su(e.inputs,t),{inputs:[e.inputs[1],e.inputs[2]],outputs:[]})}})),vc=ut((()=>{vd(),Td(),Cd(),Id(),ou=(e,t)=>{if(e.every((e=>e>0||(()=>{throw new Error("Resize requires scales input values to be positive")}))),e.length>0)if("linear"===t.mode){if(!(2===e.length||3===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]||5===e.length&&1===e[0]&&1===e[1]))throw new Error("For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1")}else if("cubic"===t.mode&&!(2===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")},lu=(e,t,n)=>{t.every((e=>e>=0&&e<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")})));let r=new Array(n).fill(1);return t.forEach(((t,n)=>r[t]=e[n])),r},uu=(e,t,n,r,s,i)=>{let[a,o,l]=n>10?[1,2,3]:[-1,e.length>1?1:-1,-1],u=e[0].dims.length;if(a>0&&e.length>a&&e[a].dims.length>0)e[a].getFloat32Array().forEach((e=>i.push(e)));else if("tf_crop_and_resize"===t.coordinateTransformMode)throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(o>0&&e.length>o&&1===e[o].dims.length&&e[o].dims[0]>0){if(e[o].getFloat32Array().forEach((e=>r.push(e))),0!==r.length&&r.length!==u&&n>=18&&r.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");ou(r,t),t.axes.length>0&&lu(r,t.axes,u).forEach(((e,t)=>r[t]=e))}if(l>0&&e.length>l&&1===e[l].dims.length&&e[l].dims[0]>0&&(e[l].getBigInt64Array().forEach((e=>s.push(Number(e)))),0!==s.length&&s.length!==u&&n>=18&&s.length!==t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(0!==r.length&&r.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(0!==s.length&&s.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof r<"u"&&typeof s<"u"&&r.length>0&&s.length>u)throw new Error("Resize requires only of scales or sizes to be specified")},du=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case"asymmetric":return`return ${t}(xResized) / ${t}(xScale);`;case"pytorch_half_pixel":return`if (lengthResized > 1) {\\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\\n                  } else {\\n                    return 0.0;\\n                  }`;case"tf_half_pixel_for_nn":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case"align_corners":return`if (lengthResized == 1) {\\n                    return 0.0;\\n                  } else {\\n                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating\\n                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\\n                    // offset-by-one error later in floor().\\n                    let whole = ${t}(xResized * (lengthOriginal - 1) / (lengthResized - 1));\\n                    let fract =\\n                        ${t}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${t}(lengthResized - 1);\\n                    return whole + fract;\\n                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {\\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\\n                        ${t}(lengthResized - 1);\\n                  } else {\\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\\n                  }`;case"half_pixel_symmetric":return`const outputWidth = ${t}xScale * ${t}(lengthResized);\\n                  const adjustment = ${t}(lengthResized) / outputWidth;\\n                  const center = ${t}(lengthOriginal) / 2;\\n                  const offset = center * (1 - adjustment);\\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case"half_pixel":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",cu=(e,t,n)=>`fn getNearestPixelFromOriginal(xOriginal: ${n}, isDownSample: bool) -> ${n} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",pu=(e,t,n)=>{let r=new Array(n).fill(0).concat(new Array(n).fill(1)),s=0===e.length?r:e.slice();return t.length>0?(t.forEach(((e,i)=>{r[e]=s[i],r[i+n]=s[t.length+i]})),r):s},hu=(e,t,n,r)=>{let s=[];if(n.length>0)if(r.length>0){if(e.forEach((e=>s.push(e))),Math.max(...r)>e.length)throw new Error("axes is out of bound");r.forEach(((e,t)=>s[e]=n[t]))}else n.forEach((e=>s.push(e)));else{if(0===t.length)throw new Error("Resize requires either scales or sizes.");s=e.map(((e,n)=>Math.round(e*t[n])))}return s},fu=(e,t,n)=>{let r=(()=>{switch(n.keepAspectRatioPolicy){case"not_larger":return n.axes.length>0?Math.min(...n.axes.map((e=>t[e])),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return n.axes.length>0?Math.max(...n.axes.map((e=>t[e])),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${n.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let s=e.slice();return n.axes.length>0?(n.axes.forEach((e=>t[e]=r)),n.axes.forEach((n=>s[n]=Math.round(e[n]*t[n])))):(t.fill(r,0,t.length),s.forEach(((e,n)=>s[n]=Math.round(e*t[n])))),s},mu=(e,t,n,r,s)=>`\\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${n.length}> {\\n      var original_indices: array<${e.type.value}, ${n.length}>;\\n      for (var i:u32 = 0; i < ${n.length}; i++) {\\n        var output_index = ${e.indicesGet("output_indices","i")};\\n        var scale = ${sr("uniforms.scales","i",r)};\\n        var roi_low = ${sr("uniforms.roi","i",s)};\\n        var roi_hi = ${sr("uniforms.roi",`i + ${t.length}`,s)};\\n        if (scale == 1.0) {\\n          original_indices[i] = ${e.type.value}(output_index);\\n        } else {\\n          var input_shape_i = ${sr("uniforms.input_shape","i",t.length)};\\n          var output_shape_i = ${sr("uniforms.output_shape","i",n.length)};\\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\\n                                                                           input_shape_i, roi_low, roi_hi);\\n        }\\n      }\\n      return original_indices;\\n    }`,_u=(e,t,n,r,s,i,a)=>`\\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\\n      var input_indices: ${e.type.indices};\\n      for (var i:u32 = 0; i < ${r.length}; i++) {\\n        var output_index = ${t.indicesGet("output_indices","i")};\\n        var input_index: u32;\\n        var scale = ${sr("uniforms.scales","i",s)};\\n        if (scale == 1.0) {\\n          input_index = output_index;\\n        } else {\\n          var roi_low = ${sr("uniforms.roi","i",i)};\\n          var roi_hi = ${sr("uniforms.roi",`i + ${n.length}`,i)};\\n          var input_shape_i = ${sr("uniforms.input_shape","i",n.length)};\\n          var output_shape_i = ${sr("uniforms.output_shape","i",r.length)};\\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\\n                                                                        input_shape_i, roi_low, roi_hi);\\n          if (!${a} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\\n            if (original_idx < 0) {\\n              input_index = 0;\\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\\n              input_index = input_shape_i - 1;\\n            } else {\\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\\n            }\\n          } else {\\n            input_index = u32(original_idx);\\n          }\\n        }\\n        ${e.indicesSet("input_indices","i"," input_index")}\\n      }\\n      return input_indices;\\n    }`,gu=(e,t)=>`\\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\\n      for (var i:u32 = 0; i < ${t.length}; i++) {\\n        var input_index = ${e.indicesGet("input_indices","i")};\\n        if (input_index < 0 || input_index >= ${sr("uniforms.input_shape","i",t.length)}) {\\n          return false;\\n        }\\n      }\\n      return true;\\n    }`,wu=(e,t,n,r)=>e.rank>r?`\\n    ${e.indicesSet("input_indices",t,"channel")};\\n    ${e.indicesSet("input_indices",n,"batch")};\\n`:"",yu=(e,t,n,r,s)=>{let[i,a,o,l]=2===n.length?[-1,0,1,-1]:[0,2,3,1],u=e.type.value;return`\\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${u} {\\n      var input_indices: ${e.type.indices};\\n      ${e.indicesSet("input_indices",a,`max(0, min(row, ${n[a]} - 1))`)};\\n      ${e.indicesSet("input_indices",o,`max(0, min(col, ${n[o]} - 1))`)};\\n      ${wu(e,l,i,2)}\\n      return ${e.getByIndices("input_indices")};\\n    }\\n\\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${u} {\\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\\n      var row:${u} = originalIndices[${a}];\\n      var col:${u} = originalIndices[${o}];\\n      ${r?`if (row < 0 || row > (${n[a]} - 1) || col < 0 || col > (${n[o]} - 1)) {\\n        return ${s};\\n      }`:""};\\n      row = max(0, min(row, ${n[a]} - 1));\\n      col = max(0, min(col, ${n[o]} - 1));\\n      var row1: u32 = u32(row);\\n      var col1: u32 = u32(col);\\n      var row2: u32 = u32(row + 1);\\n      var col2: u32 = u32(col + 1);\\n      var channel: u32 = ${n.length>2?`u32(originalIndices[${l}])`:"0"};\\n      var batch: u32 =  ${n.length>2?`u32(originalIndices[${i}])`:"0"};\\n      var x11: ${u} = getInputValue(batch, channel, row1, col1);\\n      var x12: ${u} = getInputValue(batch, channel, row1, col2);\\n      var x21: ${u} = getInputValue(batch, channel, row2, col1);\\n      var x22: ${u} = getInputValue(batch, channel, row2, col2);\\n      var dx1: ${u} = abs(row - ${u}(row1));\\n      var dx2: ${u} = abs(${u}(row2) - row);\\n      var dy1: ${u} = abs(col - ${u}(col1));\\n      var dy2: ${u} = abs(${u}(col2) - col);\\n      if (row1 == row2) {\\n        dx1 = 0.5;\\n        dx2 = 0.5;\\n      }\\n      if (col1 == col2) {\\n        dy1 = 0.5;\\n        dy2 = 0.5;\\n      }\\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\\n    }`},bu=(e,t,n,r,s,i,a,o,l,u)=>{let d=2===n.length,[c,p]=d?[0,1]:[2,3],h=e.type.value,f=a=>{let d=a===c?"row":"col";return`\\n      fn ${d}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${h} {\\n        var output_index = ${t.indicesGet("output_indices",a)};\\n        var originalIdx: ${h} = getOriginalCoordinateFromResizedCoordinate(output_index, ${s[a]},\\n        ${r[a]}, ${n[a]}, ${i[a]}, ${i[a]} + ${n.length});\\n        var fractOriginalIdx: ${h} = originalIdx - floor(originalIdx);\\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\\n\\n        if (${o} && (originalIdx < 0 || originalIdx > (${n[a]} - 1))) {\\n          return ${l};\\n        }\\n        var data: array<${h}, 4> = array<${h}, 4>(0.0, 0.0, 0.0, 0.0);\\n        for (var i: i32 = -1; i < 3; i++) {\\n          var ${d}: ${h} = originalIdx + ${h}(i);\\n          if (${d} < 0 || ${d} >= ${n[a]}) {\\n            ${u?"coefs[i + 1] = 0.0;\\n                        continue;":o?`return ${l};`:`${d} = max(0, min(${d}, ${n[a]} - 1));`};\\n          }\\n        var input_indices_copy: ${e.type.indices} = input_indices;\\n          ${e.indicesSet("input_indices_copy",a,`u32(${d})`)};\\n          data[i + 1] = ${a===c?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};\\n        }\\n        return cubicInterpolation1D(data, coefs);\\n      }`};return`\\n    ${f(c)};\\n    ${f(p)};\\n  fn getCubicInterpolationCoefs(s: ${h}) -> array<${h}, 4> {\\n    var absS = abs(s);\\n    var coeffs: array<${h}, 4> = array<${h}, 4>(0.0, 0.0, 0.0, 0.0);\\n    var oneMinusAbsS: ${h} = 1.0 - absS;\\n    var twoMinusAbsS: ${h} = 2.0 - absS;\\n    var onePlusAbsS: ${h} = 1.0 + absS;\\n    coeffs[0] = ((${a} * onePlusAbsS - 5 * ${a}) * onePlusAbsS + 8 * ${a}) * onePlusAbsS - 4 * ${a};\\n    coeffs[1] = ((${a} + 2) * absS - (${a} + 3)) * absS * absS + 1;\\n    coeffs[2] = ((${a} + 2) * oneMinusAbsS - (${a} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\\n    coeffs[3] = ((${a} * twoMinusAbsS - 5 * ${a}) * twoMinusAbsS + 8 * ${a}) * twoMinusAbsS - 4 * ${a};\\n    return coeffs;\\n  }\\n\\n  fn cubicInterpolation1D(x: array<${h}, 4>, coefs: array<${h}, 4>) -> ${h} {\\n    var coefsSum: ${h} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\\n  }\\n\\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${h} {\\n    var input_indices: ${e.type.indices} = output_indices;\\n    return colCubicInterpolation(input_indices, output_indices);\\n  }\\n    `},xu=(e,t,n,r,s)=>{let[i,a,o,l,u]=3===n.length?[-1,0,1,2,-1]:[0,2,3,4,1],d=e.type.value;return`\\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${d} {\\n      var input_indices: ${e.type.indices};\\n      ${e.indicesSet("input_indices",a,`max(0, min(depth, ${n[a]} - 1))`)};\\n      ${e.indicesSet("input_indices",o,`max(0, min(height, ${n[o]} - 1))`)};\\n      ${e.indicesSet("input_indices",l,`max(0, min(width, ${n[l]} - 1))`)};\\n      ${wu(e,u,i,3)}\\n      return ${e.getByIndices("input_indices")};\\n    }\\n\\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${d} {\\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\\n      var depth:${d} = originalIndices[${a}];\\n      var height:${d} = originalIndices[${o}];\\n      var width:${d} = originalIndices[${l}];\\n      ${r?`if (depth < 0 || depth > (${n[a]} - 1) || height < 0 || height > (${n[o]} - 1) || width < 0 || (width > ${n[l]} - 1)) {\\n      return ${s};\\n        }`:""};\\n\\n    depth = max(0, min(depth, ${n[a]} - 1));\\n      height = max(0, min(height, ${n[o]} - 1));\\n      width = max(0, min(width, ${n[l]} - 1));\\n      var depth1: u32 = u32(depth);\\n      var height1: u32 = u32(height);\\n      var width1: u32 = u32(width);\\n      var depth2: u32 = u32(depth + 1);\\n      var height2: u32 = u32(height + 1);\\n      var width2: u32 = u32(width + 1);\\n      var channel: u32 = ${n.length>3?`u32(originalIndices[${u}])`:"0"};\\n      var batch: u32 =  ${n.length>3?`u32(originalIndices[${i}])`:"0"};\\n\\n      var x111: ${d} = getInputValue(batch, channel, depth1, height1, width1);\\n      var x112: ${d} = getInputValue(batch, channel, depth1, height1, width2);\\n      var x121: ${d} = getInputValue(batch, channel, depth1, height2, width1);\\n      var x122: ${d} = getInputValue(batch, channel, depth1, height2, width2);\\n      var x211: ${d} = getInputValue(batch, channel, depth2, height1, width1);\\n      var x212: ${d} = getInputValue(batch, channel, depth2, height1, width2);\\n      var x221: ${d} = getInputValue(batch, channel, depth2, height2, width1);\\n      var x222: ${d} = getInputValue(batch, channel, depth2, height2, width2);\\n      var dx1: ${d} = abs(depth - ${d}(depth1));\\n      var dx2: ${d} = abs(${d}(depth2) - depth);\\n      var dy1: ${d} = abs(height - ${d}(height1));\\n      var dy2: ${d} = abs(${d}(height2) - height);\\n      var dz1: ${d} = abs(width - ${d}(width1));\\n      var dz2: ${d} = abs(${d}(width2) - width);\\n      if (depth1 == depth2) {\\n        dx1 = 0.5;\\n        dx2 = 0.5;\\n      }\\n      if (height1 == height2) {\\n        dy1 = 0.5;\\n        dy2 = 0.5;\\n      }\\n      if (width1 == width2) {\\n        dz1 = 0.5;\\n        dz2 = 0.5;\\n      }\\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\\n    }`},vu=(e,t,n,r,s,i)=>{let a=e.dims,o=pu(i,t.axes,a.length),l=hu(a,r,s,t.axes),u=r.slice();0===r.length&&(u=a.map(((e,t)=>0===e?1:l[t]/e)),"stretch"!==t.keepAspectRatioPolicy&&(l=fu(a,u,t)));let d=or("output",e.dataType,l.length),c=ar("input",e.dataType,a.length),p=Wn.size(l),h=a.length===l.length&&a.every(((e,t)=>e===l[t])),f="tf_crop_and_resize"===t.coordinateTransformMode,m=t.extrapolationValue,_=c.type.value;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${n}|${u.length>0?u:""}|${s.length>0?s:""}|${o.length>0?o:""}|${h}|${a}`,inputDependencies:["rank"]},getShaderSource:e=>`\\n      ${h?"":`\\n      ${du(t.coordinateTransformMode,_)};\\n      ${(()=>{switch(t.mode){case"nearest":return`\\n              ${gu(c,a)};\\n              ${cu(t.nearestMode,n,_)};\\n              ${_u(c,d,a,l,u.length,o.length,f)};\\n              `;case"linear":return`\\n              ${mu(d,a,l,u.length,o.length)};\\n              ${(()=>{if(2===a.length||4===a.length)return`${yu(c,d,a,f,m)}`;if(3===a.length||5===a.length)return`${xu(c,d,a,f,m)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};\\n            `;case"cubic":return`\\n            ${(()=>{if(2===a.length||4===a.length)return`${bu(c,d,a,l,u,o,t.cubicCoeffA,f,t.extrapolationValue,t.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};\\n            `;default:throw Error("Invalid resize mode")}})()};\\n      `}\\n      ${e.registerUniform("output_size","u32").registerUniform("scales","f32",u.length).registerUniform("roi","f32",o.length).declareVariables(c,d)}\\n      ${e.mainStart()}\\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n        ${h?"output[global_idx] = input[global_idx];":`\\n        let output_indices = ${d.offsetToIndices("global_idx")};\\n        var input_indices: ${c.type.indices};\\n        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\\n                if (checkInputIndices(input_indices)) {\\n                  output[global_idx] = ${c.getByIndices("input_indices")};\\n                } else {\\n                  output[global_idx] = ${t.extrapolationValue};\\n                }`;case"linear":return`output[global_idx] = ${2===a.length||4===a.length?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\\n`}\\n      }`,getRunData:()=>({outputs:[{dims:l,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:[{type:12,data:p},{type:1,data:u},{type:1,data:o},...Jn(a,l)]})}},$u=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},ku=(e,t)=>{let n=[],r=[],s=[],i=$u(e);if(0!==t.antialias)throw Error("Only default value (0) for Antialias attribute is supported");uu(e.inputs,t,i,n,r,s),e.compute(vu(e.inputs[0],t,i,n,r,s),{inputs:[0]})},Eu=e=>{let t=e.antialias,n=e.axes,r=e.coordinateTransformMode,s=e.cubicCoeffA,i=0!==e.excludeOutside,a=e.extrapolationValue,o=e.keepAspectRatioPolicy,l=e.mode,u=""===e.nearestMode?"simple":e.nearestMode;return Un({antialias:t,axes:n,coordinateTransformMode:r,cubicCoeffA:s,excludeOutside:i,extrapolationValue:a,keepAspectRatioPolicy:o,mode:l,nearestMode:u})}})),$c=ut((()=>{vd(),Td(),Cd(),Id(),Su=(e,t)=>{let[n,r,s,i]=e,{numHeads:a,rotaryEmbeddingDim:o}=t;if(3!==n.dims.length&&4!==n.dims.length)throw new Error(`Input \'x\' is expected to have 3 or 4 dimensions, got ${n.dims.length}`);if(!Wn.areEqual(r.dims,[])&&!Wn.areEqual(r.dims,[1])&&2!==r.dims.length)throw new Error(`Input \'position_ids\' is expected to have 0, 1, or 2 dimensions, got ${r.dims.length}`);if(2!==s.dims.length)throw new Error(`Input \'cos_cache\' is expected to have 2 dimensions, got ${s.dims.length}`);if(2!==i.dims.length)throw new Error(`Input \'sin_cache\' is expected to have 2 dimensions, got ${i.dims.length}`);if(!Wn.areEqual(s.dims,i.dims))throw new Error("Inputs \'cos_cache\' and \'sin_cache\' are expected to have the same shape");if(o>0&&0===a)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let l=n.dims[0],u=n.dims[n.dims.length-2],d=s.dims[0],c=Wn.sizeFromDimension(n.dims,1)/u,p=0===o?2*s.dims[1]:c/a;if(o>p)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(2===r.dims.length){if(l!==r.dims[0])throw new Error(`Input \'position_ids\' dimension 0 should be of size batch_size, got ${r.dims[0]}`);if(u!==r.dims[1])throw new Error(`Input \'position_ids\' dimension 1 should be of size sequence_length, got ${r.dims[1]}`)}if(p/2!==s.dims[1]&&o/2!==s.dims[1])throw new Error(`Input \'cos_cache\' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${s.dims[1]}`);if(u>d)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},zu=(e,t)=>{let{interleaved:n,numHeads:r,rotaryEmbeddingDim:s,scale:i}=t,a=e[0].dims[0],o=Wn.sizeFromDimension(e[0].dims,1),l=e[0].dims[e[0].dims.length-2],u=o/l,d=e[2].dims[1],c=0===s?2*d:u/r,p=new Array(a,l,u/c,c-d),h=Wn.computeStrides(p),f=[{type:1,data:i},{type:12,data:p},{type:12,data:h},...3===e[0].dims.length?new Array({type:12,data:[o,u,c,1]}):[],...4===e[0].dims.length?new Array({type:12,data:[o,c,l*c,1]}):[],...Jn(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)];return{name:"RotaryEmbedding",shaderCache:{hint:Un({interleaved:n}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:t=>{let r=ar("input",e[0].dataType,e[0].dims.length),s=ar("position_ids",e[1].dataType,e[1].dims.length),i=ar("cos_cache",e[2].dataType,e[2].dims.length),a=ar("sin_cache",e[3].dataType,e[3].dims.length),o=or("output",e[0].dataType,e[0].dims.length);return t.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:p.length},{name:"global_strides",type:"u32",length:h.length},{name:"input_output_strides",type:"u32",length:h.length}]),`\\n        ${t.declareVariables(r,s,i,a,o)}\\n\\n        ${t.mainStart(Xn)}\\n          let half_rotary_emb_dim = uniforms.${i.name}_shape[1];\\n          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;\\n          let size = uniforms.global_shape[0] * uniforms.global_strides[0];\\n          ${t.guardAgainstOutOfBoundsWorkgroupSizes("size")}\\n\\n          if (bsnh[3] < half_rotary_emb_dim) {\\n            let position_ids_idx =\\n                ${s.broadcastedIndicesToOffset("bsnh.xy",or("",s.type.tensor,2))};\\n            let position_id =\\n                u32(${s.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);\\n            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${n});\\n            let j = i + select(half_rotary_emb_dim, 1, ${n});\\n            let re = ${r.getByOffset("i")} * ${i.get("position_id","bsnh[3]")} -\\n                ${r.getByOffset("j")} * ${a.get("position_id","bsnh[3]")};\\n            ${o.setByOffset("i","re")}\\n            let im = ${r.getByOffset("i")} * ${a.get("position_id","bsnh[3]")} +\\n                ${r.getByOffset("j")} * ${i.get("position_id","bsnh[3]")};\\n            ${o.setByOffset("j","im")}\\n          } else {\\n            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;\\n            ${o.setByOffset("k",r.getByOffset("k"))}\\n          }\\n        }`},getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(Wn.size(p)/Xn)},programUniforms:f})}},Cu=(e,t)=>{Su(e.inputs,t),e.compute(zu(e.inputs,t))}})),kc=ut((()=>{vd(),Td(),Id(),Tu=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],n=e[1],r=e[2];if(t.dataType!==n.dataType||t.dataType!==r.dataType)throw new Error("All inputs must have the same data type");if(3!==t.dims.length&&2!==t.dims.length)throw new Error("Input must be 2D or 3D");if(3!==n.dims.length&&2!==n.dims.length)throw new Error("Skip must be 2D or 3D");let s=t.dims[t.dims.length-1],i=t.dims[t.dims.length-2];if(n.dims[n.dims.length-1]!==s)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==i)throw new Error("Skip must have the same sequence length as input");if(1!==r.dims.length)throw new Error("Gamma must be 1D");if(r.dims[r.dims.length-1]!==s)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let t=e[3];if(1!==t.dims.length)throw new Error("Beta must be 1D");if(t.dims[t.dims.length-1]!==s)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let t=e[4];if(1!==t.dims.length)throw new Error("Bias must be 1D");if(t.dims[t.dims.length-1]!==s)throw new Error("Bias must have the same hidden size as input")}},Iu=(e,t,n,r)=>{let s=t.simplified,i=e[0].dims,a=Wn.size(i),o=i,l=a,u=i.slice(-1)[0],d=r?i.slice(0,-1).concat(1):[],c=!s&&e.length>3,p=e.length>4,h=r&&n>1,f=r&&n>2,m=n>3,_=64,g=er(u),w=[{type:12,data:l},{type:12,data:g},{type:12,data:u},{type:1,data:t.epsilon}],y=[{dims:o,dataType:e[0].dataType}];return n>1&&y.push({dims:d,dataType:1}),n>2&&y.push({dims:d,dataType:1}),n>3&&y.push({dims:i,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${g};${h};${f};${m}`,inputDependencies:e.map(((e,t)=>"type"))},getShaderSource:t=>{let n=[ar("x",e[0].dataType,e[0].dims,g),ar("skip",e[1].dataType,e[1].dims,g),ar("gamma",e[2].dataType,e[2].dims,g)];c&&n.push(ar("beta",e[3].dataType,e[3].dims,g)),p&&n.push(ar("bias",e[4].dataType,e[4].dims,g)),n.push(or("output",e[0].dataType,o,g)),h&&n.push(or("mean_output",1,d)),f&&n.push(or("inv_std_output",1,d)),m&&n.push(or("input_skip_bias_sum",e[0].dataType,o,g));let r=Yn(e[0].dataType),i=Yn(1,g);return`\\n\\n      ${t.registerUniforms([{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}]).declareVariables(...n)}\\n      var<workgroup> sum_shared : array<${i}, 64>;\\n      var<workgroup> sum_squared_shared : array<${i}, 64>;\\n\\n      ${t.mainStart([_,1,1])}\\n        let ix = local_id.x;\\n        let iy = global_id.x / 64;\\n\\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\\n        var stride = hidden_size_vectorized / 64;\\n        let offset = ix * stride + iy * hidden_size_vectorized;\\n        let offset1d = stride * ix;\\n        if (ix == 63) {\\n          stride = hidden_size_vectorized - stride * ix;\\n        }\\n        for (var i: u32 = 0; i < stride; i++) {\\n          let skip_value = skip[offset + i];\\n          let bias_value = ${p?"bias[offset1d + i]":r+"(0.0)"};\\n          let input_value = x[offset + i];\\n          let value = input_value + skip_value + bias_value;\\n          ${m?"input_skip_bias_sum[offset + i] = value;":""}\\n          output[offset + i] = value;\\n          let f32_value = ${nr(r,g,"value")};\\n          sum_shared[ix] += f32_value;\\n          sum_squared_shared[ix] += f32_value * f32_value;\\n        }\\n        workgroupBarrier();\\n\\n        var reduce_size : u32 = 64;\\n        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {\\n          reduce_size = curr_size + (reduce_size & 1);\\n          if (ix < curr_size) {\\n            sum_shared[ix] += sum_shared[ix + reduce_size];\\n            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];\\n          }\\n          workgroupBarrier();\\n        }\\n\\n        let sum = sum_shared[0];\\n        let square_sum = sum_squared_shared[0];\\n        let mean = ${rr("sum",g)} / f32(uniforms.hidden_size);\\n        let inv_std_dev = inverseSqrt(${rr("square_sum",g)} / f32(uniforms.hidden_size) ${s?"":"- mean * mean"} + uniforms.epsilon);\\n        ${h?"mean_output[global_idx] = mean;":""}\\n        ${f?"inv_std_output[global_idx] = inv_std_dev;":""}\\n\\n        for (var i: u32 = 0; i < stride; i++) {\\n          output[offset + i] = (output[offset + i] ${s?"":`- ${r}(mean)`}) *\\n            ${r}(inv_std_dev) * gamma[offset1d + i]\\n            ${c?"+ beta[offset1d + i]":""};\\n        }\\n      }`},getRunData:()=>({outputs:y,dispatchGroup:{x:Math.ceil(l/u)},programUniforms:w})}},Au=(e,t)=>{Tu(e.inputs);let n=[0];e.outputCount>1&&n.push(-3),e.outputCount>2&&n.push(-3),e.outputCount>3&&n.push(3),e.compute(Iu(e.inputs,t,e.outputCount,!1),{outputs:n})}})),Ec=ut((()=>{vd(),Td(),Cd(),Id(),Mu=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(0!==t.axes.length){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach(((t,n)=>{if(6!==e[n+1].dataType&&7!==e[n+1].dataType)throw new Error(`Input ${n} must be an array of int32 or int64`)}))},Ou=(e,t)=>{let n=[];if(e.length>t)if(7===e[t].dataType)e[t].getBigInt64Array().forEach((e=>n.push(Number(e))));else{if(6!==e[t].dataType)throw new Error(`Input ${t} must be an array of int32 or int64`);e[t].getInt32Array().forEach((e=>n.push(Number(e))))}return n},Bu=(e,t)=>{if(e.length>1){let t=Ou(e,1),n=Ou(e,2),r=Ou(e,3);return 0===r.length&&(r=[...Array(e[0].dims.length).keys()]),Un({starts:t,ends:n,axes:r})}return t},Nu=(e,t,n,r,s)=>{let i=e;return e<0&&(i+=n[r[t]]),s[t]<0?Math.max(0,Math.min(i,n[r[t]]-1)):Math.max(0,Math.min(i,n[r[t]]))},Pu=(e,t,n)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\\n          var input_indices: ${e.type.indices};\\n          var carry = 0u;\\n          for (var i = ${n.length}; i >= 0; i--) {\\n            let input_shape_i = ${sr("uniforms.input_shape","i",n.length)};\\n            let steps_i = ${sr("uniforms.steps","i",n.length)};\\n            let signs_i = ${sr("uniforms.signs","i",n.length)};\\n            let starts_i = ${sr("uniforms.starts","i",n.length)};\\n            var output_index = ${t.indicesGet("output_indices","i")};\\n            var input_index = output_index * steps_i + starts_i + carry;\\n            carry = input_index / input_shape_i;\\n            input_index = input_index % input_shape_i;\\n            if (signs_i < 0) {\\n              input_index = input_shape_i - input_index - 1u + starts_i;\\n            }\\n            ${e.indicesSet("input_indices","i","input_index")};\\n          }\\n          return input_indices;\\n      }`,Ru=(e,t)=>{let n=e[0].dims,r=Wn.size(n),s=t.axes.length>0?Wn.normalizeAxes(t.axes,n.length):[...Array(n.length).keys()],i=Ou(e,4);i.forEach((e=>0!==e||(()=>{throw new Error("step cannot be 0")}))),0===i.length&&(i=Array(s.length).fill(1));let a=t.starts.map(((e,t)=>Nu(e,t,n,s,i))),o=t.ends.map(((e,t)=>Nu(e,t,n,s,i)));if(s.length!==a.length||s.length!==o.length)throw new Error("start, ends and axes should have the same number of elements");if(s.length!==n.length)for(let e=0;e<n.length;++e)s.includes(e)||(a.splice(e,0,0),o.splice(e,0,n[e]),i.splice(e,0,1));let l=i.map((e=>Math.sign(e)));i.forEach(((e,t,n)=>{if(e<0){let r=(o[t]-a[t])/e,s=a[t],l=s+r*i[t];a[t]=l,o[t]=s,n[t]=-e}}));let u=n.slice(0);s.forEach(((e,t)=>{u[e]=Math.ceil((o[e]-a[e])/i[e])}));let d={dims:u,dataType:e[0].dataType},c=or("output",e[0].dataType,u.length),p=ar("input",e[0].dataType,e[0].dims.length),h=Wn.size(u),f=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:a.length},{name:"signs",type:"i32",length:l.length},{name:"steps",type:"u32",length:i.length}],m=[{type:12,data:h},{type:12,data:a},{type:6,data:l},{type:12,data:i},...Jn(e[0].dims,u)];return{name:"Slice",shaderCache:{hint:`${l.length}_${a.length}_${i.length}`,inputDependencies:["rank"]},getShaderSource:e=>`\\n      ${e.registerUniforms(f).declareVariables(p,c)}\\n        ${Pu(p,c,n)}\\n        ${e.mainStart()}\\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\\n          let output_indices = ${c.offsetToIndices("global_idx")};\\n          let input_indices = calculateInputIndices(output_indices);\\n          ${c.setByOffset("global_idx",p.getByIndices("input_indices"))}\\n      }`,getRunData:()=>({outputs:[d],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:m})}},Du=(e,t)=>{Mu(e.inputs,t);let n=Bu(e.inputs,t);e.compute(Ru(e.inputs,n),{inputs:[0]})},Fu=e=>{let t=e.starts,n=e.ends,r=e.axes;return Un({starts:t,ends:n,axes:r})}})),Sc=ut((()=>{vd(),Td(),Cd(),Ad(),Id(),Lu=e=>{if(!e||1!==e.length)throw new Error("Softmax op requires 1 input.")},Uu=(e,t)=>{let n,r=e.inputs[0],s=r.dims,i=Wn.size(s),a=s.length,o=Wn.normalizeAxis(t.axis,a),l=o<s.length-1,u=[];l?(u=Array.from({length:a},((e,t)=>t)),u[o]=a-1,u[a-1]=o,n=e.compute(wr(r,u),{inputs:[r],outputs:[-1]})[0]):n=r;let d=n.dims,c=d[a-1],p=i/c,h=er(c),f=c/h,m=64;1===p&&(m=256);let _=ar("x",n.dataType,n.dims,h),g=or("result",n.dataType,n.dims,h),w=_.type.value,y="f32"===Yn(n.dataType)?`var threadMax = ${w}(-3.402823e+38f);`:`var threadMax = ${w}(-65504.0h);`,b=e.compute({name:"Softmax",shaderCache:{hint:`${h};${m}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:d,dataType:n.dataType}],dispatchGroup:{x:p},programUniforms:[{type:6,data:f}]}),getShaderSource:e=>`\\n      var<workgroup> rowMaxShared : ${w};\\n      var<workgroup> rowSumShared : ${w};\\n      var<workgroup> threadShared : array<${w}, ${m}>;\\n\\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${w} {\\n        let index = row * row_stride + col;\\n        return x[index];\\n      }\\n\\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${w}) {\\n        let index = row * row_stride + col;\\n        result[index] = value;\\n      }\\n      ${e.registerUniform("packedCols","i32").declareVariables(_,g)}\\n      ${e.mainStart(m)}\\n        let gindex = i32(global_idx);\\n        let lindex = i32(local_idx);\\n        const wg = ${m};\\n        let row = gindex / wg;\\n        let cols = uniforms.packedCols;\\n        let row_stride : i32 = uniforms.packedCols;\\n\\n        // find the rows max\\n        ${y}\\n        for (var col = lindex; col < cols; col += wg) {\\n          let value = getValue(row, col, row_stride);\\n          threadMax = max(threadMax, value);\\n        }\\n        if (lindex < cols) {\\n          threadShared[lindex] = threadMax;\\n        }\\n        workgroupBarrier();\\n\\n        var reduceSize = min(cols, wg);\\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\\n          reduceSize = currSize + (reduceSize & 1);\\n          if (lindex < currSize) {\\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\\n          }\\n          workgroupBarrier();\\n        }\\n        if (lindex == 0) {\\n          rowMaxShared = ${w}(${((e,t)=>4===t?`max(max(${e}.x, ${e}.y), max(${e}.z, ${e}.w))`:2===t?`max(${e}.x, ${e}.y)`:3===t?`max(max(${e}.x, ${e}.y), ${e}.z)`:e)("threadShared[0]",h)});\\n        }\\n        workgroupBarrier();\\n\\n        // find the rows sum\\n        var threadSum = ${w}(0.0);\\n        for (var col = lindex; col < cols; col += wg) {\\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\\n          threadSum += subExp;\\n        }\\n        threadShared[lindex] = threadSum;\\n        workgroupBarrier();\\n\\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\\n          if (lindex < currSize) {\\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\\n          }\\n          workgroupBarrier();\\n        }\\n        if (lindex == 0) {\\n          rowSumShared = ${w}(${rr("threadShared[0]",h)});\\n        }\\n        workgroupBarrier();\\n\\n        // calculate final value for each element in the row\\n        for (var col = lindex; col < cols; col += wg) {\\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\\n          setValue(row, col, row_stride, value);\\n        }\\n      }`},{inputs:[n],outputs:[l?-1:0]})[0];l&&e.compute(wr(b,u),{inputs:[b]})},qu=(e,t)=>{Lu(e.inputs),Uu(e,t)},Vu=e=>Un({axis:e.axis})})),zc=ut((()=>{vd(),Td(),Id(),Wu=e=>Array.from(e.getBigInt64Array(),Number),ju=e=>{if(!e||2!==e.length)throw new Error("Tile requires 2 inputs.");if(1!==e[0].dataType&&10!==e[0].dataType&&6!==e[0].dataType&&12!==e[0].dataType)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(7!==e[1].dataType)throw new Error("Tile `repeats` input should be of int64 data type");if(1!==e[1].dims.length)throw new Error("Tile `repeats` input should be 1-D");if(Wu(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Gu=(e,t)=>{let n=[];for(let r=0;r<e.length;++r)n.push(e[r]*t[r]);return n},Hu=(e,t)=>{let n=e[0].dims,r=t??Wu(e[1]),s=Gu(n,r),i=Wn.size(s),a=e[0].dataType,o=ar("input",a,n.length),l=or("output",a,s.length);return{name:"Tile",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:12,data:i},...Jn(e[0].dims,s)]}),getShaderSource:e=>`\\n      const inputShape = ${o.indices(...n)};\\n      ${e.registerUniform("output_size","u32").declareVariables(o,l)}\\n      ${e.mainStart()}\\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\\n      let output_indices = ${l.offsetToIndices("global_idx")};\\n      var input_indices: ${o.type.indices};\\n      for (var i = 0; i < ${n.length}; i++) {\\n        let input_dim_i = ${o.indicesGet("uniforms.input_shape","i")};\\n        let input_dim_value = ${l.indicesGet("output_indices","i")}  % input_dim_i;\\n\\n        ${o.indicesSet("input_indices","i","input_dim_value")}\\n      }\\n      ${l.setByOffset("global_idx",o.getByIndices("input_indices"))}\\n    }`}},Ku=e=>{ju(e.inputs),e.compute(Hu(e.inputs),{inputs:[0]})}})),Cc=ut((()=>{vd(),Td(),Id(),Xu=(e,t,n,r,s)=>{let i,a=or("output_data",s,n.length,4),o=ar("a_data",t[1].dataType,t[1].dims.length,4),l=ar("b_data",t[2].dataType,t[2].dims.length,4),u=ar("c_data",t[0].dataType,t[0].dims.length,4),d=(e,t,n)=>`select(${t}, ${e}, ${n})`;if(r){let e=(e,t,n="")=>{let r=`a_data[index_a${t}][component_a${t}]`,s=`b_data[index_b${t}][component_b${t}]`,i=`bool(c_data[index_c${t}] & (0xffu << (component_c${t} * 8)))`;return`\\n            let output_indices${t} = ${a.offsetToIndices(`global_idx * 4u + ${t}u`)};\\n            let offset_a${t} = ${o.broadcastedIndicesToOffset(`output_indices${t}`,a)};\\n            let offset_b${t} = ${l.broadcastedIndicesToOffset(`output_indices${t}`,a)};\\n            let offset_c${t} = ${u.broadcastedIndicesToOffset(`output_indices${t}`,a)};\\n            let index_a${t} = offset_a${t} / 4u;\\n            let index_b${t} = offset_b${t} / 4u;\\n            let index_c${t} = offset_c${t} / 4u;\\n            let component_a${t} = offset_a${t} % 4u;\\n            let component_b${t} = offset_b${t} % 4u;\\n            let component_c${t} = offset_c${t} % 4u;\\n            ${e}[${t}] = ${n}(${d(r,s,i)});\\n          `};i=9===s?`\\n            var data = vec4<u32>(0);\\n            ${e("data",0,"u32")}\\n            ${e("data",1,"u32")}\\n            ${e("data",2,"u32")}\\n            ${e("data",3,"u32")}\\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\\n            ${e("output_data[global_idx]",0)}\\n            ${e("output_data[global_idx]",1)}\\n            ${e("output_data[global_idx]",2)}\\n            ${e("output_data[global_idx]",3)}\\n          `}else i=a.setByOffset("global_idx",d(o.getByOffset("global_idx"),l.getByOffset("global_idx"),u.getByOffset("global_idx")));return`\\n        ${e.registerUniform("vec_size","u32").declareVariables(u,o,l,a)}\\n        ${e.mainStart()}\\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\\n        ${i}\\n      }`},Qu=e=>{let t=e[1].dims,n=e[2].dims,r=e[0].dims,s=e[1].dataType,i=!(Wn.areEqual(t,n)&&Wn.areEqual(n,r)),a=t,o=Wn.size(t);if(i){let e=Vn.calcShape(Vn.calcShape(t,n,!1),r,!1);if(!e)throw new Error("Can\'t perform where op on the given tensors");a=e,o=Wn.size(a)}let l=Math.ceil(o/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:t=>Xu(t,e,a,i,s),getRunData:()=>({outputs:[{dims:a,dataType:s}],dispatchGroup:{x:Math.ceil(o/64/4)},programUniforms:[{type:12,data:l},...Jn(r,t,n,a)]})}},Yu=e=>{e.compute(Qu(e.inputs))}})),Tc=ut((()=>{Bd(),Nd(),Pd(),Rd(),Fd(),Ld(),Ud(),Qd(),Zd(),Jd(),ec(),tc(),nc(),rc(),sc(),ic(),ac(),oc(),lc(),uc(),pc(),hc(),fc(),mc(),_c(),dc(),gc(),wc(),yc(),bc(),xc(),Od(),vc(),$c(),kc(),Ec(),Sc(),cc(),zc(),Ad(),Dd(),Cc(),Zu=new Map([["Abs",[Ns]],["Acos",[Ps]],["Acosh",[Rs]],["Add",[Ii]],["ArgMax",[_s,gs]],["ArgMin",[ms,gs]],["Asin",[Ds]],["Asinh",[Fs]],["Atan",[Ls]],["Atanh",[Us]],["Attention",[Es]],["AveragePool",[Ul,Ll]],["BatchNormalization",[Ts]],["BiasAdd",[Ms]],["BiasSplitGelu",[Si]],["Cast",[Vs,qs]],["Ceil",[Gs]],["Clip",[js]],["Concat",[Wi,ji]],["Conv",[Ta,Ea]],["ConvTranspose",[Fa,Na]],["Cos",[Hs]],["Cosh",[Ks]],["CumSum",[Ua,qa]],["DepthToSpace",[Ga,Ha]],["DequantizeLinear",[Zl,Jl]],["Div",[Ai]],["Einsum",[no,ro]],["Elu",[Qs,Xs]],["Equal",[Mi]],["Erf",[Zs]],["Exp",[Js]],["Expand",[lo]],["FastGelu",[co]],["Floor",[ei]],["FusedConv",[Ta,Ea]],["Gather",[mo,fo]],["GatherElements",[So,Eo]],["GatherBlockQuantized",[xo,vo]],["GatherND",[go,wo]],["Gelu",[ti]],["Gemm",[Io,To]],["GlobalAveragePool",[Wl,Vl]],["GlobalMaxPool",[Xl,Kl]],["Greater",[Pi]],["GreaterOrEqual",[Di]],["GridSample",[qo,Vo]],["GroupQueryAttention",[ol]],["HardSigmoid",[ui,li]],["InstanceNormalization",[cl]],["LayerNormalization",[fl]],["LeakyRelu",[ni,Xs]],["Less",[Ri]],["LessOrEqual",[Fi]],["Log",[bi]],["MatMul",[_l]],["MatMulNBits",[bl,xl]],["MaxPool",[Gl,Hl]],["Mul",[Oi]],["MultiHeadAttention",[Qo,Go]],["Neg",[si]],["Not",[ri]],["Pad",[Il]],["Pow",[Bi]],["QuickGelu",[$i,Xs]],["Range",[nu]],["Reciprocal",[ii]],["ReduceMin",[us]],["ReduceMean",[ss]],["ReduceMax",[ls]],["ReduceSum",[cs]],["ReduceProd",[ds]],["ReduceL1",[is]],["ReduceL2",[as]],["ReduceLogSum",[hs]],["ReduceLogSumExp",[os]],["ReduceSumSquare",[ps]],["Relu",[ai]],["Resize",[ku,Eu]],["RotaryEmbedding",[Cu]],["ScatterND",[au,iu]],["Sigmoid",[oi]],["Sin",[di]],["Sinh",[ci]],["Slice",[Du,Fu]],["SkipLayerNormalization",[Au]],["Split",[nl,rl]],["Sqrt",[pi]],["Softmax",[qu,Vu]],["Sub",[Ni]],["Tan",[hi]],["Tanh",[mi]],["ThresholdedRelu",[yi,Xs]],["Tile",[Ku]],["Transpose",[yr,br]],["Where",[Yu]]])})),Ic=ut((()=>{At(),kd(),Id(),Ju=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n,r,s){Ze(e.programInfo.name);let i=this.backend.device,a=this.backend.getComputePassEncoder();this.backend.writeTimestamp(2*this.backend.pendingDispatchNumber);let o=[];for(let e of t)o.push({binding:o.length,resource:{buffer:e.buffer}});for(let e of n)o.push({binding:o.length,resource:{buffer:e.buffer}});s&&o.push({binding:o.length,resource:s});let l=i.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:o,label:e.programInfo.name});if("capturing"===this.backend.sessionStatus){let t={kernelId:this.backend.currentKernelId,computePipeline:e.computePipeline,bindGroup:l,dispatchGroup:r};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(t)}a.setPipeline(e.computePipeline),a.setBindGroup(0,l),a.dispatchWorkgroups(...r),this.backend.writeTimestamp(2*this.backend.pendingDispatchNumber+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||"at-passes"===this.backend.queryType)&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Je(e.programInfo.name)}dispose(){}build(e,t){Ze(e.name);let n=this.backend.device,r=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"},{feature:"subgroups-f16",extension:"subgroups_f16"}].forEach((e=>{n.features.has(e.feature)&&r.push(`enable ${e.extension};`)}));let s=cr(t,this.backend.device.limits),i=e.getShaderSource(s),a=`${r.join("\\n")}\\n${s.additionalImplementations}\\n${i}`,o=n.createShaderModule({code:a,label:e.name});Tn("verbose",(()=>`[WebGPU] ${e.name} shader code: ${a}`));let l=n.createComputePipeline({compute:{module:o,entryPoint:"main"},layout:"auto",label:e.name});return Je(e.name),{programInfo:e,computePipeline:l,uniformVariablesInfo:s.variablesInfo}}normalizeDispatchGroupSize(e){let t="number"==typeof e?e:e.x,n="number"==typeof e?1:e.y||1,r="number"==typeof e?1:e.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=s&&n<=s&&r<=s)return[t,n,r];let i=t*n*r,a=Math.ceil(Math.sqrt(i));if(a>s){if(a=Math.ceil(Math.cbrt(i)),a>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[a,a,a]}return[a,a,1]}}})),Ac=ut((()=>{At(),vd(),kd(),Ed(),zd(),Tc(),Ic(),ed=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let n=[];for(let r=0;r<e.length;++r){let s=e[r].dataType;switch(t[r]){case"none":n.push("");break;case"type":n.push(`${s}`);break;case"rank":{let t=e[r].dims.length;n.push(`${s};${t}`);break}case"dims":{let t=e[r].dims.join(",");n.push(`${s};${t}`);break}default:throw new Error(`unsupported input dependency: ${t[r]}`)}}return n.join("|")},td=(e,t,n)=>{let r=e.name;return e.shaderCache?.hint&&(r+="["+e.shaderCache.hint+"]"),r+=":"+n+`:${ed(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,r},nd=class{constructor(e){e&&(this.architecture=e.architecture,this.vendor=e.vendor)}isArchitecture(e){return this.architecture===e}isVendor(e){return this.vendor===e}},rd=class{constructor(e){this.subgroupsSupported=e.features.has("subgroups"),this.subgroupsF16Supported=e.features.has("subgroups");let t=e.limits;this.subgroupsSupported&&t.minSubgroupSize&&t.maxSubgroupSize?this.subgroupSizeRange=[t.minSubgroupSize,t.maxSubgroupSize]:this.subgroupSizeRange=void 0}},sd=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(null===this.currentKernelId)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e,t){this.env=e;let n=[],r={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize,maxBufferSize:t.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:t.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n},s=e=>t.features.has(e)&&n.push(e)&&!0;s("chromium-experimental-timestamp-query-inside-passes")||s("timestamp-query"),s("shader-f16"),s("subgroups")&&s("subgroups-f16"),this.device=await t.requestDevice(r),this.deviceInfo=new rd(this.device),this.adapterInfo=new nd(t.info||await t.requestAdapterInfo()),this.gpuDataManager=Fn(this),this.programManager=new Ju(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,zn(e.logLevel,!!e.debug),this.device.onuncapturederror=e=>{e.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${e.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:t,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let e=this.getCommandEncoder(),t={};"at-passes"===this.queryType&&(t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:2*this.pendingDispatchNumber,endOfPassWriteIndex:2*this.pendingDispatchNumber+1}),this.computePassEncoder=e.beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;let e;Ze(),this.endComputePass(),"none"!==this.queryType&&(this.commandEncoder.resolveQuerySet(this.querySet,0,2*this.pendingDispatchNumber,this.queryResolveBuffer,0),e=this.device.createBuffer({size:2*this.pendingDispatchNumber*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(e,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,2*this.pendingDispatchNumber*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,"none"!==this.queryType&&e.mapAsync(GPUMapMode.READ).then((()=>{let t=new BigUint64Array(e.getMappedRange()),n=this.pendingQueries.get(e);for(let e=0;e<t.length/2;e++){let r=n[e],s=r.kernelId,i=this.kernels.get(s),a=i.kernelType,o=i.kernelName,l=r.programName,u=r.inputTensorViews,d=r.outputTensorViews,c=t[2*e],p=t[2*e+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=c);let h=Number(c-this.queryTimeBase),f=Number(p-this.queryTimeBase);if(!Number.isSafeInteger(h)||!Number.isSafeInteger(f))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:u.map((e=>({dims:e.dims,dataType:mn(e.dataType)}))),outputsMetadata:d.map((e=>({dims:e.dims,dataType:mn(e.dataType)}))),kernelId:s,kernelType:a,kernelName:o,programName:l,startTime:h,endTime:f});else{let e="";u.forEach(((t,n)=>{e+=`input[${n}]: [${t.dims}] | ${mn(t.dataType)}, `}));let t="";d.forEach(((e,n)=>{t+=`output[${n}]: [${e.dims}] | ${mn(e.dataType)}, `})),console.log(`[profiling] kernel "${s}|${a}|${o}|${l}" ${e}${t}execution time: ${f-h} ns`)}Qe("GPU",`${l}::${c}::${p}`)}e.unmap(),this.pendingQueries.delete(e)})),Je()}run(e,t,n,r,s,i){Ze(e.name);let a=[];for(let e=0;e<t.length;++e){let n=t[e].data;if(0===n)continue;let r=this.gpuDataManager.get(n);if(!r)throw new Error(`no GPU data for input: ${n}`);a.push(r)}let{outputs:o,dispatchGroup:l,programUniforms:u}=e.getRunData(t),d=0===n.length?o.map(((e,t)=>t)):n;if(d.length!==o.length)throw new Error(`Output size ${d.length} must be equal to ${o.length}.`);let c,p=[],h=[];for(let e=0;e<o.length;++e){if(!Number.isInteger(d[e])||d[e]<-3||d[e]>=i)throw new Error(`Invalid output index: ${d[e]}`);if(-3===d[e])continue;let t=-1===d[e],n=-2===d[e],a=t||n?s(o[e].dataType,o[e].dims):r(d[e],o[e].dataType,o[e].dims);if(p.push(a),0===a.data)continue;let l=this.gpuDataManager.get(a.data);if(!l)throw new Error(`no GPU data for output: ${a.data}`);if(t&&this.temporaryData.push(l),n){let e=this.kernelPersistentData.get(this.currentKernelId);e||(e=[],this.kernelPersistentData.set(this.currentKernelId,e)),e.push(l)}h.push(l)}if(a.length!==t.length||h.length!==p.length){if(0===h.length)return Je(e.name),p;throw new Error(`Program ${e.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}if(u){let e=0,t=[];u.forEach((n=>{let r="number"==typeof n.data?[n.data]:n.data;if(0===r.length)return;let s,i,a=10===n.type?2:4;10===n.type?(i=r.length>4?16:r.length>2?8:r.length*a,s=r.length>4?16:a*r.length):(i=r.length<=2?r.length*a:16,s=16),e=Math.ceil(e/i)*i,t.push(e);let o=10===n.type?8:4;e+=r.length>4?Math.ceil(r.length/o)*s:r.length*a}));let n=16;e=Math.ceil(e/n)*n;let r=new ArrayBuffer(e);u.forEach(((e,n)=>{let s=t[n],i="number"==typeof e.data?[e.data]:e.data;if(6===e.type)new Int32Array(r,s,i.length).set(i);else if(12===e.type)new Uint32Array(r,s,i.length).set(i);else if(10===e.type)new Uint16Array(r,s,i.length).set(i);else{if(1!==e.type)throw new Error(`Unsupported uniform type: ${mn(e.type)}`);new Float32Array(r,s,i.length).set(i)}}));let s=this.gpuDataManager.create(e,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(s.buffer,0,r,0,e),this.gpuDataManager.release(s.id),c={offset:0,size:e,buffer:s.buffer}}let f=this.programManager.normalizeDispatchGroupSize(l),m=1===f[1]&&1===f[2],_=td(e,t,m),g=this.programManager.getArtifact(_);if(g||(g=this.programManager.build(e,f),this.programManager.setArtifact(_,g),Tn("info",(()=>`[artifact] key: ${_}, programName: ${e.name}`))),u&&g.uniformVariablesInfo){if(u.length!==g.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${g.uniformVariablesInfo.length}, got ${u.length} in program "${g.programInfo.name}".`);for(let e=0;e<u.length;e++){let t=u[e],n=t.type,r="number"==typeof t.data?1:t.data.length,[s,i]=g.uniformVariablesInfo[e];if(n!==s||r!==i)throw new Error(`Uniform variable ${e} mismatch: expect type ${s} with size ${i}, got type ${n} with size ${r} in program "${g.programInfo.name}".`)}}if(Tn("info",(()=>`[ProgramManager] run "${e.name}" (key=${_}) with ${f[0]}x${f[1]}x${f[2]}`)),"none"!==this.queryType||"capturing"===this.sessionStatus){let e={kernelId:this.currentKernelId,programName:g.programInfo.name,inputTensorViews:t,outputTensorViews:p};this.pendingKernels.push(e),"capturing"===this.sessionStatus&&this.capturedPendingKernels.get(this.currentSessionId).push(e)}return this.programManager.run(g,a,h,f,c),Je(e.name),p}upload(e,t){this.gpuDataManager.upload(e,t)}memcpy(e,t){this.gpuDataManager.memcpy(e,t)}async download(e,t){await this.gpuDataManager.download(e,t)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,t,n,r){let s=Zu.get(e);if(!s)throw new Error(`kernel not implemented: ${e}`);let i={kernelType:e,kernelName:r,kernelEntry:s[0],attributes:[s[1],n]};this.kernels.set(t,i)}releaseKernel(e){let t=this.kernelPersistentData.get(e);if(t){for(let e of t)this.gpuDataManager.release(e.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,t,n){let r=this.kernels.get(e);if(!r)throw new Error(`kernel not created: ${e}`);let s=r.kernelType,i=r.kernelName,a=r.kernelEntry,o=r.attributes;if(null!==this.currentKernelId)throw new Error(`kernel "[${s}] ${i}" is not allowed to be called recursively`);this.currentKernelId=e,o[0]&&(o[1]=o[0](o[1]),o[0]=void 0),Tn("info",(()=>`[WebGPU] Start to run kernel "[${s}] ${i}"...`));let l=this.env.debug;this.temporaryData=[];try{return l&&this.device.pushErrorScope("validation"),a(t,o[1]),0}catch(e){return n.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${i}" failed. ${e}`)),1}finally{l&&n.push(this.device.popErrorScope().then((e=>e?`GPU validation error for kernel "[${s}] ${i}": ${e.message}`:null)));for(let e of this.temporaryData)this.gpuDataManager.release(e.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,t,n,r){let s=this.sessionExternalDataMapping.get(e);s||(s=new Map,this.sessionExternalDataMapping.set(e,s));let i=s.get(t),a=this.gpuDataManager.registerExternalBuffer(n,r,i);return s.set(t,[a,n]),a}unregisterBuffers(e){let t=this.sessionExternalDataMapping.get(e);t&&(t.forEach((e=>this.gpuDataManager.unregisterExternalBuffer(e[0]))),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let t=this.gpuDataManager.get(e);if(!t)throw new Error(`no GPU data for buffer: ${e}`);return t.buffer}createDownloader(e,t,n){return async()=>{let r=await Rn(this,e,t);return In(r.buffer,n)}}writeTimestamp(e){"inside-passes"===this.queryType&&this.computePassEncoder.writeTimestamp(this.querySet,e)}setQueryType(){this.queryType="none",("default"===this.env.webgpu.profiling?.mode||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),"none"!==this.queryType&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2*this.maxDispatchNumber}),this.queryResolveBuffer=this.device.createBuffer({size:2*this.maxDispatchNumber*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){Tn("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){Tn("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){Tn("info","replay"),this.sessionStatus="replaying";let e=this.capturedCommandList.get(this.currentSessionId),t=this.capturedPendingKernels.get(this.currentSessionId),n=e.length;this.pendingKernels=[];for(let r=0;r<n;r++){let n=this.getComputePassEncoder(),s=e[r];this.writeTimestamp(2*this.pendingDispatchNumber),n.setPipeline(s.computePipeline),n.setBindGroup(0,s.bindGroup),n.dispatchWorkgroups(...s.dispatchGroup),this.writeTimestamp(2*this.pendingDispatchNumber+1),this.pendingDispatchNumber++,"none"!==this.queryType&&this.pendingKernels.push(t[r]),(this.pendingDispatchNumber>=this.maxDispatchNumber||"at-passes"===this.queryType)&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(e){this.unregisterBuffers(e),this.capturedCommandList.has(e)&&this.capturedCommandList.delete(e),this.capturedPendingKernels.has(e)&&this.capturedPendingKernels.delete(e),this.gpuDataManager.onReleaseSession(e)}onRunStart(e){this.currentSessionId=e,this.setQueryType()}}})),Mc=ut((()=>{kd(),id=1,ad=()=>id++,od=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),ld=(e,t)=>{let n=od.get(e);if(!n)throw new Error("Unsupported data type.");return t.length>0?Math.ceil(t.reduce(((e,t)=>e*t))*n/8):0},ud=class{constructor(e){this.sessionId=e.sessionId,this.mlContext=e.context,this.mlTensor=e.tensor,this.dataType=e.dataType,this.tensorShape=e.shape}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return ld(this.dataType,this.tensorShape)}destroy(){Tn("verbose",(()=>"[WebNN] TensorWrapper.destroy")),this.mlTensor.destroy()}write(e){this.mlContext.writeTensor(this.mlTensor,e)}async read(e){return e?this.mlContext.readTensor(this.mlTensor,e):this.mlContext.readTensor(this.mlTensor)}sameTypeAndShape(e,t){return this.dataType===e&&this.tensorShape.length===t.length&&this.tensorShape.every(((e,n)=>e===t[n]))}},dd=class{constructor(e,t){this.tensorManager=e,this.wrapper=t}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(e,t,n){if(this.wrapper){if(this.wrapper.sameTypeAndShape(e,t))return this.wrapper.tensor;if(n){if(this.wrapper.byteLength!==ld(e,t))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let r=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(e,t,r,!0,!0),n&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(e){if(this.wrapper){if(e.byteLength===this.wrapper.byteLength)return void this.wrapper.write(e);Tn("verbose",(()=>"Data size does not match tensor size. Releasing tensor.")),this.releaseTensor()}this.activeUpload?this.activeUpload.set(e):this.activeUpload=new Uint8Array(e)}async download(e){if(this.activeUpload)return e?void(e instanceof ArrayBuffer?new Uint8Array(e).set(this.activeUpload):new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(this.activeUpload)):this.activeUpload.buffer;if(!this.wrapper)throw new Error("Tensor has not been created.");return e?this.wrapper.read(e):this.wrapper.read()}},cd=class{constructor(e){this.backend=e,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}reserveTensorId(){let e=ad();return this.tensorTrackersById.set(e,new dd(this)),e}releaseTensorId(e){let t=this.tensorTrackersById.get(e);t&&(this.tensorTrackersById.delete(e),t.tensorWrapper&&this.releaseTensor(t.tensorWrapper))}async ensureTensor(e,t,n,r){Tn("verbose",(()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${e}, dataType: ${t}, shape: ${n}, copyOld: ${r}}`));let s=this.tensorTrackersById.get(e);if(!s)throw new Error("Tensor not found.");return s.ensureTensor(t,n,r)}upload(e,t){let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");n.upload(t)}async download(e,t){Tn("verbose",(()=>`[WebNN] TensorManager.download {tensorId: ${e}, dstBuffer: ${t?.byteLength}}`));let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");return n.download(t)}releaseTensorsForSession(e){for(let t of this.freeTensors)t.sessionId===e&&t.destroy();this.freeTensors=this.freeTensors.filter((t=>t.sessionId!==e))}registerTensor(e,t,n,r){let s=ad(),i=new ud({sessionId:this.backend.currentSessionId,context:e,tensor:t,dataType:n,shape:r});return this.tensorTrackersById.set(s,new dd(this,i)),this.externalTensors.add(i),s}async getCachedTensor(e,t,n,r,s){let i=this.backend.currentSessionId;for(let[n,r]of this.freeTensors.entries())if(r.sameTypeAndShape(e,t)){Tn("verbose",(()=>`[WebNN] Reusing tensor {dataType: ${e}, shape: ${t}}`));let r=this.freeTensors.splice(n,1)[0];return r.sessionId=i,r}let a=this.backend.currentContext;Tn("verbose",(()=>`[WebNN] MLContext.createTensor {dataType: ${e}, shape: ${t}}`));let o=await a.createTensor({dataType:e,shape:t,dimensions:t,usage:n,writable:r,readable:s});return new ud({sessionId:i,context:a,tensor:o,dataType:e,shape:t})}releaseTensor(e){this.externalTensors.has(e)&&this.externalTensors.delete(e),this.freeTensors.push(e)}},pd=(...e)=>new cd(...e)})),Oc=ut((()=>{vd(),wd(),Ed(),Mc(),kd(),hd=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),fd=(e,t)=>{if(e===t)return!0;if(void 0===e||void 0===t)return!1;let n=Object.keys(e).sort(),r=Object.keys(t).sort();return n.length===r.length&&n.every(((n,s)=>n===r[s]&&e[n]===t[n]))},md=class{constructor(e){this.tensorManager=pd(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],zn(e.logLevel,!!e.debug)}get currentSessionId(){if(void 0===this.activeSessionId)throw new Error("No active session");return this.activeSessionId}onRunStart(e){this.activeSessionId=e}async createMLContext(e){if(e instanceof GPUDevice){let t=this.mlContextCache.findIndex((t=>t.gpuDevice===e));if(-1!==t)return this.mlContextCache[t].mlContext;{let t=await navigator.ml.createContext(e);return this.mlContextCache.push({gpuDevice:e,mlContext:t}),t}}if(void 0===e){let e=this.mlContextCache.findIndex((e=>void 0===e.options&&void 0===e.gpuDevice));if(-1!==e)return this.mlContextCache[e].mlContext;{let e=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:e}),e}}let t=this.mlContextCache.findIndex((t=>fd(t.options,e)));if(-1!==t)return this.mlContextCache[t].mlContext;{let t=await navigator.ml.createContext(e);return this.mlContextCache.push({options:e,mlContext:t}),t}}get currentContext(){let e=this.getMLContext(this.currentSessionId);if(!e)throw new Error(`No MLContext found for session ${this.currentSessionId}`);return e}registerMLContext(e,t){this.mlContextBySessionId.set(e,t);let n=this.sessionIdsByMLContext.get(t);n||(n=new Set,this.sessionIdsByMLContext.set(t,n)),n.add(e)}onReleaseSession(e){let t=this.mlContextBySessionId.get(e);if(!t)return;this.tensorManager.releaseTensorsForSession(e),this.mlContextBySessionId.delete(e);let n=this.sessionIdsByMLContext.get(t);if(n.delete(e),0===n.size){this.sessionIdsByMLContext.delete(t);let e=this.mlContextCache.findIndex((e=>e.mlContext===t));-1!==e&&this.mlContextCache.splice(e,1)}}getMLContext(e){return this.mlContextBySessionId.get(e)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(e){Tn("verbose",(()=>`[WebNN] releaseTensorId {tensorId: ${e}}`)),this.tensorManager.releaseTensorId(e)}async ensureTensor(e,t,n,r){let s=hd.get(t);if(!s)throw new Error(`Unsupported ONNX data type: ${t}`);return this.tensorManager.ensureTensor(e,s,n,r)}uploadTensor(e,t){if(!rn().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");Tn("verbose",(()=>`[WebNN] uploadTensor {tensorId: ${e}, data: ${t.byteLength}}`)),this.tensorManager.upload(e,t)}async downloadTensor(e,t){return this.tensorManager.download(e,t)}createMLTensorDownloader(e,t){return async()=>{let n=await this.tensorManager.download(e);return In(n,t)}}registerMLTensor(e,t,n){let r=hd.get(t);if(!r)throw new Error(`Unsupported ONNX data type: ${t}`);let s=this.tensorManager.registerTensor(this.currentContext,e,r,n);return Tn("verbose",(()=>`[WebNN] registerMLTensor {tensor: ${e}, dataType: ${r}, dimensions: ${n}} -> {tensorId: ${s}}`)),s}registerMLConstant(e,t,n,r,s,i){if(!i)throw new Error("External mounted files are not available.");let a=e;e.startsWith("./")&&(a=e.substring(2));let o=i.get(a);if(!o)throw new Error(`File with name ${a} not found in preloaded files.`);if(t+n>o.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let l,u=o.slice(t,t+n).buffer;switch(s.dataType){case"float32":l=new Float32Array(u);break;case"float16":l=new Uint16Array(u);break;case"int32":l=new Int32Array(u);break;case"uint32":l=new Uint32Array(u);break;case"int64":l=new BigInt64Array(u);break;case"uint64":l=new BigUint64Array(u);break;case"int8":l=new Int8Array(u);break;case"int4":case"uint4":case"uint8":l=new Uint8Array(u);break;default:throw new Error(`Unsupported data type: ${s.dataType} in creating WebNN Constant from external data.`)}return Tn("verbose",(()=>`[WebNN] registerMLConstant {dataType: ${s.dataType}, shape: ${s.shape}}}`)),r.constant(s,l)}flush(){}}})),Bc={};dt(Bc,{init:()=>Rc});var Nc,Pc,Rc,Dc,Fc,Lc,Uc,qc,Vc,Wc,jc,Gc,Hc,Kc,Xc,Qc,Yc,Zc,Jc,ep,tp,np,rp,sp,ip,ap,op,lp,up,dp,cp,pp,hp,fp,mp,_p,gp=ut((()=>{vd(),Ac(),kd(),Td(),Oc(),Nc=class e{constructor(e,t,n,r){this.module=e,this.dataType=t,this.data=n,this.dims=r}getFloat32Array(){if(1!==this.dataType)throw new Error("Invalid data type");let e=Wn.size(this.dims);return 0===e?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(7!==this.dataType)throw new Error("Invalid data type");let e=Wn.size(this.dims);return 0===e?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(6!==this.dataType)throw new Error("Invalid data type");let e=Wn.size(this.dims);return 0===e?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}getUint16Array(){if(10!==this.dataType&&4!==this.dataType)throw new Error("Invalid data type");let e=Wn.size(this.dims);return 0===e?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,e)}reshape(t){if(Wn.size(t)!==Wn.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},Pc=class{constructor(e,t,n){this.module=e,this.backend=t,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=t.adapterInfo,this.deviceInfo=t.deviceInfo;let r=e.PTR_SIZE,s=n/e.PTR_SIZE,i=4===r?"i32":"i64";this.opKernelContext=Number(e.getValue(r*s++,i));let a=Number(e.getValue(r*s++,i));this.outputCount=Number(e.getValue(r*s++,i)),this.customDataOffset=Number(e.getValue(r*s++,"*")),this.customDataSize=Number(e.getValue(r*s++,i));let o=[];for(let t=0;t<a;t++){let t=Number(e.getValue(r*s++,i)),n=Number(e.getValue(r*s++,"*")),a=Number(e.getValue(r*s++,i)),l=[];for(let t=0;t<a;t++)l.push(Number(e.getValue(r*s++,i)));o.push(new Nc(e,t,n,l))}this.inputs=o}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(e,t){let n=t?.inputs?.map((e=>"number"==typeof e?this.inputs[e]:e))??this.inputs,r=t?.outputs??[];return this.backend.run(e,n,r,((e,t,n)=>new Nc(this.module,t,this.output(e,n),n)),((e,t)=>{let n=_n(e,t);if(!n)throw new Error(`Unsupported data type: ${e}`);let r=n>0?this.backend.gpuDataManager.create(n).id:0;return new Nc(this.module,e,r,t)}),this.outputCount)}output(e,t){let n=this.module.stackSave();try{let n=this.module.PTR_SIZE,r=4===n?"i32":"i64",s=this.module.stackAlloc((1+t.length)*n);this.module.setValue(s,t.length,r);for(let e=0;e<t.length;e++)this.module.setValue(s+n*(e+1),t[e],r);return this.module._JsepOutput(this.opKernelContext,e,s)}catch(n){throw new Error(`Failed to generate kernel\'s output[${e}] with dims [${t}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(n)}}},Rc=async(e,t,n,r)=>{let s=t.jsepInit;if(!s)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if("webgpu"===e){let e=new sd;await e.initialize(n,r),s("webgpu",[e,t=>e.alloc(Number(t)),t=>e.free(t),(n,r,s,i=!1)=>{if(i)Tn("verbose",(()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(n)}, dst=${Number(r)}, size=${Number(s)}`)),e.memcpy(Number(n),Number(r));else{Tn("verbose",(()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(n)}, gpuDataId=${Number(r)}, size=${Number(s)}`));let i=t.HEAPU8.subarray(Number(n>>>0),Number(n>>>0)+Number(s));e.upload(Number(r),i)}},async(n,r,s)=>{Tn("verbose",(()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${n}, dataOffset=${r}, size=${s}`)),await e.download(Number(n),(()=>t.HEAPU8.subarray(Number(r)>>>0,Number(r+s)>>>0)))},(n,r,s)=>e.createKernel(n,Number(r),s,t.UTF8ToString(t._JsepGetNodeName(Number(r)))),t=>e.releaseKernel(t),(n,r,s,i)=>{Tn("verbose",(()=>`[WebGPU] jsepRun: sessionHandle=${s}, kernel=${n}, contextDataOffset=${r}`));let a=new Pc(t,e,Number(r));return e.computeKernel(Number(n),a,i)},()=>e.captureBegin(),()=>e.captureEnd(),()=>e.replay()])}else{let e=new md(n);s("webnn",[e,()=>e.reserveTensorId(),t=>e.releaseTensorId(t),async(t,n,r,s)=>e.ensureTensor(t,n,r,s),(t,n)=>{e.uploadTensor(t,n)},async(t,n)=>e.downloadTensor(t,n)])}}})),wp=ut((()=>{bd(),xd(),vd(),wd(),yd(),$d(),Dc=(e,t)=>{0!==rn()._OrtInit(e,t)&&on("Can\'t initialize onnxruntime.")},Fc=async e=>{Dc(e.wasm.numThreads,wn(e.logLevel))},Lc=async(e,t)=>{{let n=(gp(),ct(Bc)).init;if("webgpu"===t){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let t=e.webgpu.adapter;if(t){if("object"!=typeof t.limits||"object"!=typeof t.features||"function"!=typeof t.requestDevice)throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let n=e.webgpu.powerPreference;if(void 0!==n&&"low-power"!==n&&"high-performance"!==n)throw new Error(`Invalid powerPreference setting: "${n}"`);let r=e.webgpu.forceFallbackAdapter;if(void 0!==r&&"boolean"!=typeof r)throw new Error(`Invalid forceFallbackAdapter setting: "${r}"`);if(t=await navigator.gpu.requestAdapter({powerPreference:n,forceFallbackAdapter:r}),!t)throw new Error(\'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.\')}await n("webgpu",rn(),e,t)}if("webnn"===t){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await n("webnn",rn(),e)}}},Uc=new Map,qc=e=>{let t=rn(),n=t.stackSave();try{let n=t.PTR_SIZE,r=t.stackAlloc(2*n);0!==t._OrtGetInputOutputCount(e,r,r+n)&&on("Can\'t get session input/output count.");let s=4===n?"i32":"i64";return[Number(t.getValue(r,s)),Number(t.getValue(r+n,s))]}finally{t.stackRestore(n)}},Vc=e=>{let t=rn(),n=t._malloc(e.byteLength);if(0===n)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},Wc=async(e,t)=>{let n,r,s=rn();Array.isArray(e)?[n,r]=e:e.buffer===s.HEAPU8.buffer?[n,r]=[e.byteOffset,e.byteLength]:[n,r]=Vc(e);let i=0,a=0,o=0,l=[],u=[],d=[];try{if([a,l]=hn(t),t?.externalData&&s.mountExternalData){let e=[];for(let n of t.externalData){let t="string"==typeof n?n:n.path;e.push(vn("string"==typeof n?n:n.data).then((e=>{s.mountExternalData(t,e)})))}await Promise.all(e)}for(let e of t?.executionProviders??[])if("webnn"===("string"==typeof e?e:e.name)){if(s.shouldTransferToMLTensor=!1,"string"!=typeof e){let t=e,n=t?.context,r=t?.gpuDevice,i=t?.deviceType,a=t?.powerPreference;s.currentContext=n||(r?await s.jsepCreateMLContext(r):await s.jsepCreateMLContext({deviceType:i,powerPreference:a}))}else s.currentContext=await s.jsepCreateMLContext();break}i=await s._OrtCreateSession(n,r,a),0===i&&on("Can\'t create a session."),s.jsepOnCreateSession?.(),s.currentContext&&(s.jsepRegisterMLContext(i,s.currentContext),s.currentContext=void 0,s.shouldTransferToMLTensor=!0);let[e,c]=qc(i),p=!!t?.enableGraphCapture,h=[],f=[],m=[];for(let t=0;t<e;t++){let e=s._OrtGetInputName(i,t);0===e&&on("Can\'t get an input name."),u.push(e),h.push(s.UTF8ToString(e))}for(let e=0;e<c;e++){let n=s._OrtGetOutputName(i,e);0===n&&on("Can\'t get an output name."),d.push(n);let r=s.UTF8ToString(n);f.push(r);{if(p&&void 0===t?.preferredOutputLocation){m.push("gpu-buffer");continue}let e="string"==typeof t?.preferredOutputLocation?t.preferredOutputLocation:t?.preferredOutputLocation?.[r]??"cpu";if("cpu"!==e&&"cpu-pinned"!==e&&"gpu-buffer"!==e&&"ml-tensor"!==e)throw new Error(`Not supported preferred output location: ${e}.`);if(p&&"gpu-buffer"!==e)throw new Error(`Not supported preferred output location: ${e}. Only \'gpu-buffer\' location is supported when enableGraphCapture is true.`);m.push(e)}}let _=null;return m.some((e=>"gpu-buffer"===e||"ml-tensor"===e))&&(o=s._OrtCreateBinding(i),0===o&&on("Can\'t create IO binding."),_={handle:o,outputPreferredLocations:m,outputPreferredLocationsEncoded:m.map((e=>xn(e)))}),Uc.set(i,[i,u,d,_,p,!1]),[i,h,f]}catch(e){throw u.forEach((e=>s._OrtFree(e))),d.forEach((e=>s._OrtFree(e))),0!==o&&0!==s._OrtReleaseBinding(o)&&on("Can\'t release IO binding."),0!==i&&0!==s._OrtReleaseSession(i)&&on("Can\'t release session."),e}finally{s._free(n),0!==a&&0!==s._OrtReleaseSessionOptions(a)&&on("Can\'t release session options."),l.forEach((e=>s._free(e))),s.unmountExternalData?.()}},jc=e=>{let t=rn(),n=Uc.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[r,s,i,a,o]=n;a&&(o&&0!==t._OrtClearBoundOutputs(a.handle)&&on("Can\'t clear bound outputs."),0!==t._OrtReleaseBinding(a.handle)&&on("Can\'t release IO binding.")),t.jsepOnReleaseSession?.(e),s.forEach((e=>t._OrtFree(e))),i.forEach((e=>t._OrtFree(e))),0!==t._OrtReleaseSession(r)&&on("Can\'t release session."),Uc.delete(e)},Gc=(e,t,n,r,s,i=!1)=>{if(!e)return void t.push(0);let a,o,l=rn(),u=l.PTR_SIZE,d=e[0],c=e[1],p=e[3];if("string"===d&&("gpu-buffer"===p||"ml-tensor"===p))throw new Error("String tensor is not supported on GPU.");if(i&&"gpu-buffer"!==p)throw new Error(`External buffer must be provided for input/output index ${s} when enableGraphCapture is true.`);if("gpu-buffer"===p){let t=e[2].gpuBuffer;o=_n(fn(d),c);let n=l.jsepRegisterBuffer;if(!n)throw new Error(\'Tensor location "gpu-buffer" is not supported without using WebGPU.\');a=n(r,s,t,o)}else if("ml-tensor"===p){let t=e[2].mlTensor;o=_n(fn(d),c);let n=l.jsepRegisterMLTensor;if(!n)throw new Error(\'Tensor location "ml-tensor" is not supported without using WebNN.\');a=n(t,fn(d),c)}else{let t=e[2];if(Array.isArray(t)){o=u*t.length,a=l._malloc(o),n.push(a);for(let e=0;e<t.length;e++){if("string"!=typeof t[e])throw new TypeError(`tensor data at index ${e} is not a string`);l.setValue(a+e*u,sn(t[e],n),"*")}}else o=t.byteLength,a=l._malloc(o),n.push(a),l.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),a)}let h=l.stackSave(),f=l.stackAlloc(4*c.length);try{c.forEach(((e,t)=>l.setValue(f+t*u,e,4===u?"i32":"i64")));let e=l._OrtCreateTensor(fn(d),a,o,f,c.length,xn(p));0===e&&on(`Can\'t create tensor for input/output. session=${r}, index=${s}.`),t.push(e)}finally{l.stackRestore(h)}},Hc=async(e,t,n,r,s,i)=>{let a=rn(),o=a.PTR_SIZE,l=Uc.get(e);if(!l)throw new Error(`cannot run inference. invalid session id: ${e}`);let u=l[0],d=l[1],c=l[2],p=l[3],h=l[4],f=l[5],m=t.length,_=r.length,g=0,w=[],y=[],b=[],x=[],v=a.stackSave(),$=a.stackAlloc(m*o),k=a.stackAlloc(m*o),E=a.stackAlloc(_*o),S=a.stackAlloc(_*o);try{a.jsepOnRunStart?.(u),[g,w]=ln(i);for(let r=0;r<m;r++)Gc(n[r],y,x,e,t[r],h);for(let t=0;t<_;t++)Gc(s[t],b,x,e,m+r[t],h);for(let e=0;e<m;e++)a.setValue($+e*o,y[e],"*"),a.setValue(k+e*o,d[t[e]],"*");for(let e=0;e<_;e++)a.setValue(E+e*o,b[e],"*"),a.setValue(S+e*o,c[r[e]],"*");if(p&&!f){let{handle:n,outputPreferredLocations:i,outputPreferredLocationsEncoded:o}=p;if(d.length!==m)throw new Error(`input count from feeds (${m}) is expected to be always equal to model\'s input count (${d.length}).`);for(let r=0;r<m;r++){let s=t[r];0!==await a._OrtBindInput(n,d[s],y[r])&&on(`Can\'t bind input[${r}] for session=${e}.`)}for(let t=0;t<_;t++){let l=r[t];s[t]?.[3]?0!==a._OrtBindOutput(n,c[l],b[t],0)&&on(`Can\'t bind pre-allocated output[${t}] for session=${e}.`):0!==a._OrtBindOutput(n,c[l],0,o[l])&&on(`Can\'t bind output[${t}] to ${i[t]} for session=${e}.`)}Uc.set(e,[u,d,c,p,h,!0])}let l;l=p?await a._OrtRunWithBinding(u,p.handle,_,E,g):await a._OrtRun(u,k,$,m,S,_,E,g),0!==l&&on("failed to call OrtRun().");let v=[];for(let e=0;e<_;e++){let t=Number(a.getValue(E+e*o,"*"));if(t===b[e]){v.push(s[e]);continue}let n,i=a.stackSave(),l=a.stackAlloc(4*o),u=!1,d=0;try{0!==a._OrtGetTensorData(t,l,l+o,l+2*o,l+3*o)&&on(`Can\'t access output tensor data on index ${e}.`);let s=4===o?"i32":"i64",i=Number(a.getValue(l,s));d=a.getValue(l+o,"*");let c=a.getValue(l+2*o,"*"),h=Number(a.getValue(l+3*o,s)),f=[];for(let e=0;e<h;e++)f.push(Number(a.getValue(c+e*o,s)));0!==a._OrtFree(c)&&on("Can\'t free memory for tensor dims.");let m=f.reduce(((e,t)=>e*t),1);n=mn(i);let _=p?.outputPreferredLocations[r[e]];if("string"===n){if("gpu-buffer"===_||"ml-tensor"===_)throw new Error("String tensor is not supported on GPU.");let e=[];for(let t=0;t<m;t++){let n=a.getValue(d+t*o,"*"),r=a.getValue(d+(t+1)*o,"*"),s=t===m-1?void 0:r-n;e.push(a.UTF8ToString(n,s))}v.push([n,f,e,"cpu"])}else if("gpu-buffer"===_&&m>0){let e=a.jsepGetBuffer;if(!e)throw new Error(\'preferredLocation "gpu-buffer" is not supported without using WebGPU.\');let r=e(d),s=_n(i,m);if(void 0===s||!yn(n))throw new Error(`Unsupported data type: ${n}`);u=!0,v.push([n,f,{gpuBuffer:r,download:a.jsepCreateDownloader(r,s,n),dispose:()=>{0!==a._OrtReleaseTensor(t)&&on("Can\'t release tensor.")}},"gpu-buffer"])}else if("ml-tensor"===_&&m>0){let e=a.jsepEnsureTensor;if(!e)throw new Error(\'preferredLocation "ml-tensor" is not supported without using WebNN.\');if(void 0===_n(i,m)||!bn(n))throw new Error(`Unsupported data type: ${n}`);let r=await e(d,i,f,!1);u=!0,v.push([n,f,{mlTensor:r,download:a.jsepCreateMLTensorDownloader(d,n),dispose:()=>{a.jsepReleaseTensorId(d),a._OrtReleaseTensor(t)}},"ml-tensor"])}else{let e=new(gn(n))(m);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(a.HEAPU8.subarray(d,d+e.byteLength)),v.push([n,f,e,"cpu"])}}finally{a.stackRestore(i),"string"===n&&d&&a._free(d),u||a._OrtReleaseTensor(t)}}return p&&!h&&(0!==a._OrtClearBoundOutputs(p.handle)&&on("Can\'t clear bound outputs."),Uc.set(e,[u,d,c,p,h,!1])),v}finally{a.stackRestore(v),y.forEach((e=>a._OrtReleaseTensor(e))),b.forEach((e=>a._OrtReleaseTensor(e))),x.forEach((e=>a._free(e))),0!==g&&a._OrtReleaseRunOptions(g),w.forEach((e=>a._free(e)))}},Kc=e=>{let t=rn(),n=Uc.get(e);if(!n)throw new Error("invalid session id");let r=n[0],s=t._OrtEndProfiling(r);0===s&&on("Can\'t get an profile file name."),t._OrtFree(s)},Xc=e=>{let t=[];for(let n of e){let e=n[2];!Array.isArray(e)&&"buffer"in e&&t.push(e.buffer)}return t}})),yp=ut((()=>{At(),wp(),wd(),gd(),Qc=()=>!!Oe.wasm.proxy&&typeof document<"u",Zc=!1,Jc=!1,ep=!1,rp=new Map,sp=(e,t)=>{let n=rp.get(e);n?n.push(t):rp.set(e,[t])},ip=()=>{if(Zc||!Jc||ep||!Yc)throw new Error("worker not ready")},ap=e=>{switch(e.data.type){case"init-wasm":Zc=!1,e.data.err?(ep=!0,np[1](e.data.err)):(Jc=!0,np[0]()),tp&&(URL.revokeObjectURL(tp),tp=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let t=rp.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}}},op=async()=>{if(!Jc){if(Zc)throw new Error("multiple calls to \'initWasm()\' detected.");if(ep)throw new Error("previous call to \'initWasm()\' failed.");if(Zc=!0,Qc())return new Promise(((e,t)=>{Yc?.terminate(),Ht().then((([n,r])=>{try{(Yc=r).onerror=e=>t(e),Yc.onmessage=ap,np=[e,t];let s={type:"init-wasm",in:Oe};Yc.postMessage(s),tp=n}catch(e){t(e)}}),t)}));try{await nn(Oe.wasm),await Fc(Oe),Jc=!0}catch(e){throw ep=!0,e}finally{Zc=!1}}},lp=async e=>{if(Qc())return ip(),new Promise(((t,n)=>{sp("init-ep",[t,n]);let r={type:"init-ep",in:{epName:e,env:Oe}};Yc.postMessage(r)}));await Lc(Oe,e)},up=async e=>Qc()?(ip(),new Promise(((t,n)=>{sp("copy-from",[t,n]);let r={type:"copy-from",in:{buffer:e}};Yc.postMessage(r,[e.buffer])}))):Vc(e),dp=async(e,t)=>{if(Qc()){if(t?.preferredOutputLocation)throw new Error(\'session option "preferredOutputLocation" is not supported for proxy.\');return ip(),new Promise(((n,r)=>{sp("create",[n,r]);let s={type:"create",in:{model:e,options:{...t}}},i=[];e instanceof Uint8Array&&i.push(e.buffer),Yc.postMessage(s,i)}))}return Wc(e,t)},cp=async e=>{if(Qc())return ip(),new Promise(((t,n)=>{sp("release",[t,n]);let r={type:"release",in:e};Yc.postMessage(r)}));jc(e)},pp=async(e,t,n,r,s,i)=>{if(Qc()){if(n.some((e=>"cpu"!==e[3])))throw new Error("input tensor on GPU is not supported for proxy.");if(s.some((e=>e)))throw new Error("pre-allocated output tensor is not supported for proxy.");return ip(),new Promise(((s,a)=>{sp("run",[s,a]);let o=n,l={type:"run",in:{sessionId:e,inputIndices:t,inputs:o,outputIndices:r,options:i}};Yc.postMessage(l,Xc(o))}))}return Hc(e,t,n,r,s,i)},hp=async e=>{if(Qc())return ip(),new Promise(((t,n)=>{sp("end-profiling",[t,n]);let r={type:"end-profiling",in:e};Yc.postMessage(r)}));Kc(e)}})),bp=ut((()=>{At(),yp(),vd(),Mt(),$d(),fp=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},mp=e=>{switch(e[3]){case"cpu":return new Xe(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!yn(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:r,dispose:s}=e[2];return Xe.fromGpuBuffer(n,{dataType:t,dims:e[1],download:r,dispose:s})}case"ml-tensor":{let t=e[0];if(!bn(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:n,download:r,dispose:s}=e[2];return Xe.fromMLTensor(n,{dataType:t,dims:e[1],download:r,dispose:s})}default:throw new Error(`invalid data location: ${e[3]}`)}},_p=class{async fetchModelAndCopyToWasmMemory(e){return up(await vn(e))}async loadModel(e,t){let n;Ze(),n="string"==typeof e?await this.fetchModelAndCopyToWasmMemory(e):e,[this.sessionId,this.inputNames,this.outputNames]=await dp(n,t),Je()}async dispose(){return cp(this.sessionId)}async run(e,t,n){Ze();let r=[],s=[];Object.entries(e).forEach((e=>{let t=e[0],n=e[1],i=this.inputNames.indexOf(t);if(-1===i)throw new Error(`invalid input \'${t}\'`);r.push(n),s.push(i)}));let i=[],a=[];Object.entries(t).forEach((e=>{let t=e[0],n=e[1],r=this.outputNames.indexOf(t);if(-1===r)throw new Error(`invalid output \'${t}\'`);i.push(n),a.push(r)}));let o=r.map(((e,t)=>fp(e,(()=>`input "${this.inputNames[s[t]]}"`)))),l=i.map(((e,t)=>e?fp(e,(()=>`output "${this.outputNames[a[t]]}"`)):null)),u=await pp(this.sessionId,s,o,a,l,n),d={};for(let e=0;e<u.length;e++)d[this.outputNames[a[e]]]=i[e]??mp(u[e]);return Je(),d}startProfiling(){}endProfiling(){hp(this.sessionId)}}})),xp={};dt(xp,{OnnxruntimeWebAssemblyBackend:()=>$p,initializeFlags:()=>vp,wasmBackend:()=>kp});var vp,$p,kp,Ep=ut((()=>{At(),yp(),bp(),gd(),vp=()=>{if(("number"!=typeof Oe.wasm.initTimeout||Oe.wasm.initTimeout<0)&&(Oe.wasm.initTimeout=0),!1===Oe.wasm.simd&&console.warn(\'Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.\'),"boolean"!=typeof Oe.wasm.proxy&&(Oe.wasm.proxy=!1),"boolean"!=typeof Oe.wasm.trace&&(Oe.wasm.trace=!1),"number"!=typeof Oe.wasm.numThreads||!Number.isInteger(Oe.wasm.numThreads)||Oe.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)Oe.wasm.numThreads=1;else{let e=typeof navigator>"u"?lt("node:os").cpus().length:navigator.hardwareConcurrency;Oe.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},$p=class{async init(e){vp(),await op(),await lp(e)}async createInferenceSessionHandler(e,t){let n=new _p;return await n.loadModel(e,t),Promise.resolve(n)}},kp=new $p}));At(),At(),At();var Sp=It;{let e=(Ep(),ct(xp)).wasmBackend;ze("webgpu",e,5),ze("webnn",e,5),ze("cpu",e,10),ze("wasm",e,10)}Object.defineProperty(Oe.versions,"web",{value:"1.21.0-dev.20241205-d27fecd3d3",enumerable:!0});new Map;let zp="warning";const Cp={wasm:{},webgl:{},webgpu:{},versions:{common:"1.20.1"},set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);zp=e}},get logLevel(){return zp}};Object.defineProperty(Cp,"logLevel",{enumerable:!0});const Tp=(e,t)=>{if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");const{height:n,width:r}=t,s=t.norm??{mean:255,bias:0};let i,a;i="number"==typeof s.mean?[s.mean,s.mean,s.mean,s.mean]:[s.mean[0],s.mean[1],s.mean[2],s.mean[3]??255],a="number"==typeof s.bias?[s.bias,s.bias,s.bias,s.bias]:[s.bias[0],s.bias[1],s.bias[2],s.bias[3]??0];const o=void 0!==t.format?t.format:"RGBA",l=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",u=n*r,d="RGBA"===l?new Float32Array(4*u):new Float32Array(3*u);let c=4,p=0,h=1,f=2,m=3,_=0,g=u,w=2*u,y=-1;"RGB"===o&&(c=3,p=0,h=1,f=2,m=-1),"RGBA"===l?y=3*u:"RBG"===l?(_=0,w=u,g=2*u):"BGR"===l&&(w=0,g=u,_=2*u);for(let t=0;t<u;t++,p+=c,f+=c,h+=c,m+=c)d[_++]=(e[p]+a[0])/i[0],d[g++]=(e[h]+a[1])/i[1],d[w++]=(e[f]+a[2])/i[2],-1!==y&&-1!==m&&(d[y++]=(e[m]+a[3])/i[3]);return new Op("float32",d,"RGBA"===l?[1,4,n,r]:[1,3,n,r])},Ip=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Ap=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let Mp=!1;class Op{constructor(e,t,n){let r,s;if((()=>{if(!Mp){Mp=!0;const e="undefined"!=typeof BigInt64Array&&BigInt64Array.from,t="undefined"!=typeof BigUint64Array&&BigUint64Array.from,n="undefined"!=typeof Float16Array&&Float16Array.from;e&&(Ip.set("int64",BigInt64Array),Ap.set(BigInt64Array,"int64")),t&&(Ip.set("uint64",BigUint64Array),Ap.set(BigUint64Array,"uint64")),n?(Ip.set("float16",Float16Array),Ap.set(Float16Array,"float16")):Ip.set("float16",Uint16Array)}})(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,r=e.type,s=e.dims,e.location){case"cpu-pinned":{const t=Ip.get(r);if(!t)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw new TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"uint8"!==r&&"bool"!==r&&"uint4"!==r&&"int4"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;case"ml-tensor":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"uint64"!==r&&"int8"!==r&&"uint8"!==r&&"bool"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break;default:throw new Error(`Tensor constructor: unsupported location \'${this.dataLocation}\'`)}else{let i,a;if("string"==typeof e)if(r=e,a=n,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor\'s data must be a string array.");i=t}else{const n=Ip.get(e);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e&&n===Uint16Array||"uint4"===e||"int4"===e)throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${n.name} as data.`);i="uint64"===e||"int64"===e?n.from(t,BigInt):n.from(t)}else if(t instanceof n)i=t;else{if(!(t instanceof Uint8ClampedArray))throw new TypeError(`A ${r} tensor\'s data must be type of ${n}`);if("uint8"!==e)throw new TypeError("A Uint8ClampedArray tensor\'s data must be type of uint8");i=Uint8Array.from(t)}}else if(a=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");const t=typeof e[0];if("string"===t)r="string",i=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);r="bool",i=Uint8Array.from(e)}}else if(e instanceof Uint8ClampedArray)r="uint8",i=Uint8Array.from(e);else{const t=Ap.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=t,i=e}if(void 0===a)a=[i.length];else if(!Array.isArray(a))throw new TypeError("A tensor\'s dims must be a number array");s=a,this.cpuData=i,this.dataLocation="cpu"}const i=(e=>{let t=1;for(let n=0;n<e.length;n++){const r=e[n];if("number"!=typeof r||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t})(s);if(this.cpuData&&i!==this.cpuData.length&&("uint4"!==r&&"int4"!==r||Math.ceil(i/2)!==this.cpuData.length))throw new Error(`Tensor\'s size(${i}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=s,this.size=i}static async fromImage(e,t){return(async(e,t)=>{const n="undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement,r="undefined"!=typeof ImageData&&e instanceof ImageData,s="undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap,i="string"==typeof e;let a,o=t??{};const l=()=>{if("undefined"!=typeof document)return document.createElement("canvas");if("undefined"!=typeof OffscreenCanvas)return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},u=e=>"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas?e.getContext("2d"):null;if(n){const n=l();n.width=e.width,n.height=e.height;const r=u(n);if(null==r)throw new Error("Can not access image data");{let n=e.height,s=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(n=t.resizedHeight,s=t.resizedWidth),void 0!==t){if(o=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");o.tensorFormat="RGBA",o.height=n,o.width=s}else o.tensorFormat="RGBA",o.height=n,o.width=s;r.drawImage(e,0,0),a=r.getImageData(0,0,s,n).data}}else{if(!r){if(s){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");const n=l();n.width=e.width,n.height=e.height;const r=u(n);if(null!=r){const t=e.height,n=e.width;return r.drawImage(e,0,0,n,t),a=r.getImageData(0,0,n,t).data,o.height=t,o.width=n,Tp(a,o)}throw new Error("Can not access image data")}if(i)return new Promise(((t,n)=>{const r=l(),s=u(r);if(!e||!s)return n();const i=new Image;i.crossOrigin="Anonymous",i.src=e,i.onload=()=>{r.width=i.width,r.height=i.height,s.drawImage(i,0,0,r.width,r.height);const e=s.getImageData(0,0,r.width,r.height);o.height=r.height,o.width=r.width,t(Tp(e.data,o))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{let n,r;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(n=t.resizedHeight,r=t.resizedWidth):(n=e.height,r=e.width),void 0!==t&&(o=t),o.format="RGBA",o.height=n,o.width=r,void 0!==t){const t=l();t.width=r,t.height=n;const s=u(t);if(null==s)throw new Error("Can not access image data");s.putImageData(e,0,0),a=s.getImageData(0,0,r,n).data}else a=e.data}}if(void 0!==a)return Tp(a,o);throw new Error("Input data provided is not supported - aborted tensor creation")})(e,t)}static fromTexture(e,t){return((e,t)=>{const{width:n,height:r,download:s,dispose:i}=t;return new Op({location:"texture",type:"float32",texture:e,dims:[1,r,n,4],download:s,dispose:i})})(e,t)}static fromGpuBuffer(e,t){return((e,t)=>{const{dataType:n,dims:r,download:s,dispose:i}=t;return new Op({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:r,download:s,dispose:i})})(e,t)}static fromMLTensor(e,t){return((e,t)=>{const{dataType:n,dims:r,download:s,dispose:i}=t;return new Op({location:"ml-tensor",type:n??"float32",mlTensor:e,dims:r,download:s,dispose:i})})(e,t)}static fromPinnedBuffer(e,t,n){return((e,t,n)=>new Op({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]}))(e,t,n)}toDataURL(e){return((e,t)=>{const n="undefined"!=typeof document?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];const r=n.getContext("2d");if(null!=r){let s,i;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(s=e.dims[2],i=e.dims[3]):(s=e.dims[3],i=e.dims[2]);const a=void 0!==t?.format?t.format:"RGB",o=t?.norm;let l,u;void 0===o||void 0===o.mean?l=[255,255,255,255]:"number"==typeof o.mean?l=[o.mean,o.mean,o.mean,o.mean]:(l=[o.mean[0],o.mean[1],o.mean[2],0],void 0!==o.mean[3]&&(l[3]=o.mean[3])),void 0===o||void 0===o.bias?u=[0,0,0,0]:"number"==typeof o.bias?u=[o.bias,o.bias,o.bias,o.bias]:(u=[o.bias[0],o.bias[1],o.bias[2],0],void 0!==o.bias[3]&&(u[3]=o.bias[3]));const d=i*s;let c=0,p=d,h=2*d,f=-1;"RGBA"===a?(c=0,p=d,h=2*d,f=3*d):"RGB"===a?(c=0,p=d,h=2*d):"RBG"===a&&(c=0,h=d,p=2*d);for(let t=0;t<i;t++)for(let n=0;n<s;n++){const s=(e.data[c++]-u[0])*l[0],i=(e.data[p++]-u[1])*l[1],a=(e.data[h++]-u[2])*l[2],o=-1===f?255:(e.data[f++]-u[3])*l[3];r.fillStyle="rgba("+s+","+i+","+a+","+o+")",r.fillRect(n,t,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}throw new Error("Can not access image data")})(this,e)}toImageData(e){return((e,t)=>{const n="undefined"!=typeof document?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let r;if(null==n)throw new Error("Can not access image data");{let s,i,a;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(s=e.dims[2],i=e.dims[1],a=e.dims[3]):(s=e.dims[3],i=e.dims[2],a=e.dims[1]);const o=void 0!==t&&void 0!==t.format?t.format:"RGB",l=t?.norm;let u,d;void 0===l||void 0===l.mean?u=[255,255,255,255]:"number"==typeof l.mean?u=[l.mean,l.mean,l.mean,l.mean]:(u=[l.mean[0],l.mean[1],l.mean[2],255],void 0!==l.mean[3]&&(u[3]=l.mean[3])),void 0===l||void 0===l.bias?d=[0,0,0,0]:"number"==typeof l.bias?d=[l.bias,l.bias,l.bias,l.bias]:(d=[l.bias[0],l.bias[1],l.bias[2],0],void 0!==l.bias[3]&&(d[3]=l.bias[3]));const c=i*s;if(void 0!==t&&(void 0!==t.format&&4===a&&"RGBA"!==t.format||3===a&&"RGB"!==t.format&&"BGR"!==t.format))throw new Error("Tensor format doesn\'t match input tensor dims");const p=4;let h=0,f=1,m=2,_=3,g=0,w=c,y=2*c,b=-1;"RGBA"===o?(g=0,w=c,y=2*c,b=3*c):"RGB"===o?(g=0,w=c,y=2*c):"RBG"===o&&(g=0,y=c,w=2*c),r=n.createImageData(s,i);for(let t=0;t<i*s;h+=p,f+=p,m+=p,_+=p,t++)r.data[h]=(e.data[g++]-d[0])*u[0],r.data[f]=(e.data[w++]-d[1])*u[1],r.data[m]=(e.data[y++]-d[2])*u[2],r.data[_]=-1===b?255:(e.data[b++]-d[3])*u[3]}return r})(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return((e,t)=>{switch(e.location){case"cpu":return new Op(e.type,e.data,t);case"cpu-pinned":return new Op({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new Op({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new Op({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new Op({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}})(this,e)}}const Bp=Op;const Np=Object.freeze({auto:null,gpu:null,cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:{name:"webnn",deviceType:"cpu"},"webnn-npu":{name:"webnn",deviceType:"npu"},"webnn-gpu":{name:"webnn",deviceType:"gpu"},"webnn-cpu":{name:"webnn",deviceType:"cpu"}}),Pp=[];let Rp,Dp;const Fp=Symbol.for("onnxruntime");if(Fp in globalThis)Dp=globalThis[Fp];else if(D.IS_NODE_ENV){switch(Dp=nt??rt,process.platform){case"win32":Pp.push("dml");break;case"linux":"x64"===process.arch&&Pp.push("cuda")}Pp.push("cpu"),Rp=["cpu"]}else Dp=e,D.IS_WEBNN_AVAILABLE&&Pp.push("webnn-npu","webnn-gpu","webnn-cpu","webnn"),D.IS_WEBGPU_AVAILABLE&&Pp.push("webgpu"),Pp.push("wasm"),Rp=["wasm"];const Lp=Dp.InferenceSession;let Up=null;async function qp(e,t,n){Up&&await Up;const r=Lp.create(e,t);Up??=r;const s=await r;return s.config=n,s}function Vp(e){return e instanceof Dp.Tensor}const Wp=Dp?.env;function jp(){return Wp?.wasm?.proxy}Wp?.wasm&&(Wp.wasm.wasmPaths=`https://cdn.jsdelivr.net/npm/@huggingface/transformers@${V.version}/dist/`,Wp.wasm.proxy=!1,"undefined"!=typeof crossOriginIsolated&&crossOriginIsolated||(Wp.wasm.numThreads=1)),Wp?.webgpu&&(Wp.webgpu.powerPreference="high-performance"),V.backends.onnx=Wp;const Gp=async(e,t,n)=>{const r=await qp(new Uint8Array(e),t);return async e=>{const t=Object.fromEntries(Object.entries(e).map((([e,t])=>[e,t.ort_tensor]))),s=await r.run(t);return Array.isArray(n)?n.map((e=>new Xp(s[e]))):new Xp(s[n])}};class Hp{static session_options={};static get bilinear_interpolate_4d(){return this._bilinear_interpolate_4d||(this._bilinear_interpolate_4d=Gp([8,9,18,0,58,128,1,10,40,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,17,10,4,109,111,100,101,34,6,108,105,110,101,97,114,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bilinear_interpolate_4d}static get bicubic_interpolate_4d(){return this._bicubic_interpolate_4d||(this._bicubic_interpolate_4d=Gp([8,9,18,0,58,127,10,39,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,16,10,4,109,111,100,101,34,5,99,117,98,105,99,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bicubic_interpolate_4d}static get matmul(){return this._matmul||(this._matmul=Gp([8,9,18,0,58,55,10,17,10,1,97,10,1,98,18,1,99,34,6,77,97,116,77,117,108,18,1,114,90,9,10,1,97,18,4,10,2,8,1,90,9,10,1,98,18,4,10,2,8,1,98,9,10,1,99,18,4,10,2,8,1,66,2,16,20],this.session_options,"c")),this._matmul}static get stft(){return this._stft||(this._stft=Gp([8,7,18,0,58,148,1,10,38,10,1,115,10,1,106,10,1,119,10,1,108,18,1,111,34,4,83,84,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,115,90,26,10,1,115,18,21,10,19,8,1,18,15,10,3,18,1,98,10,3,18,1,115,10,3,18,1,99,90,11,10,1,106,18,6,10,4,8,7,18,0,90,16,10,1,119,18,11,10,9,8,1,18,5,10,3,18,1,119,90,11,10,1,108,18,6,10,4,8,7,18,0,98,31,10,1,111,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,102,10,3,18,1,100,10,3,18,1,99,66,2,16,17],this.session_options,"o")),this._stft}static get rfft(){return this._rfft||(this._rfft=Gp([8,9,18,0,58,97,10,33,10,1,120,10,0,10,1,97,18,1,121,34,3,68,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,100,90,21,10,1,120,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,90,11,10,1,97,18,6,10,4,8,7,18,0,98,21,10,1,121,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,66,2,16,20],this.session_options,"y")),this._rfft}static get top_k(){return this._top_k||(this._top_k=Gp([8,10,18,0,58,73,10,18,10,1,120,10,1,107,18,1,118,18,1,105,34,4,84,111,112,75,18,1,116,90,9,10,1,120,18,4,10,2,8,1,90,15,10,1,107,18,10,10,8,8,7,18,4,10,2,8,1,98,9,10,1,118,18,4,10,2,8,1,98,9,10,1,105,18,4,10,2,8,7,66,2,16,21],this.session_options,["v","i"])),this._top_k}static get slice(){return this._slice||(this._slice=Gp([8,7,18,0,58,96,10,25,10,1,120,10,1,115,10,1,101,10,1,97,10,1,116,18,1,121,34,5,83,108,105,99,101,18,1,114,90,9,10,1,120,18,4,10,2,8,1,90,9,10,1,115,18,4,10,2,8,7,90,9,10,1,101,18,4,10,2,8,7,90,9,10,1,97,18,4,10,2,8,7,90,9,10,1,116,18,4,10,2,8,7,98,9,10,1,121,18,4,10,2,8,1,66,2,16,13],this.session_options,"y")),this._slice}}const Kp=Object.freeze({float32:Float32Array,float16:Uint16Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array,uint4:Uint8Array,int4:Int8Array});class Xp{get dims(){return this.ort_tensor.dims}set dims(e){this.ort_tensor.dims=e}get type(){return this.ort_tensor.type}get data(){return this.ort_tensor.data}get size(){return this.ort_tensor.size}get location(){return this.ort_tensor.location}ort_tensor;constructor(...e){return Vp(e[0])?this.ort_tensor=e[0]:this.ort_tensor=new Bp(e[0],e[1],e[2]),new Proxy(this,{get:(e,t)=>{if("string"==typeof t){let n=Number(t);if(Number.isInteger(n))return e._getitem(n)}return e[t]},set:(e,t,n)=>e[t]=n})}dispose(){this.ort_tensor.dispose()}*[Symbol.iterator](){const[e,...t]=this.dims;if(t.length>0){const n=t.reduce(((e,t)=>e*t));for(let r=0;r<e;++r)yield this._subarray(r,n,t)}else yield*this.data}_getitem(e){const[t,...n]=this.dims;if(e=rh(e,t),n.length>0){const t=n.reduce(((e,t)=>e*t));return this._subarray(e,t,n)}return new Xp(this.type,[this.data[e]],n)}indexOf(e){const t=this.data;for(let n=0;n<t.length;++n)if(t[n]==e)return n;return-1}_subarray(e,t,n){const r=e*t,s=(e+1)*t,i="subarray"in this.data?this.data.subarray(r,s):this.data.slice(r,s);return new Xp(this.type,i,n)}item(){const e=this.data;if(1!==e.length)throw new Error(`a Tensor with ${e.length} elements cannot be converted to Scalar`);return e[0]}tolist(){return function e(t,n){const r=t.length,s=n.reduce(((e,t)=>e*t));if(r!==s)throw Error(`cannot reshape array of size ${r} into shape (${n})`);let i=t;for(let e=n.length-1;e>=0;e--)i=i.reduce(((t,r)=>{let s=t[t.length-1];return s.length<n[e]?s.push(r):t.push([r]),t}),[[]]);return i[0]}(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){const e=this.data;for(let t=0;t<e.length;++t)e[t]=1/(1+Math.exp(-e[t]));return this}map(e){return this.clone().map_(e)}map_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]=e(t[n],n,t);return this}mul(e){return this.clone().mul_(e)}mul_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]*=e;return this}div(e){return this.clone().div_(e)}div_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]/=e;return this}add(e){return this.clone().add_(e)}add_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]+=e;return this}sub(e){return this.clone().sub_(e)}sub_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]-=e;return this}clone(){return new Xp(this.type,this.data.slice(),this.dims.slice())}slice(...e){const t=[],n=[];for(let r=0;r<this.dims.length;++r){let s=e[r];if(null==s)n.push([0,this.dims[r]]),t.push(this.dims[r]);else if("number"==typeof s)s=rh(s,this.dims[r],r),n.push([s,s+1]);else{if(!Array.isArray(s)||2!==s.length)throw new Error(`Invalid slice: ${s}`);{let[e,i]=s;if(e=null===e?0:rh(e,this.dims[r],r,!1),i=null===i?this.dims[r]:rh(i,this.dims[r],r,!1),e>i)throw new Error(`Invalid slice: ${s}`);const a=[Math.max(e,0),Math.min(i,this.dims[r])];n.push(a),t.push(a[1]-a[0])}}}const r=n.map((([e,t])=>t-e)),s=r.reduce(((e,t)=>e*t)),i=this.data,a=new i.constructor(s),o=this.stride();for(let e=0;e<s;++e){let t=0;for(let s=r.length-1,i=e;s>=0;--s){const e=r[s];t+=(i%e+n[s][0])*o[s],i=Math.floor(i/e)}a[e]=i[t]}return new Xp(this.type,a,t)}permute(...e){return function t(e,n){const[r,s]=function i(e,t,n){const r=new Array(n.length),s=new Array(n.length);for(let e=n.length-1,i=1;e>=0;--e)s[e]=i,r[e]=t[n[e]],i*=r[e];const i=n.map(((e,t)=>s[n.indexOf(t)])),a=new e.constructor(e.length);for(let n=0;n<e.length;++n){let r=0;for(let e=t.length-1,s=n;e>=0;--e)r+=s%t[e]*i[e],s=Math.floor(s/t[e]);a[r]=e[n]}return[a,r]}(e.data,e.dims,n);return new Xp(e.type,r,s)}(this,e)}transpose(...e){return this.permute(...e)}sum(e=null,t=!1){return this.norm(1,e,t)}norm(e="fro",t=null,n=!1){if("fro"===e)e=2;else if("string"==typeof e)throw Error(`Unsupported norm: ${e}`);const r=this.data;if(null===t){let t=r.reduce(((t,n)=>t+n**e),0)**(1/e);return new Xp(this.type,[t],[])}t=rh(t,this.dims.length);const s=this.dims.slice();s[t]=1;const i=new r.constructor(r.length/this.dims[t]);for(let n=0;n<r.length;++n){let a=0;for(let e=this.dims.length-1,r=n,i=1;e>=0;--e){const n=this.dims[e];if(e!==t){a+=r%n*i,i*=s[e]}r=Math.floor(r/n)}i[a]+=r[n]**e}if(1!==e)for(let t=0;t<i.length;++t)i[t]=i[t]**(1/e);return n||s.splice(t,1),new Xp(this.type,i,s)}normalize_(e=2,t=1){t=rh(t,this.dims.length);const n=this.norm(e,t,!0),r=this.data,s=n.data;for(let e=0;e<r.length;++e){let n=0;for(let r=this.dims.length-1,s=e,i=1;r>=0;--r){const e=this.dims[r];if(r!==t){n+=s%e*i,i*=this.dims[r]}s=Math.floor(s/e)}r[e]/=s[n]}return this}normalize(e=2,t=1){return this.clone().normalize_(e,t)}stride(){return function e(t){const n=new Array(t.length);for(let e=t.length-1,r=1;e>=0;--e)n[e]=r,r*=t[e];return n}(this.dims)}squeeze(e=null){return new Xp(this.type,this.data,th(this.dims,e))}squeeze_(e=null){return this.dims=th(this.dims,e),this}unsqueeze(e=null){return new Xp(this.type,this.data,nh(this.dims,e))}unsqueeze_(e=null){return this.dims=nh(this.dims,e),this}flatten_(e=0,t=-1){t=(t+this.dims.length)%this.dims.length;let n=this.dims.slice(0,e),r=this.dims.slice(e,t+1),s=this.dims.slice(t+1);return this.dims=[...n,r.reduce(((e,t)=>e*t),1),...s],this}flatten(e=0,t=-1){return this.clone().flatten_(e,t)}view(...e){let t=-1;for(let n=0;n<e.length;++n)if(-1===e[n]){if(-1!==t)throw new Error("Only one dimension can be inferred");t=n}const n=this.data;if(-1!==t){const r=e.reduce(((e,n,r)=>r!==t?e*n:e),1);e[t]=n.length/r}return new Xp(this.type,n,e)}neg_(){const e=this.data;for(let t=0;t<e.length;++t)e[t]=-e[t];return this}neg(){return this.clone().neg_()}clamp_(e,t){const n=this.data;for(let r=0;r<n.length;++r)n[r]=Math.min(Math.max(n[r],e),t);return this}clamp(e,t){return this.clone().clamp_(e,t)}round_(){const e=this.data;for(let t=0;t<e.length;++t)e[t]=Math.round(e[t]);return this}round(){return this.clone().round_()}mean(e=null,t=!1){return oh(this,e,t)}to(e){if(this.type===e)return this;if(!Kp.hasOwnProperty(e))throw new Error(`Unsupported type: ${e}`);let t;const n=["int64","uint64"].includes(this.type),r=["int64","uint64"].includes(e);return n&&!r?t=Number:!n&&r&&(t=BigInt),new Xp(e,Kp[e].from(this.data,t),this.dims)}}function Qp(e,[t,n],r="bilinear",s=!1){const i=e.dims.at(-3)??1,a=e.dims.at(-2),o=e.dims.at(-1);let l=function u(e,[t,n,r],[s,i],a="bilinear",o=!1){const l=i/r,u=s/n,d=new e.constructor(s*i*t),c=n*r,p=s*i;for(let a=0;a<s;++a)for(let s=0;s<i;++s){const o=a*i+s,h=(s+.5)/l-.5,f=(a+.5)/u-.5;let m=Math.floor(h),_=Math.floor(f);const g=Math.min(m+1,r-1),w=Math.min(_+1,n-1);m=Math.max(m,0),_=Math.max(_,0);const y=h-m,b=f-_,x=(1-y)*(1-b),v=y*(1-b),$=(1-y)*b,k=y*b,E=_*r,S=w*r,z=E+m,C=E+g,T=S+m,I=S+g;for(let n=0;n<t;++n){const t=n*c;d[n*p+o]=x*e[t+z]+v*e[t+C]+$*e[t+T]+k*e[t+I]}}return d}(e.data,[i,a,o],[t,n],r,s);return new Xp(e.type,l,[i,t,n])}async function Yp(e,{size:t=null,mode:n="bilinear"}={}){if(4!==e.dims.length)throw new Error("`interpolate_4d` currently only supports 4D input.");if(!t)throw new Error("`interpolate_4d` requires a `size` argument.");let r,s;if(2===t.length)r=[...e.dims.slice(0,2),...t];else if(3===t.length)r=[e.dims[0],...t];else{if(4!==t.length)throw new Error("`size` must be of length 2, 3, or 4.");r=t}if("bilinear"===n)s=await Hp.bilinear_interpolate_4d;else{if("bicubic"!==n)throw new Error(`Unsupported mode: ${n}`);s=await Hp.bicubic_interpolate_4d}const i=new Xp("int64",new BigInt64Array(r.map(BigInt)),[r.length]);return await s({x:e,s:i})}async function Zp(e,t){const n=await Hp.top_k;return t=null===t?e.dims.at(-1):Math.min(t,e.dims.at(-1)),await n({x:e,k:new Xp("int64",[BigInt(t)],[1])})}const Jp=e=>new Xp("int64",e,[e.length]);async function eh(e,t,n,r,s){const i=await Hp.slice;return await i({x:e,s:Jp(t),e:Jp(n),a:Jp(r),t:Jp(s??new Array(r.length).fill(1))})}function th(e,t){return e=e.slice(),null===t?e=e.filter((e=>1!==e)):"number"==typeof t?1===e[t]&&e.splice(t,1):Array.isArray(t)&&(e=e.filter(((e,n)=>1!==e||!t.includes(n)))),e}function nh(e,t){return t=rh(t,e.length+1),(e=e.slice()).splice(t,0,1),e}function rh(e,t,n=null,r=!0){if(r&&(e<-t||e>=t))throw new Error(`IndexError: index ${e} is out of bounds for dimension${null===n?"":" "+n} with size ${t}`);return e<0&&(e=(e%t+t)%t),e}function sh(e,t=0){t=rh(t,e[0].dims.length);const n=e[0].dims.slice();n[t]=e.reduce(((e,n)=>e+n.dims[t]),0);const r=n.reduce(((e,t)=>e*t),1),s=new e[0].data.constructor(r),i=e[0].type;if(0===t){let t=0;for(const n of e){const e=n.data;s.set(e,t),t+=e.length}}else{let r=0;for(let i=0;i<e.length;++i){const{data:a,dims:o}=e[i];for(let e=0;e<a.length;++e){let i=0;for(let s=o.length-1,a=e,l=1;s>=0;--s){const e=o[s];let u=a%e;s===t&&(u+=r),i+=u*l,l*=n[s],a=Math.floor(a/e)}s[i]=a[e]}r+=o[t]}}return new Xp(i,s,n)}function ih(e,t=0){return sh(e.map((e=>e.unsqueeze(t))),t)}function ah(e,t=null,n=1,r=!1){const s=e.data,i=e.dims;if(null===t){const t=s.reduce(((e,t)=>e+t),0)/s.length,r=Math.sqrt(s.reduce(((e,n)=>e+(n-t)**2),0)/(s.length-n)),i=new Xp(e.type,[t],[]);return[new Xp(e.type,[r],[]),i]}const a=oh(e,t=rh(t,i.length),r),o=a.data,l=i.slice();l[t]=1;const u=new s.constructor(s.length/i[t]);for(let e=0;e<s.length;++e){let n=0;for(let r=i.length-1,s=e,a=1;r>=0;--r){const e=i[r];if(r!==t){n+=s%e*a,a*=l[r]}s=Math.floor(s/e)}u[n]+=(s[e]-o[n])**2}for(let e=0;e<u.length;++e)u[e]=Math.sqrt(u[e]/(i[t]-n));r||l.splice(t,1);return[new Xp(e.type,u,l),a]}function oh(e,t=null,n=!1){const r=e.data;if(null===t){const t=r.reduce(((e,t)=>e+t),0);return new Xp(e.type,[t/r.length],[])}const s=e.dims;t=rh(t,s.length);const i=s.slice();i[t]=1;const a=new r.constructor(r.length/s[t]);for(let e=0;e<r.length;++e){let n=0;for(let r=s.length-1,a=e,o=1;r>=0;--r){const e=s[r];if(r!==t){n+=a%e*o,o*=i[r]}a=Math.floor(a/e)}a[n]+=r[e]}if(1!==s[t])for(let e=0;e<a.length;++e)a[e]=a[e]/s[t];return n||i.splice(t,1),new Xp(e.type,a,i)}function lh(e,t,n,r){const s=e.reduce(((e,t)=>e*t),1);return new Xp(n,new r(s).fill(t),e)}function uh(e,t){let n,r;if("number"==typeof t)n="float32",r=Float32Array;else if("bigint"==typeof t)n="int64",r=BigInt64Array;else{if("boolean"!=typeof t)throw new Error("Unsupported data type: "+typeof t);n="bool",r=Uint8Array}return lh(e,t,n,r)}function dh(e,t){return uh(e.dims,t)}function ch(e){return lh(e,1n,"int64",BigInt64Array)}function ph(e){return ch(e.dims)}function hh(e){return lh(e,0n,"int64",BigInt64Array)}class fh{constructor(e=((e,t)=>e>t),t=Infinity){this._heap=[],this._comparator=e,this._maxSize=t}get size(){return this._heap.length}isEmpty(){return 0===this.size}peek(){return this._heap[0]}push(...e){return this.extend(e)}extend(e){for(const t of e)if(this.size<this._maxSize)this._heap.push(t),this._siftUp();else{const e=this._smallest();this._comparator(t,this._heap[e])&&(this._heap[e]=t,this._siftUpFrom(e))}return this.size}pop(){const e=this.peek(),t=this.size-1;return t>0&&this._swap(0,t),this._heap.pop(),this._siftDown(),e}replace(e){const t=this.peek();return this._heap[0]=e,this._siftDown(),t}_parent(e){return(e+1>>>1)-1}_left(e){return 1+(e<<1)}_right(e){return e+1<<1}_greater(e,t){return this._comparator(this._heap[e],this._heap[t])}_swap(e,t){const n=this._heap[e];this._heap[e]=this._heap[t],this._heap[t]=n}_siftUp(){this._siftUpFrom(this.size-1)}_siftUpFrom(e){for(;e>0&&this._greater(e,this._parent(e));)this._swap(e,this._parent(e)),e=this._parent(e)}_siftDown(){let e=0;for(;this._left(e)<this.size&&this._greater(this._left(e),e)||this._right(e)<this.size&&this._greater(this._right(e),e);){const t=this._right(e)<this.size&&this._greater(this._right(e),this._left(e))?this._right(e):this._left(e);this._swap(e,t),e=t}}_smallest(){return 2**Math.floor(Math.log2(this.size))-1}}class mh{constructor(){this.root=_h.default()}extend(e){for(const t of e)this.push(t)}push(e){let t=this.root;for(const n of e){let e=t.children.get(n);void 0===e&&(e=_h.default(),t.children.set(n,e)),t=e}t.isLeaf=!0}*commonPrefixSearch(e){let t=this.root;if(void 0===t)return;let n="";for(const r of e){if(n+=r,t=t.children.get(r),void 0===t)return;t.isLeaf&&(yield n)}}}class _h{constructor(e,t){this.isLeaf=e,this.children=t}static default(){return new _h(!1,new Map)}}class gh{constructor(e,t,n){this.chars=Array.from(e),this.len=this.chars.length,this.bosTokenId=t,this.eosTokenId=n,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},(()=>[])),this.endNodes=Array.from({length:this.len+1},(()=>[]));const r=new wh(this.bosTokenId,0,0,0,0),s=new wh(this.eosTokenId,1,this.len,0,0);this.nodes.push(r.clone()),this.nodes.push(s.clone()),this.beginNodes[this.len].push(s),this.endNodes[0].push(r)}insert(e,t,n,r){const s=this.nodes.length,i=new wh(r,s,e,t,n);this.beginNodes[e].push(i),this.endNodes[e+t].push(i),this.nodes.push(i)}viterbi(){const e=this.len;let t=0;for(;t<=e;){if(0==this.beginNodes[t].length)return[];for(let e of this.beginNodes[t]){e.prev=null;let n=0,r=null;for(let s of this.endNodes[t]){const t=s.backtraceScore+e.score;(null===r||t>n)&&(r=s.clone(),n=t)}if(null===r)return[];e.prev=r,e.backtraceScore=n}++t}const n=[],r=this.beginNodes[e][0].prev;if(null===r)return[];let s=r.clone();for(;null!==s.prev;){n.push(s.clone());const e=s.clone();s=e.prev.clone()}return n.reverse(),n}piece(e){return this.chars.slice(e.pos,e.pos+e.length).join("")}tokens(){return this.viterbi().map((e=>this.piece(e)))}tokenIds(){return this.viterbi().map((e=>e.tokenId))}}class wh{constructor(e,t,n,r,s){this.tokenId=e,this.nodeId=t,this.pos=n,this.length=r,this.score=s,this.prev=null,this.backtraceScore=0}clone(){const e=new wh(this.tokenId,this.nodeId,this.pos,this.length,this.score);return e.prev=this.prev,e.backtraceScore=this.backtraceScore,e}}var yh=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",NullLiteral:"NullLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",Is:"Is",NotIn:"NotIn",Else:"Else",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator",Macro:"Macro",EndMacro:"EndMacro"}),bh=Object.freeze({set:yh.Set,for:yh.For,in:yh.In,is:yh.Is,if:yh.If,else:yh.Else,endif:yh.EndIf,elif:yh.ElseIf,endfor:yh.EndFor,and:yh.And,or:yh.Or,not:yh.Not,"not in":yh.NotIn,macro:yh.Macro,endmacro:yh.EndMacro,true:yh.BooleanLiteral,false:yh.BooleanLiteral,none:yh.NullLiteral,True:yh.BooleanLiteral,False:yh.BooleanLiteral,None:yh.NullLiteral}),xh=class{constructor(e,t){this.value=e,this.type=t}};function vh(e){return/\\w/.test(e)}function $h(e){return/[0-9]/.test(e)}var kh=[["{%",yh.OpenStatement],["%}",yh.CloseStatement],["{{",yh.OpenExpression],["}}",yh.CloseExpression],["(",yh.OpenParen],[")",yh.CloseParen],["{",yh.OpenCurlyBracket],["}",yh.CloseCurlyBracket],["[",yh.OpenSquareBracket],["]",yh.CloseSquareBracket],[",",yh.Comma],[".",yh.Dot],[":",yh.Colon],["|",yh.Pipe],["<=",yh.ComparisonBinaryOperator],[">=",yh.ComparisonBinaryOperator],["==",yh.ComparisonBinaryOperator],["!=",yh.ComparisonBinaryOperator],["<",yh.ComparisonBinaryOperator],[">",yh.ComparisonBinaryOperator],["+",yh.AdditiveBinaryOperator],["-",yh.AdditiveBinaryOperator],["*",yh.MultiplicativeBinaryOperator],["/",yh.MultiplicativeBinaryOperator],["%",yh.MultiplicativeBinaryOperator],["=",yh.Equals]],Eh=new Map([["n","\\n"],["t","\\t"],["r","\\r"],["b","\\b"],["f","\\f"],["v","\\v"],["\'","\'"],[\'"\',\'"\'],["\\\\","\\\\"]]);var Sh=class{type="Statement"},zh=class extends Sh{constructor(e){super(),this.body=e}type="Program"},Ch=class extends Sh{constructor(e,t,n){super(),this.test=e,this.body=t,this.alternate=n}type="If"},Th=class extends Sh{constructor(e,t,n,r){super(),this.loopvar=e,this.iterable=t,this.body=n,this.defaultBlock=r}type="For"},Ih=class extends Sh{constructor(e,t){super(),this.assignee=e,this.value=t}type="Set"},Ah=class extends Sh{constructor(e,t,n){super(),this.name=e,this.args=t,this.body=n}type="Macro"},Mh=class extends Sh{type="Expression"},Oh=class extends Mh{constructor(e,t,n){super(),this.object=e,this.property=t,this.computed=n}type="MemberExpression"},Bh=class extends Mh{constructor(e,t){super(),this.callee=e,this.args=t}type="CallExpression"},Nh=class extends Mh{constructor(e){super(),this.value=e}type="Identifier"},Ph=class extends Mh{constructor(e){super(),this.value=e}type="Literal"},Rh=class extends Ph{type="NumericLiteral"},Dh=class extends Ph{type="StringLiteral"},Fh=class extends Ph{type="BooleanLiteral"},Lh=class extends Ph{type="NullLiteral"},Uh=class extends Ph{type="ArrayLiteral"},qh=class extends Ph{type="TupleLiteral"},Vh=class extends Ph{type="ObjectLiteral"},Wh=class extends Mh{constructor(e,t,n){super(),this.operator=e,this.left=t,this.right=n}type="BinaryExpression"},jh=class extends Mh{constructor(e,t){super(),this.operand=e,this.filter=t}type="FilterExpression"},Gh=class extends Mh{constructor(e,t){super(),this.iterable=e,this.test=t}type="SelectExpression"},Hh=class extends Mh{constructor(e,t,n){super(),this.operand=e,this.negate=t,this.test=n}type="TestExpression"},Kh=class extends Mh{constructor(e,t){super(),this.operator=e,this.argument=t}type="UnaryExpression"},Xh=class extends Mh{constructor(e=void 0,t=void 0,n=void 0){super(),this.start=e,this.stop=t,this.step=n}type="SliceExpression"},Qh=class extends Mh{constructor(e,t){super(),this.key=e,this.value=t}type="KeywordArgumentExpression"};function Yh(e){const t=new zh([]);let n=0;function r(t,r){const s=e[n++];if(!s||s.type!==t)throw new Error(`Parser Error: ${r}. ${s.type} !== ${t}.`);return s}function s(){switch(e[n].type){case yh.Text:return function t(){return new Dh(r(yh.Text,"Expected text token").value)}();case yh.OpenStatement:return function c(){let t;switch(r(yh.OpenStatement,"Expected opening statement token"),e[n].type){case yh.Set:++n,t=o(),r(yh.CloseStatement,"Expected closing statement token");break;case yh.If:++n,t=l(),r(yh.OpenStatement,"Expected {% token"),r(yh.EndIf,"Expected endif token"),r(yh.CloseStatement,"Expected %} token");break;case yh.Macro:++n,t=function c(){const e=x();if("Identifier"!==e.type)throw new SyntaxError("Expected identifier following macro statement");const t=g();r(yh.CloseStatement,"Expected closing statement token");const n=[];for(;i(yh.OpenStatement,yh.EndMacro);)n.push(s());return new Ah(e,t,n)}(),r(yh.OpenStatement,"Expected {% token"),r(yh.EndMacro,"Expected endmacro token"),r(yh.CloseStatement,"Expected %} token");break;case yh.For:++n,t=function p(){const e=u(!0);if(!(e instanceof Nh||e instanceof qh))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${e.type} instead`);r(yh.In,"Expected `in` keyword following loop variable");const t=d();r(yh.CloseStatement,"Expected closing statement token");const o=[];for(;i(yh.OpenStatement,yh.EndFor)&&i(yh.OpenStatement,yh.Else);)o.push(s());const l=[];if(a(yh.OpenStatement,yh.Else))for(++n,++n,r(yh.CloseStatement,"Expected closing statement token");i(yh.OpenStatement,yh.EndFor);)l.push(s());return new Th(e,t,o,l)}(),r(yh.OpenStatement,"Expected {% token"),r(yh.EndFor,"Expected endfor token"),r(yh.CloseStatement,"Expected %} token");break;default:throw new SyntaxError(`Unknown statement type: ${e[n].type}`)}return t}();case yh.OpenExpression:return function p(){r(yh.OpenExpression,"Expected opening expression token");const e=d();return r(yh.CloseExpression,"Expected closing expression token"),e}();default:throw new SyntaxError(`Unexpected token type: ${e[n].type}`)}}function i(...t){return n+t.length<=e.length&&t.some(((t,r)=>t!==e[n+r].type))}function a(...t){return n+t.length<=e.length&&t.every(((t,r)=>t===e[n+r].type))}function o(){const e=d();if(a(yh.Equals)){++n;const t=o();return new Ih(e,t)}return e}function l(){const t=d();r(yh.CloseStatement,"Expected closing statement token");const i=[],o=[];for(;e[n]?.type!==yh.OpenStatement||e[n+1]?.type!==yh.ElseIf&&e[n+1]?.type!==yh.Else&&e[n+1]?.type!==yh.EndIf;)i.push(s());if(e[n]?.type===yh.OpenStatement&&e[n+1]?.type!==yh.EndIf)if(++n,a(yh.ElseIf))r(yh.ElseIf,"Expected elseif token"),o.push(l());else for(r(yh.Else,"Expected else token"),r(yh.CloseStatement,"Expected closing statement token");e[n]?.type!==yh.OpenStatement||e[n+1]?.type!==yh.EndIf;)o.push(s());return new Ch(t,i,o)}function u(e=!1){const t=e?x:d,r=[t()],s=a(yh.Comma);for(;s&&(++n,r.push(t()),a(yh.Comma)););return s?new qh(r):r[0]}function d(){return function e(){const e=c();if(a(yh.If)){++n;const t=c();if(a(yh.Else)){++n;const r=c();return new Ch(t,[e],[r])}return new Gh(e,t)}return e}()}function c(){let t=p();for(;a(yh.Or);){const r=e[n];++n;const s=p();t=new Wh(r,t,s)}return t}function p(){let t=h();for(;a(yh.And);){const r=e[n];++n;const s=h();t=new Wh(r,t,s)}return t}function h(){let t;for(;a(yh.Not);){const r=e[n];++n;const s=h();t=new Kh(r,s)}return t??function r(){let t=f();for(;a(yh.ComparisonBinaryOperator)||a(yh.In)||a(yh.NotIn);){const r=e[n];++n;const s=f();t=new Wh(r,t,s)}return t}()}function f(){let t=y();for(;a(yh.AdditiveBinaryOperator);){const r=e[n];++n;const s=y();t=new Wh(r,t,s)}return t}function m(){const t=function s(){let t=x();for(;a(yh.Dot)||a(yh.OpenSquareBracket);){const s=e[n];let i;++n;const a=s.type!==yh.Dot;if(a)i=w(),r(yh.CloseSquareBracket,"Expected closing square bracket");else if(i=x(),"Identifier"!==i.type)throw new SyntaxError("Expected identifier following dot operator");t=new Oh(t,i,a)}return t}();return a(yh.OpenParen)?_(t):t}function _(e){let t=new Bh(e,g());return a(yh.OpenParen)&&(t=_(t)),t}function g(){r(yh.OpenParen,"Expected opening parenthesis for arguments list");const e=function t(){const e=[];for(;!a(yh.CloseParen);){let t=d();if(a(yh.Equals)){if(++n,!(t instanceof Nh))throw new SyntaxError("Expected identifier for keyword argument");const e=d();t=new Qh(t,e)}e.push(t),a(yh.Comma)&&++n}return e}();return r(yh.CloseParen,"Expected closing parenthesis for arguments list"),e}function w(){const e=[];let t=!1;for(;!a(yh.CloseSquareBracket);)a(yh.Colon)?(e.push(void 0),++n,t=!0):(e.push(d()),a(yh.Colon)&&(++n,t=!0));if(0===e.length)throw new SyntaxError("Expected at least one argument for member/slice expression");if(t){if(e.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new Xh(...e)}return e[0]}function y(){let t=b();for(;a(yh.MultiplicativeBinaryOperator);){const r=e[n];++n;const s=b();t=new Wh(r,t,s)}return t}function b(){let e=function t(){let e=m();for(;a(yh.Pipe);){++n;let t=x();if(!(t instanceof Nh))throw new SyntaxError("Expected identifier for the filter");a(yh.OpenParen)&&(t=_(t)),e=new jh(e,t)}return e}();for(;a(yh.Is);){++n;const t=a(yh.Not);t&&++n;let r=x();if(r instanceof Fh?r=new Nh(r.value.toString()):r instanceof Lh&&(r=new Nh("none")),!(r instanceof Nh))throw new SyntaxError("Expected identifier for the test");e=new Hh(e,t,r)}return e}function x(){const t=e[n];switch(t.type){case yh.NumericLiteral:return++n,new Rh(Number(t.value));case yh.StringLiteral:return++n,new Dh(t.value);case yh.BooleanLiteral:return++n,new Fh("true"===t.value.toLowerCase());case yh.NullLiteral:return++n,new Lh(null);case yh.Identifier:return++n,new Nh(t.value);case yh.OpenParen:{++n;const t=u();if(e[n].type!==yh.CloseParen)throw new SyntaxError(`Expected closing parenthesis, got ${e[n].type} instead`);return++n,t}case yh.OpenSquareBracket:{++n;const e=[];for(;!a(yh.CloseSquareBracket);)e.push(d()),a(yh.Comma)&&++n;return++n,new Uh(e)}case yh.OpenCurlyBracket:{++n;const e=new Map;for(;!a(yh.CloseCurlyBracket);){const t=d();r(yh.Colon,"Expected colon between key and value in object literal");const s=d();e.set(t,s),a(yh.Comma)&&++n}return++n,new Vh(e)}default:throw new SyntaxError(`Unexpected token: ${t.type}`)}}for(;n<e.length;)t.body.push(s());return t}function Zh(e,t,n=1){void 0===t&&(t=e,e=0);const r=[];for(let s=e;s<t;s+=n)r.push(s);return r}function Jh(e,t,n,r=1){const s=Math.sign(r);s>=0?(t=(t??=0)<0?Math.max(e.length+t,0):Math.min(t,e.length),n=(n??=e.length)<0?Math.max(e.length+n,0):Math.min(n,e.length)):(t=(t??=e.length-1)<0?Math.max(e.length+t,-1):Math.min(t,e.length-1),n=(n??=-1)<-1?Math.max(e.length+n,-1):Math.min(n,e.length-1));const i=[];for(let a=t;s*a<s*n;a+=r)i.push(e[a]);return i}function ef(e){return e.replace(/\\b\\w/g,(e=>e.toUpperCase()))}var tf=class{type="RuntimeValue";value;builtins=new Map;constructor(e=void 0){this.value=e}__bool__(){return new sf(!!this.value)}},nf=class extends tf{type="NumericValue"},rf=class extends tf{type="StringValue";builtins=new Map([["upper",new df((()=>new rf(this.value.toUpperCase())))],["lower",new df((()=>new rf(this.value.toLowerCase())))],["strip",new df((()=>new rf(this.value.trim())))],["title",new df((()=>new rf(ef(this.value))))],["length",new nf(this.value.length)],["rstrip",new df((()=>new rf(this.value.trimEnd())))],["lstrip",new df((()=>new rf(this.value.trimStart())))]])},sf=class extends tf{type="BooleanValue"},af=class extends tf{type="ObjectValue";__bool__(){return new sf(this.value.size>0)}builtins=new Map([["get",new df((([e,t])=>{if(!(e instanceof rf))throw new Error(`Object key must be a string: got ${e.type}`);return this.value.get(e.value)??t??new cf}))],["items",new df((()=>new lf(Array.from(this.value.entries()).map((([e,t])=>new lf([new rf(e),t]))))))]])},of=class extends af{type="KeywordArgumentsValue"},lf=class extends tf{type="ArrayValue";builtins=new Map([["length",new nf(this.value.length)]]);__bool__(){return new sf(this.value.length>0)}},uf=class extends lf{type="TupleValue"},df=class extends tf{type="FunctionValue"},cf=class extends tf{type="NullValue"},pf=class extends tf{type="UndefinedValue"},hf=class{constructor(e){this.parent=e}variables=new Map([["namespace",new df((e=>{if(0===e.length)return new af(new Map);if(1!==e.length||!(e[0]instanceof af))throw new Error("`namespace` expects either zero arguments or a single object argument");return e[0]}))]]);tests=new Map([["boolean",e=>"BooleanValue"===e.type],["callable",e=>e instanceof df],["odd",e=>{if("NumericValue"!==e.type)throw new Error(`Cannot apply test "odd" to type: ${e.type}`);return e.value%2!=0}],["even",e=>{if("NumericValue"!==e.type)throw new Error(`Cannot apply test "even" to type: ${e.type}`);return e.value%2==0}],["false",e=>"BooleanValue"===e.type&&!e.value],["true",e=>"BooleanValue"===e.type&&e.value],["none",e=>"NullValue"===e.type],["string",e=>"StringValue"===e.type],["number",e=>"NumericValue"===e.type],["integer",e=>"NumericValue"===e.type&&Number.isInteger(e.value)],["iterable",e=>"ArrayValue"===e.type||"StringValue"===e.type],["mapping",e=>"ObjectValue"===e.type],["lower",e=>{const t=e.value;return"StringValue"===e.type&&t===t.toLowerCase()}],["upper",e=>{const t=e.value;return"StringValue"===e.type&&t===t.toUpperCase()}],["none",e=>"NullValue"===e.type],["defined",e=>"UndefinedValue"!==e.type],["undefined",e=>"UndefinedValue"===e.type],["equalto",(e,t)=>e.value===t.value],["eq",(e,t)=>e.value===t.value]]);set(e,t){return this.declareVariable(e,mf(t))}declareVariable(e,t){if(this.variables.has(e))throw new SyntaxError(`Variable already declared: ${e}`);return this.variables.set(e,t),t}setVariable(e,t){return this.variables.set(e,t),t}resolve(e){if(this.variables.has(e))return this;if(this.parent)return this.parent.resolve(e);throw new Error(`Unknown variable: ${e}`)}lookupVariable(e){try{return this.resolve(e).variables.get(e)??new pf}catch{return new pf}}},ff=class{global;constructor(e){this.global=e??new hf}run(e){return this.evaluate(e,this.global)}evaluateBinaryExpression(e,t){const n=this.evaluate(e.left,t);switch(e.operator.value){case"and":return n.__bool__().value?this.evaluate(e.right,t):n;case"or":return n.__bool__().value?n:this.evaluate(e.right,t)}const r=this.evaluate(e.right,t);switch(e.operator.value){case"==":return new sf(n.value==r.value);case"!=":return new sf(n.value!=r.value)}if(n instanceof pf||r instanceof pf)throw new Error("Cannot perform operation on undefined values");if(n instanceof cf||r instanceof cf)throw new Error("Cannot perform operation on null values");if(n instanceof nf&&r instanceof nf)switch(e.operator.value){case"+":return new nf(n.value+r.value);case"-":return new nf(n.value-r.value);case"*":return new nf(n.value*r.value);case"/":return new nf(n.value/r.value);case"%":return new nf(n.value%r.value);case"<":return new sf(n.value<r.value);case">":return new sf(n.value>r.value);case">=":return new sf(n.value>=r.value);case"<=":return new sf(n.value<=r.value)}else if(n instanceof lf&&r instanceof lf){if("+"===e.operator.value)return new lf(n.value.concat(r.value))}else if(r instanceof lf){const t=void 0!==r.value.find((e=>e.value===n.value));switch(e.operator.value){case"in":return new sf(t);case"not in":return new sf(!t)}}if((n instanceof rf||r instanceof rf)&&"+"===e.operator.value)return new rf(n.value.toString()+r.value.toString());if(n instanceof rf&&r instanceof rf)switch(e.operator.value){case"in":return new sf(r.value.includes(n.value));case"not in":return new sf(!r.value.includes(n.value))}if(n instanceof rf&&r instanceof af)switch(e.operator.value){case"in":return new sf(r.value.has(n.value));case"not in":return new sf(!r.value.has(n.value))}throw new SyntaxError(`Unknown operator "${e.operator.value}" between ${n.type} and ${r.type}`)}evaluateArguments(e,t){const n=[],r=new Map;for(const s of e)if("KeywordArgumentExpression"===s.type){const e=s;r.set(e.key.value,this.evaluate(e.value,t))}else{if(r.size>0)throw new Error("Positional arguments must come before keyword arguments");n.push(this.evaluate(s,t))}return[n,r]}evaluateFilterExpression(e,t){const n=this.evaluate(e.operand,t);if("Identifier"===e.filter.type){const t=e.filter;if("tojson"===t.value)return new rf(_f(n));if(n instanceof lf)switch(t.value){case"list":return n;case"first":return n.value[0];case"last":return n.value[n.value.length-1];case"length":return new nf(n.value.length);case"reverse":return new lf(n.value.reverse());case"sort":return new lf(n.value.sort(((e,t)=>{if(e.type!==t.type)throw new Error(`Cannot compare different types: ${e.type} and ${t.type}`);switch(e.type){case"NumericValue":return e.value-t.value;case"StringValue":return e.value.localeCompare(t.value);default:throw new Error(`Cannot compare type: ${e.type}`)}})));default:throw new Error(`Unknown ArrayValue filter: ${t.value}`)}else if(n instanceof rf)switch(t.value){case"length":return new nf(n.value.length);case"upper":return new rf(n.value.toUpperCase());case"lower":return new rf(n.value.toLowerCase());case"title":return new rf(ef(n.value));case"capitalize":return new rf(n.value.charAt(0).toUpperCase()+n.value.slice(1));case"trim":return new rf(n.value.trim());case"indent":return new rf(n.value.split("\\n").map(((e,t)=>0===t||0===e.length?e:"    "+e)).join("\\n"));case"string":return n;default:throw new Error(`Unknown StringValue filter: ${t.value}`)}else{if(n instanceof nf){if("abs"===t.value)return new nf(Math.abs(n.value));throw new Error(`Unknown NumericValue filter: ${t.value}`)}if(n instanceof af)switch(t.value){case"items":return new lf(Array.from(n.value.entries()).map((([e,t])=>new lf([new rf(e),t]))));case"length":return new nf(n.value.size);default:throw new Error(`Unknown ObjectValue filter: ${t.value}`)}}throw new Error(`Cannot apply filter "${t.value}" to type: ${n.type}`)}if("CallExpression"===e.filter.type){const r=e.filter;if("Identifier"!==r.callee.type)throw new Error(`Unknown filter: ${r.callee.type}`);const s=r.callee.value;if("tojson"===s){const[,e]=this.evaluateArguments(r.args,t),s=e.get("indent")??new cf;if(!(s instanceof nf||s instanceof cf))throw new Error("If set, indent must be a number");return new rf(_f(n,s.value))}if(n instanceof lf){switch(s){case"selectattr":case"rejectattr":{const e="selectattr"===s;if(n.value.some((e=>!(e instanceof af))))throw new Error(`\\`${s}\\` can only be applied to array of objects`);if(r.args.some((e=>"StringLiteral"!==e.type)))throw new Error(`arguments of \\`${s}\\` must be strings`);const[i,a,o]=r.args.map((e=>this.evaluate(e,t)));let l;if(a){const e=t.tests.get(a.value);if(!e)throw new Error(`Unknown test: ${a.value}`);l=e}else l=(...e)=>e[0].__bool__().value;const u=n.value.filter((t=>{const n=t.value.get(i.value),r=!!n&&l(n,o);return e?r:!r}));return new lf(u)}case"map":{const[,e]=this.evaluateArguments(r.args,t);if(e.has("attribute")){const t=e.get("attribute");if(!(t instanceof rf))throw new Error("attribute must be a string");const r=e.get("default"),s=n.value.map((e=>{if(!(e instanceof af))throw new Error("items in map must be an object");return e.value.get(t.value)??r??new pf}));return new lf(s)}throw new Error("`map` expressions without `attribute` set are not currently supported.")}}throw new Error(`Unknown ArrayValue filter: ${s}`)}if(n instanceof rf){if("indent"===s){const[e,s]=this.evaluateArguments(r.args,t),i=e.at(0)??s.get("width")??new nf(4);if(!(i instanceof nf))throw new Error("width must be a number");const a=e.at(1)??s.get("first")??new sf(!1),o=e.at(2)??s.get("blank")??new sf(!1),l=n.value.split("\\n"),u=" ".repeat(i.value),d=l.map(((e,t)=>!a.value&&0===t||!o.value&&0===e.length?e:u+e));return new rf(d.join("\\n"))}throw new Error(`Unknown StringValue filter: ${s}`)}throw new Error(`Cannot apply filter "${s}" to type: ${n.type}`)}throw new Error(`Unknown filter: ${e.filter.type}`)}evaluateTestExpression(e,t){const n=this.evaluate(e.operand,t),r=t.tests.get(e.test.value);if(!r)throw new Error(`Unknown test: ${e.test.value}`);const s=r(n);return new sf(e.negate?!s:s)}evaluateUnaryExpression(e,t){const n=this.evaluate(e.argument,t);if("not"===e.operator.value)return new sf(!n.value);throw new SyntaxError(`Unknown operator: ${e.operator.value}`)}evalProgram(e,t){return this.evaluateBlock(e.body,t)}evaluateBlock(e,t){let n="";for(const r of e){const e=this.evaluate(r,t);"NullValue"!==e.type&&"UndefinedValue"!==e.type&&(n+=e.value)}return new rf(n)}evaluateIdentifier(e,t){return t.lookupVariable(e.value)}evaluateCallExpression(e,t){const[n,r]=this.evaluateArguments(e.args,t);r.size>0&&n.push(new of(r));const s=this.evaluate(e.callee,t);if("FunctionValue"!==s.type)throw new Error(`Cannot call something that is not a function: got ${s.type}`);return s.value(n,t)}evaluateSliceExpression(e,t,n){if(!(e instanceof lf||e instanceof rf))throw new Error("Slice object must be an array or string");const r=this.evaluate(t.start,n),s=this.evaluate(t.stop,n),i=this.evaluate(t.step,n);if(!(r instanceof nf||r instanceof pf))throw new Error("Slice start must be numeric or undefined");if(!(s instanceof nf||s instanceof pf))throw new Error("Slice stop must be numeric or undefined");if(!(i instanceof nf||i instanceof pf))throw new Error("Slice step must be numeric or undefined");return e instanceof lf?new lf(Jh(e.value,r.value,s.value,i.value)):new rf(Jh(Array.from(e.value),r.value,s.value,i.value).join(""))}evaluateMemberExpression(e,t){const n=this.evaluate(e.object,t);let r,s;if(e.computed){if("SliceExpression"===e.property.type)return this.evaluateSliceExpression(n,e.property,t);r=this.evaluate(e.property,t)}else r=new rf(e.property.value);if(n instanceof af){if(!(r instanceof rf))throw new Error(`Cannot access property with non-string: got ${r.type}`);s=n.value.get(r.value)??n.builtins.get(r.value)}else if(n instanceof lf||n instanceof rf)if(r instanceof nf)s=n.value.at(r.value),n instanceof rf&&(s=new rf(n.value.at(r.value)));else{if(!(r instanceof rf))throw new Error(`Cannot access property with non-string/non-number: got ${r.type}`);s=n.builtins.get(r.value)}else{if(!(r instanceof rf))throw new Error(`Cannot access property with non-string: got ${r.type}`);s=n.builtins.get(r.value)}return s instanceof tf?s:new pf}evaluateSet(e,t){const n=this.evaluate(e.value,t);if("Identifier"===e.assignee.type){const r=e.assignee.value;t.setVariable(r,n)}else{if("MemberExpression"!==e.assignee.type)throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(e.assignee)}`);{const r=e.assignee,s=this.evaluate(r.object,t);if(!(s instanceof af))throw new Error("Cannot assign to member of non-object");if("Identifier"!==r.property.type)throw new Error("Cannot assign to member with non-identifier property");s.value.set(r.property.value,n)}}return new cf}evaluateIf(e,t){const n=this.evaluate(e.test,t);return this.evaluateBlock(n.__bool__().value?e.body:e.alternate,t)}evaluateFor(e,t){const n=new hf(t);let r,s;if("SelectExpression"===e.iterable.type){const t=e.iterable;s=this.evaluate(t.iterable,n),r=t.test}else s=this.evaluate(e.iterable,n);if(!(s instanceof lf))throw new Error(`Expected iterable type in for loop: got ${s.type}`);const i=[],a=[];for(let t=0;t<s.value.length;++t){const o=new hf(n),l=s.value[t];let u;if("Identifier"===e.loopvar.type)u=t=>t.setVariable(e.loopvar.value,l);else{if("TupleLiteral"!==e.loopvar.type)throw new Error(`Invalid loop variable(s): ${e.loopvar.type}`);{const t=e.loopvar;if("ArrayValue"!==l.type)throw new Error(`Cannot unpack non-iterable type: ${l.type}`);const n=l;if(t.value.length!==n.value.length)throw new Error(`Too ${t.value.length>n.value.length?"few":"many"} items to unpack`);u=e=>{for(let r=0;r<t.value.length;++r){if("Identifier"!==t.value[r].type)throw new Error(`Cannot unpack non-identifier type: ${t.value[r].type}`);e.setVariable(t.value[r].value,n.value[r])}}}}if(r){u(o);if(!this.evaluate(r,o).__bool__().value)continue}i.push(l),a.push(u)}let o="",l=!0;for(let t=0;t<i.length;++t){const r=new Map([["index",new nf(t+1)],["index0",new nf(t)],["revindex",new nf(i.length-t)],["revindex0",new nf(i.length-t-1)],["first",new sf(0===t)],["last",new sf(t===i.length-1)],["length",new nf(i.length)],["previtem",t>0?i[t-1]:new pf],["nextitem",t<i.length-1?i[t+1]:new pf]]);n.setVariable("loop",new af(r)),a[t](n);o+=this.evaluateBlock(e.body,n).value,l=!1}if(l){o+=this.evaluateBlock(e.defaultBlock,n).value}return new rf(o)}evaluateMacro(e,t){return t.setVariable(e.name.value,new df(((t,n)=>{const r=new hf(n);let s;t=t.slice(),"KeywordArgumentsValue"===t.at(-1)?.type&&(s=t.pop());for(let n=0;n<e.args.length;++n){const i=e.args[n],a=t[n];if("Identifier"===i.type){const e=i;if(!a)throw new Error(`Missing positional argument: ${e.value}`);r.setVariable(e.value,a)}else{if("KeywordArgumentExpression"!==i.type)throw new Error(`Unknown argument type: ${i.type}`);{const e=i,t=a??s?.value.get(e.key.value)??this.evaluate(e.value,r);r.setVariable(e.key.value,t)}}}return this.evaluateBlock(e.body,r)}))),new cf}evaluate(e,t){if(void 0===e)return new pf;switch(e.type){case"Program":return this.evalProgram(e,t);case"Set":return this.evaluateSet(e,t);case"If":return this.evaluateIf(e,t);case"For":return this.evaluateFor(e,t);case"Macro":return this.evaluateMacro(e,t);case"NumericLiteral":return new nf(Number(e.value));case"StringLiteral":return new rf(e.value);case"BooleanLiteral":return new sf(e.value);case"NullLiteral":return new cf(e.value);case"ArrayLiteral":return new lf(e.value.map((e=>this.evaluate(e,t))));case"TupleLiteral":return new uf(e.value.map((e=>this.evaluate(e,t))));case"ObjectLiteral":{const n=new Map;for(const[r,s]of e.value){const e=this.evaluate(r,t);if(!(e instanceof rf))throw new Error(`Object keys must be strings: got ${e.type}`);n.set(e.value,this.evaluate(s,t))}return new af(n)}case"Identifier":return this.evaluateIdentifier(e,t);case"CallExpression":return this.evaluateCallExpression(e,t);case"MemberExpression":return this.evaluateMemberExpression(e,t);case"UnaryExpression":return this.evaluateUnaryExpression(e,t);case"BinaryExpression":return this.evaluateBinaryExpression(e,t);case"FilterExpression":return this.evaluateFilterExpression(e,t);case"TestExpression":return this.evaluateTestExpression(e,t);default:throw new SyntaxError(`Unknown node type: ${e.type}`)}}};function mf(e){switch(typeof e){case"number":return new nf(e);case"string":return new rf(e);case"boolean":return new sf(e);case"undefined":return new pf;case"object":return null===e?new cf:Array.isArray(e)?new lf(e.map(mf)):new af(new Map(Object.entries(e).map((([e,t])=>[e,mf(t)]))));case"function":return new df(((t,n)=>mf(e(...t.map((e=>e.value)))??null)));default:throw new Error(`Cannot convert to runtime value: ${e}`)}}function _f(e,t,n){const r=n??0;switch(e.type){case"NullValue":case"UndefinedValue":return"null";case"NumericValue":case"StringValue":case"BooleanValue":return JSON.stringify(e.value);case"ArrayValue":case"ObjectValue":{const n=t?" ".repeat(t):"",s="\\n"+n.repeat(r),i=s+n;if("ArrayValue"===e.type){const n=e.value.map((e=>_f(e,t,r+1)));return t?`[${i}${n.join(`,${i}`)}${s}]`:`[${n.join(", ")}]`}{const n=Array.from(e.value.entries()).map((([e,n])=>{const s=`"${e}": ${_f(n,t,r+1)}`;return t?`${i}${s}`:s}));return t?`{${n.join(",")}${s}}`:`{${n.join(", ")}}`}}default:throw new Error(`Cannot convert to JSON: ${e.type}`)}}var gf=class{parsed;constructor(e){const t=function n(e,t={}){const n=[],r=function s(e,t={}){return e.endsWith("\\n")&&(e=e.slice(0,-1)),e=e.replace(/{#.*?#}/gs,"{##}"),t.lstrip_blocks&&(e=e.replace(/^[ \\t]*({[#%])/gm,"$1")),t.trim_blocks&&(e=e.replace(/([#%]})\\n/g,"$1")),e.replace(/{##}/g,"").replace(/-%}\\s*/g,"%}").replace(/\\s*{%-/g,"{%").replace(/-}}\\s*/g,"}}").replace(/\\s*{{-/g,"{{")}(e,t);let i=0;const a=e=>{let t="";for(;e(r[i]);)if("\\\\"!==r[i]){if(t+=r[i++],i>=r.length)throw new SyntaxError("Unexpected end of input")}else{if(++i,i>=r.length)throw new SyntaxError("Unexpected end of input");const e=r[i++],n=Eh.get(e);if(void 0===n)throw new SyntaxError(`Unexpected escaped character: ${e}`);t+=n}return t};e:for(;i<r.length;){const e=n.at(-1)?.type;if(void 0===e||e===yh.CloseStatement||e===yh.CloseExpression){let e="";for(;i<r.length&&("{"!==r[i]||"%"!==r[i+1]&&"{"!==r[i+1]);)e+=r[i++];if(e.length>0){n.push(new xh(e,yh.Text));continue}}a((e=>/\\s/.test(e)));const t=r[i];if("-"===t||"+"===t){const e=n.at(-1)?.type;if(e===yh.Text||void 0===e)throw new SyntaxError(`Unexpected character: ${t}`);switch(e){case yh.Identifier:case yh.NumericLiteral:case yh.BooleanLiteral:case yh.NullLiteral:case yh.StringLiteral:case yh.CloseParen:case yh.CloseSquareBracket:break;default:{++i;const e=a($h);n.push(new xh(`${t}${e}`,e.length>0?yh.NumericLiteral:yh.UnaryOperator));continue}}}for(const[e,t]of kh)if(r.slice(i,i+e.length)===e){n.push(new xh(e,t)),i+=e.length;continue e}if("\'"!==t&&\'"\'!==t)if($h(t)){const e=a($h);n.push(new xh(e,yh.NumericLiteral))}else{if(!vh(t))throw new SyntaxError(`Unexpected character: ${t}`);{const e=a(vh),t=Object.hasOwn(bh,e)?bh[e]:yh.Identifier;t===yh.In&&n.at(-1)?.type===yh.Not?(n.pop(),n.push(new xh("not in",yh.NotIn))):n.push(new xh(e,t))}}else{++i;const e=a((e=>e!==t));n.push(new xh(e,yh.StringLiteral)),++i}}return n}(e,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=Yh(t)}render(e){const t=new hf;t.set("false",!1),t.set("true",!0),t.set("raise_exception",(e=>{throw new Error(e)})),t.set("range",Zh);for(const[n,r]of Object.entries(e))t.set(n,r);return new ff(t).run(this.parsed).value}};const wf=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],yf=new Map(wf),bf=new Map([...wf.map((([e,t])=>[t,e])),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);async function xf(e,t){const n=await Promise.all([ce(e,"tokenizer.json",!0,t),ce(e,"tokenizer_config.json",!0,t)]);return null!==t.legacy&&(n[1].legacy=t.legacy),n}function vf(e,t=!0){if(void 0!==e.Regex){let t=e.Regex.replace(/\\\\([#&~])/g,"$1");for(const[e,n]of Af)t=t.replaceAll(e,n);return new RegExp(t,"gu")}if(void 0!==e.String){const n=H(e.String);return new RegExp(t?n:`(${n})`,"gu")}return console.warn("Unknown pattern type:",e),null}function $f(e){return new Map(Object.entries(e))}function kf(e){const t=e.dims;switch(t.length){case 1:return e.tolist();case 2:if(1!==t[0])throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return e.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${t.length}.`)}}function Ef(e){return e.replace(/ \\./g,".").replace(/ \\?/g,"?").replace(/ \\!/g,"!").replace(/ ,/g,",").replace(/ \\\' /g,"\'").replace(/ n\\\'t/g,"n\'t").replace(/ \\\'m/g,"\'m").replace(/ \\\'s/g,"\'s").replace(/ \\\'ve/g,"\'ve").replace(/ \\\'re/g,"\'re")}function Sf(e){return e.replace(/\\p{M}/gu,"")}function zf(e){return e>=19968&&e<=40959||e>=13312&&e<=19903||e>=131072&&e<=173791||e>=173824&&e<=177983||e>=177984&&e<=178207||e>=178208&&e<=183983||e>=63744&&e<=64255||e>=194560&&e<=195103}const Cf="\\\\p{P}\\\\u0021-\\\\u002F\\\\u003A-\\\\u0040\\\\u005B-\\\\u0060\\\\u007B-\\\\u007E",Tf=new RegExp(`^[${Cf}]+$`,"gu"),If=".,!?",Af=new Map([["(?i:\'s|\'t|\'re|\'ve|\'m|\'ll|\'d)","(?:\'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"],[` ?[^(\\\\s|[${If}])]+`,` ?[^\\\\s${If}]+`]]);class Mf{constructor(e){this.content=e.content,this.id=e.id,this.single_word=e.single_word??!1,this.lstrip=e.lstrip??!1,this.rstrip=e.rstrip??!1,this.special=e.special??!1,this.normalized=e.normalized??null}}class Of extends j{constructor(e){super(),this.config=e,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(e,...t){switch(e.type){case"WordPiece":return new Bf(e);case"Unigram":return new Nf(e,...t);case"BPE":return new Ff(e);default:if(e.vocab)return Array.isArray(e.vocab)?new Nf(e,...t):new Lf(e,...t);throw new Error(`Unknown TokenizerModel type: ${e.type}`)}}_call(e){return e=this.encode(e),this.fuse_unk&&(e=function t(e,n,r){const s=[];let i=0;for(;i<e.length;)if(s.push(e[i]),(n.get(e[i])??r)===r)for(;++i<e.length&&(n.get(e[i])??r)===r;)n.get(s.at(-1))!==r&&(s[s.length-1]+=e[i]);else++i;return s}(e,this.tokens_to_ids,this.unk_token_id)),e}encode(e){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(e){return e.map((e=>this.tokens_to_ids.get(e)??this.unk_token_id))}convert_ids_to_tokens(e){return e.map((e=>this.vocab[e]??this.unk_token))}}class Bf extends Of{constructor(e){super(e),this.tokens_to_ids=$f(e.vocab),this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.max_input_chars_per_word=e.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e}encode(e){const t=[];for(const n of e){const e=[...n];if(e.length>this.max_input_chars_per_word){t.push(this.unk_token);continue}let r=!1,s=0;const i=[];for(;s<e.length;){let t=e.length,n=null;for(;s<t;){let r=e.slice(s,t).join("");if(s>0&&(r=this.config.continuing_subword_prefix+r),this.tokens_to_ids.has(r)){n=r;break}--t}if(null===n){r=!0;break}i.push(n),s=t}r?t.push(this.unk_token):t.push(...i)}return t}}class Nf extends Of{constructor(e,t){super(e);const n=e.vocab.length;this.vocab=new Array(n),this.scores=new Array(n);for(let t=0;t<n;++t){const n=e.vocab[t];this.vocab[t]=n[0],this.scores[t]=n[1]}this.unk_token_id=e.unk_id,this.unk_token=this.vocab[e.unk_id],this.tokens_to_ids=new Map(this.vocab.map(((e,t)=>[e,t]))),this.bos_token=" ",this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=t.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.unk_token=this.vocab[this.unk_token_id],this.minScore=me(this.scores)[0],this.unk_score=this.minScore-10,this.scores[this.unk_token_id]=this.unk_score,this.trie=new mh,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(e){const t=e.chars;let n=0;for(;n<t.length;){let r=!1;const s=[],i=t.slice(n).join(""),a=this.trie.commonPrefixSearch(i);for(const t of a){s.push(t);const i=this.tokens_to_ids.get(t),a=this.scores[i],o=ee(t);e.insert(n,o,a,i),r||1!==o||(r=!0)}r||e.insert(n,1,this.unk_score,this.unk_token_id),n+=1}}tokenize(e){const t=new gh(e,this.bos_token_id,this.eos_token_id);return this.populateNodes(t),t.tokens()}encode(e){const t=[];for(const n of e){const e=this.tokenize(n);t.push(...e)}return t}}const Pf=(()=>{const e=[...Array.from({length:"~".charCodeAt(0)-"!".charCodeAt(0)+1},((e,t)=>t+"!".charCodeAt(0))),...Array.from({length:"".charCodeAt(0)-"".charCodeAt(0)+1},((e,t)=>t+"".charCodeAt(0))),...Array.from({length:"".charCodeAt(0)-"".charCodeAt(0)+1},((e,t)=>t+"".charCodeAt(0)))],t=e.slice();let n=0;for(let r=0;r<256;++r)e.includes(r)||(e.push(r),t.push(256+n),n+=1);const r=t.map((e=>String.fromCharCode(e)));return Object.fromEntries(e.map(((e,t)=>[e,r[t]])))})(),Rf=function Df(e){return Object.fromEntries(Object.entries(e).map((([e,t])=>[t,e])))}(Pf);class Ff extends Of{constructor(e){super(e),this.tokens_to_ids=$f(e.vocab),this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e;const t=Array.isArray(e.merges[0]);this.merges=t?e.merges:e.merges.map((e=>e.split(" ",2))),this.bpe_ranks=new Map(this.merges.map(((e,t)=>[JSON.stringify(e),t]))),this.end_of_word_suffix=e.end_of_word_suffix,this.continuing_subword_suffix=e.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.cache=new Map}bpe(e){if(0===e.length)return[];const t=this.cache.get(e);if(void 0!==t)return t;const n=Array.from(e);this.end_of_word_suffix&&(n[n.length-1]+=this.end_of_word_suffix);let r=[];if(n.length>1){const e=new fh(((e,t)=>e.score<t.score));let t={token:n[0],bias:0,prev:null,next:null},s=t;for(let t=1;t<n.length;++t){const r={bias:t/n.length,token:n[t],prev:s,next:null};s.next=r,this._add_node(e,s),s=r}for(;!e.isEmpty();){const n=e.pop();if(n.deleted||!n.next||n.next.deleted)continue;if(n.deleted=!0,n.next.deleted=!0,n.prev){const e={...n.prev};n.prev.deleted=!0,n.prev=e,e.prev?e.prev.next=e:t=e}const r={token:n.token+n.next.token,bias:n.bias,prev:n.prev,next:n.next.next};r.prev?(r.prev.next=r,this._add_node(e,r.prev)):t=r,r.next&&(r.next.prev=r,this._add_node(e,r))}for(let e=t;null!==e;e=e.next)r.push(e.token)}else r=n;if(this.continuing_subword_suffix)for(let e=0;e<r.length-1;++e)r[e]+=this.continuing_subword_suffix;return this.cache.set(e,r),r}_add_node(e,t){const n=this.bpe_ranks.get(JSON.stringify([t.token,t.next.token]));void 0!==n&&(t.score=n+t.bias,e.push(t))}encode(e){const t=[];for(const n of e){if(this.ignore_merges&&this.tokens_to_ids.has(n)){t.push(n);continue}const e=this.bpe(n);for(const n of e)if(this.tokens_to_ids.has(n))t.push(n);else if(this.byte_fallback){const e=Array.from(this.text_encoder.encode(n)).map((e=>`<0x${e.toString(16).toUpperCase().padStart(2,"0")}>`));e.every((e=>this.tokens_to_ids.has(e)))?t.push(...e):t.push(this.unk_token)}else t.push(this.unk_token)}return t}}class Lf extends Of{constructor(e,t){super(e),this.tokens_to_ids=$f(t.target_lang?e.vocab[t.target_lang]:e.vocab),this.bos_token=t.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=t.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=t.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=t.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e}encode(e){return e}}class Uf extends j{constructor(e){super(),this.config=e}static fromConfig(e){if(null===e)return null;switch(e.type){case"BertNormalizer":return new Yf(e);case"Precompiled":return new $m(e);case"Sequence":return new Qf(e);case"Replace":return new qf(e);case"NFC":return new Vf(e);case"NFKC":return new Wf(e);case"NFKD":return new jf(e);case"Strip":return new Gf(e);case"StripAccents":return new Hf(e);case"Lowercase":return new Kf(e);case"Prepend":return new Xf(e);default:throw new Error(`Unknown Normalizer type: ${e.type}`)}}normalize(e){throw Error("normalize should be implemented in subclass.")}_call(e){return this.normalize(e)}}class qf extends Uf{normalize(e){const t=vf(this.config.pattern);return null===t?e:e.replaceAll(t,this.config.content)}}class Vf extends Uf{normalize(e){return e=e.normalize("NFC")}}class Wf extends Uf{normalize(e){return e=e.normalize("NFKC")}}class jf extends Uf{normalize(e){return e=e.normalize("NFKD")}}class Gf extends Uf{normalize(e){return this.config.strip_left&&this.config.strip_right?e=e.trim():(this.config.strip_left&&(e=e.trimStart()),this.config.strip_right&&(e=e.trimEnd())),e}}class Hf extends Uf{normalize(e){return e=Sf(e)}}class Kf extends Uf{normalize(e){return e=e.toLowerCase()}}class Xf extends Uf{normalize(e){return e=this.config.prepend+e}}class Qf extends Uf{constructor(e){super(e),this.normalizers=e.normalizers.map((e=>Uf.fromConfig(e)))}normalize(e){return this.normalizers.reduce(((e,t)=>t.normalize(e)),e)}}class Yf extends Uf{_tokenize_chinese_chars(e){const t=[];for(let n=0;n<e.length;++n){const r=e[n];zf(r.charCodeAt(0))?(t.push(" "),t.push(r),t.push(" ")):t.push(r)}return t.join("")}stripAccents(e){return e.normalize("NFD").replace(/\\p{Mn}/gu,"")}_is_control(e){switch(e){case"\\t":case"\\n":case"\\r":return!1;default:return/^\\p{Cc}|\\p{Cf}|\\p{Co}|\\p{Cs}$/u.test(e)}}_clean_text(e){const t=[];for(const n of e){const e=n.charCodeAt(0);0===e||65533===e||this._is_control(n)||(/^\\s$/.test(n)?t.push(" "):t.push(n))}return t.join("")}normalize(e){return this.config.clean_text&&(e=this._clean_text(e)),this.config.handle_chinese_chars&&(e=this._tokenize_chinese_chars(e)),this.config.lowercase?(e=e.toLowerCase(),!1!==this.config.strip_accents&&(e=this.stripAccents(e))):this.config.strip_accents&&(e=this.stripAccents(e)),e}}class Zf extends j{static fromConfig(e){if(null===e)return null;switch(e.type){case"BertPreTokenizer":return new Jf(e);case"Sequence":return new km(e);case"Whitespace":return new Em(e);case"WhitespaceSplit":return new Sm(e);case"Metaspace":return new xm(e);case"ByteLevel":return new em(e);case"Split":return new tm(e);case"Punctuation":return new nm(e);case"Digits":return new rm(e);case"Replace":return new zm(e);default:throw new Error(`Unknown PreTokenizer type: ${e.type}`)}}pre_tokenize_text(e,t){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(e,t){return(Array.isArray(e)?e.map((e=>this.pre_tokenize_text(e,t))):this.pre_tokenize_text(e,t)).flat()}_call(e,t){return this.pre_tokenize(e,t)}}class Jf extends Zf{constructor(e){super(),this.pattern=new RegExp(`[^\\\\s${Cf}]+|[${Cf}]`,"gu")}pre_tokenize_text(e,t){return e.trim().match(this.pattern)||[]}}class em extends Zf{constructor(e){super(),this.config=e,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=/\'s|\'t|\'re|\'ve|\'m|\'ll|\'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+/gu,this.byte_encoder=Pf,this.text_encoder=new TextEncoder}pre_tokenize_text(e,t){this.add_prefix_space&&!e.startsWith(" ")&&(e=" "+e);return(this.use_regex?e.match(this.pattern)||[]:[e]).map((e=>Array.from(this.text_encoder.encode(e),(e=>this.byte_encoder[e])).join("")))}}class tm extends Zf{constructor(e){super(),this.config=e,this.pattern=vf(this.config.pattern,this.config.invert)}pre_tokenize_text(e,t){return null===this.pattern?[]:this.config.invert?e.match(this.pattern)||[]:"removed"===this.config.behavior?.toLowerCase()?e.split(this.pattern).filter((e=>e)):function n(e,t){const n=[];let r=0;for(const s of e.matchAll(t)){const t=s[0];r<s.index&&n.push(e.slice(r,s.index)),t.length>0&&n.push(t),r=s.index+t.length}return r<e.length&&n.push(e.slice(r)),n}(e,this.pattern)}}class nm extends Zf{constructor(e){super(),this.config=e,this.pattern=new RegExp(`[^${Cf}]+|[${Cf}]+`,"gu")}pre_tokenize_text(e,t){return e.match(this.pattern)||[]}}class rm extends Zf{constructor(e){super(),this.config=e;const t="[^\\\\d]+|\\\\d"+(this.config.individual_digits?"":"+");this.pattern=new RegExp(t,"gu")}pre_tokenize_text(e,t){return e.match(this.pattern)||[]}}class sm extends j{constructor(e){super(),this.config=e}static fromConfig(e){if(null===e)return null;switch(e.type){case"TemplateProcessing":return new om(e);case"ByteLevel":return new lm(e);case"RobertaProcessing":return new am(e);case"BertProcessing":return new im(e);case"Sequence":return new um(e);default:throw new Error(`Unknown PostProcessor type: ${e.type}`)}}post_process(e,...t){throw Error("post_process should be implemented in subclass.")}_call(e,...t){return this.post_process(e,...t)}}class im extends sm{constructor(e){super(e),this.cls=e.cls[0],this.sep=e.sep[0]}post_process(e,t=null,{add_special_tokens:n=!0}={}){n&&(e=Q([this.cls],e,[this.sep]));let r=new Array(e.length).fill(0);if(null!==t){const s=n&&this instanceof am?[this.sep]:[],i=n?[this.sep]:[];e=Q(e,s,t,i),r=Q(r,new Array(t.length+s.length+i.length).fill(1))}return{tokens:e,token_type_ids:r}}}class am extends im{}class om extends sm{constructor(e){super(e),this.single=e.single,this.pair=e.pair}post_process(e,t=null,{add_special_tokens:n=!0}={}){const r=null===t?this.single:this.pair;let s=[],i=[];for(const a of r)"SpecialToken"in a?n&&(s.push(a.SpecialToken.id),i.push(a.SpecialToken.type_id)):"Sequence"in a&&("A"===a.Sequence.id?(s=Q(s,e),i=Q(i,new Array(e.length).fill(a.Sequence.type_id))):"B"===a.Sequence.id&&(s=Q(s,t),i=Q(i,new Array(t.length).fill(a.Sequence.type_id))));return{tokens:s,token_type_ids:i}}}class lm extends sm{post_process(e,t=null){return t&&(e=Q(e,t)),{tokens:e}}}class um extends sm{constructor(e){super(e),this.processors=e.processors.map((e=>sm.fromConfig(e)))}post_process(e,t=null,n={}){let r;for(const s of this.processors)if(s instanceof lm){if(e=s.post_process(e).tokens,t){t=s.post_process(t).tokens}}else{const i=s.post_process(e,t,n);e=i.tokens,r=i.token_type_ids}return{tokens:e,token_type_ids:r}}}class dm extends j{constructor(e){super(),this.config=e,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=e.trim_offsets}static fromConfig(e){if(null===e)return null;switch(e.type){case"WordPiece":return new mm(e);case"Metaspace":return new vm(e);case"ByteLevel":return new _m(e);case"Replace":return new cm(e);case"ByteFallback":return new pm(e);case"Fuse":return new hm(e);case"Strip":return new fm(e);case"Sequence":return new wm(e);case"CTC":return new gm(e);case"BPEDecoder":return new ym(e);default:throw new Error(`Unknown Decoder type: ${e.type}`)}}_call(e){return this.decode(e)}decode(e){return this.decode_chain(e).join("")}decode_chain(e){throw Error("`decode_chain` should be implemented in subclass.")}}class cm extends dm{decode_chain(e){const t=vf(this.config.pattern);return null===t?e:e.map((e=>e.replaceAll(t,this.config.content)))}}class pm extends dm{constructor(e){super(e),this.text_decoder=new TextDecoder}decode_chain(e){const t=[];let n=[];for(const r of e){let e=null;if(6===r.length&&r.startsWith("<0x")&&r.endsWith(">")){const t=parseInt(r.slice(3,5),16);isNaN(t)||(e=t)}if(null!==e)n.push(e);else{if(n.length>0){const e=this.text_decoder.decode(Uint8Array.from(n));t.push(e),n=[]}t.push(r)}}if(n.length>0){const e=this.text_decoder.decode(Uint8Array.from(n));t.push(e),n=[]}return t}}class hm extends dm{decode_chain(e){return[e.join("")]}}class fm extends dm{constructor(e){super(e),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(e){return e.map((e=>{let t=0;for(let n=0;n<this.start&&e[n]===this.content;++n)t=n+1;let n=e.length;for(let t=0;t<this.stop;++t){const r=e.length-t-1;if(e[r]!==this.content)break;n=r}return e.slice(t,n)}))}}class mm extends dm{constructor(e){super(e),this.cleanup=e.cleanup}decode_chain(e){return e.map(((e,t)=>(0!==t&&(e=e.startsWith(this.config.prefix)?e.replace(this.config.prefix,""):" "+e),this.cleanup&&(e=Ef(e)),e)))}}class _m extends dm{constructor(e){super(e),this.byte_decoder=Rf,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(e){const t=e.join(""),n=new Uint8Array([...t].map((e=>this.byte_decoder[e])));return this.text_decoder.decode(n)}decode_chain(e){const t=[];let n=[];for(const r of e)void 0!==this.added_tokens.find((e=>e.content===r))?(n.length>0&&(t.push(this.convert_tokens_to_string(n)),n=[]),t.push(r)):n.push(r);return n.length>0&&t.push(this.convert_tokens_to_string(n)),t}}class gm extends dm{constructor(e){super(e),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(e){if(0===e.length)return"";const t=[e[0]];for(let n=1;n<e.length;++n)e[n]!==t.at(-1)&&t.push(e[n]);let n=t.filter((e=>e!==this.pad_token)).join("");return this.cleanup&&(n=Ef(n).replaceAll(this.word_delimiter_token," ").trim()),n}decode_chain(e){return[this.convert_tokens_to_string(e)]}}class wm extends dm{constructor(e){super(e),this.decoders=e.decoders.map((e=>dm.fromConfig(e)))}decode_chain(e){return this.decoders.reduce(((e,t)=>t.decode_chain(e)),e)}}class ym extends dm{constructor(e){super(e),this.suffix=this.config.suffix}decode_chain(e){return e.map(((t,n)=>t.replaceAll(this.suffix,n===e.length-1?"":" ")))}}class bm extends dm{decode_chain(e){let t="";for(let n=1;n<e.length;n+=2)t+=e[n];return[t]}}class xm extends Zf{constructor(e){super(),this.addPrefixSpace=e.add_prefix_space,this.replacement=e.replacement,this.strRep=e.str_rep||this.replacement,this.prepend_scheme=e.prepend_scheme??"always"}pre_tokenize_text(e,{section_index:t}={}){let n=e.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!n.startsWith(this.replacement)&&("always"===this.prepend_scheme||"first"===this.prepend_scheme&&0===t)&&(n=this.strRep+n),[n]}}class vm extends dm{constructor(e){super(e),this.addPrefixSpace=e.add_prefix_space,this.replacement=e.replacement}decode_chain(e){const t=[];for(let n=0;n<e.length;++n){let r=e[n].replaceAll(this.replacement," ");this.addPrefixSpace&&0==n&&r.startsWith(" ")&&(r=r.substring(1)),t.push(r)}return t}}class $m extends Uf{constructor(e){super(e),this.charsmap=e.precompiled_charsmap}normalize(e){if((e=(e=e.replace(/[\\u0001-\\u0008\\u000B\\u000E-\\u001F\\u007F\\u008F\\u009F]/gm,"")).replace(/[\\u0009\\u000A\\u000C\\u000D\\u00A0\\u1680\\u2000-\\u200F\\u2028\\u2029\\u202F\\u205F\\u2581\\u3000\\uFEFF\\uFFFD]/gm," ")).includes("")){const t=e.split("");e=t.map((e=>e.normalize("NFKC"))).join("")}else e=e.normalize("NFKC");return e}}class km extends Zf{constructor(e){super(),this.tokenizers=e.pretokenizers.map((e=>Zf.fromConfig(e)))}pre_tokenize_text(e,t){return this.tokenizers.reduce(((e,n)=>n.pre_tokenize(e,t)),[e])}}class Em extends Zf{constructor(e){super()}pre_tokenize_text(e,t){return e.match(/\\w+|[^\\w\\s]+/g)||[]}}class Sm extends Zf{constructor(e){super()}pre_tokenize_text(e,t){return function n(e){return e.match(/\\S+/g)||[]}(e)}}class zm extends Zf{constructor(e){super(),this.config=e,this.pattern=vf(this.config.pattern),this.content=this.config.content}pre_tokenize_text(e,t){return null===this.pattern?[e]:[e.replaceAll(this.pattern,this.config.content)]}}const Cm=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function Tm(e,t,n,r){for(const s of Object.keys(e)){const i=t-e[s].length,a=n(s),o=new Array(i).fill(a);e[s]="right"===r?Q(e[s],o):Q(o,e[s])}}function Im(e,t){for(const n of Object.keys(e))e[n].length=t}class Am extends j{return_token_type_ids=!1;padding_side="right";constructor(e,t){super(),this._tokenizer_config=t,this.normalizer=Uf.fromConfig(e.normalizer),this.pre_tokenizer=Zf.fromConfig(e.pre_tokenizer),this.model=Of.fromConfig(e.model,t),this.post_processor=sm.fromConfig(e.post_processor),this.decoder=dm.fromConfig(e.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const t of e.added_tokens){const e=new Mf(t);this.added_tokens.push(e),this.model.tokens_to_ids.set(e.content,e.id),this.model.vocab[e.id]=e.content,e.special&&(this.special_tokens.push(e.content),this.all_special_ids.push(e.id))}if(this.additional_special_tokens=t.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_regex=this.added_tokens.length>0?new RegExp(this.added_tokens.slice().sort(((e,t)=>t.content.length-e.content.length)).map((e=>`${e.lstrip?"\\\\s*":""}(${H(e.content)})${e.rstrip?"\\\\s*":""}`)).join("|")):null,this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.bos_token=this.getToken("bos_token"),this.bos_token_id=this.model.tokens_to_ids.get(this.bos_token),this.eos_token=this.getToken("eos_token"),this.eos_token_id=this.model.tokens_to_ids.get(this.eos_token),this.model_max_length=t.model_max_length,this.remove_space=t.remove_space,this.clean_up_tokenization_spaces=t.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=t.do_lowercase_and_remove_accent??!1,t.padding_side&&(this.padding_side=t.padding_side),this.legacy=!1,this.chat_template=t.chat_template??null,Array.isArray(this.chat_template)){const e=Object.create(null);for(const{name:t,template:n}of this.chat_template){if("string"!=typeof t||"string"!=typeof n)throw new Error(\'Chat template must be a list of objects with "name" and "template" properties\');e[t]=n}this.chat_template=e}this._compiled_template_cache=new Map}getToken(...e){for(const t of e){const e=this._tokenizer_config[t];if(e){if("object"==typeof e){if("AddedToken"===e.__type)return e.content;throw Error(`Unknown token: ${e}`)}return e}}return null}static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:i="main",legacy:a=null}={}){return new this(...await xf(e,{progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:i,legacy:a}))}_call(e,{text_pair:t=null,add_special_tokens:n=!0,padding:r=!1,truncation:s=null,max_length:i=null,return_tensor:a=!0,return_token_type_ids:o=null}={}){const l=Array.isArray(e);let u;if(l){if(0===e.length)throw Error("text array must be non-empty");if(null!==t){if(!Array.isArray(t))throw Error("text_pair must also be an array");if(e.length!==t.length)throw Error("text and text_pair must have the same length");u=e.map(((e,r)=>this._encode_plus(e,{text_pair:t[r],add_special_tokens:n,return_token_type_ids:o})))}else u=e.map((e=>this._encode_plus(e,{add_special_tokens:n,return_token_type_ids:o})))}else{if(null==e)throw Error("text may not be null or undefined");if(Array.isArray(t))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");u=[this._encode_plus(e,{text_pair:t,add_special_tokens:n,return_token_type_ids:o})]}if(null===i?i="max_length"===r?this.model_max_length:_e(u.map((e=>e.input_ids.length)))[0]:s||console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=true` to explicitly truncate examples to max length."),i=Math.min(i,this.model_max_length??Infinity),r||s)for(let e=0;e<u.length;++e)u[e].input_ids.length!==i&&(u[e].input_ids.length>i?s&&Im(u[e],i):r&&Tm(u[e],i,(e=>"input_ids"===e?this.pad_token_id:0),this.padding_side));const d={};if(a){if((!r||!s)&&u.some((e=>{for(const t of Object.keys(e))if(e[t].length!==u[0][t]?.length)return!0;return!1})))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with \'padding=true\' and \'truncation=true\' to have batched tensors with the same length.");const e=[u.length,u[0].input_ids.length];for(const t of Object.keys(u[0]))d[t]=new Xp("int64",BigInt64Array.from(u.flatMap((e=>e[t])).map(BigInt)),e)}else{for(const e of Object.keys(u[0]))d[e]=u.map((t=>t[e]));if(!l)for(const e of Object.keys(d))d[e]=d[e][0]}return d}_encode_text(e){if(null===e)return null;const t=(this.added_tokens_regex?e.split(this.added_tokens_regex).filter((e=>e)):[e]).map(((e,t)=>{const n=this.added_tokens.find((t=>t.content===e));if(void 0!==n)return e;{if(!0===this.remove_space&&(e=e.trim().split(/\\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(e=function n(e){return Sf(e.toLowerCase())}(e)),null!==this.normalizer&&(e=this.normalizer(e)),0===e.length)return[];const r=null!==this.pre_tokenizer?this.pre_tokenizer(e,{section_index:t}):[e];return this.model(r)}})).flat();return t}_encode_plus(e,{text_pair:t=null,add_special_tokens:n=!0,return_token_type_ids:r=null}={}){const{tokens:s,token_type_ids:i}=this._tokenize_helper(e,{pair:t,add_special_tokens:n}),a=this.model.convert_tokens_to_ids(s),o={input_ids:a,attention_mask:new Array(a.length).fill(1)};return(r??this.return_token_type_ids)&&i&&(o.token_type_ids=i),o}_tokenize_helper(e,{pair:t=null,add_special_tokens:n=!1}={}){const r=this._encode_text(e),s=this._encode_text(t);return this.post_processor?this.post_processor(r,s,{add_special_tokens:n}):{tokens:Q(r??[],s??[])}}tokenize(e,{pair:t=null,add_special_tokens:n=!1}={}){return this._tokenize_helper(e,{pair:t,add_special_tokens:n}).tokens}encode(e,{text_pair:t=null,add_special_tokens:n=!0,return_token_type_ids:r=null}={}){return this._encode_plus(e,{text_pair:t,add_special_tokens:n,return_token_type_ids:r}).input_ids}batch_decode(e,t={}){return e instanceof Xp&&(e=e.tolist()),e.map((e=>this.decode(e,t)))}decode(e,t={}){if(e instanceof Xp&&(e=kf(e)),!Array.isArray(e)||0===e.length||!function n(e){return Number.isInteger(e)||"bigint"==typeof e}(e[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(e,t)}decode_single(e,{skip_special_tokens:t=!1,clean_up_tokenization_spaces:n=null}){let r=this.model.convert_ids_to_tokens(e);t&&(r=r.filter((e=>!this.special_tokens.includes(e))));let s=this.decoder?this.decoder(r):r.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(s=s.replaceAll(this.decoder.end_of_word_suffix," "),t&&(s=s.trim())),(n??this.clean_up_tokenization_spaces)&&(s=Ef(s)),s}get_chat_template({chat_template:e=null,tools:t=null}={}){if(this.chat_template&&"object"==typeof this.chat_template){const n=this.chat_template;if(null!==e&&Object.hasOwn(n,e))e=n[e];else if(null===e)if(null!==t&&"tool_use"in n)e=n.tool_use;else{if(!("default"in n))throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the \'chat_template\' argument. Available template names are ${Object.keys(n).sort()}.`);e=n.default}}else if(null===e){if(!this.chat_template)throw Error("Cannot use apply_chat_template() because tokenizer.chat_template is not set and no template argument was passed! For information about writing templates and setting the tokenizer.chat_template attribute, please see the documentation at https://huggingface.co/docs/transformers/main/en/chat_templating");e=this.chat_template}return e}apply_chat_template(e,{tools:t=null,documents:n=null,chat_template:r=null,add_generation_prompt:s=!1,tokenize:i=!0,padding:a=!1,truncation:o=!1,max_length:l=null,return_tensor:u=!0,return_dict:d=!1,tokenizer_kwargs:c={},...p}={}){if("string"!=typeof(r=this.get_chat_template({chat_template:r,tools:t})))throw Error("chat_template must be a string, but got "+typeof r);let h=this._compiled_template_cache.get(r);void 0===h&&(h=new gf(r),this._compiled_template_cache.set(r,h));const f=Object.create(null);for(const e of Cm){const t=this.getToken(e);t&&(f[e]=t)}const m=h.render({messages:e,add_generation_prompt:s,tools:t,documents:n,...f,...p});if(i){const e=this._call(m,{add_special_tokens:!1,padding:a,truncation:o,max_length:l,return_tensor:u,...c});return d?e:e.input_ids}return m}}class Mm extends Am{return_token_type_ids=!0}class Om extends Am{return_token_type_ids=!0}class Bm extends Am{return_token_type_ids=!0}class Nm extends Am{return_token_type_ids=!0}class Pm extends Am{return_token_type_ids=!0}class Rm extends Am{return_token_type_ids=!0}class Dm extends Am{return_token_type_ids=!0}class Fm extends Am{return_token_type_ids=!0}class Lm extends Am{return_token_type_ids=!0}class Um extends Am{}class qm extends Am{}class Vm extends Am{return_token_type_ids=!0;constructor(e,t){super(e,t),console.warn(\'WARNING: `XLMTokenizer` is not yet supported by Hugging Face\\\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.\')}}class Wm extends Am{return_token_type_ids=!0}class jm extends Am{}class Gm extends Am{}class Hm extends Am{}class Km extends Am{constructor(e,t){super(e,t),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter((e=>this.languageRegex.test(e))),this.lang_to_token=e=>e}_build_translation_inputs(e,t,n){return u_(this,e,t,n)}}class Xm extends Km{}class Qm extends Am{}class Ym extends Am{}const Zm="";class Jm extends Am{padding_side="left";constructor(e,t){super(e,t),this.legacy=t.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new xm({replacement:Zm,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(e){if(null===e)return null;if(this.legacy||0===e.length)return super._encode_text(e);let t=super._encode_text(Zm+e.replaceAll(Zm," "));return t.length>1&&t[0]===Zm&&this.special_tokens.includes(t[1])&&(t=t.slice(1)),t}}class e_ extends Am{}class t_ extends Am{}class n_ extends Am{}class r_ extends Am{}class s_ extends Am{}class i_ extends Am{}class a_ extends Am{}class o_ extends Am{}class l_ extends Am{}function u_(e,t,n,r){if(!("language_codes"in e)||!Array.isArray(e.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in e&&e.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in e)||"function"!=typeof e.lang_to_token)throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const s=r.src_lang,i=r.tgt_lang;if(!e.language_codes.includes(i))throw new Error(`Target language code "${i}" is not valid. Must be one of: {${e.language_codes.join(", ")}}`);if(void 0!==s){if(!e.language_codes.includes(s))throw new Error(`Source language code "${s}" is not valid. Must be one of: {${e.language_codes.join(", ")}}`);for(const t of e.post_processor.config.single)if("SpecialToken"in t&&e.languageRegex.test(t.SpecialToken.id)){t.SpecialToken.id=e.lang_to_token(s);break}}return r.forced_bos_token_id=e.model.convert_tokens_to_ids([e.lang_to_token(i)])[0],e._call(t,n)}class d_ extends Am{constructor(e,t){super(e,t),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter((e=>this.languageRegex.test(e))),this.lang_to_token=e=>e}_build_translation_inputs(e,t,n){return u_(this,e,t,n)}}class c_ extends Am{constructor(e,t){super(e,t),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter((e=>this.languageRegex.test(e))).map((e=>e.slice(2,-2))),this.lang_to_token=e=>`__${e}__`}_build_translation_inputs(e,t,n){return u_(this,e,t,n)}}class p_ extends Am{get timestamp_begin(){return this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1}_decode_asr(e,{return_timestamps:t=!1,return_language:n=!1,time_precision:r=null,force_full_sequences:s=!0}={}){if(null===r)throw Error("Must specify time_precision");let i=null;const a="word"===t;function o(){return{language:i,timestamp:[null,null],text:""}}const l=[];let u=o(),d=0;const c=this.timestamp_begin,p=c+1500;let h=[],f=[],m=!1,_=null;const g=new Set(this.all_special_ids);for(const n of e){const e=n.tokens,s=a?n.token_timestamps:null;let w=null,y=c;if("stride"in n){const[t,s,i]=n.stride;if(d-=s,_=t-i,s&&(y=s/r+c),i)for(let t=e.length-1;t>=0;--t){const n=Number(e[t]);if(n>=c){if(null!==w&&(n-c)*r<_)break;w=n}}}let b=[],x=[];for(let n=0;n<e.length;++n){const _=Number(e[n]);if(g.has(_)){const e=this.decode([_]),n=yf.get(e.slice(2,-2));if(void 0!==n){if(null!==i&&n!==i&&!t){h.push(b);const e=this.findLongestCommonSequence(h)[0],t=this.decode(e);u.text=t,l.push(u),h=[],b=[],u=o()}i=u.language=n}}else if(_>=c&&_<=p){const e=ve((_-c)*r+d,2);if(null!==w&&_>=w)m=!0;else if(m||h.length>0&&_<y)m=!1;else if(null===u.timestamp[0])u.timestamp[0]=e;else if(e===u.timestamp[0]);else{u.timestamp[1]=e,h.push(b),a&&f.push(x);const[t,n]=this.findLongestCommonSequence(h,f),r=this.decode(t);u.text=r,a&&(u.words=this.collateWordTimestamps(t,n,i)),l.push(u),h=[],b=[],f=[],x=[],u=o()}}else if(b.push(_),a){let e,t=ve(s[n]+d,2);if(n+1<s.length){e=ve(s[n+1]+d,2);const i=this.decode([_]);Tf.test(i)&&(e=ve(Math.min(t+r,e),2))}else e=null;x.push([t,e])}}if("stride"in n){const[e,t,r]=n.stride;d+=e-r}b.length>0?(h.push(b),a&&f.push(x)):h.every((e=>0===e.length))&&(u=o(),h=[],b=[],f=[],x=[])}if(h.length>0){if(s&&t)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[e,n]=this.findLongestCommonSequence(h,f),r=this.decode(e);u.text=r,a&&(u.words=this.collateWordTimestamps(e,n,i)),l.push(u)}let w=Object.create(null);const y=l.map((e=>e.text)).join("");if(t||n){for(let e=0;e<l.length;++e){const r=l[e];t||delete r.timestamp,n||delete r.language}if(a){const e=[];for(const t of l)for(const n of t.words)e.push(n);w={chunks:e}}else w={chunks:l}}return[y,w]}findLongestCommonSequence(e,t=null){let n=e[0],r=n.length,s=[];const i=Array.isArray(t)&&t.length>0;let a=i?[]:null,o=i?t[0]:null;for(let l=1;l<e.length;++l){const u=e[l];let d=0,c=[r,r,0,0];const p=u.length;for(let e=1;e<r+p;++e){const s=Math.max(0,r-e),a=Math.min(r,r+p-e),h=n.slice(s,a),f=Math.max(0,e-r),m=Math.min(p,e),_=u.slice(f,m);if(h.length!==_.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");let g;g=i?h.filter(((e,n)=>e===_[n]&&o[s+n]<=t[l][f+n])).length:h.filter(((e,t)=>e===_[t])).length;const w=g/e+e/1e4;g>1&&w>d&&(d=w,c=[s,a,f,m])}const[h,f,m,_]=c,g=Math.floor((f+h)/2),w=Math.floor((_+m)/2);s.push(...n.slice(0,g)),n=u.slice(w),r=n.length,i&&(a.push(...o.slice(0,g)),o=t[l].slice(w))}return s.push(...n),i?(a.push(...o),[s,a]):[s,[]]}collateWordTimestamps(e,t,n){const[r,s,i]=this.combineTokensIntoWords(e,n),a=[];for(let e=0;e<r.length;++e){const n=i[e];a.push({text:r[e],timestamp:[t[n.at(0)][0],t[n.at(-1)][1]]})}return a}combineTokensIntoWords(e,t,n="\\"\'([{-",r="\\"\'.,!?:)]}"){let s,i,a;return["chinese","japanese","thai","lao","myanmar"].includes(t=t??"english")?[s,i,a]=this.splitTokensOnUnicode(e):[s,i,a]=this.splitTokensOnSpaces(e),this.mergePunctuations(s,i,a,n,r)}decode(e,t){let n;return t?.decode_with_timestamps?(e instanceof Xp&&(e=kf(e)),n=this.decodeWithTimestamps(e,t)):n=super.decode(e,t),n}decodeWithTimestamps(e,t){const n=t?.time_precision??.02,r=Array.from(this.all_special_ids).at(-1)+1;let s=[[]];for(let t of e)if(t=Number(t),t>=r){const e=((t-r)*n).toFixed(2);s.push(`<|${e}|>`),s.push([])}else s[s.length-1].push(t);return s=s.map((e=>"string"==typeof e?e:super.decode(e,t))),s.join("")}splitTokensOnUnicode(e){const t=this.decode(e,{decode_with_timestamps:!0}),n=[],r=[],s=[];let i=[],a=[],o=0;for(let l=0;l<e.length;++l){const u=e[l];i.push(u),a.push(l);const d=this.decode(i,{decode_with_timestamps:!0});d.includes("")&&""!==t[o+d.indexOf("")]||(n.push(d),r.push(i),s.push(a),i=[],a=[],o+=d.length)}return[n,r,s]}splitTokensOnSpaces(e){const[t,n,r]=this.splitTokensOnUnicode(e),s=[],i=[],a=[],o=new RegExp(`^[${Cf}]$`,"gu");for(let e=0;e<t.length;++e){const l=t[e],u=n[e],d=r[e],c=u[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),p=l.startsWith(" "),h=l.trim(),f=o.test(h);if(c||p||f||0===s.length)s.push(l),i.push(u),a.push(d);else{const e=s.length-1;s[e]+=l,i[e].push(...u),a[e].push(...d)}}return[s,i,a]}mergePunctuations(e,t,n,r,s){const i=structuredClone(e),a=structuredClone(t),o=structuredClone(n);let l=i.length-2,u=i.length-1;for(;l>=0;)i[l].startsWith(" ")&&r.includes(i[l].trim())?(i[u]=i[l]+i[u],a[u]=Q(a[l],a[u]),o[u]=Q(o[l],o[u]),i[l]="",a[l]=[],o[l]=[]):u=l,--l;for(l=0,u=1;u<i.length;)!i[l].endsWith(" ")&&s.includes(i[u])?(i[l]+=i[u],a[l]=Q(a[l],a[u]),o[l]=Q(o[l],o[u]),i[u]="",a[u]=[],o[u]=[]):l=u,++u;return[i.filter((e=>e)),a.filter((e=>e.length>0)),o.filter((e=>e.length>0))]}}class h_ extends Am{}class f_ extends Am{}class m_ extends Am{}class __ extends Am{constructor(e,t){super(e,t),this.languageRegex=/^(>>\\w+<<)\\s*/g,this.supported_language_codes=this.model.vocab.filter((e=>this.languageRegex.test(e))),console.warn(\'WARNING: `MarianTokenizer` is not yet supported by Hugging Face\\\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.\')}_encode_text(e){if(null===e)return null;const[t,...n]=e.trim().split(this.languageRegex);if(0===n.length)return super._encode_text(t);if(2===n.length){const[e,t]=n;return this.supported_language_codes.includes(e)||console.warn(`Unsupported language code "${e}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),Q([e],super._encode_text(t))}}}class g_ extends Am{}class w_ extends Am{}class y_ extends Am{}class b_ extends Am{}class x_ extends Am{}class v_ extends Am{constructor(e,t){super(e,t),this.decoder=new bm({})}}class $_ extends Am{}class k_ extends Am{}class E_{static TOKENIZER_CLASS_MAPPING={T5Tokenizer:jm,DistilBertTokenizer:Um,CamembertTokenizer:qm,DebertaTokenizer:Pm,DebertaV2Tokenizer:Rm,BertTokenizer:Mm,HerbertTokenizer:Dm,ConvBertTokenizer:Fm,RoFormerTokenizer:Lm,XLMTokenizer:Vm,ElectraTokenizer:Wm,MobileBertTokenizer:Bm,SqueezeBertTokenizer:Nm,AlbertTokenizer:Om,GPT2Tokenizer:Gm,BartTokenizer:Hm,MBartTokenizer:Km,MBart50Tokenizer:Xm,RobertaTokenizer:Qm,WhisperTokenizer:p_,CodeGenTokenizer:h_,CLIPTokenizer:f_,SiglipTokenizer:m_,MarianTokenizer:__,BloomTokenizer:Ym,NllbTokenizer:d_,M2M100Tokenizer:c_,LlamaTokenizer:Jm,CodeLlamaTokenizer:e_,XLMRobertaTokenizer:t_,MPNetTokenizer:n_,FalconTokenizer:r_,GPTNeoXTokenizer:s_,EsmTokenizer:i_,Wav2Vec2CTCTokenizer:g_,BlenderbotTokenizer:w_,BlenderbotSmallTokenizer:y_,SpeechT5Tokenizer:b_,NougatTokenizer:x_,VitsTokenizer:v_,Qwen2Tokenizer:a_,GemmaTokenizer:o_,Grok1Tokenizer:l_,CohereTokenizer:$_,MgpstrTokenizer:k_,PreTrainedTokenizer:Am};static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:i="main",legacy:a=null}={}){const[o,l]=await xf(e,{progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:i,legacy:a}),u=l.tokenizer_class?.replace(/Fast$/,"")??"PreTrainedTokenizer";let d=this.TOKENIZER_CLASS_MAPPING[u];return d||(console.warn(`Unknown tokenizer class "${u}", attempting to construct from base class.`),d=Am),new d(o,l)}}function S_(e){const t={};let n={};switch(e.model_type){case"llava":case"paligemma":case"florence2":case"llava_onevision":case"idefics3":n=S_(e.text_config);break;case"moondream1":n=S_(e.phi_config);break;case"musicgen":n=S_(e.decoder);break;case"multi_modality":n=S_(e.language_config);break;case"gpt2":case"gptj":case"jais":case"codegen":case"gpt_bigcode":t.num_heads="n_head",t.num_layers="n_layer",t.hidden_size="n_embd";break;case"gpt_neox":case"stablelm":case"opt":case"falcon":t.num_heads="num_attention_heads",t.num_layers="num_hidden_layers",t.hidden_size="hidden_size";break;case"llama":case"olmo":case"olmo2":case"mobilellm":case"granite":case"cohere":case"mistral":case"starcoder2":case"qwen2":case"qwen2_vl":case"phi":case"phi3":case"phi3_v":t.num_heads="num_key_value_heads",t.num_layers="num_hidden_layers",t.hidden_size="hidden_size",t.num_attention_heads="num_attention_heads";break;case"gemma":case"gemma2":t.num_heads="num_key_value_heads",t.num_layers="num_hidden_layers",t.dim_kv="head_dim";break;case"openelm":t.num_heads="num_kv_heads",t.num_layers="num_transformer_layers",t.dim_kv="head_dim";break;case"gpt_neo":case"donut-swin":t.num_heads="num_heads",t.num_layers="num_layers",t.hidden_size="hidden_size";break;case"bloom":t.num_heads="n_head",t.num_layers="n_layer",t.hidden_size="hidden_size";break;case"mpt":t.num_heads="n_heads",t.num_layers="n_layers",t.hidden_size="d_model";break;case"exaone":t.num_heads="num_key_value_heads",t.num_layers="num_layers",t.dim_kv="head_dim",t.num_attention_heads="num_attention_heads";break;case"t5":case"mt5":case"longt5":t.num_decoder_layers="num_decoder_layers",t.num_decoder_heads="num_heads",t.decoder_dim_kv="d_kv",t.num_encoder_layers="num_layers",t.num_encoder_heads="num_heads",t.encoder_dim_kv="d_kv";break;case"bart":case"mbart":case"marian":case"whisper":case"m2m_100":case"blenderbot":case"blenderbot-small":case"florence2_language":t.num_decoder_layers="decoder_layers",t.num_decoder_heads="decoder_attention_heads",t.decoder_hidden_size="d_model",t.num_encoder_layers="encoder_layers",t.num_encoder_heads="encoder_attention_heads",t.encoder_hidden_size="d_model";break;case"speecht5":t.num_decoder_layers="decoder_layers",t.num_decoder_heads="decoder_attention_heads",t.decoder_hidden_size="hidden_size",t.num_encoder_layers="encoder_layers",t.num_encoder_heads="encoder_attention_heads",t.encoder_hidden_size="hidden_size";break;case"trocr":t.num_encoder_layers=t.num_decoder_layers="decoder_layers",t.num_encoder_heads=t.num_decoder_heads="decoder_attention_heads",t.encoder_hidden_size=t.decoder_hidden_size="d_model";break;case"musicgen_decoder":case"moonshine":t.num_encoder_layers=t.num_decoder_layers="num_hidden_layers",t.num_encoder_heads=t.num_decoder_heads="num_attention_heads",t.encoder_hidden_size=t.decoder_hidden_size="hidden_size";break;case"vision-encoder-decoder":const r=S_(e.decoder),s="num_decoder_layers"in r,i=J(e,["model_type","is_encoder_decoder"]);return s?(i.num_decoder_layers=r.num_decoder_layers,i.num_decoder_heads=r.num_decoder_heads,i.decoder_hidden_size=r.decoder_hidden_size,i.num_encoder_layers=r.num_encoder_layers,i.num_encoder_heads=r.num_encoder_heads,i.encoder_hidden_size=r.encoder_hidden_size):(i.num_layers=r.num_layers,i.num_heads=r.num_heads,i.hidden_size=r.hidden_size),i}const r={...n,...J(e,["model_type","multi_query","is_encoder_decoder"])};for(const n in t)r[n]=e[t[n]];return r}function z_(e,{prefix:t="past_key_values",batch_size:n=1}={}){const r={},s=e.normalized_config;if(s.is_encoder_decoder&&"num_encoder_heads"in s&&"num_decoder_heads"in s){const e=s.encoder_dim_kv??s.encoder_hidden_size/s.num_encoder_heads,i=s.decoder_dim_kv??s.decoder_hidden_size/s.num_decoder_heads,a=[n,s.num_encoder_heads,0,e],o=[n,s.num_decoder_heads,0,i];for(let e=0;e<s.num_decoder_layers;++e)r[`${t}.${e}.encoder.key`]=a,r[`${t}.${e}.encoder.value`]=a,r[`${t}.${e}.decoder.key`]=o,r[`${t}.${e}.decoder.value`]=o}else{const e=s.num_heads,i=s.num_layers,a=s.dim_kv??s.hidden_size/(s.num_attention_heads??e);if("falcon"===s.model_type){const s=[n*e,0,a];for(let e=0;e<i;++e)r[`${t}.${e}.key`]=s,r[`${t}.${e}.value`]=s}else if(s.multi_query){const s=[n*e,0,2*a];for(let e=0;e<i;++e)r[`${t}.${e}.key_value`]=s}else if("bloom"===s.model_type){const s=[n*e,a,0],o=[n*e,0,a];for(let e=0;e<i;++e)r[`${t}.${e}.key`]=s,r[`${t}.${e}.value`]=o}else if("openelm"===s.model_type)for(let s=0;s<i;++s){const i=[n,e[s],0,a];r[`${t}.${s}.key`]=i,r[`${t}.${s}.value`]=i}else{const s=[n,e,0,a];for(let e=0;e<i;++e)r[`${t}.${e}.key`]=s,r[`${t}.${e}.value`]=s}}return r}class C_{model_type=null;is_encoder_decoder=!1;max_position_embeddings;"transformers.js_config";constructor(e){Object.assign(this,e),this.normalized_config=S_(this)}static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:i="main"}={}){!n||n instanceof C_||(n=new C_(n));const a=n??await async function o(e,t){return await ce(e,"config.json",!0,t)}(e,{progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:i});return new this(a)}}class T_{static async from_pretrained(...e){return C_.from_pretrained(...e)}}const I_=Object.freeze({auto:"auto",gpu:"gpu",cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:"webnn","webnn-npu":"webnn-npu","webnn-gpu":"webnn-gpu","webnn-cpu":"webnn-cpu"}),A_=function(){let e;return async function(){if(void 0===e)if(D.IS_WEBGPU_AVAILABLE)try{const t=await navigator.gpu.requestAdapter();e=t.features.has("shader-f16")}catch(t){e=!1}else e=!1;return e}}(),M_=Object.freeze({auto:"auto",fp32:"fp32",fp16:"fp16",q8:"q8",int8:"int8",uint8:"uint8",q4:"q4",bnb4:"bnb4",q4f16:"q4f16"}),O_=Object.freeze({[I_.wasm]:M_.q8}),B_=Object.freeze({[M_.fp32]:"",[M_.fp16]:"_fp16",[M_.int8]:"_int8",[M_.uint8]:"_uint8",[M_.q8]:"_quantized",[M_.q4]:"_q4",[M_.q4f16]:"_q4f16",[M_.bnb4]:"_bnb4"}),N_="https://github.com/huggingface/transformers.js/issues/new/choose",P_="preprocessor_config.json",R_=P_;class D_ extends j{_call(e,t){throw Error("`_call` should be implemented in a subclass")}}class F_ extends j{_call(e,t){throw Error("`_call` should be implemented in a subclass")}}class L_ extends j{constructor(){super(),this.processors=[]}push(e){this.processors.push(e)}extend(e){this.processors.push(...e)}_call(e,t){let n=t;for(const t of this.processors)n=t(e,n);return n}[Symbol.iterator](){return this.processors.values()}}class U_ extends D_{constructor(e){super(),this.bos_token_id=e}_call(e,t){for(let n=0;n<e.length;++n)if(1===e[n].length){const e=t[n].data;e.fill(-Infinity),e[this.bos_token_id]=0}return t}}class q_ extends D_{constructor(e,t){super(),this.max_length=e,this.eos_token_id=Array.isArray(t)?t:[t]}_call(e,t){for(let n=0;n<e.length;++n)if(e[n].length===this.max_length-1){const e=t[n].data;e.fill(-Infinity);for(const t of this.eos_token_id)e[t]=0}return t}}class V_ extends D_{constructor(e,t){super(),this.begin_suppress_tokens=e,this.begin_index=t}_call(e,t){for(let n=0;n<e.length;++n)if(e[n].length===this.begin_index){const e=t[n].data;for(const t of this.begin_suppress_tokens)e[t]=-Infinity}return t}}class W_ extends D_{constructor(e,t){super(),this.eos_token_id=Array.isArray(e.eos_token_id)?e.eos_token_id[0]:e.eos_token_id,this.no_timestamps_token_id=e.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=t.length,t.at(-1)===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=e.max_initial_timestamp_index}_call(e,t){for(let n=0;n<e.length;++n){const r=t[n].data;if(r[this.no_timestamps_token_id]=-Infinity,e[n].length===this.begin_index-1){r.fill(-Infinity),r[this.timestamp_begin]=0;continue}const s=e[n].slice(this.begin_index),i=s.length>=1&&s[s.length-1]>=this.timestamp_begin,a=s.length<2||s[s.length-2]>=this.timestamp_begin;if(i&&(a?r.subarray(this.timestamp_begin).fill(-Infinity):r.subarray(0,this.eos_token_id).fill(-Infinity)),e[n].length===this.begin_index&&null!==this.max_initial_timestamp_index){const e=this.timestamp_begin+this.max_initial_timestamp_index;r.subarray(e+1).fill(-Infinity)}const o=fe(r);Math.log(o.subarray(this.timestamp_begin).map(Math.exp).reduce(((e,t)=>e+t)))>_e(o.subarray(0,this.timestamp_begin))[0]&&r.subarray(0,this.timestamp_begin).fill(-Infinity)}return t}}class j_ extends D_{constructor(e){super(),this.no_repeat_ngram_size=e}getNgrams(e){const t=e.length,n=[];for(let r=0;r<t+1-this.no_repeat_ngram_size;++r){const t=[];for(let n=0;n<this.no_repeat_ngram_size;++n)t.push(e[r+n]);n.push(t.map(Number))}const r=new Map;for(const e of n){const t=e.slice(0,e.length-1),n=JSON.stringify(t),s=r.get(n)??[];s.push(e[e.length-1]),r.set(n,s)}return r}getGeneratedNgrams(e,t){const n=t.slice(t.length+1-this.no_repeat_ngram_size,t.length);return e.get(JSON.stringify(n.map(Number)))??[]}calcBannedNgramTokens(e){const t=[];if(e.length+1<this.no_repeat_ngram_size)return t;{const t=this.getNgrams(e);return this.getGeneratedNgrams(t,e)}}_call(e,t){for(let n=0;n<e.length;++n){const r=t[n].data,s=this.calcBannedNgramTokens(e[n]);for(const e of s)r[e]=-Infinity}return t}}class G_ extends D_{constructor(e){super(),this.penalty=e}_call(e,t){for(let n=0;n<e.length;++n){const r=t[n].data;for(const t of new Set(e[n])){const e=Number(t);r[e]<0?r[e]*=this.penalty:r[e]/=this.penalty}}return t}}class H_ extends D_{constructor(e,t){super(),this.min_length=e,this.eos_token_id=Array.isArray(t)?t:[t]}_call(e,t){for(let n=0;n<e.length;++n)if(e[n].length<this.min_length){const e=t[n].data;for(const t of this.eos_token_id)e[t]=-Infinity}return t}}class K_ extends D_{constructor(e,t,n){super(),this.prompt_length_to_skip=e,this.min_new_tokens=t,this.eos_token_id=Array.isArray(n)?n:[n]}_call(e,t){for(let n=0;n<e.length;++n){if(e[n].length-this.prompt_length_to_skip<this.min_new_tokens){const e=t[n].data;for(const t of this.eos_token_id)e[t]=-Infinity}}return t}}class X_ extends D_{constructor(e,t){super(),this.bad_words_ids=e,this.eos_token_id=Array.isArray(t)?t:[t]}_call(e,t){for(let n=0;n<e.length;++n){const r=t[n].data,s=e[n];for(const e of this.bad_words_ids){let t=!0;for(let n=1;n<=e.length-1&&e.length<s.length;++n)if(e.at(-n-1)!=s.at(-n)){t=!1;break}t&&(r[e.at(-1)]=-Infinity)}}return t}}class Q_ extends D_{constructor(e){if(super(),e<=1)throw new Error(`Require guidance scale >1 to use the classifier free guidance processor, got guidance scale ${e}.`);this.guidance_scale=e}_call(e,t){if(t.dims[0]!==2*e.length)throw new Error(`Logits should have twice the batch size of the input ids, the first half of batches corresponding to the conditional inputs, and the second half of batches corresponding to the unconditional inputs. Got batch size ${t.dims[0]} for the logits and ${e.length} for the input ids.`);const n=e.length,r=t.slice([0,n],null),s=t.slice([n,t.dims[0]],null);for(let e=0;e<s.data.length;++e)s.data[e]+=(r.data[e]-s.data[e])*this.guidance_scale;return s}}class Y_ extends F_{constructor(e){if(super(),"number"!=typeof e||e<=0){let t=`\\`temperature\\` (=${e}) must be a strictly positive float, otherwise your next token scores will be invalid.`;0===e&&(t+=" If you\'re looking for greedy decoding strategies, set `do_sample=false`.")}this.temperature=e}_call(e,t){const n=t.data;for(let e=0;e<n.length;++e)n[e]/=this.temperature;return t}}class Z_ extends F_{constructor(e,{filter_value:t=-Infinity,min_tokens_to_keep:n=1}={}){if(super(),e<0||e>1)throw new Error(`\\`top_p\\` must be a float > 0 and < 1, but is ${e}`);if(!Number.isInteger(n)||n<1)throw new Error(`\\`min_tokens_to_keep\\` must be a positive integer, but is ${n}`);this.top_p=e,this.filter_value=t,this.min_tokens_to_keep=n}}class J_ extends F_{constructor(e,{filter_value:t=-Infinity,min_tokens_to_keep:n=1}={}){if(super(),!Number.isInteger(e)||e<0)throw new Error(`\\`top_k\\` must be a positive integer, but is ${e}`);this.top_k=Math.max(e,n),this.filter_value=t}}class eg{max_length=20;max_new_tokens=null;min_length=0;min_new_tokens=null;early_stopping=!1;max_time=null;do_sample=!1;num_beams=1;num_beam_groups=1;penalty_alpha=null;use_cache=!0;temperature=1;top_k=50;top_p=1;typical_p=1;epsilon_cutoff=0;eta_cutoff=0;diversity_penalty=0;repetition_penalty=1;encoder_repetition_penalty=1;length_penalty=1;no_repeat_ngram_size=0;bad_words_ids=null;force_words_ids=null;renormalize_logits=!1;constraints=null;forced_bos_token_id=null;forced_eos_token_id=null;remove_invalid_values=!1;exponential_decay_length_penalty=null;suppress_tokens=null;streamer=null;begin_suppress_tokens=null;forced_decoder_ids=null;guidance_scale=null;num_return_sequences=1;output_attentions=!1;output_hidden_states=!1;output_scores=!1;return_dict_in_generate=!1;pad_token_id=null;bos_token_id=null;eos_token_id=null;encoder_no_repeat_ngram_size=0;decoder_start_token_id=null;generation_kwargs={};constructor(e){Object.assign(this,J(e,Object.getOwnPropertyNames(this)))}}var tg=s(655);let ng,rg,sg;const ig=D.IS_BROWSER_ENV||D.IS_WEBWORKER_ENV;if(ig)ng=(e,t)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(e,t)},sg=self.createImageBitmap,rg=self.ImageData;else{if(!tg)throw new Error("Unable to load image processing library.");sg=async e=>{const t=(await e.metadata()).channels,{data:n,info:r}=await e.rotate().raw().toBuffer({resolveWithObject:!0}),s=new lg(new Uint8ClampedArray(n),r.width,r.height,r.channels);return void 0!==t&&t!==r.channels&&s.convert(t),s}}const ag={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},og=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class lg{constructor(e,t,n,r){this.data=e,this.width=t,this.height=n,this.channels=r}get size(){return[this.width,this.height]}static async read(e){if(e instanceof lg)return e;if("string"==typeof e||e instanceof URL)return await this.fromURL(e);throw new Error("Unsupported input type: "+typeof e)}static fromCanvas(e){if(!ig)throw new Error("fromCanvas() is only supported in browser environments.");const t=e.getContext("2d").getImageData(0,0,e.width,e.height).data;return new lg(t,e.width,e.height,4)}static async fromURL(e){const t=await oe(e);if(200!==t.status)throw new Error(`Unable to read image from "${e}" (${t.status} ${t.statusText})`);const n=await t.blob();return this.fromBlob(n)}static async fromBlob(e){if(ig){const t=await sg(e),n=ng(t.width,t.height).getContext("2d");return n.drawImage(t,0,0),new this(n.getImageData(0,0,t.width,t.height).data,t.width,t.height,4)}{const t=tg(await e.arrayBuffer());return await sg(t)}}static fromTensor(e,t="CHW"){if(3!==e.dims.length)throw new Error(`Tensor should have 3 dimensions, but has ${e.dims.length} dimensions.`);if("CHW"===t)e=e.transpose(1,2,0);else if("HWC"!==t)throw new Error(`Unsupported channel format: ${t}`);if(!(e.data instanceof Uint8ClampedArray||e.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${e.type}`);switch(e.dims[2]){case 1:case 2:case 3:case 4:return new lg(e.data,e.dims[1],e.dims[0],e.dims[2]);default:throw new Error(`Unsupported number of channels: ${e.dims[2]}`)}}grayscale(){if(1===this.channels)return this;const e=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let t=0,n=0;t<this.data.length;t+=this.channels){const r=this.data[t],s=this.data[t+1],i=this.data[t+2];e[n++]=Math.round(.2989*r+.587*s+.114*i)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,1)}rgb(){if(3===this.channels)return this;const e=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let t=0,n=0;t<this.data.length;++t)e[n++]=this.data[t],e[n++]=this.data[t],e[n++]=this.data[t];break;case 4:for(let t=0,n=0;t<this.data.length;t+=4)e[n++]=this.data[t],e[n++]=this.data[t+1],e[n++]=this.data[t+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,3)}rgba(){if(4===this.channels)return this;const e=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let t=0,n=0;t<this.data.length;++t)e[n++]=this.data[t],e[n++]=this.data[t],e[n++]=this.data[t],e[n++]=255;break;case 3:for(let t=0,n=0;t<this.data.length;t+=3)e[n++]=this.data[t],e[n++]=this.data[t+1],e[n++]=this.data[t+2],e[n++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,4)}putAlpha(e){if(e.width!==this.width||e.height!==this.height)throw new Error(`Expected mask size to be ${this.width}x${this.height}, but got ${e.width}x${e.height}`);if(1!==e.channels)throw new Error(`Expected mask to have 1 channel, but got ${e.channels}`);const t=this.data,n=e.data,r=this.width*this.height;if(3===this.channels){const e=new Uint8ClampedArray(4*r);for(let s=0,i=0,a=0;s<r;++s)e[a++]=t[i++],e[a++]=t[i++],e[a++]=t[i++],e[a++]=n[s];return this._update(e,this.width,this.height,4)}if(4===this.channels){for(let e=0;e<r;++e)t[4*e+3]=n[e];return this}throw new Error(`Expected image to have 3 or 4 channels, but got ${this.channels}`)}async resize(e,t,{resample:n=2}={}){if(this.width===e&&this.height===t)return this;let r=ag[n]??n;const s=K(e),i=K(t);if(s&&i)return this;if(s?e=t/this.height*this.width:i&&(t=e/this.width*this.height),ig){const n=this.channels,r=this.toCanvas(),s=ng(e,t).getContext("2d");s.drawImage(r,0,0,e,t);return new lg(s.getImageData(0,0,e,t).data,e,t,4).convert(n)}{let n=this.toSharp();switch(r){case"box":case"hamming":"box"!==r&&"hamming"!==r||(console.warn(`Resampling method ${r} is not yet supported. Using bilinear instead.`),r="bilinear");case"nearest":case"bilinear":case"bicubic":n=n.affine([e/this.width,0,0,t/this.height],{interpolator:r});break;case"lanczos":n=n.resize({width:e,height:t,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${r} is not supported.`)}return await sg(n)}}async pad([e,t,n,r]){if(e=Math.max(e,0),t=Math.max(t,0),n=Math.max(n,0),r=Math.max(r,0),0===e&&0===t&&0===n&&0===r)return this;if(ig){const s=this.channels,i=this.toCanvas(),a=this.width+e+t,o=this.height+n+r,l=ng(a,o).getContext("2d");l.drawImage(i,0,0,this.width,this.height,e,n,this.width,this.height);return new lg(l.getImageData(0,0,a,o).data,a,o,4).convert(s)}{const s=this.toSharp().extend({left:e,right:t,top:n,bottom:r});return await sg(s)}}async crop([e,t,n,r]){if(e=Math.max(e,0),t=Math.max(t,0),n=Math.min(n,this.width-1),r=Math.min(r,this.height-1),0===e&&0===t&&n===this.width-1&&r===this.height-1)return this;const s=n-e+1,i=r-t+1;if(ig){const n=this.channels,r=this.toCanvas(),a=ng(s,i).getContext("2d");a.drawImage(r,e,t,s,i,0,0,s,i);return new lg(a.getImageData(0,0,s,i).data,s,i,4).convert(n)}{const n=this.toSharp().extract({left:e,top:t,width:s,height:i});return await sg(n)}}async center_crop(e,t){if(this.width===e&&this.height===t)return this;const n=(this.width-e)/2,r=(this.height-t)/2;if(ig){const s=this.channels,i=this.toCanvas(),a=ng(e,t).getContext("2d");let o=0,l=0,u=0,d=0;n>=0?o=n:u=-n,r>=0?l=r:d=-r,a.drawImage(i,o,l,e,t,u,d,e,t);return new lg(a.getImageData(0,0,e,t).data,e,t,4).convert(s)}{let s=this.toSharp();if(n>=0&&r>=0)s=s.extract({left:Math.floor(n),top:Math.floor(r),width:e,height:t});else if(n<=0&&r<=0){const i=Math.floor(-r),a=Math.floor(-n);s=s.extend({top:i,left:a,right:e-this.width-a,bottom:t-this.height-i})}else{let i=[0,0],a=0;r<0?(i[0]=Math.floor(-r),i[1]=t-this.height-i[0]):a=Math.floor(r);let o=[0,0],l=0;n<0?(o[0]=Math.floor(-n),o[1]=e-this.width-o[0]):l=Math.floor(n),s=s.extend({top:i[0],bottom:i[1],left:o[0],right:o[1]}).extract({left:l,top:a,width:e,height:t})}return await sg(s)}}async toBlob(e="image/png",t=1){if(!ig)throw new Error("toBlob() is only supported in browser environments.");const n=this.toCanvas();return await n.convertToBlob({type:e,quality:t})}toTensor(e="CHW"){let t=new Xp("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if("HWC"===e);else{if("CHW"!==e)throw new Error(`Unsupported channel format: ${e}`);t=t.permute(2,0,1)}return t}toCanvas(){if(!ig)throw new Error("toCanvas() is only supported in browser environments.");const e=this.clone().rgba(),t=ng(e.width,e.height),n=new rg(e.data,e.width,e.height);return t.getContext("2d").putImageData(n,0,0),t}split(){const{data:e,width:t,height:n,channels:r}=this,s=e.constructor,i=e.length/r,a=Array.from({length:r},(()=>new s(i)));for(let t=0;t<i;++t){const n=r*t;for(let s=0;s<r;++s)a[s][t]=e[n+s]}return a.map((e=>new lg(e,t,n,1)))}_update(e,t,n,r=null){return this.data=e,this.width=t,this.height=n,null!==r&&(this.channels=r),this}clone(){return new lg(this.data.slice(),this.width,this.height,this.channels)}convert(e){if(this.channels===e)return this;switch(e){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(e){if(!ig){if(V.useFS){const t=this.toSharp();return await t.toFile(e)}throw new Error("Unable to save the image because filesystem is disabled in this environment.")}{if(D.IS_WEBWORKER_ENV)throw new Error("Unable to save an image from a Web Worker.");const t=e.split(".").pop().toLowerCase(),n=og.get(t)??"image/png",r=await this.toBlob(n),s=URL.createObjectURL(r),i=document.createElement("a");i.href=s,i.download=e,i.click(),i.remove()}}toSharp(){if(ig)throw new Error("toSharp() is only supported in server-side environments.");return tg(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}lg.read.bind(lg);class ug extends j{_call(e,t){throw Error("StoppingCriteria needs to be subclassed")}}class dg extends j{constructor(){super(),this.criteria=[]}push(e){this.criteria.push(e)}extend(e){e instanceof dg?e=e.criteria:e instanceof ug&&(e=[e]),this.criteria.push(...e)}_call(e,t){const n=new Array(e.length).fill(!1);for(const r of this.criteria){const s=r(e,t);for(let e=0;e<n.length;++e)n[e]||=s[e]}return n}[Symbol.iterator](){return this.criteria.values()}}class cg extends ug{constructor(e,t=null){super(),this.max_length=e,this.max_position_embeddings=t}_call(e){return e.map((e=>e.length>=this.max_length))}}class pg extends ug{constructor(e){super(),Array.isArray(e)||(e=[e]),this.eos_token_id=e}_call(e,t){return e.map((e=>{const t=e.at(-1);return this.eos_token_id.some((e=>t==e))}))}}class hg extends j{constructor(e){super(),this.generation_config=e}async _call(e){return this.sample(e)}async sample(e){throw Error("sample should be implemented in subclasses.")}getLogits(e,t){let n=e.dims.at(-1),r=e.data;if(-1===t)r=r.slice(-n);else{let e=t*n;r=r.slice(e,e+n)}return r}randomSelect(e){let t=0;for(let n=0;n<e.length;++n)t+=e[n];let n=Math.random()*t;for(let t=0;t<e.length;++t)if(n-=e[t],n<=0)return t;return 0}static getSampler(e){if(e.do_sample)return new mg(e);if(e.num_beams>1)return new _g(e);if(e.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${e.num_return_sequences}.`);return new fg(e)}}class fg extends hg{async sample(e){const t=_e(e.data)[1];return[[BigInt(t),0]]}}class mg extends hg{async sample(e){let t=e.dims.at(-1);this.generation_config.top_k>0&&(t=Math.min(this.generation_config.top_k,t));const[n,r]=await Zp(e,t),s=he(n.data);return Array.from({length:this.generation_config.num_beams},(()=>{const e=this.randomSelect(s);return[r.data[e],Math.log(s[e])]}))}}class _g extends hg{async sample(e){let t=e.dims.at(-1);this.generation_config.top_k>0&&(t=Math.min(this.generation_config.top_k,t));const[n,r]=await Zp(e,t),s=he(n.data);return Array.from({length:this.generation_config.num_beams},((e,t)=>[r.data[t],Math.log(s[t])]))}}class gg extends eg{return_timestamps=null;return_token_timestamps=null;num_frames=null;alignment_heads=null;task=null;language=null;no_timestamps_token_id=null;prompt_ids=null;is_multilingual=null;lang_to_id=null;task_to_id=null;max_initial_timestamp_index=1}const wg=0,yg=1,bg=2,xg=3,vg=4,$g=5,kg=6,Eg=7,Sg=8,zg=9,Cg=new Map,Tg=new Map,Ig=new Map;async function Ag(e,t,n){const r=n.config?.["transformers.js_config"]??{};let s=n.device??r.device;s&&"string"!=typeof s&&(s.hasOwnProperty(t)?s=s[t]:(console.warn(`device not specified for "${t}". Using the default device.`),s=null));const i=s??(D.IS_NODE_ENV?"cpu":"wasm"),a=function o(e=null){if(!e)return Rp;switch(e){case"auto":return Pp;case"gpu":return Pp.filter((e=>["webgpu","cuda","dml","webnn-gpu"].includes(e)))}if(Pp.includes(e))return[Np[e]??e];throw new Error(`Unsupported device: "${e}". Should be one of: ${Pp.join(", ")}.`)}(i);let l=n.dtype??r.dtype;if("string"!=typeof l&&(l&&l.hasOwnProperty(t)?l=l[t]:(l=O_[i]??M_.fp32,console.warn(`dtype not specified for "${t}". Using the default dtype (${l}) for this device (${i}).`))),l===M_.auto){let e=r.dtype;"string"!=typeof e&&(e=e[t]),l=e&&e!==M_.auto&&M_.hasOwnProperty(e)?e:O_[i]??M_.fp32}const u=l;if(!B_.hasOwnProperty(u))throw new Error(`Invalid dtype: ${u}. Should be one of: ${Object.keys(M_).join(", ")}`);if(u===M_.fp16&&"webgpu"===i&&!await A_())throw new Error(`The device (${i}) does not support fp16.`);const d=r.kv_cache_dtype?"string"==typeof r.kv_cache_dtype?r.kv_cache_dtype:r.kv_cache_dtype[u]??"float32":void 0;if(d&&!["float32","float16"].includes(d))throw new Error(`Invalid kv_cache_dtype: ${d}. Should be one of: float32, float16`);const c={dtype:u,kv_cache_dtype:d},p=B_[u],h=`${n.subfolder??""}/${t}${p}.onnx`,f={...n.session_options};f.executionProviders??=a;const m=r.free_dimension_overrides;m?f.freeDimensionOverrides??=m:i.startsWith("webnn")&&!f.freeDimensionOverrides&&console.warn(\'WebNN does not currently support dynamic shapes and requires `free_dimension_overrides` to be set in config.json as a field within "transformers.js_config". When `free_dimension_overrides` is not set, you may experience significant performance degradation.\');const _=de(e,h,!0,n),g=n.use_external_data_format??r.use_external_data_format;let w=[];if(g&&(!0===g||"object"==typeof g&&g.hasOwnProperty(t)&&!0===g[t])){if(D.IS_NODE_ENV)throw new Error("External data format is not yet supported in Node.js");const r=`${t}${p}.onnx_data`,s=`${n.subfolder??""}/${r}`;w.push(new Promise((async(t,i)=>{const a=await de(e,s,!0,n);t({path:r,data:a})})))}else void 0!==f.externalData&&(w=f.externalData.map((async t=>{if("string"==typeof t.data){const r=await de(e,t.data,!0,n);return{...t,data:r}}return t})));if(w.length>0&&(f.externalData=await Promise.all(w)),"webgpu"===i){const e=z_(n.config,{prefix:"present"});if(Object.keys(e).length>0&&!jp()){const t={};for(const n in e)t[n]="gpu-buffer";f.preferredOutputLocation=t}}return{buffer:await _,session_options:f,session_config:c}}async function Mg(e,t,n){return Object.fromEntries(await Promise.all(Object.keys(t).map((async r=>{const{buffer:s,session_options:i,session_config:a}=await Ag(e,t[r],n);return[r,await qp(s,i,a)]}))))}async function Og(e,t,n){return Object.fromEntries(await Promise.all(Object.keys(t).map((async r=>[r,await ce(e,t[r],!1,n)]))))}async function Bg(e,t){const n=function r(e,t){const n=Object.create(null),r=[];for(const s of e.inputNames){const e=t[s];e instanceof Xp?n[s]=jp()?e.clone():e:r.push(s)}if(r.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${r.join(", ")}.`);const s=Object.keys(t).length,i=e.inputNames.length;if(s>i){let n=Object.keys(t).filter((t=>!e.inputNames.includes(t)));console.warn(`WARNING: Too many inputs were provided (${s} > ${i}). The following inputs will be ignored: "${n.join(", ")}".`)}return n}(e,t);try{const t=Object.fromEntries(Object.entries(n).map((([e,t])=>[e,t.ort_tensor])));let r=await e.run(t);return r=Ng(r),r}catch(e){const t=Object.fromEntries(Object.entries(n).map((([e,{type:t,dims:n,data:r}])=>[e,{type:t,dims:n,data:r}])));throw console.error(`An error occurred during model execution: "${e}".`),console.error("Inputs given to model:",t),e}}function Ng(e){for(let t in e)Vp(e[t])?e[t]=new Xp(e[t]):"object"==typeof e[t]&&Ng(e[t]);return e}function Pg(e){if(e instanceof Xp)return e;if(0===e.length)throw Error("items must be non-empty");if(Array.isArray(e[0])){if(e.some((t=>t.length!==e[0].length)))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with \'padding=True\' and/or \'truncation=True\' to have batched tensors with the same length.");return new Xp("int64",BigInt64Array.from(e.flat().map((e=>BigInt(e)))),[e.length,e[0].length])}return new Xp("int64",BigInt64Array.from(e.map((e=>BigInt(e)))),[1,e.length])}function Rg(e){return new Xp("bool",[e],[1])}async function Dg(e,t){let{encoder_outputs:n,input_ids:r,decoder_input_ids:s,...i}=t;if(!n){const r=J(t,e.sessions.model.inputNames);n=(await Fg(e,r)).last_hidden_state}i.input_ids=s,i.encoder_hidden_states=n,e.sessions.decoder_model_merged.inputNames.includes("encoder_attention_mask")&&(i.encoder_attention_mask=t.attention_mask);return await Lg(e,i,!0)}async function Fg(e,t){const n=e.sessions.model,r=J(t,n.inputNames);if(n.inputNames.includes("inputs_embeds")&&!r.inputs_embeds){if(!t.input_ids)throw new Error("Both `input_ids` and `inputs_embeds` are missing in the model inputs.");r.inputs_embeds=await e.encode_text({input_ids:t.input_ids})}return n.inputNames.includes("token_type_ids")&&!r.token_type_ids&&(r.token_type_ids=new Xp("int64",new BigInt64Array(r.input_ids.data.length),r.input_ids.dims)),await Bg(n,r)}async function Lg(e,t,n=!1){const r=e.sessions[n?"decoder_model_merged":"model"],{past_key_values:s,...i}=t;if(r.inputNames.includes("use_cache_branch")&&(i.use_cache_branch=Rg(!!s)),r.inputNames.includes("position_ids")&&i.attention_mask&&!i.position_ids){const t="paligemma"===e.config.model_type?1:0;i.position_ids=function n(e,t=null,r=0){const{input_ids:s,inputs_embeds:i,attention_mask:a}=e,{data:o,dims:l}=Vg(a,r);let u=new Xp("int64",o,l);if(t){const e=-(s??i).dims.at(1);u=u.slice(null,[e,null])}return u}(i,s,t)}e.addPastKeyValues(i,s);const a=J(i,r.inputNames);return await Bg(r,a)}function Ug({image_token_id:e,inputs_embeds:t,image_features:n,input_ids:r,attention_mask:s}){const i=r.tolist().map((t=>t.reduce(((t,n,r)=>(n==e&&t.push(r),t)),[]))),a=i.reduce(((e,t)=>e+t.length),0),o=n.dims[0];if(a!==o)throw new Error(`Image features and image tokens do not match: tokens: ${a}, features ${o}`);let l=0;for(let e=0;e<i.length;++e){const r=i[e],s=t[e];for(let e=0;e<r.length;++e)s[r[e]].data.set(n[l++].data)}return{inputs_embeds:t,attention_mask:s}}async function qg(e,{input_ids:t=null,attention_mask:n=null,pixel_values:r=null,position_ids:s=null,inputs_embeds:i=null,past_key_values:a=null,generation_config:o=null,logits_processor:l=null,...u}){if(!i)if(i=await e.encode_text({input_ids:t,...u}),r&&1!==t.dims[1]){const s=await e.encode_image({pixel_values:r,...u});({inputs_embeds:i,attention_mask:n}=e._merge_input_ids_with_image_features({image_features:s,inputs_embeds:i,input_ids:t,attention_mask:n}))}else if(a&&r&&1===t.dims[1]){const e=t.dims[1],r=Object.values(a)[0].dims.at(-2);n=sh([ch([t.dims[0],r]),n.slice(null,[n.dims[1]-e,n.dims[1]])],1)}if(!s&&"qwen2_vl"===e.config.model_type){const{image_grid_thw:r,video_grid_thw:i}=u;[s]=e.get_rope_index(t,r,i,n)}return await Lg(e,{inputs_embeds:i,past_key_values:a,attention_mask:n,position_ids:s,generation_config:o,logits_processor:l},!0)}function Vg(e,t=0){const[n,r]=e.dims,s=e.data,i=new BigInt64Array(s.length);for(let e=0;e<n;++e){const n=e*r;let a=BigInt(t);for(let e=0;e<r;++e){const t=n+e;0n===s[t]?i[t]=BigInt(1):(i[t]=a,a+=s[t])}}return{data:i,dims:e.dims}}function Wg(e,t,n,r){if(n.past_key_values){const t=Object.values(n.past_key_values)[0].dims.at(-2),{input_ids:r,attention_mask:s}=n;if(s&&s.dims[1]>r.dims[1]);else if(t<r.dims[1])n.input_ids=r.slice(null,[t,null]);else if(null!=e.config.image_token_index&&r.data.some((t=>t==e.config.image_token_index))){const s=e.config.num_image_tokens;if(!s)throw new Error("`num_image_tokens` is missing in the model configuration.");const i=r.dims[1]-(t-s);n.input_ids=r.slice(null,[-i,null]),n.attention_mask=ch([1,t+i])}}return n}function jg(e,t,n,r){return n.past_key_values&&(t=t.map((e=>[e.at(-1)]))),{...n,decoder_input_ids:Pg(t)}}function Gg(e,...t){return e.config.is_encoder_decoder?jg(e,...t):Wg(e,...t)}function Hg(e,t,n,r){const s=!!n.past_key_values;if(null!==r.guidance_scale&&r.guidance_scale>1&&(s?n.input_ids=sh([n.input_ids,n.input_ids],0):(n.input_ids=sh([n.input_ids,dh(n.input_ids,BigInt(r.pad_token_id))],0),n.attention_mask=sh([n.attention_mask,dh(n.attention_mask,0n)],0))),!s&&n.pixel_values||(n.pixel_values=uh([0,0,3,384,384],1)),s){const e=0,t=1,r=e>0?1:0,s=1;n.images_seq_mask=new Xp("bool",new Array(e+t).fill(!0).fill(!1,0,t),[s,e+t]),n.images_emb_mask=new Xp("bool",new Array(e).fill(!!r),[s,1,e])}return n}class Kg extends j{main_input_name="input_ids";forward_params=["input_ids","attention_mask"];constructor(e,t,n){super(),this.config=e,this.sessions=t,this.configs=n;const r=Ig.get(this.constructor),s=Cg.get(r);switch(this.can_generate=!1,this._forward=null,this._prepare_inputs_for_generation=null,s){case vg:this.can_generate=!0,this._forward=Lg,this._prepare_inputs_for_generation=Wg;break;case bg:case xg:case Eg:this.can_generate=!0,this._forward=Dg,this._prepare_inputs_for_generation=jg;break;case yg:this._forward=Dg;break;case kg:this.can_generate=!0,this._forward=qg,this._prepare_inputs_for_generation=Gg;break;case zg:this.can_generate=!0,this._prepare_inputs_for_generation=Gg;break;case Sg:this.can_generate=!0,this._prepare_inputs_for_generation=Hg;break;default:this._forward=Fg}this.can_generate&&this.forward_params.push("past_key_values"),this.custom_config=this.config["transformers.js_config"]??{}}async dispose(){const e=[];for(const t of Object.values(this.sessions))t?.handler?.dispose&&e.push(t.handler.dispose());return await Promise.all(e)}static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:i="main",model_file_name:a=null,subfolder:o="onnx",device:l=null,dtype:u=null,use_external_data_format:d=null,session_options:c={}}={}){let p={progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:i,model_file_name:a,subfolder:o,device:l,dtype:u,use_external_data_format:d,session_options:c};const h=Ig.get(this),f=Cg.get(h);let m;if(n=p.config=await T_.from_pretrained(e,p),f===vg)m=await Promise.all([Mg(e,{model:p.model_file_name??"model"},p),Og(e,{generation_config:"generation_config.json"},p)]);else if(f===bg||f===xg)m=await Promise.all([Mg(e,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},p),Og(e,{generation_config:"generation_config.json"},p)]);else if(f===$g)m=await Promise.all([Mg(e,{model:"vision_encoder",prompt_encoder_mask_decoder:"prompt_encoder_mask_decoder"},p)]);else if(f===yg)m=await Promise.all([Mg(e,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},p)]);else if(f===kg){const t={embed_tokens:"embed_tokens",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};n.is_encoder_decoder&&(t.model="encoder_model"),m=await Promise.all([Mg(e,t,p),Og(e,{generation_config:"generation_config.json"},p)])}else if(f===Eg)m=await Promise.all([Mg(e,{model:"text_encoder",decoder_model_merged:"decoder_model_merged",encodec_decode:"encodec_decode"},p),Og(e,{generation_config:"generation_config.json"},p)]);else if(f===Sg)m=await Promise.all([Mg(e,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"language_model",lm_head:"lm_head",gen_head:"gen_head",gen_img_embeds:"gen_img_embeds",image_decode:"image_decode"},p),Og(e,{generation_config:"generation_config.json"},p)]);else if(f===zg)m=await Promise.all([Mg(e,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"model",vision_encoder:"vision_encoder"},p),Og(e,{generation_config:"generation_config.json"},p)]);else{if(f!==wg){const e=h??n?.model_type;"custom"!==e&&console.warn(`Model type for \'${e}\' not found, assuming encoder-only architecture. Please report this at ${N_}.`)}m=await Promise.all([Mg(e,{model:p.model_file_name??"model"},p)])}return new this(n,...m)}async _call(e){return await this.forward(e)}async forward(e){return await this._forward(this,e)}get generation_config(){return this.configs?.generation_config??null}_get_logits_warper(e){const t=new L_;return null!==e.temperature&&1!==e.temperature&&t.push(new Y_(e.temperature)),null!==e.top_k&&0!==e.top_k&&t.push(new J_(e.top_k)),null!==e.top_p&&e.top_p<1&&t.push(new Z_(e.top_p)),t}_get_logits_processor(e,t,n=null){const r=new L_;if(null!==e.repetition_penalty&&1!==e.repetition_penalty&&r.push(new G_(e.repetition_penalty)),null!==e.no_repeat_ngram_size&&e.no_repeat_ngram_size>0&&r.push(new j_(e.no_repeat_ngram_size)),null!==e.bad_words_ids&&r.push(new X_(e.bad_words_ids,e.eos_token_id)),null!==e.min_length&&null!==e.eos_token_id&&e.min_length>0&&r.push(new H_(e.min_length,e.eos_token_id)),null!==e.min_new_tokens&&null!==e.eos_token_id&&e.min_new_tokens>0&&r.push(new K_(t,e.min_new_tokens,e.eos_token_id)),null!==e.forced_bos_token_id&&r.push(new U_(e.forced_bos_token_id)),null!==e.forced_eos_token_id&&r.push(new q_(e.max_length,e.forced_eos_token_id)),null!==e.begin_suppress_tokens){const n=t>1||null===e.forced_bos_token_id?t:t+1;r.push(new V_(e.begin_suppress_tokens,n))}return null!==e.guidance_scale&&e.guidance_scale>1&&r.push(new Q_(e.guidance_scale)),null!==n&&r.extend(n),r}_prepare_generation_config(e,t,n=eg){const r={...this.config};for(const e of["decoder","generator","text_config"])e in r&&Object.assign(r,r[e]);const s=new n(r);return Object.assign(s,this.generation_config??{}),e&&Object.assign(s,e),t&&Object.assign(s,J(t,Object.getOwnPropertyNames(s))),s}_get_stopping_criteria(e,t=null){const n=new dg;return null!==e.max_length&&n.push(new cg(e.max_length,this.config.max_position_embeddings??null)),null!==e.eos_token_id&&n.push(new pg(e.eos_token_id)),t&&n.extend(t),n}_validate_model_class(){if(!this.can_generate){const e=[k$,Nk,f$,Cv],t=Ig.get(this.constructor),n=new Set,r=this.config.model_type;for(const t of e){const e=t.get(r);e&&n.add(e[0])}let s=`The current model class (${t}) is not compatible with \\`.generate()\\`, as it doesn\'t have a language model head.`;throw n.size>0&&(s+=` Please use the following class instead: ${[...n].join(", ")}`),Error(s)}}prepare_inputs_for_generation(...e){return this._prepare_inputs_for_generation(this,...e)}_update_model_kwargs_for_generation({generated_input_ids:e,outputs:t,model_inputs:n,is_encoder_decoder:r}){return n.past_key_values=this.getPastKeyValues(t,n.past_key_values),n.input_ids=new Xp("int64",e.flat(),[e.length,1]),r||(n.attention_mask=sh([n.attention_mask,ch([n.attention_mask.dims[0],1])],1)),n.position_ids=null,n}_prepare_model_inputs({inputs:e,bos_token_id:t,model_kwargs:n}){const r=J(n,this.forward_params),s=this.main_input_name;if(s in r){if(e)throw new Error("`inputs`: {inputs}` were passed alongside {input_name} which is not allowed. Make sure to either pass {inputs} or {input_name}=...")}else r[s]=e;return{inputs_tensor:r[s],model_inputs:r,model_input_name:s}}async _prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:e,model_inputs:t,model_input_name:n,generation_config:r}){if(this.sessions.model.inputNames.includes("inputs_embeds")&&!t.inputs_embeds&&"_prepare_inputs_embeds"in this){const{input_ids:e,pixel_values:n,attention_mask:r,...s}=t;t={...s,...J(await this._prepare_inputs_embeds(t),["inputs_embeds","attention_mask"])}}let{last_hidden_state:s}=await Fg(this,t);if(null!==r.guidance_scale&&r.guidance_scale>1)s=sh([s,dh(s,0)],0),"attention_mask"in t&&(t.attention_mask=sh([t.attention_mask,(i=t.attention_mask,hh(i.dims))],0));else if(t.decoder_input_ids){const e=Pg(t.decoder_input_ids).dims[0];if(e!==s.dims[0]){if(1!==s.dims[0])throw new Error(`The encoder outputs have a different batch size (${s.dims[0]}) than the decoder inputs (${e}).`);s=sh(Array.from({length:e},(()=>s)),0)}}var i;return t.encoder_outputs=s,t}_prepare_decoder_input_ids_for_generation({batch_size:e,model_input_name:t,model_kwargs:n,decoder_start_token_id:r,bos_token_id:s,generation_config:i}){let{decoder_input_ids:a,...o}=n;if(!(a instanceof Xp)){if(a)Array.isArray(a[0])||(a=Array.from({length:e},(()=>a)));else if(r??=s,"musicgen"===this.config.model_type)a=Array.from({length:e*this.config.decoder.num_codebooks},(()=>[r]));else if(Array.isArray(r)){if(r.length!==e)throw new Error(`\\`decoder_start_token_id\\` expcted to have length ${e} but got ${r.length}`);a=r}else a=Array.from({length:e},(()=>[r]));a=Pg(a)}return n.decoder_attention_mask=ph(a),{input_ids:a,model_inputs:o}}async generate({inputs:e=null,generation_config:t=null,logits_processor:n=null,stopping_criteria:r=null,streamer:s=null,...i}){this._validate_model_class(),t=this._prepare_generation_config(t,i);let{inputs_tensor:a,model_inputs:o,model_input_name:l}=this._prepare_model_inputs({inputs:e,model_kwargs:i});const u=this.config.is_encoder_decoder;let d;u&&("encoder_outputs"in o||(o=await this._prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:a,model_inputs:o,model_input_name:l,generation_config:t}))),u?({input_ids:d,model_inputs:o}=this._prepare_decoder_input_ids_for_generation({batch_size:o[l].dims.at(0),model_input_name:l,model_kwargs:o,decoder_start_token_id:t.decoder_start_token_id,bos_token_id:t.bos_token_id,generation_config:t})):d=o[l];let c=d.dims.at(-1);null!==t.max_new_tokens&&(t.max_length=c+t.max_new_tokens);const p=this._get_logits_processor(t,c,n),h=this._get_stopping_criteria(t,r),f=o[l].dims.at(0),m=hg.getSampler(t),_=new Array(f).fill(0),g=d.tolist();let w;s&&s.put(g);let y={};for(;;){if(o=this.prepare_inputs_for_generation(g,o,t),w=await this.forward(o),t.output_attentions&&t.return_dict_in_generate){const e=this.getAttentions(w);for(const t in e)t in y||(y[t]=[]),y[t].push(e[t])}const e=p(g,w.logits.slice(null,-1,null)),n=[];for(let t=0;t<e.dims.at(0);++t){const r=e[t],s=await m(r);for(const[e,r]of s){const s=BigInt(e);_[t]+=r,g[t].push(s),n.push([s]);break}}s&&s.put(n);if(h(g).every((e=>e)))break;o=this._update_model_kwargs_for_generation({generated_input_ids:n,outputs:w,model_inputs:o,is_encoder_decoder:u})}s&&s.end();const b=this.getPastKeyValues(w,o.past_key_values,!0),x=new Xp("int64",g.flat(),[g.length,g[0].length]);if(t.return_dict_in_generate)return{sequences:x,past_key_values:b,...y};for(const e of Object.values(w))"gpu-buffer"===e.location&&e.dispose();return x}getPastKeyValues(e,t,n=!1){const r=Object.create(null);for(const s in e)if(s.startsWith("present")){const i=s.replace("present","past_key_values"),a=s.includes("encoder");if(r[i]=a&&t?t[i]:e[s],t&&(!a||n)){const e=t[i];"gpu-buffer"===e.location&&e.dispose()}}return r}getAttentions(e){const t={};for(const n of["cross_attentions","encoder_attentions","decoder_attentions"])for(const r in e)r.startsWith(n)&&(n in t||(t[n]=[]),t[n].push(e[r]));return t}addPastKeyValues(e,t){if(t)Object.assign(e,t);else{const t=this.sessions.decoder_model_merged??this.sessions.model,n=t?.config?.kv_cache_dtype??"float32",r="float16"===n?new Uint16Array:[],s=(e[this.main_input_name]??e.attention_mask)?.dims?.[0]??1,i=z_(this.config,{batch_size:s});for(const t in i)e[t]=new Xp(n,r,i[t])}}async encode_image({pixel_values:e}){const t=(await Bg(this.sessions.vision_encoder,{pixel_values:e})).image_features;return this.config.num_image_tokens||(console.warn(`The number of image tokens was not set in the model configuration. Setting it to the number of features detected by the vision encoder (${t.dims[1]}).`),this.config.num_image_tokens=t.dims[1]),t}async encode_text({input_ids:e}){return(await Bg(this.sessions.embed_tokens,{input_ids:e})).inputs_embeds}}class Xg{}class Qg extends Kg{}class Yg extends Kg{}class Zg extends Kg{}class Jg extends Kg{}class ew extends Kg{}class tw extends Kg{}class nw extends Kg{}class rw extends Kg{}class sw extends Kg{}class iw extends Kg{}class aw extends Kg{}class ow extends Kg{}class lw extends Kg{}class uw extends Kg{}class dw extends Kg{forward_params=["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"]}class cw extends Kg{}class pw extends Kg{}class hw extends Kg{}class fw extends Kg{}class mw extends Kg{}class _w extends Kg{}class gw extends Kg{}class ww extends Kg{}class yw extends Kg{}class bw extends Kg{}class xw extends Kg{requires_attention_mask=!1;main_input_name="input_features";forward_params=["input_features","attention_mask","decoder_input_ids","decoder_attention_mask","past_key_values"]}class vw extends Kg{requires_attention_mask=!1;main_input_name="input_values";forward_params=["input_values","decoder_input_ids","past_key_values"]}class $w extends Kg{main_input_name="pixel_values";forward_params=["pixel_values","decoder_input_ids","encoder_hidden_states","past_key_values"]}class kw extends Kg{forward_params=["input_ids","attention_mask","pixel_values","position_ids","past_key_values"]}class Ew extends kw{_merge_input_ids_with_image_features({inputs_embeds:e,image_features:t,input_ids:n,attention_mask:r}){const s=this.config.image_token_index,i=n.tolist().map((e=>e.findIndex((e=>e==s)))),a=i.every((e=>-1===e)),o=i.every((e=>-1!==e));if(!a&&!o)throw new Error("Every input should contain either 0 or 1 image token.");if(a)return{inputs_embeds:e,attention_mask:r};const l=[],u=[];for(let n=0;n<i.length;++n){const s=i[n],a=e[n],o=t[n],d=r[n];l.push(sh([a.slice([0,s]),o,a.slice([s+1,a.dims[0]])],0)),u.push(sh([d.slice([0,s]),ch([o.dims[0]]),d.slice([s+1,d.dims[0]])],0))}return{inputs_embeds:ih(l,0),attention_mask:ih(u,0)}}}class Sw extends Kg{forward_params=["input_ids","inputs_embeds","attention_mask","pixel_values","encoder_outputs","decoder_input_ids","decoder_inputs_embeds","decoder_attention_mask","past_key_values"];main_input_name="inputs_embeds"}class zw extends Kg{forward_params=["input_ids","attention_mask","pixel_values","position_ids","past_key_values"]}class Cw extends Kg{forward_params=["input_ids","attention_mask","pixel_values","pixel_attention_mask","position_ids","past_key_values"]}class Tw extends Cw{async encode_image({pixel_values:e,pixel_attention_mask:t}){return(await Bg(this.sessions.vision_encoder,{pixel_values:e,pixel_attention_mask:t})).image_features}_merge_input_ids_with_image_features(e){const t=e.image_features.dims.at(-1),n=e.image_features.view(-1,t);return Ug({image_token_id:this.config.image_token_id,...e,image_features:n})}}class Iw extends Kg{forward_params=["input_ids","inputs_embeds","attention_mask","position_ids","pixel_values","image_sizes","past_key_values"]}class Aw extends Iw{async forward({input_ids:e=null,attention_mask:t=null,pixel_values:n=null,image_sizes:r=null,position_ids:s=null,inputs_embeds:i=null,past_key_values:a=null,generation_config:o=null,logits_processor:l=null,...u}){if(!i){let t;if(n&&1!==e.dims[1]){if(!r)throw new Error("`image_sizes` must be provided when `pixel_values` is provided.");({image_features:t}=await Bg(this.sessions.vision_encoder,{pixel_values:n,image_sizes:r}))}else{const e=this.config.normalized_config.hidden_size;t=new Xp("float32",[],[0,e])}({inputs_embeds:i}=await Bg(this.sessions.prepare_inputs_embeds,{input_ids:e,image_features:t}))}return await Lg(this,{inputs_embeds:i,past_key_values:a,attention_mask:t,position_ids:s,generation_config:o,logits_processor:l},!1)}}class Mw extends Kg{}class Ow extends Kg{}class Bw extends Kg{}class Nw extends Kg{}class Pw extends Kg{}class Rw extends Kg{}class Dw extends Kg{}class Fw extends Kg{}class Lw extends Kg{}class Uw extends Kg{}class qw extends Kg{}class Vw extends Kg{}class Ww extends Kg{}class jw extends Kg{}class Gw extends Kg{}class Hw extends Kg{}class Kw extends Kg{}class Xw extends Kg{}class Qw extends Kg{}class Yw extends Kg{}class Zw extends Kg{}class Jw extends Kg{}class ey extends Kg{}class ty extends Kg{forward_params=["input_ids","attention_mask","position_ids","past_key_values","pixel_values","image_grid_thw"]}class ny extends Kg{}class ry extends Kg{}class sy extends Kg{}class iy extends Kg{}class ay extends Kg{}class oy extends Kg{}class ly extends Kg{}class uy extends Kg{}class dy extends Kg{}class cy extends Kg{}class py extends Kg{}class hy extends Kg{}class fy extends Kg{}class my extends Kg{}class _y extends Kg{}class gy extends Kg{}class wy extends Kg{}class yy extends Kg{}class by extends Kg{}class xy extends Kg{}class vy extends xy{async _call(e){return new ky(await super._call(e))}}class $y extends Xg{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class ky extends Xg{constructor({logits:e,pred_boxes:t,pred_masks:n}){super(),this.logits=e,this.pred_boxes=t,this.pred_masks=n}}class Ey extends Kg{}class Sy extends Xg{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class zy extends Kg{}class Cy extends $y{}class Ty extends Kg{}class Iy extends Kg{}class Ay extends Kg{}class My extends Kg{}class Oy extends Kg{}class By extends Kg{}class Ny extends Kg{}class Py extends Kg{}class Ry extends Kg{}class Dy extends Kg{}class Fy extends Kg{}class Ly extends Kg{}class Uy extends Kg{}class qy extends Kg{}class Vy extends Kg{}class Wy extends Kg{}class jy extends Xg{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class Gy extends Kg{}class Hy extends Xg{constructor({iou_scores:e,pred_masks:t}){super(),this.iou_scores=e,this.pred_masks=t}}class Ky extends Kg{}class Xy extends Kg{}class Qy extends Kg{}class Yy extends Kg{}class Zy extends Kg{}class Jy extends Kg{}class eb extends Kg{}class tb extends Kg{}class nb extends Kg{}class rb extends Kg{}class sb extends Kg{}class ib extends Kg{}class ab extends Kg{}class ob extends Kg{}class lb extends Kg{}class ub extends Kg{}class db extends ub{async _call(e){return new BS(await super._call(e))}}class cb extends Kg{}class pb extends Kg{}class hb extends Kg{}class fb extends Kg{forward_params=["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"];_apply_and_filter_by_delay_pattern_mask(e){const[t,n]=e.dims,r=this.config.decoder.num_codebooks,s=n-r;let i=0;for(let t=0;t<e.size;++t){if(e.data[t]===this.config.decoder.pad_token_id)continue;const a=t%n-Math.floor(t/n)%r;a>0&&a<=s&&(e.data[i++]=e.data[t])}const a=Math.floor(t/r),o=i/(a*r);return new Xp(e.type,e.data.slice(0,i),[a,r,o])}prepare_inputs_for_generation(e,t,n){let r=structuredClone(e);for(let e=0;e<r.length;++e)for(let t=0;t<r[e].length;++t)e%this.config.decoder.num_codebooks>=t&&(r[e][t]=BigInt(this.config.decoder.pad_token_id));null!==n.guidance_scale&&n.guidance_scale>1&&(r=r.concat(r));return super.prepare_inputs_for_generation(r,t,n)}async generate(e){const t=await super.generate(e),n=this._apply_and_filter_by_delay_pattern_mask(t).unsqueeze_(0),{audio_values:r}=await Bg(this.sessions.encodec_decode,{audio_codes:n});return r}}class mb extends Kg{}class _b extends Kg{}class gb extends Kg{}class wb extends Kg{}class yb extends Kg{}class bb extends Kg{}class xb extends Xg{constructor({char_logits:e,bpe_logits:t,wp_logits:n}){super(),this.char_logits=e,this.bpe_logits=t,this.wp_logits=n}get logits(){return[this.char_logits,this.bpe_logits,this.wp_logits]}}class vb extends Kg{}class $b extends Kg{}class kb extends Kg{}class Eb{static MODEL_CLASS_MAPPINGS=null;static BASE_IF_FAIL=!1;static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:i="main",model_file_name:a=null,subfolder:o="onnx",device:l=null,dtype:u=null,use_external_data_format:d=null,session_options:c={}}={}){const p={progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:i,model_file_name:a,subfolder:o,device:l,dtype:u,use_external_data_format:d,session_options:c};if(p.config=await T_.from_pretrained(e,p),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);for(const t of this.MODEL_CLASS_MAPPINGS){const n=t.get(p.config.model_type);if(n)return await n[1].from_pretrained(e,p)}if(this.BASE_IF_FAIL)return console.warn(`Unknown model class "${p.config.model_type}", attempting to construct from base class.`),await Kg.from_pretrained(e,p);throw Error(`Unsupported model type: ${p.config.model_type}`)}}const Sb=new Map([["bert",["BertModel",class zb extends Qg{}]],["nomic_bert",["NomicBertModel",class Cb extends Yg{}]],["roformer",["RoFormerModel",class Tb extends Zg{}]],["electra",["ElectraModel",class Ib extends ew{}]],["esm",["EsmModel",class Ab extends iw{}]],["convbert",["ConvBertModel",class Mb extends Jg{}]],["camembert",["CamembertModel",class Ob extends tw{}]],["deberta",["DebertaModel",class Bb extends nw{}]],["deberta-v2",["DebertaV2Model",class Nb extends rw{}]],["mpnet",["MPNetModel",class Pb extends ow{}]],["albert",["AlbertModel",class Rb extends uw{}]],["distilbert",["DistilBertModel",class Db extends sw{}]],["roberta",["RobertaModel",class Fb extends gw{}]],["xlm",["XLMModel",class Lb extends ww{}]],["xlm-roberta",["XLMRobertaModel",class Ub extends yw{}]],["clap",["ClapModel",class qb extends lb{}]],["clip",["CLIPModel",class Vb extends Mw{}]],["clipseg",["CLIPSegModel",class Wb extends Pw{}]],["chinese_clip",["ChineseCLIPModel",class jb extends Bw{}]],["siglip",["SiglipModel",class Gb extends Ow{}]],["jina_clip",["JinaCLIPModel",class Hb extends Nw{async forward(e){const t=!e.input_ids,n=!e.pixel_values;if(t&&n)throw new Error("Either `input_ids` or `pixel_values` should be provided.");if(t&&(e.input_ids=ch([e.pixel_values.dims[0],1])),n){const{image_size:t}=this.config.vision_config;e.pixel_values=uh([0,3,t,t],0)}const{text_embeddings:r,image_embeddings:s,l2norm_text_embeddings:i,l2norm_image_embeddings:a}=await super.forward(e),o={};return t||(o.text_embeddings=r,o.l2norm_text_embeddings=i),n||(o.image_embeddings=s,o.l2norm_image_embeddings=a),o}}]],["mobilebert",["MobileBertModel",class Kb extends aw{}]],["squeezebert",["SqueezeBertModel",class Xb extends lw{}]],["wav2vec2",["Wav2Vec2Model",class Qb extends Qy{}]],["wav2vec2-bert",["Wav2Vec2BertModel",class Yb extends tb{}]],["unispeech",["UniSpeechModel",class Zb extends Jy{}]],["unispeech-sat",["UniSpeechSatModel",class Jb extends eb{}]],["hubert",["HubertModel",class ex extends Qy{}]],["wavlm",["WavLMModel",class tx extends nb{}]],["audio-spectrogram-transformer",["ASTModel",class nx extends bw{}]],["vits",["VitsModel",db]],["pyannote",["PyAnnoteModel",class rx extends Yy{}]],["wespeaker-resnet",["WeSpeakerResNetModel",class sx extends Zy{}]],["detr",["DetrModel",class ix extends xy{}]],["rt_detr",["RTDetrModel",class ax extends Ey{}]],["table-transformer",["TableTransformerModel",class ox extends zy{}]],["vit",["ViTModel",class lx extends oy{}]],["ijepa",["IJepaModel",class ux extends ly{}]],["pvt",["PvtModel",class dx extends dy{}]],["vit_msn",["ViTMSNModel",class cx extends py{}]],["vit_mae",["ViTMAEModel",class px extends cy{}]],["groupvit",["GroupViTModel",class hx extends hy{}]],["fastvit",["FastViTModel",class fx extends fy{}]],["mobilevit",["MobileViTModel",class mx extends _y{}]],["mobilevitv2",["MobileViTV2Model",class _x extends gy{}]],["owlvit",["OwlViTModel",class gx extends wy{}]],["owlv2",["Owlv2Model",class wx extends yy{}]],["beit",["BeitModel",class yx extends by{}]],["deit",["DeiTModel",class bx extends Ty{}]],["hiera",["HieraModel",class xx extends Iy{}]],["convnext",["ConvNextModel",class vx extends Uy{}]],["convnextv2",["ConvNextV2Model",class $x extends qy{}]],["dinov2",["Dinov2Model",class kx extends Vy{}]],["resnet",["ResNetModel",class Ex extends Ay{}]],["swin",["SwinModel",class Sx extends My{}]],["swin2sr",["Swin2SRModel",class zx extends Oy{}]],["donut-swin",["DonutSwinModel",class Cx extends Ly{}]],["yolos",["YolosModel",class Tx extends Wy{}]],["dpt",["DPTModel",class Ix extends By{}]],["glpn",["GLPNModel",class Ax extends Fy{}]],["hifigan",["SpeechT5HifiGan",class Mx extends Kg{main_input_name="spectrogram"}]],["efficientnet",["EfficientNetModel",class Ox extends hb{}]],["decision_transformer",["DecisionTransformerModel",class Bx extends yb{}]],["patchtst",["PatchTSTForPrediction",class Nx extends $b{}]],["patchtsmixer",["PatchTSMixerForPrediction",class Px extends kb{}]],["mobilenet_v1",["MobileNetV1Model",class Rx extends mb{}]],["mobilenet_v2",["MobileNetV2Model",class Dx extends _b{}]],["mobilenet_v3",["MobileNetV3Model",class Fx extends gb{}]],["mobilenet_v4",["MobileNetV4Model",class Lx extends wb{}]],["maskformer",["MaskFormerModel",class Ux extends Dy{}]],["mgp-str",["MgpstrForSceneTextRecognition",class qx extends vb{async _call(e){return new xb(await super._call(e))}}]]]),Vx=new Map([["t5",["T5Model",class Wx extends dw{}]],["longt5",["LongT5Model",class jx extends cw{}]],["mt5",["MT5Model",class Gx extends pw{}]],["bart",["BartModel",class Hx extends hw{}]],["mbart",["MBartModel",class Kx extends fw{}]],["marian",["MarianModel",class Xx extends Ky{}]],["whisper",["WhisperModel",class Qx extends xw{}]],["m2m_100",["M2M100Model",class Yx extends Xy{}]],["blenderbot",["BlenderbotModel",class Zx extends mw{}]],["blenderbot-small",["BlenderbotSmallModel",class Jx extends _w{}]]]),ev=new Map([["bloom",["BloomModel",class tv extends sy{}]],["jais",["JAISModel",class nv extends Dw{}]],["gpt2",["GPT2Model",class rv extends Rw{}]],["gptj",["GPTJModel",class sv extends Uw{}]],["gpt_bigcode",["GPTBigCodeModel",class iv extends qw{}]],["gpt_neo",["GPTNeoModel",class av extends Fw{}]],["gpt_neox",["GPTNeoXModel",class ov extends Lw{}]],["codegen",["CodeGenModel",class lv extends Vw{}]],["llama",["LlamaModel",class uv extends Ww{}]],["exaone",["ExaoneModel",class dv extends jw{}]],["olmo",["OlmoModel",class cv extends Hw{}]],["olmo2",["Olmo2Model",class pv extends Kw{}]],["mobilellm",["MobileLLMModel",class hv extends Gw{}]],["granite",["GraniteModel",class fv extends Xw{}]],["cohere",["CohereModel",class mv extends Qw{}]],["gemma",["GemmaModel",class _v extends Yw{}]],["gemma2",["Gemma2Model",class gv extends Zw{}]],["openelm",["OpenELMModel",class wv extends Jw{}]],["qwen2",["Qwen2Model",class yv extends ey{}]],["phi",["PhiModel",class bv extends ny{}]],["phi3",["Phi3Model",class xv extends ry{}]],["mpt",["MptModel",class vv extends iy{}]],["opt",["OPTModel",class $v extends ay{}]],["mistral",["MistralModel",class kv extends ib{}]],["starcoder2",["Starcoder2Model",class Ev extends ab{}]],["falcon",["FalconModel",class Sv extends ob{}]],["stablelm",["StableLmModel",class zv extends pb{}]]]),Cv=new Map([["speecht5",["SpeechT5ForSpeechToText",class Tv extends rb{}]],["whisper",["WhisperForConditionalGeneration",class Iv extends xw{_prepare_generation_config(e,t){return super._prepare_generation_config(e,t,gg)}_retrieve_init_tokens(e){const t=[e.decoder_start_token_id];let n=e.language;const r=e.task;if(e.is_multilingual){n||(console.warn("No language specified - defaulting to English (en)."),n="en");const s=function i(e){e=e.toLowerCase();let t=bf.get(e);if(void 0===t){if(!yf.has(e)){const t=2===e.length?yf.keys():yf.values();throw new Error(`Language "${e}" is not supported. Must be one of: ${JSON.stringify(t)}`)}t=e}return t}(n),a=`<|${s}|>`;t.push(e.lang_to_id[a]),t.push(e.task_to_id[r??"transcribe"])}else if(n||r)throw new Error("Cannot specify `task` or `language` for an English-only model. If the model is intended to be multilingual, pass `is_multilingual=true` to generate, or update the generation config.");return!e.return_timestamps&&e.no_timestamps_token_id&&t.at(-1)!==e.no_timestamps_token_id?t.push(e.no_timestamps_token_id):e.return_timestamps&&t.at(-1)===e.no_timestamps_token_id&&(console.warn("<|notimestamps|> prompt token is removed from generation_config since `return_timestamps` is set to `true`."),t.pop()),t.filter((e=>null!=e))}async generate({inputs:e=null,generation_config:t=null,logits_processor:n=null,stopping_criteria:r=null,...s}){t=this._prepare_generation_config(t,s);const i=s.decoder_input_ids??this._retrieve_init_tokens(t);if(t.return_timestamps&&(n??=new L_,n.push(new W_(t,i))),t.begin_suppress_tokens&&(n??=new L_,n.push(new V_(t.begin_suppress_tokens,i.length))),t.return_token_timestamps){if(!t.alignment_heads)throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");"translate"===t.task&&console.warn("Token-level timestamps may not be reliable for task \'translate\'."),t.output_attentions=!0,t.return_dict_in_generate=!0}const a=await super.generate({inputs:e,generation_config:t,logits_processor:n,decoder_input_ids:i,...s});return t.return_token_timestamps&&(a.token_timestamps=this._extract_token_timestamps(a,t.alignment_heads,t.num_frames)),a}_extract_token_timestamps(e,t,n=null,r=.02){if(!e.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");null==n&&console.warn("`num_frames` has not been set, meaning the entire audio will be analyzed. This may lead to inaccurate token-level timestamps for short audios (< 30 seconds).");let s=this.config.median_filter_width;void 0===s&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),s=7);const i=e.cross_attentions,a=Array.from({length:this.config.decoder_layers},((e,t)=>sh(i.map((e=>e[t])),2))),o=ih(t.map((([e,t])=>{if(e>=a.length)throw new Error(`Layer index ${e} is out of bounds for cross attentions (length ${a.length}).`);return n?a[e].slice(null,t,null,[0,n]):a[e].slice(null,t)}))).transpose(1,0,2,3),[l,u]=ah(o,-2,0,!0),d=o.clone();for(let e=0;e<d.dims[0];++e){const t=d[e];for(let n=0;n<t.dims[0];++n){const r=t[n],i=l[e][n][0].data,a=u[e][n][0].data;for(let e=0;e<r.dims[0];++e){let t=r[e].data;for(let e=0;e<t.length;++e)t[e]=(t[e]-a[e])/i[e];t.set(xe(t,s))}}}const c=[oh(d,1)],p=e.sequences.dims,h=new Xp("float32",new Float32Array(p[0]*p[1]),p);for(let e=0;e<p[0];++e){const t=c[e].neg().squeeze_(0),[n,s]=$e(t.tolist()),i=Q([1],Array.from({length:n.length-1},((e,t)=>n[t+1]-n[t]))).map((e=>!!e)),a=[];for(let e=0;e<i.length;++e)i[e]&&a.push(s[e]*r);h[e].data.set(a,1)}return h}}]],["moonshine",["MoonshineForConditionalGeneration",class Av extends vw{}]]]),Mv=new Map([["speecht5",["SpeechT5ForTextToSpeech",class Ov extends rb{async generate_speech(e,t,{threshold:n=.5,minlenratio:r=0,maxlenratio:s=20,vocoder:i=null}={}){const a={input_ids:e},{encoder_outputs:o,encoder_attention_mask:l}=await Fg(this,a),u=o.dims[1]/this.config.reduction_factor,d=Math.floor(u*s),c=Math.floor(u*r),p=this.config.num_mel_bins;let h=[],f=null,m=null,_=0;for(;;){++_;const e=Rg(!!m);let r;r=m?m.output_sequence_out:new Xp("float32",new Float32Array(p),[1,1,p]);let s={use_cache_branch:e,output_sequence:r,encoder_attention_mask:l,speaker_embeddings:t,encoder_hidden_states:o};this.addPastKeyValues(s,f),m=await Bg(this.sessions.decoder_model_merged,s),f=this.getPastKeyValues(m,f);const{prob:i,spectrum:a}=m;if(h.push(a),_>=c&&(Array.from(i.data).filter((e=>e>=n)).length>0||_>=d))break}const g=sh(h),{waveform:w}=await Bg(i.sessions.model,{spectrogram:g});return{spectrogram:g,waveform:w}}}]]]),Bv=new Map([["vits",["VitsModel",db]],["musicgen",["MusicgenForConditionalGeneration",fb]]]),Nv=new Map([["bert",["BertForSequenceClassification",class Pv extends Qg{async _call(e){return new zS(await super._call(e))}}]],["roformer",["RoFormerForSequenceClassification",class Rv extends Zg{async _call(e){return new zS(await super._call(e))}}]],["electra",["ElectraForSequenceClassification",class Dv extends ew{async _call(e){return new zS(await super._call(e))}}]],["esm",["EsmForSequenceClassification",class Fv extends iw{async _call(e){return new zS(await super._call(e))}}]],["convbert",["ConvBertForSequenceClassification",class Lv extends Jg{async _call(e){return new zS(await super._call(e))}}]],["camembert",["CamembertForSequenceClassification",class Uv extends tw{async _call(e){return new zS(await super._call(e))}}]],["deberta",["DebertaForSequenceClassification",class qv extends nw{async _call(e){return new zS(await super._call(e))}}]],["deberta-v2",["DebertaV2ForSequenceClassification",class Vv extends rw{async _call(e){return new zS(await super._call(e))}}]],["mpnet",["MPNetForSequenceClassification",class Wv extends ow{async _call(e){return new zS(await super._call(e))}}]],["albert",["AlbertForSequenceClassification",class jv extends uw{async _call(e){return new zS(await super._call(e))}}]],["distilbert",["DistilBertForSequenceClassification",class Gv extends sw{async _call(e){return new zS(await super._call(e))}}]],["roberta",["RobertaForSequenceClassification",class Hv extends gw{async _call(e){return new zS(await super._call(e))}}]],["xlm",["XLMForSequenceClassification",class Kv extends ww{async _call(e){return new zS(await super._call(e))}}]],["xlm-roberta",["XLMRobertaForSequenceClassification",class Xv extends yw{async _call(e){return new zS(await super._call(e))}}]],["bart",["BartForSequenceClassification",class Qv extends hw{async _call(e){return new zS(await super._call(e))}}]],["mbart",["MBartForSequenceClassification",class Yv extends fw{async _call(e){return new zS(await super._call(e))}}]],["mobilebert",["MobileBertForSequenceClassification",class Zv extends aw{async _call(e){return new zS(await super._call(e))}}]],["squeezebert",["SqueezeBertForSequenceClassification",class Jv extends lw{async _call(e){return new zS(await super._call(e))}}]]]),e$=new Map([["bert",["BertForTokenClassification",class t$ extends Qg{async _call(e){return new TS(await super._call(e))}}]],["roformer",["RoFormerForTokenClassification",class n$ extends Zg{async _call(e){return new TS(await super._call(e))}}]],["electra",["ElectraForTokenClassification",class r$ extends ew{async _call(e){return new TS(await super._call(e))}}]],["esm",["EsmForTokenClassification",class s$ extends iw{async _call(e){return new TS(await super._call(e))}}]],["convbert",["ConvBertForTokenClassification",class i$ extends Jg{async _call(e){return new TS(await super._call(e))}}]],["camembert",["CamembertForTokenClassification",class a$ extends tw{async _call(e){return new TS(await super._call(e))}}]],["deberta",["DebertaForTokenClassification",class o$ extends nw{async _call(e){return new TS(await super._call(e))}}]],["deberta-v2",["DebertaV2ForTokenClassification",class l$ extends rw{async _call(e){return new TS(await super._call(e))}}]],["mpnet",["MPNetForTokenClassification",class u$ extends ow{async _call(e){return new TS(await super._call(e))}}]],["distilbert",["DistilBertForTokenClassification",class d$ extends sw{async _call(e){return new TS(await super._call(e))}}]],["roberta",["RobertaForTokenClassification",class c$ extends gw{async _call(e){return new TS(await super._call(e))}}]],["xlm",["XLMForTokenClassification",class p$ extends ww{async _call(e){return new TS(await super._call(e))}}]],["xlm-roberta",["XLMRobertaForTokenClassification",class h$ extends yw{async _call(e){return new TS(await super._call(e))}}]]]),f$=new Map([["t5",["T5ForConditionalGeneration",class m$ extends dw{}]],["longt5",["LongT5ForConditionalGeneration",class _$ extends cw{}]],["mt5",["MT5ForConditionalGeneration",class g$ extends pw{}]],["bart",["BartForConditionalGeneration",class w$ extends hw{}]],["mbart",["MBartForConditionalGeneration",class y$ extends fw{}]],["marian",["MarianMTModel",class b$ extends Ky{}]],["m2m_100",["M2M100ForConditionalGeneration",class x$ extends Xy{}]],["blenderbot",["BlenderbotForConditionalGeneration",class v$ extends mw{}]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",class $$ extends _w{}]]]),k$=new Map([["bloom",["BloomForCausalLM",class E$ extends sy{}]],["gpt2",["GPT2LMHeadModel",class S$ extends Rw{}]],["jais",["JAISLMHeadModel",class z$ extends Dw{}]],["gptj",["GPTJForCausalLM",class C$ extends Uw{}]],["gpt_bigcode",["GPTBigCodeForCausalLM",class T$ extends qw{}]],["gpt_neo",["GPTNeoForCausalLM",class I$ extends Fw{}]],["gpt_neox",["GPTNeoXForCausalLM",class A$ extends Lw{}]],["codegen",["CodeGenForCausalLM",class M$ extends Vw{}]],["llama",["LlamaForCausalLM",class O$ extends Ww{}]],["exaone",["ExaoneForCausalLM",class B$ extends jw{}]],["olmo",["OlmoForCausalLM",class N$ extends Hw{}]],["olmo2",["Olmo2ForCausalLM",class P$ extends Kw{}]],["mobilellm",["MobileLLMForCausalLM",class R$ extends Gw{}]],["granite",["GraniteForCausalLM",class D$ extends Xw{}]],["cohere",["CohereForCausalLM",class F$ extends Qw{}]],["gemma",["GemmaForCausalLM",class L$ extends Yw{}]],["gemma2",["Gemma2ForCausalLM",class U$ extends Zw{}]],["openelm",["OpenELMForCausalLM",class q$ extends Jw{}]],["qwen2",["Qwen2ForCausalLM",class V$ extends ey{}]],["phi",["PhiForCausalLM",class W$ extends ny{}]],["phi3",["Phi3ForCausalLM",class j$ extends ry{}]],["mpt",["MptForCausalLM",class G$ extends iy{}]],["opt",["OPTForCausalLM",class H$ extends ay{}]],["mbart",["MBartForCausalLM",class K$ extends fw{}]],["mistral",["MistralForCausalLM",class X$ extends ib{}]],["starcoder2",["Starcoder2ForCausalLM",class Q$ extends ab{}]],["falcon",["FalconForCausalLM",class Y$ extends ob{}]],["trocr",["TrOCRForCausalLM",class Z$ extends sb{}]],["stablelm",["StableLmForCausalLM",class J$ extends pb{}]],["phi3_v",["Phi3VForCausalLM",Aw]]]),ek=new Map([["multi_modality",["MultiModalityCausalLM",class tk extends bb{forward_params=["input_ids","pixel_values","images_seq_mask","images_emb_mask","attention_mask","position_ids","past_key_values"];constructor(...e){super(...e),this._generation_mode="text"}async forward(e){const t=this._generation_mode??"text";let n;if("text"!==t&&e.past_key_values){const t=this.sessions.gen_img_embeds,r=J({image_ids:e.input_ids},t.inputNames);n=await Bg(t,r)}else{const t=this.sessions.prepare_inputs_embeds,r=J(e,t.inputNames);n=await Bg(t,r)}const r={...e,...n},s=await Lg(this,r),i=this.sessions["text"===t?"lm_head":"gen_head"];if(!i)throw new Error(`Unable to find "${i}" generation head`);const a=await Bg(i,J(s,i.inputNames));return{...n,...s,...a}}async generate(e){return this._generation_mode="text",super.generate(e)}async generate_images(e){this._generation_mode="image";const t=(e.inputs??e[this.main_input_name]).dims[1],n=(await super.generate(e)).slice(null,[t,null]),r=this.sessions.image_decode,{decoded_image:s}=await Bg(r,{generated_tokens:n}),i=s.add_(1).mul_(127.5).clamp_(0,255).to("uint8"),a=[];for(const e of i){const t=lg.fromTensor(e);a.push(t)}return a}}]]]),nk=new Map([["bert",["BertForMaskedLM",class rk extends Qg{async _call(e){return new IS(await super._call(e))}}]],["roformer",["RoFormerForMaskedLM",class sk extends Zg{async _call(e){return new IS(await super._call(e))}}]],["electra",["ElectraForMaskedLM",class ik extends ew{async _call(e){return new IS(await super._call(e))}}]],["esm",["EsmForMaskedLM",class ak extends iw{async _call(e){return new IS(await super._call(e))}}]],["convbert",["ConvBertForMaskedLM",class ok extends Jg{async _call(e){return new IS(await super._call(e))}}]],["camembert",["CamembertForMaskedLM",class lk extends tw{async _call(e){return new IS(await super._call(e))}}]],["deberta",["DebertaForMaskedLM",class uk extends nw{async _call(e){return new IS(await super._call(e))}}]],["deberta-v2",["DebertaV2ForMaskedLM",class dk extends rw{async _call(e){return new IS(await super._call(e))}}]],["mpnet",["MPNetForMaskedLM",class ck extends ow{async _call(e){return new IS(await super._call(e))}}]],["albert",["AlbertForMaskedLM",class pk extends uw{async _call(e){return new IS(await super._call(e))}}]],["distilbert",["DistilBertForMaskedLM",class hk extends sw{async _call(e){return new IS(await super._call(e))}}]],["roberta",["RobertaForMaskedLM",class fk extends gw{async _call(e){return new IS(await super._call(e))}}]],["xlm",["XLMWithLMHeadModel",class mk extends ww{async _call(e){return new IS(await super._call(e))}}]],["xlm-roberta",["XLMRobertaForMaskedLM",class _k extends yw{async _call(e){return new IS(await super._call(e))}}]],["mobilebert",["MobileBertForMaskedLM",class gk extends aw{async _call(e){return new IS(await super._call(e))}}]],["squeezebert",["SqueezeBertForMaskedLM",class wk extends lw{async _call(e){return new IS(await super._call(e))}}]]]),yk=new Map([["bert",["BertForQuestionAnswering",class bk extends Qg{async _call(e){return new AS(await super._call(e))}}]],["roformer",["RoFormerForQuestionAnswering",class xk extends Zg{async _call(e){return new AS(await super._call(e))}}]],["electra",["ElectraForQuestionAnswering",class vk extends ew{async _call(e){return new AS(await super._call(e))}}]],["convbert",["ConvBertForQuestionAnswering",class $k extends Jg{async _call(e){return new AS(await super._call(e))}}]],["camembert",["CamembertForQuestionAnswering",class kk extends tw{async _call(e){return new AS(await super._call(e))}}]],["deberta",["DebertaForQuestionAnswering",class Ek extends nw{async _call(e){return new AS(await super._call(e))}}]],["deberta-v2",["DebertaV2ForQuestionAnswering",class Sk extends rw{async _call(e){return new AS(await super._call(e))}}]],["mpnet",["MPNetForQuestionAnswering",class zk extends ow{async _call(e){return new AS(await super._call(e))}}]],["albert",["AlbertForQuestionAnswering",class Ck extends uw{async _call(e){return new AS(await super._call(e))}}]],["distilbert",["DistilBertForQuestionAnswering",class Tk extends sw{async _call(e){return new AS(await super._call(e))}}]],["roberta",["RobertaForQuestionAnswering",class Ik extends gw{async _call(e){return new AS(await super._call(e))}}]],["xlm",["XLMForQuestionAnswering",class Ak extends ww{async _call(e){return new AS(await super._call(e))}}]],["xlm-roberta",["XLMRobertaForQuestionAnswering",class Mk extends yw{async _call(e){return new AS(await super._call(e))}}]],["mobilebert",["MobileBertForQuestionAnswering",class Ok extends aw{async _call(e){return new AS(await super._call(e))}}]],["squeezebert",["SqueezeBertForQuestionAnswering",class Bk extends lw{async _call(e){return new AS(await super._call(e))}}]]]),Nk=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",$w]],["idefics3",["Idefics3ForConditionalGeneration",Tw]]]),Pk=new Map([["llava",["LlavaForConditionalGeneration",Ew]],["llava_onevision",["LlavaOnevisionForConditionalGeneration",class Rk extends Ew{}]],["moondream1",["Moondream1ForConditionalGeneration",class Dk extends Ew{}]],["florence2",["Florence2ForConditionalGeneration",class Fk extends Sw{_merge_input_ids_with_image_features({inputs_embeds:e,image_features:t,input_ids:n,attention_mask:r}){return{inputs_embeds:sh([t,e],1),attention_mask:sh([ch(t.dims.slice(0,2)),r],1)}}async _prepare_inputs_embeds({input_ids:e,pixel_values:t,inputs_embeds:n,attention_mask:r}){if(!e&&!t)throw new Error("Either `input_ids` or `pixel_values` should be provided.");let s,i;return e&&(s=await this.encode_text({input_ids:e})),t&&(i=await this.encode_image({pixel_values:t})),s&&i?({inputs_embeds:n,attention_mask:r}=this._merge_input_ids_with_image_features({inputs_embeds:s,image_features:i,input_ids:e,attention_mask:r})):n=s||i,{inputs_embeds:n,attention_mask:r}}async forward({input_ids:e,pixel_values:t,attention_mask:n,decoder_input_ids:r,decoder_attention_mask:s,encoder_outputs:i,past_key_values:a,inputs_embeds:o,decoder_inputs_embeds:l}){if(o||({inputs_embeds:o,attention_mask:n}=await this._prepare_inputs_embeds({input_ids:e,pixel_values:t,inputs_embeds:o,attention_mask:n})),!i){let{last_hidden_state:e}=await Fg(this,{inputs_embeds:o,attention_mask:n});i=e}if(!l){if(!r)throw new Error("Either `decoder_input_ids` or `decoder_inputs_embeds` should be provided.");l=await this.encode_text({input_ids:r})}const u={inputs_embeds:l,attention_mask:s,encoder_attention_mask:n,encoder_hidden_states:i,past_key_values:a};return await Lg(this,u,!0)}}]],["qwen2-vl",["Qwen2VLForConditionalGeneration",class Lk extends ty{get_rope_index(e,t,n,r){const{vision_config:s,image_token_id:i,video_token_id:a,vision_start_token_id:o}=this.config,l=s.spatial_merge_size??2,u=[];if(t||n){let s=e.tolist();r||(r=ph(e));const d=r.tolist(),c=Array.from({length:3},(t=>Array.from({length:e.dims[0]},(t=>Array.from({length:e.dims[1]},(e=>1)))))),p=t?t.tolist():[],h=n?n.tolist():[];let f=0,m=0;for(let e=0;e<s.length;++e){const t=s[e].filter(((t,n)=>1==d[e][n])),n=t.reduce(((e,t,n)=>(t==o&&e.push(n),e)),[]).map((e=>t[e+1])),r=n.filter((e=>e==i)).length,_=n.filter((e=>e==a)).length;let g=[],w=0,y=r,b=_;for(let e=0;e<n.length;++e){const e=t.findIndex(((e,t)=>t>w&&e==i)),n=t.findIndex(((e,t)=>t>w&&e==a)),r=y>0&&-1!==e?e:t.length+1,s=b>0&&-1!==n?n:t.length+1;let o,u,d,c;r<s?([u,d,c]=p[f],++f,--y,o=r):([u,d,c]=h[m],++m,--b,o=s);const[_,x,v]=[Number(u),Math.floor(Number(d)/l),Math.floor(Number(c)/l)],$=o-w,k=g.length>0?_e(g.at(-1))[0]+1:0;g.push(Array.from({length:3*$},((e,t)=>k+t%$)));const E=$+k,S=_*x*v,z=Array.from({length:S},((e,t)=>E+Math.floor(t/(x*v)))),C=Array.from({length:S},((e,t)=>E+Math.floor(t/v)%x)),T=Array.from({length:S},((e,t)=>E+t%v));g.push([z,C,T].flat()),w=o+S}if(w<t.length){const e=g.length>0?_e(g.at(-1))[0]+1:0,n=t.length-w;g.push(Array.from({length:3*n},((t,r)=>e+r%n)))}const x=g.reduce(((e,t)=>e+t.length),0),v=new Array(x);let $=0;for(let e=0;e<3;++e)for(let t=0;t<g.length;++t){const n=g[t],r=n.length/3;for(let t=e*r;t<(e+1)*r;++t)v[$++]=n[t]}let k=0;const E=d[e];for(let t=0;t<E.length;++t)if(1==E[t]){for(let n=0;n<3;++n)c[n][e][t]=v[n*x/3+k];++k}const S=_e(v)[0];u.push(S+1-s[e].length)}return[new Xp("int64",c.flat(Infinity),[3,e.dims[0],e.dims[1]]),new Xp("int64",u,[u.length,1])]}if(r){const{data:e,dims:t}=Vg(r),n=BigInt64Array.from({length:3*e.length},((t,n)=>e[n%e.length])),s=Array.from({length:t[0]},((n,r)=>_e(e.subarray(t[1]*r,t[1]*(r+1)))[0]+1+t[1]));return[new Xp("int64",n,[3,...t]),new Xp("int64",s,[s.length,1])]}{const[t,n]=e.dims,r=BigInt64Array.from({length:3*t*n},((e,r)=>BigInt(Math.floor(r%n/t))));return[new Xp("int64",r,[3,...e.dims]),hh([t,1])]}}async encode_image({pixel_values:e,image_grid_thw:t}){return(await Bg(this.sessions.vision_encoder,{pixel_values:e,grid_thw:t})).image_features}_merge_input_ids_with_image_features(e){return Ug({image_token_id:this.config.image_token_id,...e})}prepare_inputs_for_generation(e,t,n){if(t.attention_mask&&!t.position_ids)if(t.past_key_values){t.pixel_values=null;const e=BigInt(Object.values(t.past_key_values)[0].dims.at(-2)),n=t.rope_deltas.map((t=>e+t));t.position_ids=ih([n,n,n],0)}else[t.position_ids,t.rope_deltas]=this.get_rope_index(t.input_ids,t.image_grid_thw,t.video_grid_thw,t.attention_mask);return t}}]],["idefics3",["Idefics3ForConditionalGeneration",Tw]],["paligemma",["PaliGemmaForConditionalGeneration",class Uk extends zw{_merge_input_ids_with_image_features(e){const t=e.image_features.dims.at(-1),n=e.image_features.view(-1,t);return Ug({image_token_id:this.config.image_token_index,...e,image_features:n})}}]]]),qk=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",$w]]]),Vk=new Map([["vit",["ViTForImageClassification",class Wk extends oy{async _call(e){return new zS(await super._call(e))}}]],["ijepa",["IJepaForImageClassification",class jk extends ly{async _call(e){return new zS(await super._call(e))}}]],["pvt",["PvtForImageClassification",class Gk extends dy{async _call(e){return new zS(await super._call(e))}}]],["vit_msn",["ViTMSNForImageClassification",class Hk extends py{async _call(e){return new zS(await super._call(e))}}]],["fastvit",["FastViTForImageClassification",class Kk extends fy{async _call(e){return new zS(await super._call(e))}}]],["mobilevit",["MobileViTForImageClassification",class Xk extends _y{async _call(e){return new zS(await super._call(e))}}]],["mobilevitv2",["MobileViTV2ForImageClassification",class Qk extends gy{async _call(e){return new zS(await super._call(e))}}]],["beit",["BeitForImageClassification",class Yk extends by{async _call(e){return new zS(await super._call(e))}}]],["deit",["DeiTForImageClassification",class Zk extends Ty{async _call(e){return new zS(await super._call(e))}}]],["hiera",["HieraForImageClassification",class Jk extends Iy{async _call(e){return new zS(await super._call(e))}}]],["convnext",["ConvNextForImageClassification",class eE extends Uy{async _call(e){return new zS(await super._call(e))}}]],["convnextv2",["ConvNextV2ForImageClassification",class tE extends qy{async _call(e){return new zS(await super._call(e))}}]],["dinov2",["Dinov2ForImageClassification",class nE extends Vy{async _call(e){return new zS(await super._call(e))}}]],["resnet",["ResNetForImageClassification",class rE extends Ay{async _call(e){return new zS(await super._call(e))}}]],["swin",["SwinForImageClassification",class sE extends My{async _call(e){return new zS(await super._call(e))}}]],["segformer",["SegformerForImageClassification",class iE extends cb{}]],["efficientnet",["EfficientNetForImageClassification",class aE extends hb{async _call(e){return new zS(await super._call(e))}}]],["mobilenet_v1",["MobileNetV1ForImageClassification",class oE extends mb{async _call(e){return new zS(await super._call(e))}}]],["mobilenet_v2",["MobileNetV2ForImageClassification",class lE extends _b{async _call(e){return new zS(await super._call(e))}}]],["mobilenet_v3",["MobileNetV3ForImageClassification",class uE extends gb{async _call(e){return new zS(await super._call(e))}}]],["mobilenet_v4",["MobileNetV4ForImageClassification",class dE extends wb{async _call(e){return new zS(await super._call(e))}}]]]),cE=new Map([["detr",["DetrForObjectDetection",class pE extends xy{async _call(e){return new $y(await super._call(e))}}]],["rt_detr",["RTDetrForObjectDetection",class hE extends Ey{async _call(e){return new Sy(await super._call(e))}}]],["table-transformer",["TableTransformerForObjectDetection",class fE extends zy{async _call(e){return new Cy(await super._call(e))}}]],["yolos",["YolosForObjectDetection",class mE extends Wy{async _call(e){return new jy(await super._call(e))}}]]]),_E=new Map([["owlvit",["OwlViTForObjectDetection",class gE extends wy{}]],["owlv2",["Owlv2ForObjectDetection",class wE extends yy{}]]]),yE=new Map([["detr",["DetrForSegmentation",vy]],["clipseg",["CLIPSegForImageSegmentation",class bE extends Pw{}]]]),xE=new Map([["segformer",["SegformerForSemanticSegmentation",class vE extends cb{}]],["sapiens",["SapiensForSemanticSegmentation",class $E extends Py{}]]]),kE=new Map([["detr",["DetrForSegmentation",vy]],["maskformer",["MaskFormerForInstanceSegmentation",class EE extends Dy{}]]]),SE=new Map([["sam",["SamModel",class zE extends Gy{async get_image_embeddings({pixel_values:e}){return await Fg(this,{pixel_values:e})}async forward(e){if(e.image_embeddings&&e.image_positional_embeddings||(e={...e,...await this.get_image_embeddings(e)}),!e.input_labels&&e.input_points){const t=e.input_points.dims.slice(0,-1),n=t.reduce(((e,t)=>e*t),1);e.input_labels=new Xp("int64",new BigInt64Array(n).fill(1n),t)}const t={image_embeddings:e.image_embeddings,image_positional_embeddings:e.image_positional_embeddings};return e.input_points&&(t.input_points=e.input_points),e.input_labels&&(t.input_labels=e.input_labels),e.input_boxes&&(t.input_boxes=e.input_boxes),await Bg(this.sessions.prompt_encoder_mask_decoder,t)}async _call(e){return new Hy(await super._call(e))}}]]]),CE=new Map([["wav2vec2",["Wav2Vec2ForCTC",class TE extends Qy{async _call(e){return new MS(await super._call(e))}}]],["wav2vec2-bert",["Wav2Vec2BertForCTC",class IE extends tb{async _call(e){return new MS(await super._call(e))}}]],["unispeech",["UniSpeechForCTC",class AE extends Jy{async _call(e){return new MS(await super._call(e))}}]],["unispeech-sat",["UniSpeechSatForCTC",class ME extends eb{async _call(e){return new MS(await super._call(e))}}]],["wavlm",["WavLMForCTC",class OE extends nb{async _call(e){return new MS(await super._call(e))}}]],["hubert",["HubertForCTC",class BE extends Qy{async _call(e){return new MS(await super._call(e))}}]]]),NE=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",class PE extends Qy{async _call(e){return new zS(await super._call(e))}}]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",class RE extends tb{async _call(e){return new zS(await super._call(e))}}]],["unispeech",["UniSpeechForSequenceClassification",class DE extends Jy{async _call(e){return new zS(await super._call(e))}}]],["unispeech-sat",["UniSpeechSatForSequenceClassification",class FE extends eb{async _call(e){return new zS(await super._call(e))}}]],["wavlm",["WavLMForSequenceClassification",class LE extends nb{async _call(e){return new zS(await super._call(e))}}]],["hubert",["HubertForSequenceClassification",class UE extends Qy{async _call(e){return new zS(await super._call(e))}}]],["audio-spectrogram-transformer",["ASTForAudioClassification",class qE extends bw{}]]]),VE=new Map([["wavlm",["WavLMForXVector",class WE extends nb{async _call(e){return new CS(await super._call(e))}}]]]),jE=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",class GE extends eb{async _call(e){return new TS(await super._call(e))}}]],["wavlm",["WavLMForAudioFrameClassification",class HE extends nb{async _call(e){return new TS(await super._call(e))}}]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",class KE extends Qy{async _call(e){return new TS(await super._call(e))}}]],["pyannote",["PyAnnoteForAudioFrameClassification",class XE extends Yy{async _call(e){return new TS(await super._call(e))}}]]]),QE=new Map([["vitmatte",["VitMatteForImageMatting",class YE extends my{async _call(e){return new OS(await super._call(e))}}]]]),ZE=new Map([["patchtst",["PatchTSTForPrediction",class JE extends $b{}]],["patchtsmixer",["PatchTSMixerForPrediction",class eS extends kb{}]]]),tS=new Map([["swin2sr",["Swin2SRForImageSuperResolution",class nS extends Oy{}]]]),rS=new Map([["dpt",["DPTForDepthEstimation",class sS extends By{}]],["depth_anything",["DepthAnythingForDepthEstimation",class iS extends Ny{}]],["glpn",["GLPNForDepthEstimation",class aS extends Fy{}]],["sapiens",["SapiensForDepthEstimation",class oS extends Py{}]],["depth_pro",["DepthProForDepthEstimation",class lS extends Ry{}]]]),uS=new Map([["sapiens",["SapiensForNormalEstimation",class dS extends Py{}]]]),cS=new Map([["vitpose",["VitPoseForPoseEstimation",class pS extends uy{}]]]),hS=new Map([["clip",["CLIPVisionModelWithProjection",class fS extends Mw{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"vision_model",...t})}}]],["siglip",["SiglipVisionModel",class mS extends Mw{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"vision_model",...t})}}]],["jina_clip",["JinaCLIPVisionModel",class _S extends Nw{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"vision_model",...t})}}]]]),gS=[[Sb,wg],[Vx,yg],[ev,vg],[Nv,wg],[e$,wg],[f$,bg],[Cv,bg],[k$,vg],[ek,Sg],[nk,wg],[yk,wg],[Nk,xg],[Pk,kg],[Vk,wg],[yE,wg],[kE,wg],[xE,wg],[QE,wg],[ZE,wg],[tS,wg],[rS,wg],[uS,wg],[cS,wg],[cE,wg],[_E,wg],[SE,$g],[CE,wg],[NE,wg],[Mv,bg],[Bv,wg],[VE,wg],[jE,wg],[hS,wg]];for(const[e,t]of gS)for(const[n,r]of e.values())Cg.set(n,t),Ig.set(r,n),Tg.set(n,r);const wS=[["MusicgenForConditionalGeneration",fb,Eg],["Phi3VForCausalLM",Aw,zg],["CLIPTextModelWithProjection",class yS extends Mw{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"text_model",...t})}},wg],["SiglipTextModel",class bS extends Ow{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"text_model",...t})}},wg],["JinaCLIPTextModel",class xS extends Nw{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"text_model",...t})}},wg],["ClapTextModelWithProjection",class vS extends lb{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"text_model",...t})}},wg],["ClapAudioModelWithProjection",class $S extends lb{static async from_pretrained(e,t={}){return super.from_pretrained(e,{model_file_name:"audio_model",...t})}},wg]];for(const[e,t,n]of wS)Cg.set(e,n),Ig.set(t,e),Tg.set(e,t);class kS extends Eb{static MODEL_CLASS_MAPPINGS=gS.map((e=>e[0]));static BASE_IF_FAIL=!0}class ES extends Eb{static MODEL_CLASS_MAPPINGS=[Nv]}class SS extends Eb{static MODEL_CLASS_MAPPINGS=[f$]}class zS extends Xg{constructor({logits:e}){super(),this.logits=e}}class CS extends Xg{constructor({logits:e,embeddings:t}){super(),this.logits=e,this.embeddings=t}}class TS extends Xg{constructor({logits:e}){super(),this.logits=e}}class IS extends Xg{constructor({logits:e}){super(),this.logits=e}}class AS extends Xg{constructor({start_logits:e,end_logits:t}){super(),this.start_logits=e,this.end_logits=t}}class MS extends Xg{constructor({logits:e}){super(),this.logits=e}}class OS extends Xg{constructor({alphas:e}){super(),this.alphas=e}}class BS extends Xg{constructor({waveform:e,spectrogram:t}){super(),this.waveform=e,this.spectrogram=t}}class NS extends j{static classes=["image_processor_class","tokenizer_class","feature_extractor_class"];static uses_processor_config=!1;constructor(e,t){super(),this.config=e,this.components=t}get image_processor(){return this.components.image_processor}get tokenizer(){return this.components.tokenizer}get feature_extractor(){return this.components.feature_extractor}apply_chat_template(e,t={}){if(!this.tokenizer)throw new Error("Unable to apply chat template without a tokenizer.");return this.tokenizer.apply_chat_template(e,{tokenize:!1,...t})}batch_decode(...e){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.batch_decode(...e)}async _call(e,...t){for(const n of[this.image_processor,this.feature_extractor,this.tokenizer])if(n)return n(e,...t);throw new Error("No image processor, feature extractor, or tokenizer found.")}static async from_pretrained(e,t){const[n,r]=await Promise.all([this.uses_processor_config?ce(e,"processor_config.json",!0,t):{},Promise.all(this.classes.filter((e=>e in this)).map((async n=>{const r=await this[n].from_pretrained(e,t);return[n.replace(/_class$/,""),r]}))).then(Object.fromEntries)]);return new this(n,r)}}function PS(e,t,n=0,r=null){const s=e/t;let i=function a(e){const t=Math.round(e);return Math.abs(e)%1==.5?t%2==0?t:t-1:t}(s)*t;return null!==r&&i>r&&(i=Math.floor(s)*t),i<n&&(i=Math.ceil(s)*t),i}function RS([e,t],n){return[Math.max(Math.floor(e/n),1)*n,Math.max(Math.floor(t/n),1)*n]}function DS([e,t,n,r]){return[e-n/2,t-r/2,e+n/2,t+r/2]}function FS(e,t=.5,n=null,r=!1){const s=e.logits,i=e.pred_boxes,[a,o,l]=s.dims;if(null!==n&&n.length!==a)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let u=[];for(let e=0;e<a;++e){let a=null!==n?n[e]:null,d={boxes:[],classes:[],scores:[]},c=s[e],p=i[e];for(let e=0;e<o;++e){let n,s=c[e],i=[];if(r){n=s.sigmoid().data;for(let e=0;e<n.length;++e)n[e]>t&&i.push(e)}else{let e=_e(s.data)[1];if(e===l-1)continue;if(n=he(s.data),n[e]<t)continue;i.push(e)}for(const t of i){let r=p[e].data;r=DS(r),null!==a&&(r=r.map(((e,t)=>e*a[(t+1)%2]))),d.boxes.push(r),d.classes.push(t),d.scores.push(n[t])}}u.push(d)}return u}function LS(e,t,n,r){const s=[],i=[],a=[];for(let o=0;o<e.dims[0];++o){const l=e[o],u=t[o],d=_e(l.data)[1];if(d===r)continue;const c=he(l.data)[d];c>n&&(s.push(u),i.push(c),a.push(d))}return[s,i,a]}function US(e,t,n,r=.5,s=.8){const i=[];let a=0,o=0;const l=t[n].data;for(let t=0;t<e.length;++t)e[t]===n&&(i.push(t),++a),l[t]>=r&&++o;let u=a>0&&o>0;if(u){u=a/o>s}return[u,i]}function qS(e,t,n,r,s,i=null,a=null){const[o,l]=a??e[0].dims,u=new Xp("int32",new Int32Array(o*l),[o,l]),d=[];if(null!==a)for(let t=0;t<e.length;++t)e[t]=Qp(e[t],a,"bilinear",!1);const c=new Int32Array(e[0].data.length),p=new Float32Array(e[0].data.length);for(let n=0;n<e.length;++n){let r=t[n];const s=e[n].data;for(let e=0;e<s.length;++e)s[e]*=r,s[e]>p[e]&&(c[e]=n,p[e]=s[e])}let h=0;const f=u.data;for(let i=0;i<n.length;++i){const a=n[i],[o,l]=US(c,e,i,r,s);if(o){++h;for(const e of l)f[e]=h;d.push({id:h,label_id:a,score:t[i]})}}return[u,d]}function VS(e,t=.5,n=.5,r=.8,s=null,i=null){null===s&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),s=new Set);const a=e.class_queries_logits??e.logits,o=(e.masks_queries_logits??e.pred_masks).sigmoid();let[l,u,d]=a.dims;if(d-=1,null!==i&&i.length!==l)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let c=[];for(let e=0;e<l;++e){let l=null!==i?i[e]:null,u=a[e],p=o[e],[h,f,m]=LS(u,p,t,d);if(0===m.length){let[e,t]=l??p.dims.slice(-2),n=new Xp("int32",new Int32Array(e*t).fill(-1),[e,t]);c.push({segmentation:n,segments_info:[]});continue}let[_,g]=qS(h,f,m,n,r,s,l);c.push({segmentation:_,segments_info:g})}return c}function WS(e,t=.5,n=null){throw new Error("`post_process_instance_segmentation` is not yet implemented.")}class jS extends j{constructor(e){super(),this.image_mean=e.image_mean??e.mean,this.image_std=e.image_std??e.std,this.resample=e.resample??2,this.do_rescale=e.do_rescale??!0,this.rescale_factor=e.rescale_factor??1/255,this.do_normalize=e.do_normalize,this.do_thumbnail=e.do_thumbnail,this.size=e.size??e.image_size,this.do_resize=e.do_resize??void 0!==this.size,this.size_divisibility=e.size_divisibility??e.size_divisor,this.do_center_crop=e.do_center_crop,this.crop_size=e.crop_size,this.do_convert_rgb=e.do_convert_rgb??!0,this.do_crop_margin=e.do_crop_margin,this.pad_size=e.pad_size,this.do_pad=e.do_pad,this.do_pad&&!this.pad_size&&this.size&&void 0!==this.size.width&&void 0!==this.size.height&&(this.pad_size=this.size),this.do_flip_channel_order=e.do_flip_channel_order??!1,this.config=e}async thumbnail(e,t,n=2){const r=e.height,s=e.width,i=t.height,a=t.width;let o=Math.min(r,i),l=Math.min(s,a);return o===r&&l===s?e:(r>s?l=Math.floor(s*o/r):s>r&&(o=Math.floor(r*l/s)),await e.resize(l,o,{resample:n}))}async crop_margin(e,t=200){const n=e.clone().grayscale(),r=me(n.data)[0],s=_e(n.data)[0]-r;if(0===s)return e;const i=t/255;let a=n.width,o=n.height,l=0,u=0;const d=n.data;for(let e=0;e<n.height;++e){const t=e*n.width;for(let c=0;c<n.width;++c)(d[t+c]-r)/s<i&&(a=Math.min(a,c),o=Math.min(o,e),l=Math.max(l,c),u=Math.max(u,e))}return e=await e.crop([a,o,l,u])}pad_image(e,t,n,{mode:r="constant",center:s=!1,constant_values:i=0}={}){const[a,o,l]=t;let u,d;if("number"==typeof n?(u=n,d=n):"square"===n?u=d=Math.max(a,o):(u=n.width,d=n.height),u!==o||d!==a){const n=new Float32Array(u*d*l);if(Array.isArray(i))for(let e=0;e<n.length;++e)n[e]=i[e%l];else 0!==i&&n.fill(i);const[c,p]=s?[Math.floor((u-o)/2),Math.floor((d-a)/2)]:[0,0];for(let t=0;t<a;++t){const r=(t+p)*u,s=t*o;for(let t=0;t<o;++t){const i=(r+t+c)*l,a=(s+t)*l;for(let t=0;t<l;++t)n[i+t]=e[a+t]}}if("symmetric"===r){if(s)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const t=a-1,r=o-1;for(let s=0;s<d;++s){const i=s*u,d=Z(s,t)*o;for(let t=0;t<u;++t){if(s<a&&t<o)continue;const u=(i+t)*l,c=(d+Z(t,r))*l;for(let t=0;t<l;++t)n[u+t]=e[c+t]}}}e=n,t=[d,u,l]}return[e,t]}rescale(e){for(let t=0;t<e.length;++t)e[t]=this.rescale_factor*e[t]}get_resize_output_image_size(e,t){const[n,r]=e.size;let s,i;if(this.do_thumbnail){const{height:e,width:n}=t;s=Math.min(e,n)}else Number.isInteger(t)?(s=t,i=this.config.max_size??s):void 0!==t&&(s=t.shortest_edge,i=t.longest_edge);if(void 0!==s||void 0!==i){const e=void 0===s?1:Math.max(s/n,s/r),t=n*e,a=r*e,o=void 0===i?1:Math.min(i/t,i/a);let l=Math.floor(Number((t*o).toFixed(2))),u=Math.floor(Number((a*o).toFixed(2)));return void 0!==this.size_divisibility&&([l,u]=RS([l,u],this.size_divisibility)),[l,u]}if(void 0!==t&&void 0!==t.width&&void 0!==t.height){let e=t.width,s=t.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let t=s/r,i=e/n;Math.abs(1-i)<Math.abs(1-t)?t=i:i=t,s=PS(t*r,this.config.ensure_multiple_of),e=PS(i*n,this.config.ensure_multiple_of)}return[e,s]}if(void 0!==this.size_divisibility)return RS([n,r],this.size_divisibility);if(void 0!==t.min_pixels&&void 0!==t.max_pixels){const{min_pixels:e,max_pixels:s}=t;return function i(e,t,n=28,r=3136,s=1003520){if(e<n||t<n)throw new Error(`height:${e} or width:${t} must be larger than factor:${n}`);if(Math.max(e,t)/Math.min(e,t)>200)throw new Error("absolute aspect ratio must be smaller than 200, got "+Math.max(e,t)/Math.min(e,t));let i=Math.round(e/n)*n,a=Math.round(t/n)*n;if(i*a>s){const r=Math.sqrt(e*t/s);i=Math.floor(e/r/n)*n,a=Math.floor(t/r/n)*n}else if(i*a<r){const s=Math.sqrt(r/(e*t));i=Math.ceil(e*s/n)*n,a=Math.ceil(t*s/n)*n}return[i,a]}(r,n,this.config.patch_size*this.config.merge_size,e,s)}throw new Error(`Could not resize image due to unsupported \\`this.size\\` option in config: ${JSON.stringify(t)}`)}async resize(e){const[t,n]=this.get_resize_output_image_size(e,this.size);return await e.resize(t,n,{resample:this.resample})}async preprocess(e,{do_normalize:t=null,do_pad:n=null,do_convert_rgb:r=null,do_convert_grayscale:s=null,do_flip_channel_order:i=null}={}){this.do_crop_margin&&(e=await this.crop_margin(e));const[a,o]=e.size;if(r??this.do_convert_rgb?e=e.rgb():s&&(e=e.grayscale()),this.do_resize&&(e=await this.resize(e)),this.do_thumbnail&&(e=await this.thumbnail(e,this.size,this.resample)),this.do_center_crop){let t,n;Number.isInteger(this.crop_size)?(t=this.crop_size,n=this.crop_size):(t=this.crop_size.width,n=this.crop_size.height),e=await e.center_crop(t,n)}const l=[e.height,e.width];let u=Float32Array.from(e.data),d=[e.height,e.width,e.channels];if(this.do_rescale&&this.rescale(u),t??this.do_normalize){let t=this.image_mean;Array.isArray(this.image_mean)||(t=new Array(e.channels).fill(t));let n=this.image_std;if(Array.isArray(this.image_std)||(n=new Array(e.channels).fill(t)),t.length!==e.channels||n.length!==e.channels)throw new Error(`When set to arrays, the length of \\`image_mean\\` (${t.length}) and \\`image_std\\` (${n.length}) must match the number of channels in the image (${e.channels}).`);for(let r=0;r<u.length;r+=e.channels)for(let s=0;s<e.channels;++s)u[r+s]=(u[r+s]-t[s])/n[s]}if(n??this.do_pad)if(this.pad_size){const t=this.pad_image(u,[e.height,e.width,e.channels],this.pad_size);[u,d]=t}else if(this.size_divisibility){const[e,t]=RS([d[1],d[0]],this.size_divisibility);[u,d]=this.pad_image(u,d,{width:e,height:t})}if(i??this.do_flip_channel_order){if(3!==d[2])throw new Error("Flipping channel order is only supported for RGB images.");for(let e=0;e<u.length;e+=3){const t=u[e];u[e]=u[e+2],u[e+2]=t}}return{original_size:[o,a],reshaped_input_size:l,pixel_values:new Xp("float32",u,d).permute(2,0,1)}}async _call(e,...t){Array.isArray(e)||(e=[e]);const n=await Promise.all(e.map((e=>this.preprocess(e))));return{pixel_values:ih(n.map((e=>e.pixel_values)),0),original_sizes:n.map((e=>e.original_size)),reshaped_input_sizes:n.map((e=>e.reshaped_input_size))}}static async from_pretrained(e,t){return new this(await ce(e,R_,!0,t))}}class GS extends jS{}class HS extends jS{}class KS extends jS{}class XS extends jS{}class QS extends XS{}class YS extends jS{constructor(e){super(e),this.crop_pct=this.config.crop_pct??.875}async resize(e){const t=this.size?.shortest_edge;if(void 0===t)throw new Error("Size dictionary must contain \'shortest_edge\' key.");if(t<384){const n=Math.floor(t/this.crop_pct),[r,s]=this.get_resize_output_image_size(e,{shortest_edge:n});e=await e.resize(r,s,{resample:this.resample}),e=await e.center_crop(t,t)}else e=await e.resize(t,t,{resample:this.resample});return e}}class ZS extends YS{}class JS extends jS{}class ez extends JS{}class tz extends jS{async _call(e){const t=await super._call(e),n=uh([t.pixel_values.dims[0],64,64],1n);return{...t,pixel_mask:n}}post_process_object_detection(...e){return FS(...e)}post_process_panoptic_segmentation(...e){return VS(...e)}post_process_instance_segmentation(...e){return WS(...e)}}class nz extends tz{}class rz extends jS{pad_image(e,t,n,r={}){const[s,i,a]=t;let o=this.image_mean;Array.isArray(this.image_mean)||(o=new Array(a).fill(o));let l=this.image_std;Array.isArray(l)||(l=new Array(a).fill(o));const u=o.map(((e,t)=>-e/l[t]));return super.pad_image(e,t,n,{center:!0,constant_values:u,...r})}}class sz extends rz{}class iz extends jS{}class az extends iz{}class oz extends jS{constructor(e){super(e),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map((e=>e*e)))}}class lz extends jS{}class uz extends jS{constructor(e){super(e),this.do_image_splitting=e.do_image_splitting??!0,this.max_image_size=e.max_image_size}get_resize_for_vision_encoder(e,t){let[n,r]=e.dims.slice(-2);const s=r/n;return r>=n?(r=Math.ceil(r/t)*t,n=Math.floor(r/s),n=Math.ceil(n/t)*t):(n=Math.ceil(n/t)*t,r=Math.floor(n*s),r=Math.ceil(r/t)*t),{height:n,width:r}}async _call(e,{do_image_splitting:t=null,return_row_col_info:n=!1}={}){let r;if(Array.isArray(e)){if(0===e.length||!e[0])throw new Error("No images provided.");r=Array.isArray(e[0])?e:[e]}else r=[[e]];let s=[],i=[],a=[];const o=[],l=[];for(const e of r){let n=await Promise.all(e.map((e=>this.preprocess(e))));o.push(...n.map((e=>e.original_size))),l.push(...n.map((e=>e.reshaped_input_size))),n.forEach((e=>e.pixel_values.unsqueeze_(0)));const{longest_edge:r}=this.max_image_size;let u;if(t??this.do_image_splitting){let e=new Array(n.length),t=new Array(n.length);u=await Promise.all(n.map((async(n,s)=>{const i=this.get_resize_for_vision_encoder(n.pixel_values,r),a=await Yp(n.pixel_values,{size:[i.height,i.width]}),{frames:o,num_splits_h:l,num_splits_w:u}=await this.split_image(a,this.max_image_size);return e[s]=l,t[s]=u,sh(o,0)}))),i.push(e),a.push(t)}else{const e=[r,r];u=await Promise.all(n.map((t=>Yp(t.pixel_values,{size:e})))),i.push(new Array(n.length).fill(0)),a.push(new Array(n.length).fill(0))}s.push(sh(u,0))}const u=s.length,[d,c,p,h]=s[0].dims;let f,m;if(1===u)f=s[0].unsqueeze_(0),m=uh([u,d,p,h],!0);else{const e=Math.max(...s.map((e=>e.dims.at(0))));m=uh([u,e,p,h],!0);const t=m.data,n=e*p*h;for(let r=0;r<u;++r){const i=s[r].dims[0];if(i<e){s[r]=sh([s[r],uh([e-i,c,p,h],0)],0);const a=r*n+i*p*h,o=(r+1)*n;t.fill(!1,a,o)}}f=ih(s,0)}return{pixel_values:f,pixel_attention_mask:m,original_sizes:o,reshaped_input_sizes:l,...n?{rows:i,cols:a}:{}}}async split_image(e,{longest_edge:t}){const n=t,r=t,s=[],[i,a]=e.dims.slice(-2);let o=0,l=0;if(i>n||a>r){o=Math.ceil(i/n),l=Math.ceil(a/r);const t=Math.ceil(i/o),u=Math.ceil(a/l);for(let n=0;n<o;++n)for(let r=0;r<l;++r){let d,c,p,h;n===o-1?(c=i-t,h=i):(c=n*t,h=(n+1)*t),r===l-1?(d=a-u,p=a):(d=r*u,p=(r+1)*u);const f=[c,d],m=[h,p],_=await eh(e,f,m,[2,3]);s.push(_)}const d=n,c=r;i===d&&a===c||(e=await Yp(e,{size:[d,c]}))}return s.push(e),{frames:s,num_splits_h:o,num_splits_w:l}}}class dz extends jS{constructor(e){super({do_pad:!0,pad_size:{width:e.image_size,height:e.image_size},...e}),this.constant_values=this.config.background_color.map((e=>e*this.rescale_factor))}pad_image(e,t,n,r){return super.pad_image(e,t,n,{constant_values:this.constant_values,center:!0,...r})}}class cz extends jS{constructor(e){const{resize_mode:t,fill_color:n,interpolation:r,size:s,...i}=e;super({...i,size:"squash"===t?{width:s,height:s}:"shortest"===t?{shortest_edge:s}:{longest_edge:s},resample:"bicubic"===r?3:2,do_center_crop:!0,crop_size:s,do_normalize:!0})}}class pz extends jS{}class hz extends jS{post_process_panoptic_segmentation(...e){return VS(...e)}post_process_instance_segmentation(...e){return WS(...e)}}class fz extends hz{}class mz extends hz{}class _z extends jS{}class gz extends _z{}class wz extends jS{}class yz extends wz{}class bz extends jS{}class xz extends bz{}class vz extends jS{}class $z extends vz{}class kz extends jS{}class Ez extends kz{}class Sz extends rz{}class zz extends jS{post_process_object_detection(...e){return FS(...e)}}class Cz extends zz{}class Tz extends zz{}const Iz=336,Az=[2,3],{ceil:Mz,floor:Oz,sqrt:Bz}=Math;class Nz extends jS{constructor(e){super({...e,do_normalize:!0,do_pad:!0,pad_size:"custom",do_convert_rgb:!0,do_resize:!0}),this._num_crops=e.num_crops}calc_num_image_tokens_from_image_size(e,t){const{num_img_tokens:n}=this.config;return Oz((Oz(t/Iz)*Oz(e/Iz)+1)*n+1+(Oz(t/Iz)+1)*Bz(n))}get_resize_output_image_size(e,t){const n=this._num_crops,[r,s]=e.size;let i=r/s,a=1;for(;a*Math.ceil(a/i)<=n;)a+=1;a-=1;const o=Math.floor(336*a);return[o,Math.floor(o/i)]}pad_image(e,t,n,r={}){const[s,i]=t,a=Iz*Mz(s/Iz),o=Iz*Mz(i/Iz),l=[1,1,1].map(((e,t)=>(e-this.image_mean[t])/this.image_std[t]));return super.pad_image(e,t,{width:o,height:a},{center:!0,constant_values:l,...r})}async _call(e,{num_crops:t=null}={}){if(this._num_crops=t??=this.config.num_crops,t<4||Bz(t)%1!=0)throw new Error("num_crops must be a square number >= 4");Array.isArray(e)||(e=[e]);const n=e.length,r=await Promise.all(e.map((e=>this.preprocess(e)))),s=r.map((e=>e.original_size)),i=r.map((e=>e.reshaped_input_size)),a=[];for(const{pixel_values:e}of r){e.unsqueeze_(0);const[n,r]=e.dims.slice(-2),s=await Yp(e,{size:[Iz,Iz],mode:"bicubic"});if(t>0){const i=[],o=Bz(t),l=Oz(r/o),u=Oz(n/o);for(let t=0;t<o;++t)for(let s=0;s<o;++s){let a,d,c,p;t===o-1?(d=n-u,p=n):(d=t*u,p=(t+1)*u),s===o-1?(a=r-l,c=r):(a=s*l,c=(s+1)*l);const h=[d,a],f=[p,c],m=await eh(e,h,f,Az);i.push(m)}const d=await Yp(sh(i,0),{size:[Iz,Iz],mode:"bicubic"});a.push(sh([s,d],0))}else a.push(s)}const o=ih(a,0),l=i.map((e=>e.map((e=>Iz*Mz(e/Iz)))));return{pixel_values:o,original_sizes:s,reshaped_input_sizes:i,image_sizes:new Xp("int64",l.flat(),[n,2]),num_img_tokens:l.map((([e,t])=>this.calc_num_image_tokens_from_image_size(t,e)))}}}class Pz extends jS{}class Rz extends jS{async _call(e,...t){const{pixel_values:n,original_sizes:r,reshaped_input_sizes:s}=await super._call(e,...t);let i=n;const{temporal_patch_size:a,merge_size:o,patch_size:l}=this.config;1===i.dims[0]&&(i=sh(Array.from({length:a},(()=>i)),0));const u=i.dims[0]/a,d=i.dims[1],c=Math.floor(i.dims[2]/l),p=Math.floor(i.dims[3]/l);return{pixel_values:i.view(u,a,d,Math.floor(c/o),o,l,Math.floor(p/o),o,l).permute(0,3,6,4,7,2,1,5,8).view(u*c*p,d*a*l*l),image_grid_thw:new Xp("int64",[u,c,p],[1,3]),original_sizes:r,reshaped_input_sizes:s}}}class Dz extends jS{post_process_object_detection(...e){return FS(...e)}}class Fz extends jS{reshape_input_points(e,t,n,r=!1){let s=X(e=structuredClone(e));if(3===s.length)r||(s=[1,...s]),e=[e];else if(4!==s.length)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let r=0;r<e.length;++r){let s=t[r],i=n[r],a=[i[0]/s[0],i[1]/s[1]];for(let t=0;t<e[r].length;++t)for(let n=0;n<e[r][t].length;++n)for(let s=0;s<e[r][t][n].length;++s)e[r][t][n][s]*=a[s%2]}return new Xp("float32",Float32Array.from(e.flat(Infinity)),s)}add_input_labels(e,t){let n=X(e);if(2===n.length)n=[1,...n],e=[e];else if(3!==n.length)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(n.some(((e,n)=>e!==t.dims[n])))throw Error(`The first ${n.length} dimensions of \'input_points\' and \'input_labels\' must be the same.`);return new Xp("int64",e.flat(Infinity).map(BigInt),n)}async _call(e,{input_points:t=null,input_labels:n=null,input_boxes:r=null}={}){const s=await super._call(e);if(t&&(s.input_points=this.reshape_input_points(t,s.original_sizes,s.reshaped_input_sizes)),n){if(!s.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");s.input_labels=this.add_input_labels(n,s.input_points)}return r&&(s.input_boxes=this.reshape_input_points(r,s.original_sizes,s.reshaped_input_sizes,!0)),s}async post_process_masks(e,t,n,{mask_threshold:r=0,binarize:s=!0,pad_size:i=null}={}){const a=[],o=[(i=i??this.pad_size).height,i.width];for(let i=0;i<t.length;++i){const l=t[i],u=n[i];let d=await Yp(e[i],{mode:"bilinear",size:o});if(d=d.slice(null,null,[0,u[0]],[0,u[1]]),d=await Yp(d,{mode:"bilinear",size:l}),s){const e=d.data,t=new Uint8Array(e.length);for(let n=0;n<e.length;++n)e[n]>r&&(t[n]=1);d=new Xp("bool",t,d.dims)}a.push(d)}return a}generate_crop_boxes(e,t,{crop_n_layers:n=0,overlap_ratio:r=512/1500,points_per_crop:s=32,crop_n_points_downscale_factor:i=1}={}){}}class Lz extends jS{post_process_semantic_segmentation(...e){return function t(e,n=null){const r=e.logits,s=r.dims[0];if(null!==n&&n.length!==s)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const i=[];for(let e=0;e<s;++e){const t=null!==n?n[e]:null;let s=r[e];null!==t&&(s=Qp(s,t,"bilinear",!1));const[a,o]=t??s.dims.slice(-2),l=new Xp("int32",new Int32Array(a*o),[a,o]),u=s[0].data,d=l.data;for(let e=1;e<s.dims[0];++e){const t=s[e].data;for(let n=0;n<t.length;++n)t[n]>u[n]&&(u[n]=t[n],d[n]=e)}const c=new Array(s.dims[0]);for(let e=0;e<d.length;++e){const t=d[e];c[t]=t}const p=c.filter((e=>void 0!==e));i.push({segmentation:l,labels:p})}return i}(...e)}}class Uz extends Lz{}class qz extends jS{}class Vz extends jS{pad_image(e,t,n,r={}){const[s,i,a]=t;return super.pad_image(e,t,{width:i+(n-i%n)%n,height:s+(n-s%n)%n},{mode:"symmetric",center:!1,constant_values:-1,...r})}}class Wz extends jS{}class jz extends Wz{}class Gz extends jS{async _call(e,t){Array.isArray(e)||(e=[e]),Array.isArray(t)||(t=[t]);const n=await Promise.all(e.map((e=>this.preprocess(e)))),r=await Promise.all(t.map((e=>this.preprocess(e,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0}))));return{pixel_values:ih(n.map(((e,t)=>sh([e.pixel_values,r[t].pixel_values],0))),0),original_sizes:n.map((e=>e.original_size)),reshaped_input_sizes:n.map((e=>e.reshaped_input_size))}}}class Hz extends jS{post_process_pose_estimation(e,t,{threshold:n=null}={}){const r=e.tolist(),[s,i,a,o]=e.dims,l=[];for(let e=0;e<s;++e){const s=r[e],i=t[e],u=[];for(let e=0;e<i.length;++e){const t=i[e],r=[],l=[],d=[],c=t.at(-2)/o,p=t.at(-1)/a;for(let e=0;e<s.length;++e){let[t,i]=[0,0],a=0,o=-Infinity;const u=s[e];for(let e=0;e<u.length;++e){const n=u[e];for(let r=0;r<n.length;++r){const s=n[r];a+=s,o=Math.max(o,s),t+=(r+.5)*s,i+=e*s}}if(null!=n&&o<n)continue;const h=[c*t/a,p*i/a];r.push(h),d.push(e),l.push(o)}u.push({bbox:t,scores:l,labels:d,keypoints:r})}l.push(u)}return l}}class Kz extends jS{post_process_object_detection(...e){return FS(...e)}}class Xz extends Kz{}class Qz{static async from_pretrained(e,n={}){const r=await ce(e,R_,!0,n),s=r.image_processor_type??r.feature_extractor_type;let i=t[s];return i||(void 0!==s&&console.warn(`Image processor type \'${s}\' not found, assuming base ImageProcessor. Please report this at ${N_}.`),i=jS),new i(r)}}class Yz extends NS{static tokenizer_class=E_;static image_processor_class=Qz;constructor(e,t){super(e,t);const{tasks_answer_post_processing_type:n,task_prompts_without_inputs:r,task_prompts_with_input:s}=this.image_processor.config;this.tasks_answer_post_processing_type=new Map(Object.entries(n??{})),this.task_prompts_without_inputs=new Map(Object.entries(r??{})),this.task_prompts_with_input=new Map(Object.entries(s??{})),this.regexes={quad_boxes:/(.+?)<loc_(\\d+)><loc_(\\d+)><loc_(\\d+)><loc_(\\d+)><loc_(\\d+)><loc_(\\d+)><loc_(\\d+)><loc_(\\d+)>/gm,bboxes:/([^<]+)?<loc_(\\d+)><loc_(\\d+)><loc_(\\d+)><loc_(\\d+)>/gm},this.size_per_bin=1e3}construct_prompts(e){"string"==typeof e&&(e=[e]);const t=[];for(const n of e)if(this.task_prompts_without_inputs.has(n))t.push(this.task_prompts_without_inputs.get(n));else{for(const[e,r]of this.task_prompts_with_input)if(n.includes(e)){t.push(r.replaceAll("{input}",n).replaceAll(e,""));break}t.length!==e.length&&t.push(n)}return t}post_process_generation(e,t,n){const r=this.tasks_answer_post_processing_type.get(t)??"pure_text";let s;switch(e=e.replaceAll("<s>","").replaceAll("</s>",""),r){case"pure_text":s=e;break;case"description_with_bboxes":case"bboxes":case"phrase_grounding":case"ocr":const i="ocr"===r?"quad_boxes":"bboxes",a=e.matchAll(this.regexes[i]),o=[],l=[];for(const[e,t,...r]of a)o.push(t?t.trim():o.at(-1)??""),l.push(r.map(((e,t)=>(Number(e)+.5)/this.size_per_bin*n[t%2])));s={labels:o,[i]:l};break;default:throw new Error(`Task "${t}" (of type "${r}") not yet implemented.`)}return{[t]:s}}async _call(e,t=null,n={}){if(!e&&!t)throw new Error("Either text or images must be provided");return{...await this.image_processor(e,n),...t?this.tokenizer(t,n):{}}}}const Zz={char:["char_decode",1],bpe:["bpe_decode",2],wp:["wp_decode",102]};class Jz extends NS{static tokenizer_class=E_;static image_processor_class=Qz;get char_tokenizer(){return this.components.char_tokenizer}get bpe_tokenizer(){return this.components.bpe_tokenizer}get wp_tokenizer(){return this.components.wp_tokenizer}_decode_helper(e,t){if(!Zz.hasOwnProperty(t))throw new Error(`Format ${t} is not supported.`);const[n,r]=Zz[t],s=this[n].bind(this),[i,a]=e.dims,o=[],l=[],u=e.tolist();for(let e=0;e<i;++e){const t=u[e],n=[],s=[];for(let e=1;e<a;++e){const[i,a]=_e(he(t[e]));if(s.push(i),a==r)break;n.push(a)}const i=s.length>0?s.reduce(((e,t)=>e*t),1):0;l.push(n),o.push(i)}return[s(l),o]}char_decode(e){return this.char_tokenizer.batch_decode(e).map((e=>e.replaceAll(" ","")))}bpe_decode(e){return this.bpe_tokenizer.batch_decode(e)}wp_decode(e){return this.wp_tokenizer.batch_decode(e).map((e=>e.replaceAll(" ","")))}batch_decode([e,t,n]){const[r,s]=this._decode_helper(e,"char"),[i,a]=this._decode_helper(t,"bpe"),[o,l]=this._decode_helper(n,"wp"),u=[],d=[];for(let e=0;e<r.length;++e){const[t,n]=_e([s[e],a[e],l[e]]);u.push([r[e],i[e],o[e]][n]),d.push(t)}return{generated_text:u,scores:d,char_preds:r,bpe_preds:i,wp_preds:o}}static async from_pretrained(...e){const t=await super.from_pretrained(...e),n=await E_.from_pretrained("Xenova/gpt2"),r=await E_.from_pretrained("Xenova/bert-base-uncased");return t.components={image_processor:t.image_processor,char_tokenizer:t.tokenizer,bpe_tokenizer:n,wp_tokenizer:r},t}async _call(e,t=null){const n=await this.image_processor(e);return t&&(n.labels=this.tokenizer(t).input_ids),n}}class eC extends j{constructor(e){super(),this.config=e}static async from_pretrained(e,t){return new this(await ce(e,P_,!0,t))}}function tC(e,t){if(!(e instanceof Float32Array||e instanceof Float64Array))throw new Error(`${t} expects input to be a Float32Array or a Float64Array, but got ${e?.constructor?.name??typeof e} instead. If using the feature extractor directly, remember to use \\`read_audio(url, sampling_rate)\\` to obtain the raw audio data of the file/url.`)}function nC(e,t){if(e<1)return new Float64Array;if(1===e)return new Float64Array([1]);const n=1-t,r=2*Math.PI/(e-1),s=new Float64Array(e);for(let i=0;i<e;++i)s[i]=t-n*Math.cos(i*r);return s}function rC(e){return nC(e,.5)}const sC={htk:e=>2595*Math.log10(1+e/700),kaldi:e=>1127*Math.log(1+e/700),slaney:(e,t=1e3,n=15,r=27/Math.log(6.4))=>e>=t?n+Math.log(e/t)*r:3*e/200};function iC(e,t="htk"){const n=sC[t];if(!n)throw new Error(\'mel_scale should be one of "htk", "slaney" or "kaldi".\');return"number"==typeof e?n(e):e.map((e=>n(e)))}const aC={htk:e=>700*(10**(e/2595)-1),kaldi:e=>700*(Math.exp(e/1127)-1),slaney:(e,t=1e3,n=15,r=Math.log(6.4)/27)=>e>=n?t*Math.exp(r*(e-n)):200*e/3};function oC(e,t,n){const r=(t-e)/(n-1);return Float64Array.from({length:n},((t,n)=>e+r*n))}function lC(e,t,n,r,s,i=null,a="htk",o=!1){if(null!==i&&"slaney"!==i)throw new Error(\'norm must be one of null or "slaney"\');const l=oC(iC(n,a),iC(r,a),t+2);let u,d=function c(e,t="htk"){const n=aC[t];if(!n)throw new Error(\'mel_scale should be one of "htk", "slaney" or "kaldi".\');return"number"==typeof e?n(e):e.map((e=>n(e)))}(l,a);if(o){const t=s/(2*e);u=iC(Float64Array.from({length:e},((e,n)=>n*t)),a),d=l}else u=oC(0,Math.floor(s/2),e);const p=function h(e,t){const n=Float64Array.from({length:t.length-1},((e,n)=>t[n+1]-t[n])),r=Array.from({length:e.length},(()=>new Array(t.length)));for(let n=0;n<e.length;++n){const s=r[n];for(let r=0;r<t.length;++r)s[r]=t[r]-e[n]}const s=t.length-2,i=Array.from({length:s},(()=>new Array(e.length)));for(let t=0;t<e.length;++t){const e=r[t];for(let r=0;r<s;++r){const s=-e[r]/n[r],a=e[r+2]/n[r+1];i[r][t]=Math.max(0,Math.min(s,a))}}return i}(u,d);if(null!==i&&"slaney"===i)for(let n=0;n<t;++n){const t=p[n],r=2/(d[n+2]-d[n]);for(let n=0;n<e;++n)t[n]*=r}return p}function uC(e,t,n,r,s){if(n<=0)throw new Error("reference must be greater than zero");if(r<=0)throw new Error("min_value must be greater than zero");n=Math.max(r,n);const i=Math.log10(n);for(let n=0;n<e.length;++n)e[n]=t*Math.log10(Math.max(r,e[n])-i);if(null!==s){if(s<=0)throw new Error("db_range must be greater than zero");const t=_e(e)[0]-s;for(let n=0;n<e.length;++n)e[n]=Math.max(e[n],t)}return e}async function dC(e,t,n,r,{fft_length:s=null,power:i=1,center:a=!0,pad_mode:o="reflect",onesided:l=!0,preemphasis:u=null,mel_filters:d=null,mel_floor:c=1e-10,log_mel:p=null,reference:h=1,min_value:f=1e-10,db_range:m=null,remove_dc_offset:_=null,min_num_frames:g=null,max_num_frames:w=null,do_pad:y=!0,transpose:b=!1}={}){const x=t.length;if(null===s&&(s=n),n>s)throw Error(`frame_length (${n}) may not be larger than fft_length (${s})`);if(x!==n)throw new Error(`Length of the window (${x}) must equal frame_length (${n})`);if(r<=0)throw new Error("hop_length must be greater than zero");if(null===i&&null!==d)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(a){if("reflect"!==o)throw new Error(`pad_mode="${o}" not implemented yet.`);const t=Math.floor((s-1)/2)+1;e=function n(e,t,r){const s=new e.constructor(e.length+t+r),i=e.length-1;for(let n=0;n<e.length;++n)s[t+n]=e[n];for(let n=1;n<=t;++n)s[t-n]=e[Z(n,i)];for(let n=1;n<=r;++n)s[i+t+n]=e[Z(i-n,i)];return s}(e,t,t)}let v=Math.floor(1+Math.floor((e.length-n)/r));null!==g&&v<g&&(v=g);const $=l?Math.floor(s/2)+1:s;let k=v,E=v;null!==w&&(w>v?y&&(E=w):E=k=w);const S=new be(s),z=new Float64Array(s),C=new Float64Array(S.outputBufferSize),T=new Float32Array($*E);for(let s=0;s<k;++s){const i=s*r,a=Math.min(e.length-i,n);a!==n&&z.fill(0,0,n);for(let t=0;t<a;++t)z[t]=e[i+t];if(_){let e=0;for(let t=0;t<a;++t)e+=z[t];const t=e/a;for(let e=0;e<a;++e)z[e]-=t}if(null!==u){for(let e=a-1;e>=1;--e)z[e]-=u*z[e-1];z[0]*=1-u}for(let e=0;e<t.length;++e)z[e]*=t[e];S.realTransform(C,z);for(let e=0;e<$;++e){const t=e<<1;T[e*E+s]=C[t]**2+C[t+1]**2}}if(null!==i&&2!==i){const e=2/i;for(let t=0;t<T.length;++t)T[t]**=e}const I=d.length;let A=await async function M(e,t){const n=await Hp.matmul;return await n({a:e,b:t})}(new Xp("float32",d.flat(),[I,$]),new Xp("float32",T,[$,E]));b&&(A=A.transpose(1,0));const O=A.data;for(let e=0;e<O.length;++e)O[e]=Math.max(c,O[e]);if(null!==i&&null!==p){const e=Math.min(O.length,k*I);switch(p){case"log":for(let t=0;t<e;++t)O[t]=Math.log(O[t]);break;case"log10":for(let t=0;t<e;++t)O[t]=Math.log10(O[t]);break;case"dB":if(1===i)!function t(e,n=1,r=1e-5,s=null){return uC(e,20,n,r,s)}(O,h,f,m);else{if(2!==i)throw new Error(`Cannot use log_mel option \'${p}\' with power ${i}`);!function e(t,n=1,r=1e-10,s=null){return uC(t,10,n,r,s)}(O,h,f,m)}break;default:throw new Error(`log_mel must be one of null, \'log\', \'log10\' or \'dB\'. Got \'${p}\'`)}}return A}function cC(e,t,{periodic:n=!0,frame_length:r=null,center:s=!0}={}){const i=n?e+1:e;let a;switch(t){case"boxcar":a=new Float64Array(i).fill(1);break;case"hann":case"hann_window":a=rC(i);break;case"hamming":a=function e(t){return nC(t,.54)}(i);break;case"povey":a=rC(i).map((e=>Math.pow(e,.85)));break;default:throw new Error(`Unknown window type ${t}.`)}if(n&&(a=a.subarray(0,e)),null===r)return a;if(e>r)throw new Error(`Length of the window (${e}) may not be larger than frame_length (${r})`);return a}class pC extends eC{constructor(e){super(e);const t=this.config.sampling_rate,n=lC(256,this.config.num_mel_bins,20,Math.floor(t/2),t,null,"kaldi",!0);for(let e=0;e<n.length;++e)n[e].push(0);this.mel_filters=n,this.window=cC(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}async _extract_fbank_features(e,t){return dC(e,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1.192092955078125e-7,remove_dc_offset:!0,max_num_frames:t,transpose:!0})}async _call(e){tC(e,"ASTFeatureExtractor");const t=await this._extract_fbank_features(e,this.config.max_length);if(this.config.do_normalize){const e=2*this.std,n=t.data;for(let t=0;t<n.length;++t)n[t]=(n[t]-this.mean)/e}return{input_values:t.unsqueeze_(0)}}}class hC extends eC{constructor(e){super(e),this.mel_filters=lC(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=lC(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=cC(this.config.fft_window_size,"hann")}async _get_input_mel(e,t,n,r){let s,i=!1;const a=e.length-t;if(a>0){if("rand_trunc"!==n)throw new Error(`Truncation strategy "${n}" not implemented`);{i=!0;const n=Math.floor(Math.random()*(a+1));e=e.subarray(n,n+t),s=await this._extract_fbank_features(e,this.mel_filters_slaney,this.config.nb_max_samples)}}else{if(a<0){let n=new Float64Array(t);if(n.set(e),"repeat"===r)for(let r=e.length;r<t;r+=e.length)n.set(e.subarray(0,Math.min(e.length,t-r)),r);else if("repeatpad"===r)for(let t=e.length;t<-a;t+=e.length)n.set(e,t);e=n}if("fusion"===n)throw new Error(`Truncation strategy "${n}" not implemented`);s=await this._extract_fbank_features(e,this.mel_filters_slaney,this.config.nb_max_samples)}return s.unsqueeze_(0)}async _extract_fbank_features(e,t,n=null){return dC(e,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:t,log_mel:"dB",max_num_frames:n,do_pad:!1,transpose:!0})}async _call(e,{max_length:t=null}={}){tC(e,"ClapFeatureExtractor");return{input_features:(await this._get_input_mel(e,t??this.config.nb_max_samples,this.config.truncation,this.config.padding)).unsqueeze_(0)}}}class fC extends eC{async _call(e){tC(e,"MoonshineFeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));const t=[1,e.length];return{input_values:new Xp("float32",e,t)}}}class mC extends eC{async _call(e){tC(e,"PyAnnoteFeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));const t=[1,1,e.length];return{input_values:new Xp("float32",e,t)}}samples_to_frames(e){return(e-this.config.offset)/this.config.step}post_process_speaker_diarization(e,t){const n=t/this.samples_to_frames(t)/this.config.sampling_rate,r=[];for(const t of e.tolist()){const e=[];let s=-1;for(let n=0;n<t.length;++n){const r=he(t[n]),[i,a]=_e(r),[o,l]=[n,n+1];a!==s?(s=a,e.push({id:a,start:o,end:l,score:i})):(e.at(-1).end=l,e.at(-1).score+=i)}r.push(e.map((({id:e,start:t,end:r,score:s})=>({id:e,start:t*n,end:r*n,confidence:s/(r-t)}))))}return r}}class _C extends eC{constructor(e){super(e);const t=this.config.sampling_rate,n=lC(256,this.config.num_mel_bins,20,Math.floor(t/2),t,null,"kaldi",!0);for(let e=0;e<n.length;++e)n[e].push(0);this.mel_filters=n,this.window=cC(400,"povey",{periodic:!1})}async _extract_fbank_features(e,t){return dC(e=e.map((e=>32768*e)),this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1.192092955078125e-7,remove_dc_offset:!0,max_num_frames:t,transpose:!0})}async _call(e,{padding:t=!0,pad_to_multiple_of:n=2,do_normalize_per_mel_bins:r=!0,return_attention_mask:s=!0}={}){tC(e,"SeamlessM4TFeatureExtractor");let i,a=await this._extract_fbank_features(e,this.config.max_length);if(r){const[e,t]=a.dims,n=a.data;for(let r=0;r<t;++r){let s=0;for(let i=0;i<e;++i)s+=n[i*t+r];const i=s/e;let a=0;for(let s=0;s<e;++s)a+=(n[s*t+r]-i)**2;a/=e-1;const o=Math.sqrt(a+1e-7);for(let s=0;s<e;++s){const e=s*t+r;n[e]=(n[e]-i)/o}}}if(t){const[e,t]=a.dims,r=a.data,o=e%n;if(o>0){const n=new Float32Array(t*(e+o));n.set(r),n.fill(this.config.padding_value,r.length);const l=e+o;a=new Xp(a.type,n,[l,t]),s&&(i=new Xp("int64",new BigInt64Array(l),[1,l]),i.data.fill(1n,0,e))}}const[o,l]=a.dims,u=this.config.stride;if(0!==o%u)throw new Error(`The number of frames (${o}) must be a multiple of the stride (${u}).`);const d=a.view(1,Math.floor(o/u),l*u),c={input_features:d};if(s){const e=d.dims[1],t=new BigInt64Array(e);if(i){const e=i.data;for(let n=1,r=0;n<o;n+=u,++r)t[r]=e[n]}else t.fill(1n);c.attention_mask=new Xp("int64",t,[1,e])}return c}}class gC extends eC{}class wC extends eC{_zero_mean_unit_var_norm(e){const t=e.reduce(((e,t)=>e+t),0)/e.length,n=e.reduce(((e,n)=>e+(n-t)**2),0)/e.length;return e.map((e=>(e-t)/Math.sqrt(n+1e-7)))}async _call(e){tC(e,"Wav2Vec2FeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));let t=e;this.config.do_normalize&&(t=this._zero_mean_unit_var_norm(t));const n=[1,t.length];return{input_values:new Xp("float32",t,n),attention_mask:new Xp("int64",new BigInt64Array(t.length).fill(1n),n)}}}class yC extends eC{constructor(e){super(e);const t=this.config.sampling_rate,n=lC(256,this.config.num_mel_bins,20,Math.floor(t/2),t,null,"kaldi",!0);for(let e=0;e<n.length;++e)n[e].push(0);this.mel_filters=n,this.window=cC(400,"hamming",{periodic:!1}),this.min_num_frames=this.config.min_num_frames}async _extract_fbank_features(e){return dC(e=e.map((e=>32768*e)),this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1.192092955078125e-7,remove_dc_offset:!0,transpose:!0,min_num_frames:this.min_num_frames})}async _call(e){tC(e,"WeSpeakerFeatureExtractor");const t=(await this._extract_fbank_features(e)).unsqueeze_(0);if(null===this.config.fbank_centering_span){const e=t.mean(1).data,n=t.data,[r,s,i]=t.dims;for(let t=0;t<r;++t){const r=t*s*i,a=t*i;for(let t=0;t<s;++t){const s=r+t*i;for(let t=0;t<i;++t)n[s+t]-=e[a+t]}}}return{input_features:t}}}class bC extends eC{constructor(e){super(e),this.config.mel_filters??=lC(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney"),this.window=cC(this.config.n_fft,"hann")}async _extract_fbank_features(e){const t=await dC(e,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:this.config.nb_max_frames}),n=t.data,r=_e(n)[0];for(let e=0;e<n.length;++e)n[e]=(Math.max(n[e],r-8)+4)/4;return t}async _call(e){let t;tC(e,"WhisperFeatureExtractor"),e.length>this.config.n_samples?(console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),t=e.slice(0,this.config.n_samples)):(t=new Float32Array(this.config.n_samples),t.set(e));return{input_features:(await this._extract_fbank_features(t)).unsqueeze_(0)}}}class xC{static async from_pretrained(e,t={}){const r=await ce(e,P_,!0,t),s=r.feature_extractor_type,i=n[s];if(!i)throw new Error(`Unknown feature_extractor_type: \'${s}\'. Please report this at ${N_}.`);return new i(r)}}class vC extends NS{static tokenizer_class=E_;static feature_extractor_class=xC;async _call(e){return await this.feature_extractor(e)}}function $C(e,t,n,r,s,i){return 0===e&&0===t?function a(e,t,n,r){return`${t}${r}`+n.repeat(e)+`${t}`}(n,r,s,i):function o(e,t,n,r,s,i){let a="";for(let i=0;i<t;++i){for(let t=0;t<n;++t)a+=r+`<row_${i+1}_col_${t+1}>`+s.repeat(e);a+="\\n"}return a+=`\\n${r}${i}`+s.repeat(e)+`${r}`,a}(n,e,t,r,s,i)}class kC extends NS{static image_processor_class=Qz;static tokenizer_class=E_;static uses_processor_config=!0;fake_image_token="<fake_token_around_image>";image_token="<image>";global_img_token="<global-img>";async _call(e,t=null,n={}){let r;n.return_row_col_info??=!0,t&&(r=await this.image_processor(t,n)),Array.isArray(e)||(e=[e]);const s=r.rows??[new Array(e.length).fill(0)],i=r.cols??[new Array(e.length).fill(0)],a=this.config.image_seq_len,o=[],l=[];for(let t=0;t<e.length;++t){const n=e[t],r=s[t],u=i[t];o.push(te(n,this.image_token));const d=r.map(((e,t)=>$C(e,u[t],a,this.fake_image_token,this.image_token,this.global_img_token))),c=n.split(this.image_token);if(0===c.length)throw new Error("The image token should be present in the text.");let p=c[0];for(let e=0;e<d.length;++e)p+=d[e]+c[e+1];l.push(p)}return{...this.tokenizer(l),...r}}}class EC extends NS{static image_processor_class=Qz;static tokenizer_class=E_;static uses_processor_config=!0;constructor(e,t){super(e,t),this.image_tag=this.config.image_tag,this.image_start_tag=this.config.image_start_tag,this.image_end_tag=this.config.image_end_tag,this.num_image_tokens=this.config.num_image_tokens}async _call(e,{images:t=null,chat_template:n="default"}={}){t?Array.isArray(t)||(t=[t]):t=await Promise.all(e.filter((e=>e.images)).flatMap((e=>e.images)).map((e=>lg.read(e))));const r=this.tokenizer,s=e=>r.encode(e,{add_special_tokens:!1}),i=r.apply_chat_template(e,{tokenize:!1,add_generation_prompt:!0,chat_template:n}).split(this.image_tag),a=i.length-1;if(t.length!==a)throw new Error(`Number of images provided (${t.length}) does not match number of "${this.image_tag}" image tags (${a})`);const[o,l,u]=r.model.convert_tokens_to_ids([this.image_tag,this.image_start_tag,this.image_end_tag]);let d=s(i[0]),c=new Array(d.length).fill(!1);for(let e=1;e<i.length;++e){const t=new Array(this.num_image_tokens).fill(o),n=s(i[e]);d=Q(d,[l],t,[u],n);c=Q(c,[!1],new Array(this.num_image_tokens).fill(!0),[!1],new Array(n.length).fill(!1))}const p=[1,d.length],h={input_ids:new Xp("int64",d,p),attention_mask:new Xp("int64",new Array(d.length).fill(1),p),images_seq_mask:new Xp("bool",c,p),images_emb_mask:new Xp("bool",new Array(a*this.num_image_tokens).fill(!0),[1,a,this.num_image_tokens])};if(t&&t.length>0){const e=await this.image_processor(t);return e.pixel_values.unsqueeze_(0),{...h,...e}}return h}}class SC extends NS{static tokenizer_class=E_;static image_processor_class=Qz;async _call(e=null,t=null,n={}){if(!e&&!t)throw new Error("Either text or images must be provided");return{...e?this.tokenizer(e,n):{},...t?await this.image_processor(t,n):{}}}}class zC extends NS{static tokenizer_class=E_;static image_processor_class=Qz}const CC="<|image|>",TC=/<\\|image_\\d+\\|>/g;class IC extends NS{static image_processor_class=Qz;static tokenizer_class=E_;async _call(e,t=null,{padding:n=!0,truncation:r=!0,num_crops:s=null}={}){let i,a;if(Array.isArray(e)||(e=[e]),t){a=await this.image_processor(t,{num_crops:s});const{num_img_tokens:o}=a,l=e.map(((e,t)=>e.split(TC).join(CC.repeat(o[t]))));i=this.tokenizer(l,{padding:n,truncation:r});const u=this.tokenizer.model.convert_tokens_to_ids([CC])[0];i.input_ids.map_((e=>e==u?-e:e))}else i=this.tokenizer(e);return{...i,...a}}}const AC="<image>";class MC extends NS{static tokenizer_class=E_;static image_processor_class=Qz;static uses_processor_config=!1;async _call(e,t=null,n={}){t||(console.warn("You are using PaliGemma without a text prefix. It will perform as a picture-captioning model."),t=""),Array.isArray(e)||(e=[e]),Array.isArray(t)||(t=[t]);const r=this.tokenizer.bos_token,s=this.image_processor.config.image_seq_length;let i;t.some((e=>e.includes(AC)))?i=t.map((e=>{const t=e.replaceAll(AC,AC.repeat(s)),n=t.lastIndexOf(AC),i=-1===n?0:n+7;return t.slice(0,i)+r+t.slice(i)+"\\n"})):(console.warn("You are passing both `text` and `images` to `PaliGemmaProcessor`. The processor expects special image tokens in the text, as many tokens as there are images per each text. It is recommended to add `<image>` tokens in the very beginning of your text. For this call, we will infer how many images each text has and add special tokens."),i=t.map((t=>function n(e,t,r,s,i){return`${s.repeat(r*i)}${t}${e}\\n`}(t,r,s,AC,e.length))));const a=this.tokenizer(i,n);return{...await this.image_processor(e,n),...a}}}class OC extends NS{static feature_extractor_class=mC;async _call(e){return await this.feature_extractor(e)}post_process_speaker_diarization(...e){return this.feature_extractor.post_process_speaker_diarization(...e)}get sampling_rate(){return this.feature_extractor.config.sampling_rate}}class BC extends NS{static image_processor_class=Qz;static tokenizer_class=E_;async _call(e,t=null,...n){let r,s;if(Array.isArray(e)||(e=[e]),t&&(r=await this.image_processor(t),s=r.image_grid_thw),s){let t=this.image_processor.config.merge_size**2,n=0;const r=s.tolist();e=e.map((e=>{for(;e.includes("<|image_pad|>");){const s=Number(r[n++].reduce(((e,t)=>e*t),1n));e=e.replace("<|image_pad|>","<|placeholder|>".repeat(Math.floor(s/t)))}return e.replaceAll("<|placeholder|>","<|image_pad|>")}))}return{...this.tokenizer(e),...r}}}class NC extends NS{static image_processor_class=Qz;async _call(...e){return await this.image_processor(...e)}post_process_masks(...e){return this.image_processor.post_process_masks(...e)}reshape_input_points(...e){return this.image_processor.reshape_input_points(...e)}}class PC extends NS{static tokenizer_class=E_;static feature_extractor_class=xC;async _call(e){return await this.feature_extractor(e)}}class RC extends NS{static feature_extractor_class=xC;async _call(e){return await this.feature_extractor(e)}}class DC extends NS{static tokenizer_class=E_;static feature_extractor_class=xC;async _call(e){return await this.feature_extractor(e)}}class FC{static async from_pretrained(e,s={}){const i=await ce(e,R_,!0,s),{image_processor_type:a,feature_extractor_type:o,processor_class:l}=i;if(l&&r[l])return r[l].from_pretrained(e,s);if(!a&&!o)throw new Error("No `image_processor_type` or `feature_extractor_type` found in the config.");const u={};if(a){const e=t[a];if(!e)throw new Error(`Unknown image_processor_type: \'${a}\'.`);u.image_processor=new e(i)}if(o){const e=t[o];if(e)u.image_processor=new e(i);else{const e=n[o];if(!e)throw new Error(`Unknown feature_extractor_type: \'${o}\'.`);u.feature_extractor=new e(i)}}return new NS({},u)}}async function LC(e){return Array.isArray(e)||(e=[e]),await Promise.all(e.map((e=>lg.read(e))))}async function UC(e,t){return Array.isArray(e)||(e=[e]),await Promise.all(e.map((e=>"string"==typeof e||e instanceof URL?async function n(e,t){if("undefined"==typeof AudioContext)throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const n=await(await oe(e)).arrayBuffer(),r=new AudioContext({sampleRate:t});"undefined"==typeof t&&console.warn(`No sampling rate provided, using default of ${r.sampleRate}Hz.`);const s=await r.decodeAudioData(n);let i;if(2===s.numberOfChannels){const e=Math.sqrt(2),t=s.getChannelData(0),n=s.getChannelData(1);i=new Float32Array(t.length);for(let r=0;r<s.length;++r)i[r]=e*(t[r]+n[r])/2}else i=s.getChannelData(0);return i}(e,t):e instanceof Float64Array?new Float32Array(e):e)))}function qC(e,t){t&&(e=e.map((e=>0|e)));const[n,r,s,i]=e;return{xmin:n,ymin:r,xmax:s,ymax:i}}class VC extends j{constructor({task:e,model:t,tokenizer:n=null,processor:r=null}){super(),this.task=e,this.model=t,this.tokenizer=n,this.processor=r}async dispose(){await this.model.dispose()}}class WC extends VC{_key="generated_text";constructor(e){super(e)}async _call(e,t={}){Array.isArray(e)||(e=[e]),this.model.config.prefix&&(e=e.map((e=>this.model.config.prefix+e)));const n=this.model.config.task_specific_params;n&&n[this.task]&&n[this.task].prefix&&(e=e.map((e=>n[this.task].prefix+e)));const r=this.tokenizer,s={padding:!0,truncation:!0};let i;i=this instanceof jC&&"_build_translation_inputs"in r?r._build_translation_inputs(e,s,t):r(e,s);const a=await this.model.generate({...i,...t});return r.batch_decode(a,{skip_special_tokens:!0}).map((e=>({[this._key]:e})))}}class jC extends WC{_key="translation_text";constructor(e){super(e)}}function GC(e){return Array.isArray(e)&&e.every((e=>"role"in e&&"content"in e))}Object.freeze({"text-classification":{tokenizer:E_,pipeline:class HC extends VC{constructor(e){super(e)}async _call(e,{top_k:t=1}={}){const n=this.tokenizer(e,{padding:!0,truncation:!0}),r=await this.model(n),s="multi_label_classification"===this.model.config.problem_type?e=>e.sigmoid():e=>new Xp("float32",he(e.data),e.dims),i=this.model.config.id2label,a=[];for(const e of r.logits){const n=s(e),r=await Zp(n,t),o=r[0].tolist(),l=r[1].tolist().map(((e,t)=>({label:i?i[e]:`LABEL_${e}`,score:o[t]})));1===t?a.push(...l):a.push(l)}return Array.isArray(e)||1===t?a:a[0]}},model:ES,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:E_,pipeline:class KC extends VC{constructor(e){super(e)}async _call(e,{ignore_labels:t=["O"]}={}){const n=Array.isArray(e),r=this.tokenizer(n?e:[e],{padding:!0,truncation:!0}),s=(await this.model(r)).logits,i=this.model.config.id2label,a=[];for(let e=0;e<s.dims[0];++e){const n=r.input_ids[e],o=s[e],l=[];for(let e=0;e<o.dims[0];++e){const r=o[e],s=_e(r.data)[1],a=i?i[s]:`LABEL_${s}`;if(t.includes(a))continue;const u=this.tokenizer.decode([n[e].item()],{skip_special_tokens:!0});if(""===u)continue;const d=he(r.data);l.push({entity:a,score:d[s],index:e,word:u})}a.push(l)}return n?a:a[0]}},model:class XC extends Eb{static MODEL_CLASS_MAPPINGS=[e$]},default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:E_,pipeline:class QC extends VC{constructor(e){super(e)}async _call(e,t,{top_k:n=1}={}){const r=this.tokenizer(e,{text_pair:t,padding:!0,truncation:!0}),{start_logits:s,end_logits:i}=await this.model(r),a=r.input_ids.tolist(),o=r.attention_mask.tolist(),l=this.tokenizer.all_special_ids,u=[];for(let e=0;e<s.dims[0];++e){const t=a[e],r=t.findIndex((e=>e==this.tokenizer.sep_token_id)),d=(o[e].map(((e,n)=>1==e&&(0===n||n>r&&-1===l.findIndex((e=>e==t[n]))))),s[e].tolist()),c=i[e].tolist();for(let n=1;n<d.length;++n)(0==o[e]||n<=r||-1!==l.findIndex((e=>e==t[n])))&&(d[n]=-Infinity,c[n]=-Infinity);const p=he(d).map(((e,t)=>[e,t])),h=he(c).map(((e,t)=>[e,t]));p[0][0]=0,h[0][0]=0;const f=Y(p,h).filter((e=>e[0][1]<=e[1][1])).map((e=>[e[0][1],e[1][1],e[0][0]*e[1][0]])).sort(((e,t)=>t[2]-e[2]));for(let e=0;e<Math.min(f.length,n);++e){const[n,r,s]=f[e],i=t.slice(n,r+1),a=this.tokenizer.decode(i,{skip_special_tokens:!0});u.push({answer:a,score:s})}}return 1===n?u[0]:u}},model:class YC extends Eb{static MODEL_CLASS_MAPPINGS=[yk]},default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:E_,pipeline:class ZC extends VC{constructor(e){super(e)}async _call(e,{top_k:t=5}={}){const n=this.tokenizer(e,{padding:!0,truncation:!0}),{logits:r}=await this.model(n),s=[],i=n.input_ids.tolist();for(let e=0;e<i.length;++e){const n=i[e],a=n.findIndex((e=>e==this.tokenizer.mask_token_id));if(-1===a)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const o=r[e][a],l=await Zp(new Xp("float32",he(o.data),o.dims),t),u=l[0].tolist(),d=l[1].tolist();s.push(d.map(((e,t)=>{const r=n.slice();return r[a]=e,{score:u[t],token:Number(e),token_str:this.tokenizer.model.vocab[e],sequence:this.tokenizer.decode(r,{skip_special_tokens:!0})}})))}return Array.isArray(e)?s:s[0]}},model:class JC extends Eb{static MODEL_CLASS_MAPPINGS=[nk]},default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:E_,pipeline:class eT extends WC{_key="summary_text";constructor(e){super(e)}},model:SS,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:E_,pipeline:jC,model:SS,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:E_,pipeline:WC,model:SS,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:E_,pipeline:class tT extends VC{constructor(e){super(e)}async _call(e,t={}){let n,r=!1,s=!1;if("string"==typeof e)n=e=[e];else if(Array.isArray(e)&&e.every((e=>"string"==typeof e)))r=!0,n=e;else{if(GC(e))e=[e];else{if(!Array.isArray(e)||!e.every(GC))throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");r=!0}s=!0,n=e.map((e=>this.tokenizer.apply_chat_template(e,{tokenize:!1,add_generation_prompt:!0})))}const i=t.add_special_tokens??!1,a=!s&&(t.return_full_text??!0);this.tokenizer.padding_side="left";const o=this.tokenizer(n,{add_special_tokens:i,padding:!0,truncation:!0}),l=await this.model.generate({...o,...t}),u=this.tokenizer.batch_decode(l,{skip_special_tokens:!0});let d;!a&&o.input_ids.dims.at(-1)>0&&(d=this.tokenizer.batch_decode(o.input_ids,{skip_special_tokens:!0}).map((e=>e.length)));const c=Array.from({length:e.length},(e=>[]));for(let t=0;t<u.length;++t){const n=Math.floor(t/l.dims[0]*e.length);d&&(u[t]=u[t].slice(d[n])),c[n].push({generated_text:s?[...e[n],{role:"assistant",content:u[t]}]:u[t]})}return r||1!==c.length?c:c[0]}},model:class nT extends Eb{static MODEL_CLASS_MAPPINGS=[k$]},default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:E_,pipeline:class rT extends VC{constructor(e){super(e),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map((([e,t])=>[e.toLowerCase(),t]))),this.entailment_id=this.label2id.entailment,void 0===this.entailment_id&&(console.warn("Could not find \'entailment\' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,void 0===this.contradiction_id&&(console.warn("Could not find \'contradiction\' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(e,t,{hypothesis_template:n="This example is {}.",multi_label:r=!1}={}){const s=Array.isArray(e);s||(e=[e]),Array.isArray(t)||(t=[t]);const i=t.map((e=>n.replace("{}",e))),a=r||1===t.length,o=[];for(const n of e){const e=[];for(const t of i){const r=this.tokenizer(n,{text_pair:t,padding:!0,truncation:!0}),s=await this.model(r);a?e.push([s.logits.data[this.contradiction_id],s.logits.data[this.entailment_id]]):e.push(s.logits.data[this.entailment_id])}const r=(a?e.map((e=>he(e)[1])):he(e)).map(((e,t)=>[e,t])).sort(((e,t)=>t[0]-e[0]));o.push({sequence:n,labels:r.map((e=>t[e[1]])),scores:r.map((e=>e[0]))})}return s?o:o[0]}},model:ES,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:class sT extends VC{constructor(e){super(e)}async _call(e,{top_k:t=5}={}){const n=this.processor.feature_extractor.config.sampling_rate,r=await UC(e,n),s=this.model.config.id2label,i=[];for(const e of r){const n=await this.processor(e),r=(await this.model(n)).logits[0],a=await Zp(new Xp("float32",he(r.data),r.dims),t),o=a[0].tolist(),l=a[1].tolist().map(((e,t)=>({label:s?s[e]:`LABEL_${e}`,score:o[t]})));i.push(l)}return Array.isArray(e)?i:i[0]}},model:class iT extends Eb{static MODEL_CLASS_MAPPINGS=[NE]},processor:FC,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:E_,pipeline:class aT extends VC{constructor(e){super(e)}async _call(e,t,{hypothesis_template:n="This is a sound of {}."}={}){const r=!Array.isArray(e);r&&(e=[e]);const s=t.map((e=>n.replace("{}",e))),i=this.tokenizer(s,{padding:!0,truncation:!0}),a=this.processor.feature_extractor.config.sampling_rate,o=await UC(e,a),l=[];for(const e of o){const n=await this.processor(e),r=he((await this.model({...i,...n})).logits_per_audio.data);l.push([...r].map(((e,n)=>({score:e,label:t[n]}))))}return r?l[0]:l}},model:kS,processor:FC,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:E_,pipeline:class oT extends VC{constructor(e){super(e)}async _call(e,t={}){switch(this.model.config.model_type){case"whisper":return this._call_whisper(e,t);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":return this._call_wav2vec2(e,t);case"moonshine":return this._call_moonshine(e,t);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type \'${this.model.config.model_type}\'.`)}}async _call_wav2vec2(e,t){t.language&&console.warn(\'`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".\'),t.task&&console.warn(\'`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".\');const n=!Array.isArray(e);n&&(e=[e]);const r=this.processor.feature_extractor.config.sampling_rate,s=await UC(e,r),i=[];for(const e of s){const t=await this.processor(e),n=(await this.model(t)).logits[0],r=[];for(const e of n)r.push(_e(e.data)[1]);const s=this.tokenizer.decode(r);i.push({text:s})}return n?i[0]:i}async _call_whisper(e,t){const n=t.return_timestamps??!1,r=t.chunk_length_s??0,s=t.force_full_sequences??!1;let i=t.stride_length_s??null;const a={...t};"word"===n&&(a.return_token_timestamps=!0,a.return_timestamps=!1);const o=!Array.isArray(e);o&&(e=[e]);const l=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,u=this.processor.feature_extractor.config.hop_length,d=this.processor.feature_extractor.config.sampling_rate,c=await UC(e,d),p=[];for(const e of c){let t=[];if(r>0){if(null===i)i=r/6;else if(r<=i)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const n=d*r,s=d*i,a=n-2*s;let o=0;for(;;){const r=o+n,i=e.subarray(o,r),l=await this.processor(i),u=0===o,d=r>=e.length;if(t.push({stride:[i.length,u?0:s,d?0:s],input_features:l.input_features,is_last:d}),d)break;o+=a}}else t=[{stride:[e.length,0,0],input_features:(await this.processor(e)).input_features,is_last:!0}];for(const e of t){a.num_frames=Math.floor(e.stride[0]/u);const t=await this.model.generate({inputs:e.input_features,...a});"word"===n?(e.tokens=t.sequences.tolist()[0],e.token_timestamps=t.token_timestamps.tolist()[0].map((e=>ve(e,2)))):e.tokens=t[0].tolist(),e.stride=e.stride.map((e=>e/d))}const[o,c]=this.tokenizer._decode_asr(t,{time_precision:l,return_timestamps:n,force_full_sequences:s});p.push({text:o,...c})}return o?p[0]:p}async _call_moonshine(e,t){const n=!Array.isArray(e);n&&(e=[e]);const r=this.processor.feature_extractor.config.sampling_rate,s=await UC(e,r),i=[];for(const e of s){const n=await this.processor(e),s=6*Math.floor(e.length/r),a=await this.model.generate({max_new_tokens:s,...t,...n}),o=this.processor.batch_decode(a,{skip_special_tokens:!0})[0];i.push({text:o})}return n?i[0]:i}},model:[class lT extends Eb{static MODEL_CLASS_MAPPINGS=[Cv]},class uT extends Eb{static MODEL_CLASS_MAPPINGS=[CE]}],processor:FC,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:E_,pipeline:class dT extends VC{DEFAULT_VOCODER_ID="Xenova/speecht5_hifigan";constructor(e){super(e),this.vocoder=e.vocoder??null}async _call(e,{speaker_embeddings:t=null}={}){return this.processor?this._call_text_to_spectrogram(e,{speaker_embeddings:t}):this._call_text_to_waveform(e)}async _call_text_to_waveform(e){const t=this.tokenizer(e,{padding:!0,truncation:!0}),{waveform:n}=await this.model(t),r=this.model.config.sampling_rate;return{audio:n.data,sampling_rate:r}}async _call_text_to_spectrogram(e,{speaker_embeddings:t}){if(this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await kS.from_pretrained(this.DEFAULT_VOCODER_ID,{dtype:"fp32"})),("string"==typeof t||t instanceof URL)&&(t=new Float32Array(await(await fetch(t)).arrayBuffer())),t instanceof Float32Array)t=new Xp("float32",t,[1,t.length]);else if(!(t instanceof Xp))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");const{input_ids:n}=this.tokenizer(e,{padding:!0,truncation:!0}),{waveform:r}=await this.model.generate_speech(n,t,{vocoder:this.vocoder}),s=this.processor.feature_extractor.config.sampling_rate;return{audio:r.data,sampling_rate:s}}},model:[class cT extends Eb{static MODEL_CLASS_MAPPINGS=[Bv]},class pT extends Eb{static MODEL_CLASS_MAPPINGS=[Mv]}],processor:[FC,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:E_,pipeline:class hT extends VC{constructor(e){super(e)}async _call(e,t={}){const n=Array.isArray(e),r=await LC(e),{pixel_values:s}=await this.processor(r),i=[];for(const e of s){e.dims=[1,...e.dims];const n=await this.model.generate({inputs:e,...t}),r=this.tokenizer.batch_decode(n,{skip_special_tokens:!0}).map((e=>({generated_text:e.trim()})));i.push(r)}return n?i:i[0]}},model:class fT extends Eb{static MODEL_CLASS_MAPPINGS=[Nk]},processor:FC,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:class mT extends VC{constructor(e){super(e)}async _call(e,{top_k:t=5}={}){const n=await LC(e),{pixel_values:r}=await this.processor(n),s=await this.model({pixel_values:r}),i=this.model.config.id2label,a=[];for(const e of s.logits){const n=await Zp(new Xp("float32",he(e.data),e.dims),t),r=n[0].tolist(),s=n[1].tolist().map(((e,t)=>({label:i?i[e]:`LABEL_${e}`,score:r[t]})));a.push(s)}return Array.isArray(e)?a:a[0]}},model:class _T extends Eb{static MODEL_CLASS_MAPPINGS=[Vk]},processor:FC,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:class gT extends VC{constructor(e){super(e),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(e,{threshold:t=.5,mask_threshold:n=.5,overlap_mask_area_threshold:r=.8,label_ids_to_fuse:s=null,target_sizes:i=null,subtask:a=null}={}){if(Array.isArray(e)&&1!==e.length)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const o=await LC(e),l=o.map((e=>[e.height,e.width])),{pixel_values:u,pixel_mask:d}=await this.processor(o),c=await this.model({pixel_values:u,pixel_mask:d});let p=null;if(null!==a)p=this.subtasks_mapping[a];else for(let[e,t]of Object.entries(this.subtasks_mapping))if(t in this.processor.image_processor){p=this.processor.image_processor[t].bind(this.processor.image_processor),a=e;break}const h=this.model.config.id2label,f=[];if("panoptic"===a||"instance"===a){const e=p(c,t,n,r,s,i??l)[0],a=e.segmentation;for(const t of e.segments_info){const e=new Uint8ClampedArray(a.data.length);for(let n=0;n<a.data.length;++n)a.data[n]===t.id&&(e[n]=255);const n=new lg(e,a.dims[1],a.dims[0],1);f.push({score:t.score,label:h[t.label_id],mask:n})}}else{if("semantic"!==a)throw Error(`Subtask ${a} not supported.`);{const{segmentation:e,labels:t}=p(c,i??l)[0];for(const n of t){const t=new Uint8ClampedArray(e.data.length);for(let r=0;r<e.data.length;++r)e.data[r]===n&&(t[r]=255);const r=new lg(t,e.dims[1],e.dims[0],1);f.push({score:null,label:h[n],mask:r})}}}return f}},model:[class wT extends Eb{static MODEL_CLASS_MAPPINGS=[yE]},class yT extends Eb{static MODEL_CLASS_MAPPINGS=[xE]},class bT extends Eb{static MODEL_CLASS_MAPPINGS=[kE]}],processor:FC,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"zero-shot-image-classification":{tokenizer:E_,pipeline:class xT extends VC{constructor(e){super(e)}async _call(e,t,{hypothesis_template:n="This is a photo of {}"}={}){const r=Array.isArray(e),s=await LC(e),i=t.map((e=>n.replace("{}",e))),a=this.tokenizer(i,{padding:"siglip"!==this.model.config.model_type||"max_length",truncation:!0}),{pixel_values:o}=await this.processor(s),l=await this.model({...a,pixel_values:o}),u="siglip"===this.model.config.model_type?e=>e.sigmoid().data:e=>he(e.data),d=[];for(const e of l.logits_per_image){const n=[...u(e)].map(((e,n)=>({score:e,label:t[n]})));n.sort(((e,t)=>t.score-e.score)),d.push(n)}return r?d:d[0]}},model:kS,processor:FC,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:class vT extends VC{constructor(e){super(e)}async _call(e,{threshold:t=.9,percentage:n=!1}={}){const r=Array.isArray(e);if(r&&1!==e.length)throw Error("Object detection pipeline currently only supports a batch size of 1.");const s=await LC(e),i=n?null:s.map((e=>[e.height,e.width])),{pixel_values:a,pixel_mask:o}=await this.processor(s),l=await this.model({pixel_values:a,pixel_mask:o}),u=this.processor.image_processor.post_process_object_detection(l,t,i),d=this.model.config.id2label,c=u.map((e=>e.boxes.map(((t,r)=>({score:e.scores[r],label:d[e.classes[r]],box:qC(t,!n)})))));return r?c:c[0]}},model:class $T extends Eb{static MODEL_CLASS_MAPPINGS=[cE]},processor:FC,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:E_,pipeline:class kT extends VC{constructor(e){super(e)}async _call(e,t,{threshold:n=.1,top_k:r=null,percentage:s=!1}={}){const i=Array.isArray(e),a=await LC(e),o=this.tokenizer(t,{padding:!0,truncation:!0}),l=await this.processor(a),u=[];for(let e=0;e<a.length;++e){const i=a[e],d=s?null:[[i.height,i.width]],c=l.pixel_values[e].unsqueeze_(0),p=await this.model({...o,pixel_values:c}),h=this.processor.image_processor.post_process_object_detection(p,n,d,!0)[0];let f=h.boxes.map(((e,n)=>({score:h.scores[n],label:t[h.classes[n]],box:qC(e,!s)}))).sort(((e,t)=>t.score-e.score));null!==r&&(f=f.slice(0,r)),u.push(f)}return i?u:u[0]}},model:class ET extends Eb{static MODEL_CLASS_MAPPINGS=[_E]},processor:FC,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:E_,pipeline:class ST extends VC{constructor(e){super(e)}async _call(e,t,n={}){const r=(await LC(e))[0],{pixel_values:s}=await this.processor(r),i=`<s_docvqa><s_question>${t}</s_question><s_answer>`,a=this.tokenizer(i,{add_special_tokens:!1,padding:!0,truncation:!0}).input_ids,o=await this.model.generate({inputs:s,max_length:this.model.config.decoder.max_position_embeddings,decoder_input_ids:a,...n}),l=this.tokenizer.batch_decode(o)[0].match(/<s_answer>(.*?)<\\/s_answer>/);let u=null;return l&&l.length>=2&&(u=l[1].trim()),[{answer:u}]}},model:class zT extends Eb{static MODEL_CLASS_MAPPINGS=[qk]},processor:FC,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:class CT extends VC{constructor(e){super(e)}async _call(e){const t=await LC(e),n=await this.processor(t),r=await this.model(n),s=[];for(const e of r.reconstruction){const t=e.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");s.push(lg.fromTensor(t))}return s.length>1?s:s[0]}},model:class TT extends Eb{static MODEL_CLASS_MAPPINGS=[tS]},processor:FC,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:class IT extends VC{constructor(e){super(e)}async _call(e){const t=await LC(e),n=await this.processor(t),{predicted_depth:r}=await this.model(n),s=[];for(let e=0;e<t.length;++e){const n=Qp(r[e],t[e].size.reverse(),"bilinear",!1),i=n.mul_(255/_e(n.data)[0]).to("uint8");s.push({predicted_depth:r[e],depth:lg.fromTensor(i)})}return s.length>1?s:s[0]}},model:class AT extends Eb{static MODEL_CLASS_MAPPINGS=[rS]},processor:FC,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:E_,pipeline:class MT extends VC{constructor(e){super(e)}async _call(e,{pooling:t="none",normalize:n=!1,quantize:r=!1,precision:s="binary"}={}){const i=this.tokenizer(e,{padding:!0,truncation:!0}),a=await this.model(i);let o=a.last_hidden_state??a.logits??a.token_embeddings;if("none"===t);else if("mean"===t)o=function l(e,t){const n=e.data,r=t.data,s=[e.dims[0],e.dims[2]],i=new n.constructor(s[0]*s[1]),[a,o,l]=e.dims;let u=0;for(let e=0;e<a;++e){const t=e*l*o;for(let s=0;s<l;++s){let a=0,d=0;const c=e*o,p=t+s;for(let e=0;e<o;++e){const t=Number(r[c+e]);d+=t,a+=n[p+e*l]*t}const h=a/d;i[u++]=h}}return new Xp(e.type,i,s)}(o,i.attention_mask);else{if("cls"!==t)throw Error(`Pooling method \'${t}\' not supported.`);o=o.slice(null,0)}return n&&(o=o.normalize(2,-1)),r&&(o=function u(e,t){if(2!==e.dims.length)throw new Error("The tensor must have 2 dimensions");if(e.dims.at(-1)%8!=0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(t))throw new Error("The precision must be either \'binary\' or \'ubinary\'");const n="binary"===t,r=n?"int8":"uint8",s=n?Int8Array:Uint8Array,i=e.data,a=new s(i.length/8);for(let e=0;e<i.length;++e){const t=i[e]>0?1:0,r=Math.floor(e/8),s=e%8;a[r]|=t<<7-s,n&&0===s&&(a[r]-=128)}return new Xp(r,a,[e.dims[0],e.dims[1]/8])}(o,s)),o}},model:kS,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:FC,pipeline:class OT extends VC{constructor(e){super(e)}async _call(e,{pool:t=null}={}){const n=await LC(e),{pixel_values:r}=await this.processor(n),s=await this.model({pixel_values:r});let i;if(t){if(!("pooler_output"in s))throw Error("No pooled output was returned. Make sure the model has a \'pooler\' layer when using the \'pool\' option.");i=s.pooler_output}else i=s.last_hidden_state??s.logits??s.image_embeds;return i}},model:[class BT extends Eb{static MODEL_CLASS_MAPPINGS=[hS]},kS],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});D.IS_PROCESS_AVAILABLE;["upload","listen","summarize","telehealth"].map((e=>`finished-${e}-transcriptions`));const NT=(e,t=void 0)=>e instanceof Function?e(t):e,PT=(e,t,n=(()=>{}))=>(...r)=>NT(e)?t(...r):n(...r);var RT,DT;globalThis.requestIdleCallback||(globalThis.requestIdleCallback=e=>+setTimeout((()=>e({didTimeout:!1,timeRemaining:()=>1})))),globalThis.cancelIdleCallback||(globalThis.cancelIdleCallback=clearTimeout);null!==(RT=(DT=Set.prototype).union)&&void 0!==RT||(DT.union=function(e){const t=new Set(this);for(const n of e.keys())t.add(n);return t});const FT="undefined"!=typeof navigator&&navigator.userAgent.includes("Firefox");let LT=48e3;if("undefined"!=typeof AudioContext){const e=new AudioContext;LT=e.sampleRate,e.close()}const UT=FT?LT:16e3,qT=(!!globalThis.navigator&&/Mobi|Android/i.test(navigator.userAgent),"undefined"==typeof location?"":location.search),VT="undefined"!=typeof process,WT=(!VT&&"undefined"!=typeof location&&location.pathname.includes("/dashboard"),"undefined"!=typeof AudioWorkletProcessor),jT="undefined"!=typeof DedicatedWorkerGlobalScope||WT,GT=!VT&&(jT||WT||"undefined"!=typeof navigator),HT="undefined"!=typeof location&&("localhost"===location.hostname||location.href.startsWith("blob:http://localhost"));GT&&"undefined"!=typeof location&&(location.host.includes("nuiq.com")||location.href.startsWith("blob:https://nuiq.com")||HT&&location.port),"undefined"!=typeof location&&(location.host.includes("stage.nuiq.com")||location.href.startsWith("blob:https://stage.nuiq.com")),HT||/debug(\\=true)?($|&)/.test(qT),"undefined"!=typeof navigator&&/Safari/i.test(navigator.userAgent)&&navigator.userAgent.includes("Chrome"),qT.includes("useDevServer=true"),Math.PI;jT&&self.addEventListener("unhandledrejection",(e=>{e.preventDefault(),postMessage({status:"error",args:[e.reason]}),console.error("error in worker",e)}));class KT{async init(e,t){jT&&postMessage({status:"ready"})}async process(e,t){return e}constructor(){jT&&(p(this),postMessage({status:"listening"}))}}var XT,QT;const YT=(...e)=>e.reduce(((e,t)=>(e[t]=t,e)),{}),ZT=YT("milliseconds","seconds","minutes","hours","days","weeks"),JT=YT("ms","s","m","h","d","w"),eI=36e5,tI=864e5,nI={milliseconds:1,seconds:1e3,minutes:6e4,hours:eI,days:tI,weeks:7*tI},rI={ms:"milliseconds",s:"seconds",m:"minutes",h:"hours",d:"days",w:"weeks"};Number.prototype.in=function(e){return this/("number"==typeof e?e:nI[e])},Object.defineProperties(Number.prototype,Object.values(ZT).reduce(((e,t)=>(e[t]={get(){return this*nI[t]}},e)),{})),Object.defineProperties(Number.prototype,Object.values(JT).reduce(((e,t)=>(e[t]={get(){return oI(this*nI[rI[t]])}},e)),{}));const sI="undefined"==typeof performance?()=>currentTime:performance.now.bind(performance),iI="undefined"==typeof performance?sI:()=>performance.timeOrigin+aI(),aI=new(QT=class e extends Function{constructor(){super("return performance.now();"),this[XT]=sI}},XT=Symbol.toPrimitive,QT),oI=e=>{let t=!1;const n=new Promise((n=>setTimeout((()=>!t&&n()),e)));return Object.assign(n,{cancel:()=>{t=!0}})},{fromEntries:lI,keys:uI}=((new Date).getDay(),Object);const{parse:dI,stringify:cI}=JSON;var pI;let hI=!1;try{hI=!1}catch(DT){}const fI=globalThis.setTimeout||(e=>{});class mI{}pI=mI,mI.passed=0,mI.failed=0,mI.testPromises=[],mI.expect=PT(hI,((e,t,n="")=>{const r=new Promise((r=>fI((async()=>{const s=await NT(e),i=NT(t),a=s===i,o=null!=n?n:e instanceof Function?e.name:"";a?pI.passed+=1:(console.error(` failed InlineTest::${o} (expected ${i}, got ${s})`),pI.failed+=1),r()}))));return pI.testPromises.push(r),r})),fI(PT(hI,(async()=>{await Promise.all(pI.testPromises);const{passed:e,failed:t}=pI,n=e+t;console.log(` InlineTest: passed ${e} / ${n} (${kI(e/n)})`),t&&console.log(` InlineTest: failed ${t} / ${n} (${kI(t/n)})`)})),5..seconds);const _I=new Map,gI=e=>{const t=JSON.stringify(e);return _I.has(t)?_I.get(t):(_I.set(t,e),e)};mI.expect(gI({a:1,b:2,c:3}),gI({a:1,b:2,c:3}));const{floor:wI,max:yI,round:bI}=Math,{isArray:xI}=Array,{entries:vI}=Object,{ListFormat:$I}=Intl,kI=e=>zI(e)?`${EI(100*+e)}%`:"0%",EI=e=>e.toFixed(/\\./.test(`${e}`)?2:0),SI=new Set(["boolean","symbol"]),zI=e=>!SI.has(typeof e)&&""!==e&&+e==+e;new $I("en",{style:"long",type:"conjunction"});Map;Map;WeakMap;Map;Map;const{floor:CI,max:TI,min:II,pow:AI,random:MI,sqrt:OI}=Math;new Intl.Collator("en");function BI(e,t){return n=>null==t?n[e]:t instanceof Function?t(n[e]):n[e]===t}BI("length");const NI=(e,t=(e=>e))=>{let n=0;for(let r=0;r<e.length;r+=1)n+=t(e[r]);return n},PI=(e,t=(e=>e))=>NI(e,t)/e.length,RI=(e,t=(e=>e))=>TI.apply(null,e.map((e=>t(e)))),DI=(e,t=(e=>e))=>II.apply(null,e.map((e=>t(e)))),FI=(e,t=(e=>e))=>{e=e.map((e=>t(e)));const n=PI(e),r=[];let s=e.length;for(;s-- >0;)r.push(AI(e[s]-n,2));return PI(r)},LI={sum:NI,mean:PI,median:(e,t=(e=>e))=>{const n=[].sort.call(e.map(t),((e,t)=>e-t)),r=n.length,s=CI(.5*r);return r%2?n[s]:.5*(n[s-1]+n[s])},mode:(e,t=(e=>e))=>{var n;const r=new Map;for(const s of e){const e=t(s);r.set(e,(null!==(n=r.get(e))&&void 0!==n?n:0)+1)}const s=Math.max.apply(null,[...r.values()]);return[...r.keys()].find((e=>r.get(e)===s))},min:DI,max:RI,range:(e,t=(e=>e))=>(e=e.map((e=>t(e))),RI(e)-DI(e)),deviation:(e,t=(e=>e))=>OI(FI(e,t)),variance:FI};Object.keys(LI);let{from:UI}=Array;const qI=e=>Math.floor(e*UT),VI=(e,t)=>t.map((e=>t=>{const n=t.end-t.start,r=e.length/UT,s=Math.max(0,1-n);if(s){const e={start:t.start-s/2,end:t.end+s/2};e.start<0?(e.end+=Math.abs(e.start),e.start=0):e.end>r&&(e.start-=e.end-r),t.start=e.start,t.end=e.end}return e.slice(qI(t.start),qI(t.end))})(e));const WI=e=>{const t=1/function n(e){let t=0,n=e.length;for(;n-- >0;){const r=e[n];t+=r*r}return Math.sqrt(t)}(e),r=e.slice();let s=r.length;for(;s-- >0;)r[s]*=t;return r};let jI,GI;V.backends.onnx&&V.backends.onnx.wasm&&(V.backends.onnx.wasm.numThreads=1),V.allowLocalModels=!1;const HI=((e,{mode:t="chain"}={})=>{let n,r=!1;const s=async(...i)=>r?"chain"===t?n.then((()=>s(...i))):n:(r=!0,n=new Promise((async(t,n)=>{try{t(await e(...i))}catch(e){console.error(e),n(e)}finally{r=!1}})),n);return s})((async e=>{try{const t=await jI(e),{embeddings:n}=await GI(t);return n.data}catch(e){console.error(e)}return new Float32Array(512)}));let KI=0,XI=0,QI=0,YI=0,ZI=0,JI=new Set,eA={};const tA=crypto.randomUUID().split("-")[0];new class nA extends KT{async metrics(){return{id:tA,requests:KI,retries:0,failures:XI,successes:ZI,hallucinations:0,processed:QI,processedIndices:[...JI],elapsed:YI,xRealTime:QI/YI,misc:eA}}async init(){console.log("loading embed model Xenova/wavlm-base-plus-sv"),jI=await FC.from_pretrained("Xenova/wavlm-base-plus-sv",{}),GI=await kS.from_pretrained("Xenova/wavlm-base-plus-sv",{quantized:!1,dtype:"fp32"}),console.log("loaded model Xenova/wavlm-base-plus-sv"),await super.init()}async process(e){const t=iI();KI+=1;const n=e.audio.length/UT;QI+=n,JI.add(e.index);const r=[],s=VI(e.audio,e.segments);try{for(const t of s){const n=e.segments[s.indexOf(t)];r.push(Object.assign(n,{embedding:WI(await HI(t))}))}ZI+=1}catch(e){console.error(e),XI+=1}return YI+=.001*(iI()-t),v({...e,segments:r},r.map(BI("embedding")).map(BI("buffer")))}dispose(){GI.dispose()}}})()})();',"Worker",void 0,void 0)}var d=n(105),c=n(758),p=n(901);const h=[],f=[];class m extends d.Z{constructor(){super(...arguments),this.name="LocalBackend",this.chunkParams=m.chunkParams,this.segments=[],this.workers=[],this.transcribeNodes=(0,s.Ry)(),this.embedNodes=(0,s.Ry)(),this.ownNodes=[],this.processorIndex=0,this.dispose=()=>{h.length=0}}async init({type:e,diarize:t=!1,localWorkers:n=1,embedWorkers:i=4}){const a=async e=>{const[t,n]=await(async e=>{const t=await(0,c.oe)(),n=t?new o:new l,s=r.LV(n);(0,p.Rm)(`will use ${t?"gpu":"cpu"} transcribe worker`);const i=[n,s];return h.push(i),f.push(n),await s.init(e),i})(e);this.transcribeNodes.push(n),this.workers.push(t)},d=async()=>{const[t,n]=await(async(e,t=(()=>{}))=>{const n=new u,s=r.LV(n);return f.push(n),await s.init(e),[n,s]})({type:e});this.embedNodes.push(n),this.ownNodes.push(n),this.workers.push(t)};return window.addEventListener("offline",(()=>{this.ownNodes.forEach((e=>(0,s.TF)(this.embedNodes,e)))})),window.addEventListener("online",(()=>{this.ownNodes.forEach((e=>this.embedNodes.push(e)))})),await Promise.all([...(0,s.QL)(n,(e=>{var t;return null!==(t=h[e])&&void 0!==t?t:a({device:"webgpu",model:"tiny"})})),...t?(0,s.QL)(i,(()=>d())):[]]),this}}m.chunkParams={minDuration:10,maxDuration:20}}}]);